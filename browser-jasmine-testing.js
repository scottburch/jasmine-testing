/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	__webpack_require__(1);
	__webpack_require__(5);
	var scripts = [__webpack_require__(6), __webpack_require__(7), __webpack_require__(8), __webpack_require__(9)].join(';');
	
	eval.call(global, scripts);
	sourceMapSupport.install();
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(2);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(4)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../node_modules/css-loader/index.js!./jasmine.css", function() {
				var newContent = require("!!./../../../node_modules/css-loader/index.js!./jasmine.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(3)();
	// imports
	
	
	// module
	exports.push([module.id, "body { overflow-y: scroll; }\n\n.jasmine_html-reporter { background-color: #eee; padding: 5px; margin: -8px; font-size: 11px; font-family: Monaco, \"Lucida Console\", monospace; line-height: 14px; color: #333; }\n.jasmine_html-reporter a { text-decoration: none; }\n.jasmine_html-reporter a:hover { text-decoration: underline; }\n.jasmine_html-reporter p, .jasmine_html-reporter h1, .jasmine_html-reporter h2, .jasmine_html-reporter h3, .jasmine_html-reporter h4, .jasmine_html-reporter h5, .jasmine_html-reporter h6 { margin: 0; line-height: 14px; }\n.jasmine_html-reporter .banner, .jasmine_html-reporter .symbol-summary, .jasmine_html-reporter .summary, .jasmine_html-reporter .result-message, .jasmine_html-reporter .spec .description, .jasmine_html-reporter .spec-detail .description, .jasmine_html-reporter .alert .bar, .jasmine_html-reporter .stack-trace { padding-left: 9px; padding-right: 9px; }\n.jasmine_html-reporter .banner { position: relative; }\n.jasmine_html-reporter .banner .title { background: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAAAZCAMAAACGusnyAAACdlBMVEX/////AP+AgICqVaqAQICZM5mAVYCSSZKAQICOOY6ATYCLRouAQICJO4mSSYCIRIiPQICHPIeOR4CGQ4aMQICGPYaLRoCFQ4WKQICPPYWJRYCOQoSJQICNPoSIRICMQoSHQICHRICKQoOHQICKPoOJO4OJQYOMQICMQ4CIQYKLQICIPoKLQ4CKQICNPoKJQISMQ4KJQoSLQYKJQISLQ4KIQoSKQYKIQICIQISMQoSKQYKLQIOLQoOJQYGLQIOKQIOMQoGKQYOLQYGKQIOLQoGJQYOJQIOKQYGJQIOKQoGKQIGLQIKLQ4KKQoGLQYKJQIGKQYKJQIGKQIKJQoGKQYKLQIGKQYKLQIOJQoKKQoOJQYKKQIOJQoKKQoOKQIOLQoKKQYOLQYKJQIOKQoKKQYKKQoKJQYOKQYKLQIOKQoKLQYOKQYKLQIOJQoGKQYKJQYGJQoGKQYKLQoGLQYGKQoGJQYKKQYGJQIKKQoGJQYKLQIKKQYGLQYKKQYGKQYGKQYKJQYOKQoKJQYOKQYKLQYOLQYOKQYKLQYOKQoKKQYKKQYOKQYOJQYKKQYKLQYKKQIKKQoKKQYKKQYKKQoKJQIKKQYKLQYKKQYKKQIKKQYKKQYKKQYKKQIKKQYKJQYGLQYGKQYKKQYKKQYGKQIKKQYGKQYOJQoKKQYOLQYKKQYOKQoKKQYKKQoKKQYKKQYKJQYKLQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKJQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKLQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKmIDpEAAAA0XRSTlMAAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobHB0eHyAiIyQlJycoKissLS4wMTQ1Njc4OTo7PDw+P0BCQ0RISUpLTE1OUFNUVVdYWFlaW15fYGFiY2ZnaGlqa2xtb3BxcnN0dnh5ent8fX5/gIGChIWIioyNjo+QkZOUlZaYmZqbnJ2eoKGio6WmqKmsra6vsLGztre4ubq7vL2+wMHDxMjJysvNzs/Q0dLU1tfY2dvc3t/g4eLj5ebn6Onq6+zt7u/w8vP09fb3+Pn6+/z9/vkVQXAAAAMaSURBVHhe5dXxV1N1GMfxz2ABbDgIAm5VDJOyVDIJLUMaVpBWUZUaGbmqoGpZRSiGiRWp6KoZ5AB0ZY50RImZQIlahKkMYXv/R90dBvET/rJfOr3Ouc8v99zPec59zvf56j+vYKlViSf7250X4Mr3O29Tgq08BdGB4DhcekEJ5YkQKFsgWZdtj9JpV+I8xPjLFqkrsEIqO8PHSpis36jWazcqjEsfJjkvRssVU37SdIOu4XCf5vEJPsnwJpnRNU9JmxhMk8l1gehIrq7hTFjzOD+Vf88629qKMJVNltInFeRexRQyJlNeqd1iGDlSzrIUIyXbyFfm3RYprcQRe7lqtWyGYbfc6dT0R2vmdOOkX3u55C1rP37ftiH+tDby4r/RBT0w8TyEkr+epB9XgPDmSYYWbrhCuFYaIyw3fDQAXTnSkh+ANofiHmWf9l+FY1I90FdQTetstO00o23novzVsJ7uB3/C5TkbjRwZ5JerwV4iRWq9HFbFMaK/d0TYqayRiQPuIxxS3Bu8JWU90/60tKi7vkhaznez0a/TbVOKj5CaOZh6fWG6/Lyv9B/ZLR1gw/S/fpbeVD3MCW1li6SvWDOn65tr99/uvWtBS0XDm4s1t+sOHpG0kpBKx/l77wOSnxLpcx6TXmXLTPQOKYOf9Q1dfr8/SJ2mFdCvl1Yl93DiHUZvXeLJbGSzYu5gVJ2slbSakOR8dxCq5adQ2oFLqsE9Ex3L4qQO0eOPeU5x56bypXp4onSEb5OkICX6lDat55TeoztNKQcJaakrz9KCb95oD69IKq+yKW4XPjknaS52V0TZqE2cTtXjcHSCRmUO88e+85hj3EP74i9p8pylw7lxgMDyyl6OV7ZejnjNMfatu87LxRbH0IS35gt2a4ZjmGpVBdKK3Wr6INk8jWWSGqbA55CKgjBRC6E9w78ydTg3ABS3AFV1QN0Y4Aa2pgEjWnQURj9L0ayK6R2ysEqxHUKzYnLvvyU+i9KM2JHJzE4vyZOyDcOwOsySajeLPc8sNvPJkFlyJd20wpqAzZeAfZ3oWybxd+P/3j+SG3uSBdf2VQAAAABJRU5ErkJggg==') no-repeat; background: url('data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgoKPHN2ZwogICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgIHhtbG5zOmNjPSJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9ucyMiCiAgIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyIKICAgeG1sbnM6c3ZnPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxuczppbmtzY2FwZT0iaHR0cDovL3d3dy5pbmtzY2FwZS5vcmcvbmFtZXNwYWNlcy9pbmtzY2FwZSIKICAgdmVyc2lvbj0iMS4xIgogICB3aWR0aD0iNjgxLjk2MjUyIgogICBoZWlnaHQ9IjE4Ny41IgogICBpZD0ic3ZnMiIKICAgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+PG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhOCI+PHJkZjpSREY+PGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPjxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PjxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz48L2NjOldvcms+PC9yZGY6UkRGPjwvbWV0YWRhdGE+PGRlZnMKICAgICBpZD0iZGVmczYiPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoMTgiPjxwYXRoCiAgICAgICAgIGQ9Ik0gMCwxNTAwIDAsMCBsIDU0NTUuNzQsMCAwLDE1MDAgTCAwLDE1MDAgeiIKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgaWQ9InBhdGgyMCIgLz48L2NsaXBQYXRoPjwvZGVmcz48ZwogICAgIHRyYW5zZm9ybT0ibWF0cml4KDEuMjUsMCwwLC0xLjI1LDAsMTg3LjUpIgogICAgIGlkPSJnMTAiPjxnCiAgICAgICB0cmFuc2Zvcm09InNjYWxlKDAuMSwwLjEpIgogICAgICAgaWQ9ImcxMiI+PGcKICAgICAgICAgaWQ9ImcxNCI+PGcKICAgICAgICAgICBjbGlwLXBhdGg9InVybCgjY2xpcFBhdGgxOCkiCiAgICAgICAgICAgaWQ9ImcxNiI+PHBhdGgKICAgICAgICAgICAgIGQ9Im0gMTU0NCw1OTkuNDM0IGMgMC45MiwtNDAuMzUyIDI1LjY4LC04MS42MDIgNzEuNTMsLTgxLjYwMiAyNy41MSwwIDQ3LjY4LDEyLjgzMiA2MS40NCwzNS43NTQgMTIuODMsMjIuOTMgMTIuODMsNTYuODUyIDEyLjgzLDgyLjUyNyBsIDAsMzI5LjE4NCAtNzEuNTIsMCAwLDEwNC41NDMgMjY2LjgzLDAgMCwtMTA0LjU0MyAtNzAuNiwwIDAsLTM0NC43NyBjIDAsLTU4LjY5MSAtMy42OCwtMTA0LjUzMSAtNDQuOTMsLTE1Mi4yMTggLTM2LjY4LC00Mi4xOCAtOTYuMjgsLTY2LjAyIC0xNTMuMTQsLTY2LjAyIC0xMTcuMzcsMCAtMjA3LjI0LDc3Ljk0MSAtMjAyLjY0LDE5Ny4xNDUgbCAxMzAuMiwwIgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoMjIiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDIzMDEuNCw2NjIuNjk1IGMgMCw4MC43MDMgLTY2Ljk0LDE0NS44MTMgLTE0Ny42MywxNDUuODEzIC04My40NCwwIC0xNDcuNjMsLTY4Ljc4MSAtMTQ3LjYzLC0xNTEuMzAxIDAsLTc5Ljc4NSA2Ni45NCwtMTQ1LjgwMSAxNDUuOCwtMTQ1LjgwMSA4NC4zNSwwIDE0OS40Niw2Ny44NTIgMTQ5LjQ2LDE1MS4yODkgeiBtIC0xLjgzLC0xODEuNTQ3IGMgLTM1Ljc3LC01NC4wOTcgLTkzLjUzLC03OC44NTkgLTE1Ny43MiwtNzguODU5IC0xNDAuMywwIC0yNTEuMjQsMTE2LjQ0OSAtMjUxLjI0LDI1NC45MTggMCwxNDIuMTI5IDExMy43LDI2MC40MSAyNTYuNzQsMjYwLjQxIDYzLjI3LDAgMTE4LjI5LC0yOS4zMzYgMTUyLjIyLC04Mi41MjMgbCAwLDY5LjY4NyAxNzUuMTQsMCAwLC0xMDQuNTI3IC02MS40NCwwIDAsLTI4MC41OTggNjEuNDQsMCAwLC0xMDQuNTI3IC0xNzUuMTQsMCAwLDY2LjAxOSIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDI0IgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSAyNjIyLjMzLDU1Ny4yNTggYyAzLjY3LC00NC4wMTYgMzMuMDEsLTczLjM0OCA3OC44NiwtNzMuMzQ4IDMzLjkzLDAgNjYuOTMsMjMuODI0IDY2LjkzLDYwLjUwNCAwLDQ4LjYwNiAtNDUuODQsNTYuODU2IC04My40NCw2Ni45NDEgLTg1LjI4LDIyLjAwNCAtMTc4LjgxLDQ4LjYwNiAtMTc4LjgxLDE1NS44NzkgMCw5My41MzYgNzguODYsMTQ3LjYzMyAxNjUuOTgsMTQ3LjYzMyA0NCwwIDgzLjQzLC05LjE3NiAxMTAuOTQsLTQ0LjAwOCBsIDAsMzMuOTIyIDgyLjUzLDAgMCwtMTMyLjk2NSAtMTA4LjIxLDAgYyAtMS44MywzNC44NTYgLTI4LjQyLDU3Ljc3NCAtNjMuMjYsNTcuNzc0IC0zMC4yNiwwIC02Mi4zNSwtMTcuNDIyIC02Mi4zNSwtNTEuMzQ4IDAsLTQ1Ljg0NyA0NC45MywtNTUuOTMgODAuNjksLTY0LjE4IDg4LjAyLC0yMC4xNzUgMTgyLjQ3LC00Ny42OTUgMTgyLjQ3LC0xNTcuNzM0IDAsLTk5LjAyNyAtODMuNDQsLTE1NC4wMzkgLTE3NS4xMywtMTU0LjAzOSAtNDkuNTMsMCAtOTQuNDYsMTUuNTgyIC0xMjYuNTUsNTMuMTggbCAwLC00MC4zNCAtODUuMjcsMCAwLDE0Mi4xMjkgMTE0LjYyLDAiCiAgICAgICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgICAgICAgaWQ9InBhdGgyNiIKICAgICAgICAgICAgIHN0eWxlPSJmaWxsOiM4YTQxODI7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiIC8+PHBhdGgKICAgICAgICAgICAgIGQ9Im0gMjk4OC4xOCw4MDAuMjU0IC02My4yNiwwIDAsMTA0LjUyNyAxNjUuMDUsMCAwLC03My4zNTUgYyAzMS4xOCw1MS4zNDcgNzguODYsODUuMjc3IDE0MS4yMSw4NS4yNzcgNjcuODUsMCAxMjQuNzEsLTQxLjI1OCAxNTIuMjEsLTEwMi42OTkgMjYuNiw2Mi4zNTEgOTIuNjIsMTAyLjY5OSAxNjAuNDcsMTAyLjY5OSA1My4xOSwwIDEwNS40NiwtMjIgMTQxLjIxLC02Mi4zNTEgMzguNTIsLTQ0LjkzOCAzOC41MiwtOTMuNTMyIDM4LjUyLC0xNDkuNDU3IGwgMCwtMTg1LjIzOSA2My4yNywwIDAsLTEwNC41MjcgLTIzOC40MiwwIDAsMTA0LjUyNyA2My4yOCwwIDAsMTU3LjcxNSBjIDAsMzIuMTAyIDAsNjAuNTI3IC0xNC42Nyw4OC45NTcgLTE4LjM0LDI2LjU4MiAtNDguNjEsNDAuMzQ0IC03OS43Nyw0MC4zNDQgLTMwLjI2LDAgLTYzLjI4LC0xMi44NDQgLTgyLjUzLC0zNi42NzIgLTIyLjkzLC0yOS4zNTUgLTIyLjkzLC01Ni44NjMgLTIyLjkzLC05Mi42MjkgbCAwLC0xNTcuNzE1IDYzLjI3LDAgMCwtMTA0LjUyNyAtMjM4LjQxLDAgMCwxMDQuNTI3IDYzLjI4LDAgMCwxNTAuMzgzIGMgMCwyOS4zNDggMCw2Ni4wMjMgLTE0LjY3LDkxLjY5OSAtMTUuNTksMjkuMzM2IC00Ny42OSw0NC45MzQgLTgwLjcsNDQuOTM0IC0zMS4xOCwwIC01Ny43NywtMTEuMDA4IC03Ny45NCwtMzUuNzc0IC0yNC43NywtMzAuMjUzIC0yNi42LC02Mi4zNDMgLTI2LjYsLTk5Ljk0MSBsIDAsLTE1MS4zMDEgNjMuMjcsMCAwLC0xMDQuNTI3IC0yMzguNCwwIDAsMTA0LjUyNyA2My4yNiwwIDAsMjgwLjU5OCIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDI4IgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSAzOTk4LjY2LDk1MS41NDcgLTExMS44NywwIDAsMTE4LjI5MyAxMTEuODcsMCAwLC0xMTguMjkzIHogbSAwLC00MzEuODkxIDYzLjI3LDAgMCwtMTA0LjUyNyAtMjM5LjMzLDAgMCwxMDQuNTI3IDY0LjE5LDAgMCwyODAuNTk4IC02My4yNywwIDAsMTA0LjUyNyAxNzUuMTQsMCAwLC0zODUuMTI1IgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoMzAiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDQxNTkuMTIsODAwLjI1NCAtNjMuMjcsMCAwLDEwNC41MjcgMTc1LjE0LDAgMCwtNjkuNjg3IGMgMjkuMzUsNTQuMTAxIDg0LjM2LDgwLjY5OSAxNDQuODcsODAuNjk5IDUzLjE5LDAgMTA1LjQ1LC0yMi4wMTYgMTQxLjIyLC02MC41MjcgNDAuMzQsLTQ0LjkzNCA0MS4yNiwtODguMDMyIDQxLjI2LC0xNDMuOTU3IGwgMCwtMTkxLjY1MyA2My4yNywwIDAsLTEwNC41MjcgLTIzOC40LDAgMCwxMDQuNTI3IDYzLjI2LDAgMCwxNTguNjM3IGMgMCwzMC4yNjIgMCw2MS40MzQgLTE5LjI2LDg4LjAzNSAtMjAuMTcsMjYuNTgyIC01My4xOCwzOS40MTQgLTg2LjE5LDM5LjQxNCAtMzMuOTMsMCAtNjguNzcsLTEzLjc1IC04OC45NCwtNDEuMjUgLTIxLjA5LC0yNy41IC0yMS4wOSwtNjkuNjg3IC0yMS4wOSwtMTAyLjcwNyBsIDAsLTE0Mi4xMjkgNjMuMjYsMCAwLC0xMDQuNTI3IC0yMzguNCwwIDAsMTA0LjUyNyA2My4yNywwIDAsMjgwLjU5OCIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDMyIgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSA1MDgyLjQ4LDcwMy45NjUgYyAtMTkuMjQsNzAuNjA1IC04MS42LDExNS41NDcgLTE1NC4wNCwxMTUuNTQ3IC02Ni4wNCwwIC0xMjkuMywtNTEuMzQ4IC0xNDMuMDUsLTExNS41NDcgbCAyOTcuMDksMCB6IG0gODUuMjcsLTE0NC44ODMgYyAtMzguNTEsLTkzLjUyMyAtMTI5LjI3LC0xNTYuNzkzIC0yMzEuMDUsLTE1Ni43OTMgLTE0My4wNywwIC0yNTcuNjgsMTExLjg3MSAtMjU3LjY4LDI1NS44MzYgMCwxNDQuODgzIDEwOS4xMiwyNjEuMzI4IDI1NC45MSwyNjEuMzI4IDY3Ljg3LDAgMTM1LjcyLC0zMC4yNTggMTgzLjM5LC03OC44NjMgNDguNjIsLTUxLjM0NCA2OC43OSwtMTEzLjY5NSA2OC43OSwtMTgzLjM4MyBsIC0zLjY3LC0zOS40MzQgLTM5Ni4xMywwIGMgMTQuNjcsLTY3Ljg2MyA3Ny4wMywtMTE3LjM2MyAxNDYuNzIsLTExNy4zNjMgNDguNTksMCA5MC43NiwxOC4zMjggMTE4LjI4LDU4LjY3MiBsIDExNi40NCwwIgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoMzQiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDY5MC44OTUsODUwLjcwMyA5MC43NSwwIDIyLjU0MywzMS4wMzUgMCwyNDMuMTIyIC0xMzUuODI5LDAgMCwtMjQzLjE0MSAyMi41MzYsLTMxLjAxNiIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDM2IgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSA2MzIuMzk1LDc0Mi4yNTggMjguMDM5LDg2LjMwNCAtMjIuNTUxLDMxLjA0IC0yMzEuMjIzLDc1LjEyOCAtNDEuOTc2LC0xMjkuMTgzIDIzMS4yNTcsLTc1LjEzNyAzNi40NTQsMTEuODQ4IgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoMzgiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDcxNy40NDksNjUzLjEwNSAtNzMuNDEsNTMuMzYgLTM2LjQ4OCwtMTEuODc1IC0xNDIuOTAzLC0xOTYuNjkyIDEwOS44ODMsLTc5LjgyOCAxNDIuOTE4LDE5Ni43MDMgMCwzOC4zMzIiCiAgICAgICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgICAgICAgaWQ9InBhdGg0MCIKICAgICAgICAgICAgIHN0eWxlPSJmaWxsOiM4YTQxODI7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiIC8+PHBhdGgKICAgICAgICAgICAgIGQ9Im0gODI4LjUyLDcwNi40NjUgLTczLjQyNiwtNTMuMzQgMC4wMTEsLTM4LjM1OSBMIDg5OC4wMDQsNDE4LjA3IDEwMDcuOSw0OTcuODk4IDg2NC45NzMsNjk0LjYwOSA4MjguNTIsNzA2LjQ2NSIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDQyIgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSA4MTIuMDg2LDgyOC41ODYgMjguMDU1LC04Ni4zMiAzNi40ODQsLTExLjgzNiAyMzEuMjI1LDc1LjExNyAtNDEuOTcsMTI5LjE4MyAtMjMxLjIzOSwtNzUuMTQgLTIyLjU1NSwtMzEuMDA0IgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoNDQiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDczNi4zMDEsMTMzNS44OCBjIC0zMjMuMDQ3LDAgLTU4NS44NzUsLTI2Mi43OCAtNTg1Ljg3NSwtNTg1Ljc4MiAwLC0zMjMuMTE4IDI2Mi44MjgsLTU4NS45NzcgNTg1Ljg3NSwtNTg1Ljk3NyAzMjMuMDE5LDAgNTg1LjgwOSwyNjIuODU5IDU4NS44MDksNTg1Ljk3NyAwLDMyMy4wMDIgLTI2Mi43OSw1ODUuNzgyIC01ODUuODA5LDU4NS43ODIgbCAwLDAgeiBtIDAsLTExOC42MSBjIDI1Ny45NzIsMCA0NjcuMTg5LC0yMDkuMTMgNDY3LjE4OSwtNDY3LjE3MiAwLC0yNTguMTI5IC0yMDkuMjE3LC00NjcuMzQ4IC00NjcuMTg5LC00NjcuMzQ4IC0yNTguMDc0LDAgLTQ2Ny4yNTQsMjA5LjIxOSAtNDY3LjI1NCw0NjcuMzQ4IDAsMjU4LjA0MiAyMDkuMTgsNDY3LjE3MiA0NjcuMjU0LDQ2Ny4xNzIiCiAgICAgICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgICAgICAgaWQ9InBhdGg0NiIKICAgICAgICAgICAgIHN0eWxlPSJmaWxsOiM4YTQxODI7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiIC8+PHBhdGgKICAgICAgICAgICAgIGQ9Im0gMTA5MS4xMyw2MTkuODgzIC0xNzUuNzcxLDU3LjEyMSAxMS42MjksMzUuODA4IDE3NS43NjIsLTU3LjEyMSAtMTEuNjIsLTM1LjgwOCIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDQ4IgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0iTSA4NjYuOTU3LDkwMi4wNzQgODM2LjUsOTI0LjE5OSA5NDUuMTIxLDEwNzMuNzMgOTc1LjU4NiwxMDUxLjYxIDg2Ni45NTcsOTAyLjA3NCIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDUwIgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0iTSA2MDcuNDY1LDkwMy40NDUgNDk4Ljg1NSwxMDUyLjk3IDUyOS4zMiwxMDc1LjEgNjM3LjkzLDkyNS41NjYgNjA3LjQ2NSw5MDMuNDQ1IgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoNTIiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDM4MC42ODgsNjIyLjEyOSAtMTEuNjI2LDM1LjgwMSAxNzUuNzU4LDU3LjA5IDExLjYyMSwtMzUuODAxIC0xNzUuNzUzLC01Ny4wOSIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDU0IgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSA3MTYuMjg5LDM3Ni41OSAzNy42NDA2LDAgMCwxODQuODE2IC0zNy42NDA2LDAgMCwtMTg0LjgxNiB6IgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoNTYiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjwvZz48L2c+PC9nPjwvZz48L3N2Zz4=') no-repeat, none; -moz-background-size: 100%; -o-background-size: 100%; -webkit-background-size: 100%; background-size: 100%; display: block; float: left; width: 90px; height: 25px; }\n.jasmine_html-reporter .banner .version { margin-left: 14px; position: relative; top: 6px; }\n.jasmine_html-reporter #jasmine_content { position: fixed; right: 100%; }\n.jasmine_html-reporter .version { color: #aaa; }\n.jasmine_html-reporter .banner { margin-top: 14px; }\n.jasmine_html-reporter .duration { color: #fff; float: right; line-height: 28px; padding-right: 9px; }\n.jasmine_html-reporter .symbol-summary { overflow: hidden; *zoom: 1; margin: 14px 0; }\n.jasmine_html-reporter .symbol-summary li { display: inline-block; height: 8px; width: 14px; font-size: 16px; }\n.jasmine_html-reporter .symbol-summary li.passed { font-size: 14px; }\n.jasmine_html-reporter .symbol-summary li.passed:before { color: #007069; content: \"\\2022\"; }\n.jasmine_html-reporter .symbol-summary li.failed { line-height: 9px; }\n.jasmine_html-reporter .symbol-summary li.failed:before { color: #ca3a11; content: \"\\D7\"; font-weight: bold; margin-left: -1px; }\n.jasmine_html-reporter .symbol-summary li.disabled { font-size: 14px; }\n.jasmine_html-reporter .symbol-summary li.disabled:before { color: #bababa; content: \"\\2022\"; }\n.jasmine_html-reporter .symbol-summary li.pending { line-height: 17px; }\n.jasmine_html-reporter .symbol-summary li.pending:before { color: #ba9d37; content: \"*\"; }\n.jasmine_html-reporter .symbol-summary li.empty { font-size: 14px; }\n.jasmine_html-reporter .symbol-summary li.empty:before { color: #ba9d37; content: \"\\2022\"; }\n.jasmine_html-reporter .run-options { float: right; margin-right: 5px; border: 1px solid #8a4182; color: #8a4182; position: relative; line-height: 20px; }\n.jasmine_html-reporter .run-options .trigger { cursor: pointer; padding: 8px 16px; }\n.jasmine_html-reporter .run-options .payload { position: absolute; display: none; right: -1px; border: 1px solid #8a4182; background-color: #eee; white-space: nowrap; padding: 4px 8px; }\n.jasmine_html-reporter .run-options .payload.open { display: block; }\n.jasmine_html-reporter .bar { line-height: 28px; font-size: 14px; display: block; color: #eee; }\n.jasmine_html-reporter .bar.failed { background-color: #ca3a11; }\n.jasmine_html-reporter .bar.passed { background-color: #007069; }\n.jasmine_html-reporter .bar.skipped { background-color: #bababa; }\n.jasmine_html-reporter .bar.errored { background-color: #ca3a11; }\n.jasmine_html-reporter .bar.menu { background-color: #fff; color: #aaa; }\n.jasmine_html-reporter .bar.menu a { color: #333; }\n.jasmine_html-reporter .bar a { color: white; }\n.jasmine_html-reporter.spec-list .bar.menu.failure-list, .jasmine_html-reporter.spec-list .results .failures { display: none; }\n.jasmine_html-reporter.failure-list .bar.menu.spec-list, .jasmine_html-reporter.failure-list .summary { display: none; }\n.jasmine_html-reporter .results { margin-top: 14px; }\n.jasmine_html-reporter .summary { margin-top: 14px; }\n.jasmine_html-reporter .summary ul { list-style-type: none; margin-left: 14px; padding-top: 0; padding-left: 0; }\n.jasmine_html-reporter .summary ul.suite { margin-top: 7px; margin-bottom: 7px; }\n.jasmine_html-reporter .summary li.passed a { color: #007069; }\n.jasmine_html-reporter .summary li.failed a { color: #ca3a11; }\n.jasmine_html-reporter .summary li.empty a { color: #ba9d37; }\n.jasmine_html-reporter .summary li.pending a { color: #ba9d37; }\n.jasmine_html-reporter .summary li.disabled a { color: #bababa; }\n.jasmine_html-reporter .description + .suite { margin-top: 0; }\n.jasmine_html-reporter .suite { margin-top: 14px; }\n.jasmine_html-reporter .suite a { color: #333; }\n.jasmine_html-reporter .failures .spec-detail { margin-bottom: 28px; }\n.jasmine_html-reporter .failures .spec-detail .description { background-color: #ca3a11; }\n.jasmine_html-reporter .failures .spec-detail .description a { color: white; }\n.jasmine_html-reporter .result-message { padding-top: 14px; color: #333; white-space: pre; }\n.jasmine_html-reporter .result-message span.result { display: block; }\n.jasmine_html-reporter .stack-trace { margin: 5px 0 0 0; max-height: 224px; overflow: auto; line-height: 18px; color: #666; border: 1px solid #ddd; background: white; white-space: pre; }\n", ""]);
	
	// exports


/***/ },
/* 3 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	// css base code, injected by the css-loader
	module.exports = function() {
		var list = [];
	
		// return the list of modules as css string
		list.toString = function toString() {
			var result = [];
			for(var i = 0; i < this.length; i++) {
				var item = this[i];
				if(item[2]) {
					result.push("@media " + item[2] + "{" + item[1] + "}");
				} else {
					result.push(item[1]);
				}
			}
			return result.join("");
		};
	
		// import a list of modules into the list
		list.i = function(modules, mediaQuery) {
			if(typeof modules === "string")
				modules = [[null, modules, ""]];
			var alreadyImportedModules = {};
			for(var i = 0; i < this.length; i++) {
				var id = this[i][0];
				if(typeof id === "number")
					alreadyImportedModules[id] = true;
			}
			for(i = 0; i < modules.length; i++) {
				var item = modules[i];
				// skip already imported module
				// this implementation is not 100% perfect for weird media query combinations
				//  when a module is imported multiple times with different media queries.
				//  I hope this will never occur (Hey this way we have smaller bundles)
				if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
					if(mediaQuery && !item[2]) {
						item[2] = mediaQuery;
					} else if(mediaQuery) {
						item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
					}
					list.push(item);
				}
			}
		};
		return list;
	};


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var stylesInDom = {},
		memoize = function(fn) {
			var memo;
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		},
		isOldIE = memoize(function() {
			return /msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase());
		}),
		getHeadElement = memoize(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		singletonElement = null,
		singletonCounter = 0,
		styleElementsInsertedAtTop = [];
	
	module.exports = function(list, options) {
		if(false) {
			if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}
	
		options = options || {};
		// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (typeof options.singleton === "undefined") options.singleton = isOldIE();
	
		// By default, add <style> tags to the bottom of <head>.
		if (typeof options.insertAt === "undefined") options.insertAt = "bottom";
	
		var styles = listToStyles(list);
		addStylesToDom(styles, options);
	
		return function update(newList) {
			var mayRemove = [];
			for(var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
			if(newList) {
				var newStyles = listToStyles(newList);
				addStylesToDom(newStyles, options);
			}
			for(var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
				if(domStyle.refs === 0) {
					for(var j = 0; j < domStyle.parts.length; j++)
						domStyle.parts[j]();
					delete stylesInDom[domStyle.id];
				}
			}
		};
	}
	
	function addStylesToDom(styles, options) {
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			if(domStyle) {
				domStyle.refs++;
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}
	
	function listToStyles(list) {
		var styles = [];
		var newStyles = {};
		for(var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
			if(!newStyles[id])
				styles.push(newStyles[id] = {id: id, parts: [part]});
			else
				newStyles[id].parts.push(part);
		}
		return styles;
	}
	
	function insertStyleElement(options, styleElement) {
		var head = getHeadElement();
		var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
		if (options.insertAt === "top") {
			if(!lastStyleElementInsertedAtTop) {
				head.insertBefore(styleElement, head.firstChild);
			} else if(lastStyleElementInsertedAtTop.nextSibling) {
				head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
			} else {
				head.appendChild(styleElement);
			}
			styleElementsInsertedAtTop.push(styleElement);
		} else if (options.insertAt === "bottom") {
			head.appendChild(styleElement);
		} else {
			throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
		}
	}
	
	function removeStyleElement(styleElement) {
		styleElement.parentNode.removeChild(styleElement);
		var idx = styleElementsInsertedAtTop.indexOf(styleElement);
		if(idx >= 0) {
			styleElementsInsertedAtTop.splice(idx, 1);
		}
	}
	
	function createStyleElement(options) {
		var styleElement = document.createElement("style");
		styleElement.type = "text/css";
		insertStyleElement(options, styleElement);
		return styleElement;
	}
	
	function createLinkElement(options) {
		var linkElement = document.createElement("link");
		linkElement.rel = "stylesheet";
		insertStyleElement(options, linkElement);
		return linkElement;
	}
	
	function addStyle(obj, options) {
		var styleElement, update, remove;
	
		if (options.singleton) {
			var styleIndex = singletonCounter++;
			styleElement = singletonElement || (singletonElement = createStyleElement(options));
			update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
			remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
		} else if(obj.sourceMap &&
			typeof URL === "function" &&
			typeof URL.createObjectURL === "function" &&
			typeof URL.revokeObjectURL === "function" &&
			typeof Blob === "function" &&
			typeof btoa === "function") {
			styleElement = createLinkElement(options);
			update = updateLink.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
				if(styleElement.href)
					URL.revokeObjectURL(styleElement.href);
			};
		} else {
			styleElement = createStyleElement(options);
			update = applyToTag.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
			};
		}
	
		update(obj);
	
		return function updateStyle(newObj) {
			if(newObj) {
				if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
					return;
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}
	
	var replaceText = (function () {
		var textStore = [];
	
		return function (index, replacement) {
			textStore[index] = replacement;
			return textStore.filter(Boolean).join('\n');
		};
	})();
	
	function applyToSingletonTag(styleElement, index, remove, obj) {
		var css = remove ? "" : obj.css;
	
		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = replaceText(index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = styleElement.childNodes;
			if (childNodes[index]) styleElement.removeChild(childNodes[index]);
			if (childNodes.length) {
				styleElement.insertBefore(cssNode, childNodes[index]);
			} else {
				styleElement.appendChild(cssNode);
			}
		}
	}
	
	function applyToTag(styleElement, obj) {
		var css = obj.css;
		var media = obj.media;
		var sourceMap = obj.sourceMap;
	
		if(media) {
			styleElement.setAttribute("media", media)
		}
	
		if(styleElement.styleSheet) {
			styleElement.styleSheet.cssText = css;
		} else {
			while(styleElement.firstChild) {
				styleElement.removeChild(styleElement.firstChild);
			}
			styleElement.appendChild(document.createTextNode(css));
		}
	}
	
	function updateLink(linkElement, obj) {
		var css = obj.css;
		var media = obj.media;
		var sourceMap = obj.sourceMap;
	
		if(sourceMap) {
			// http://stackoverflow.com/a/26603875
			css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
		}
	
		var blob = new Blob([css], { type: "text/css" });
	
		var oldSrc = linkElement.href;
	
		linkElement.href = URL.createObjectURL(blob);
	
		if(oldSrc)
			URL.revokeObjectURL(oldSrc);
	}


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * https://github.com/es-shims/es5-shim
	 * @license es5-shim Copyright 2009-2015 by contributors, MIT License
	 * see https://github.com/es-shims/es5-shim/blob/master/LICENSE
	 */
	
	// vim: ts=4 sts=4 sw=4 expandtab
	
	// Add semicolon to prevent IIFE from being passed as argument to concatenated code.
	;
	
	// UMD (Universal Module Definition)
	// see https://github.com/umdjs/umd/blob/master/templates/returnExports.js
	(function (root, factory) {
	    'use strict';
	
	    /* global define, exports, module */
	    if (true) {
	        // AMD. Register as an anonymous module.
	        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof exports === 'object') {
	        // Node. Does not work with strict CommonJS, but
	        // only CommonJS-like enviroments that support module.exports,
	        // like Node.
	        module.exports = factory();
	    } else {
	        // Browser globals (root is window)
	        root.returnExports = factory();
	    }
	}(this, function () {
	
	/**
	 * Brings an environment as close to ECMAScript 5 compliance
	 * as is possible with the facilities of erstwhile engines.
	 *
	 * Annotated ES5: http://es5.github.com/ (specific links below)
	 * ES5 Spec: http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf
	 * Required reading: http://javascriptweblog.wordpress.com/2011/12/05/extending-javascript-natives/
	 */
	
	// Shortcut to an often accessed properties, in order to avoid multiple
	// dereference that costs universally. This also holds a reference to known-good
	// functions.
	var $Array = Array;
	var ArrayPrototype = $Array.prototype;
	var $Object = Object;
	var ObjectPrototype = $Object.prototype;
	var FunctionPrototype = Function.prototype;
	var $String = String;
	var StringPrototype = $String.prototype;
	var $Number = Number;
	var NumberPrototype = $Number.prototype;
	var array_slice = ArrayPrototype.slice;
	var array_splice = ArrayPrototype.splice;
	var array_push = ArrayPrototype.push;
	var array_unshift = ArrayPrototype.unshift;
	var array_concat = ArrayPrototype.concat;
	var call = FunctionPrototype.call;
	var apply = FunctionPrototype.apply;
	var max = Math.max;
	var min = Math.min;
	
	// Having a toString local variable name breaks in Opera so use to_string.
	var to_string = ObjectPrototype.toString;
	
	var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';
	var isCallable; /* inlined from https://npmjs.com/is-callable */ var fnToStr = Function.prototype.toString, tryFunctionObject = function tryFunctionObject(value) { try { fnToStr.call(value); return true; } catch (e) { return false; } }, fnClass = '[object Function]', genClass = '[object GeneratorFunction]'; isCallable = function isCallable(value) { if (typeof value !== 'function') { return false; } if (hasToStringTag) { return tryFunctionObject(value); } var strClass = to_string.call(value); return strClass === fnClass || strClass === genClass; };
	var isRegex; /* inlined from https://npmjs.com/is-regex */ var regexExec = RegExp.prototype.exec, tryRegexExec = function tryRegexExec(value) { try { regexExec.call(value); return true; } catch (e) { return false; } }, regexClass = '[object RegExp]'; isRegex = function isRegex(value) { if (typeof value !== 'object') { return false; } return hasToStringTag ? tryRegexExec(value) : to_string.call(value) === regexClass; };
	var isString; /* inlined from https://npmjs.com/is-string */ var strValue = String.prototype.valueOf, tryStringObject = function tryStringObject(value) { try { strValue.call(value); return true; } catch (e) { return false; } }, stringClass = '[object String]'; isString = function isString(value) { if (typeof value === 'string') { return true; } if (typeof value !== 'object') { return false; } return hasToStringTag ? tryStringObject(value) : to_string.call(value) === stringClass; };
	
	/* inlined from http://npmjs.com/define-properties */
	var supportsDescriptors = $Object.defineProperty && (function () {
	    try {
	        var obj = {};
	        $Object.defineProperty(obj, 'x', { enumerable: false, value: obj });
	        for (var _ in obj) { return false; }
	        return obj.x === obj;
	    } catch (e) { /* this is ES3 */
	        return false;
	    }
	}());
	var defineProperties = (function (has) {
	  // Define configurable, writable, and non-enumerable props
	  // if they don't exist.
	  var defineProperty;
	  if (supportsDescriptors) {
	      defineProperty = function (object, name, method, forceAssign) {
	          if (!forceAssign && (name in object)) { return; }
	          $Object.defineProperty(object, name, {
	              configurable: true,
	              enumerable: false,
	              writable: true,
	              value: method
	          });
	      };
	  } else {
	      defineProperty = function (object, name, method, forceAssign) {
	          if (!forceAssign && (name in object)) { return; }
	          object[name] = method;
	      };
	  }
	  return function defineProperties(object, map, forceAssign) {
	      for (var name in map) {
	          if (has.call(map, name)) {
	            defineProperty(object, name, map[name], forceAssign);
	          }
	      }
	  };
	}(ObjectPrototype.hasOwnProperty));
	
	//
	// Util
	// ======
	//
	
	/* replaceable with https://npmjs.com/package/es-abstract /helpers/isPrimitive */
	var isPrimitive = function isPrimitive(input) {
	    var type = typeof input;
	    return input === null || (type !== 'object' && type !== 'function');
	};
	
	var isActualNaN = $Number.isNaN || function (x) { return x !== x; };
	
	var ES = {
	    // ES5 9.4
	    // http://es5.github.com/#x9.4
	    // http://jsperf.com/to-integer
	    /* replaceable with https://npmjs.com/package/es-abstract ES5.ToInteger */
	    ToInteger: function ToInteger(num) {
	        var n = +num;
	        if (isActualNaN(n)) {
	            n = 0;
	        } else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {
	            n = (n > 0 || -1) * Math.floor(Math.abs(n));
	        }
	        return n;
	    },
	
	    /* replaceable with https://npmjs.com/package/es-abstract ES5.ToPrimitive */
	    ToPrimitive: function ToPrimitive(input) {
	        var val, valueOf, toStr;
	        if (isPrimitive(input)) {
	            return input;
	        }
	        valueOf = input.valueOf;
	        if (isCallable(valueOf)) {
	            val = valueOf.call(input);
	            if (isPrimitive(val)) {
	                return val;
	            }
	        }
	        toStr = input.toString;
	        if (isCallable(toStr)) {
	            val = toStr.call(input);
	            if (isPrimitive(val)) {
	                return val;
	            }
	        }
	        throw new TypeError();
	    },
	
	    // ES5 9.9
	    // http://es5.github.com/#x9.9
	    /* replaceable with https://npmjs.com/package/es-abstract ES5.ToObject */
	    ToObject: function (o) {
	        if (o == null) { // this matches both null and undefined
	            throw new TypeError("can't convert " + o + ' to object');
	        }
	        return $Object(o);
	    },
	
	    /* replaceable with https://npmjs.com/package/es-abstract ES5.ToUint32 */
	    ToUint32: function ToUint32(x) {
	        return x >>> 0;
	    }
	};
	
	//
	// Function
	// ========
	//
	
	// ES-5 15.3.4.5
	// http://es5.github.com/#x15.3.4.5
	
	var Empty = function Empty() {};
	
	defineProperties(FunctionPrototype, {
	    bind: function bind(that) { // .length is 1
	        // 1. Let Target be the this value.
	        var target = this;
	        // 2. If IsCallable(Target) is false, throw a TypeError exception.
	        if (!isCallable(target)) {
	            throw new TypeError('Function.prototype.bind called on incompatible ' + target);
	        }
	        // 3. Let A be a new (possibly empty) internal list of all of the
	        //   argument values provided after thisArg (arg1, arg2 etc), in order.
	        // XXX slicedArgs will stand in for "A" if used
	        var args = array_slice.call(arguments, 1); // for normal call
	        // 4. Let F be a new native ECMAScript object.
	        // 11. Set the [[Prototype]] internal property of F to the standard
	        //   built-in Function prototype object as specified in 15.3.3.1.
	        // 12. Set the [[Call]] internal property of F as described in
	        //   15.3.4.5.1.
	        // 13. Set the [[Construct]] internal property of F as described in
	        //   15.3.4.5.2.
	        // 14. Set the [[HasInstance]] internal property of F as described in
	        //   15.3.4.5.3.
	        var bound;
	        var binder = function () {
	
	            if (this instanceof bound) {
	                // 15.3.4.5.2 [[Construct]]
	                // When the [[Construct]] internal method of a function object,
	                // F that was created using the bind function is called with a
	                // list of arguments ExtraArgs, the following steps are taken:
	                // 1. Let target be the value of F's [[TargetFunction]]
	                //   internal property.
	                // 2. If target has no [[Construct]] internal method, a
	                //   TypeError exception is thrown.
	                // 3. Let boundArgs be the value of F's [[BoundArgs]] internal
	                //   property.
	                // 4. Let args be a new list containing the same values as the
	                //   list boundArgs in the same order followed by the same
	                //   values as the list ExtraArgs in the same order.
	                // 5. Return the result of calling the [[Construct]] internal
	                //   method of target providing args as the arguments.
	
	                var result = target.apply(
	                    this,
	                    array_concat.call(args, array_slice.call(arguments))
	                );
	                if ($Object(result) === result) {
	                    return result;
	                }
	                return this;
	
	            } else {
	                // 15.3.4.5.1 [[Call]]
	                // When the [[Call]] internal method of a function object, F,
	                // which was created using the bind function is called with a
	                // this value and a list of arguments ExtraArgs, the following
	                // steps are taken:
	                // 1. Let boundArgs be the value of F's [[BoundArgs]] internal
	                //   property.
	                // 2. Let boundThis be the value of F's [[BoundThis]] internal
	                //   property.
	                // 3. Let target be the value of F's [[TargetFunction]] internal
	                //   property.
	                // 4. Let args be a new list containing the same values as the
	                //   list boundArgs in the same order followed by the same
	                //   values as the list ExtraArgs in the same order.
	                // 5. Return the result of calling the [[Call]] internal method
	                //   of target providing boundThis as the this value and
	                //   providing args as the arguments.
	
	                // equiv: target.call(this, ...boundArgs, ...args)
	                return target.apply(
	                    that,
	                    array_concat.call(args, array_slice.call(arguments))
	                );
	
	            }
	
	        };
	
	        // 15. If the [[Class]] internal property of Target is "Function", then
	        //     a. Let L be the length property of Target minus the length of A.
	        //     b. Set the length own property of F to either 0 or L, whichever is
	        //       larger.
	        // 16. Else set the length own property of F to 0.
	
	        var boundLength = max(0, target.length - args.length);
	
	        // 17. Set the attributes of the length own property of F to the values
	        //   specified in 15.3.5.1.
	        var boundArgs = [];
	        for (var i = 0; i < boundLength; i++) {
	            array_push.call(boundArgs, '$' + i);
	        }
	
	        // XXX Build a dynamic function with desired amount of arguments is the only
	        // way to set the length property of a function.
	        // In environments where Content Security Policies enabled (Chrome extensions,
	        // for ex.) all use of eval or Function costructor throws an exception.
	        // However in all of these environments Function.prototype.bind exists
	        // and so this code will never be executed.
	        bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this, arguments); }')(binder);
	
	        if (target.prototype) {
	            Empty.prototype = target.prototype;
	            bound.prototype = new Empty();
	            // Clean up dangling references.
	            Empty.prototype = null;
	        }
	
	        // TODO
	        // 18. Set the [[Extensible]] internal property of F to true.
	
	        // TODO
	        // 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).
	        // 20. Call the [[DefineOwnProperty]] internal method of F with
	        //   arguments "caller", PropertyDescriptor {[[Get]]: thrower, [[Set]]:
	        //   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and
	        //   false.
	        // 21. Call the [[DefineOwnProperty]] internal method of F with
	        //   arguments "arguments", PropertyDescriptor {[[Get]]: thrower,
	        //   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},
	        //   and false.
	
	        // TODO
	        // NOTE Function objects created using Function.prototype.bind do not
	        // have a prototype property or the [[Code]], [[FormalParameters]], and
	        // [[Scope]] internal properties.
	        // XXX can't delete prototype in pure-js.
	
	        // 22. Return F.
	        return bound;
	    }
	});
	
	// _Please note: Shortcuts are defined after `Function.prototype.bind` as we
	// use it in defining shortcuts.
	var owns = call.bind(ObjectPrototype.hasOwnProperty);
	var toStr = call.bind(ObjectPrototype.toString);
	var arraySlice = call.bind(array_slice);
	var arraySliceApply = apply.bind(array_slice);
	var strSlice = call.bind(StringPrototype.slice);
	var strSplit = call.bind(StringPrototype.split);
	var strIndexOf = call.bind(StringPrototype.indexOf);
	var push = call.bind(array_push);
	var isEnum = call.bind(ObjectPrototype.propertyIsEnumerable);
	var arraySort = call.bind(ArrayPrototype.sort);
	
	//
	// Array
	// =====
	//
	
	var isArray = $Array.isArray || function isArray(obj) {
	    return toStr(obj) === '[object Array]';
	};
	
	// ES5 15.4.4.12
	// http://es5.github.com/#x15.4.4.13
	// Return len+argCount.
	// [bugfix, ielt8]
	// IE < 8 bug: [].unshift(0) === undefined but should be "1"
	var hasUnshiftReturnValueBug = [].unshift(0) !== 1;
	defineProperties(ArrayPrototype, {
	    unshift: function () {
	        array_unshift.apply(this, arguments);
	        return this.length;
	    }
	}, hasUnshiftReturnValueBug);
	
	// ES5 15.4.3.2
	// http://es5.github.com/#x15.4.3.2
	// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray
	defineProperties($Array, { isArray: isArray });
	
	// The IsCallable() check in the Array functions
	// has been replaced with a strict check on the
	// internal class of the object to trap cases where
	// the provided function was actually a regular
	// expression literal, which in V8 and
	// JavaScriptCore is a typeof "function".  Only in
	// V8 are regular expression literals permitted as
	// reduce parameters, so it is desirable in the
	// general case for the shim to match the more
	// strict and common behavior of rejecting regular
	// expressions.
	
	// ES5 15.4.4.18
	// http://es5.github.com/#x15.4.4.18
	// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/array/forEach
	
	// Check failure of by-index access of string characters (IE < 9)
	// and failure of `0 in boxedString` (Rhino)
	var boxedString = $Object('a');
	var splitString = boxedString[0] !== 'a' || !(0 in boxedString);
	
	var properlyBoxesContext = function properlyBoxed(method) {
	    // Check node 0.6.21 bug where third parameter is not boxed
	    var properlyBoxesNonStrict = true;
	    var properlyBoxesStrict = true;
	    if (method) {
	        method.call('foo', function (_, __, context) {
	            if (typeof context !== 'object') { properlyBoxesNonStrict = false; }
	        });
	
	        method.call([1], function () {
	            'use strict';
	
	            properlyBoxesStrict = typeof this === 'string';
	        }, 'x');
	    }
	    return !!method && properlyBoxesNonStrict && properlyBoxesStrict;
	};
	
	defineProperties(ArrayPrototype, {
	    forEach: function forEach(callbackfn/*, thisArg*/) {
	        var object = ES.ToObject(this);
	        var self = splitString && isString(this) ? strSplit(this, '') : object;
	        var i = -1;
	        var length = ES.ToUint32(self.length);
	        var T;
	        if (arguments.length > 1) {
	          T = arguments[1];
	        }
	
	        // If no callback function or if callback is not a callable function
	        if (!isCallable(callbackfn)) {
	            throw new TypeError('Array.prototype.forEach callback must be a function');
	        }
	
	        while (++i < length) {
	            if (i in self) {
	                // Invoke the callback function with call, passing arguments:
	                // context, property value, property key, thisArg object
	                if (typeof T === 'undefined') {
	                    callbackfn(self[i], i, object);
	                } else {
	                    callbackfn.call(T, self[i], i, object);
	                }
	            }
	        }
	    }
	}, !properlyBoxesContext(ArrayPrototype.forEach));
	
	// ES5 15.4.4.19
	// http://es5.github.com/#x15.4.4.19
	// https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map
	defineProperties(ArrayPrototype, {
	    map: function map(callbackfn/*, thisArg*/) {
	        var object = ES.ToObject(this);
	        var self = splitString && isString(this) ? strSplit(this, '') : object;
	        var length = ES.ToUint32(self.length);
	        var result = $Array(length);
	        var T;
	        if (arguments.length > 1) {
	            T = arguments[1];
	        }
	
	        // If no callback function or if callback is not a callable function
	        if (!isCallable(callbackfn)) {
	            throw new TypeError('Array.prototype.map callback must be a function');
	        }
	
	        for (var i = 0; i < length; i++) {
	            if (i in self) {
	                if (typeof T === 'undefined') {
	                    result[i] = callbackfn(self[i], i, object);
	                } else {
	                    result[i] = callbackfn.call(T, self[i], i, object);
	                }
	            }
	        }
	        return result;
	    }
	}, !properlyBoxesContext(ArrayPrototype.map));
	
	// ES5 15.4.4.20
	// http://es5.github.com/#x15.4.4.20
	// https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter
	defineProperties(ArrayPrototype, {
	    filter: function filter(callbackfn/*, thisArg*/) {
	        var object = ES.ToObject(this);
	        var self = splitString && isString(this) ? strSplit(this, '') : object;
	        var length = ES.ToUint32(self.length);
	        var result = [];
	        var value;
	        var T;
	        if (arguments.length > 1) {
	            T = arguments[1];
	        }
	
	        // If no callback function or if callback is not a callable function
	        if (!isCallable(callbackfn)) {
	            throw new TypeError('Array.prototype.filter callback must be a function');
	        }
	
	        for (var i = 0; i < length; i++) {
	            if (i in self) {
	                value = self[i];
	                if (typeof T === 'undefined' ? callbackfn(value, i, object) : callbackfn.call(T, value, i, object)) {
	                    push(result, value);
	                }
	            }
	        }
	        return result;
	    }
	}, !properlyBoxesContext(ArrayPrototype.filter));
	
	// ES5 15.4.4.16
	// http://es5.github.com/#x15.4.4.16
	// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/every
	defineProperties(ArrayPrototype, {
	    every: function every(callbackfn/*, thisArg*/) {
	        var object = ES.ToObject(this);
	        var self = splitString && isString(this) ? strSplit(this, '') : object;
	        var length = ES.ToUint32(self.length);
	        var T;
	        if (arguments.length > 1) {
	            T = arguments[1];
	        }
	
	        // If no callback function or if callback is not a callable function
	        if (!isCallable(callbackfn)) {
	            throw new TypeError('Array.prototype.every callback must be a function');
	        }
	
	        for (var i = 0; i < length; i++) {
	            if (i in self && !(typeof T === 'undefined' ? callbackfn(self[i], i, object) : callbackfn.call(T, self[i], i, object))) {
	                return false;
	            }
	        }
	        return true;
	    }
	}, !properlyBoxesContext(ArrayPrototype.every));
	
	// ES5 15.4.4.17
	// http://es5.github.com/#x15.4.4.17
	// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/some
	defineProperties(ArrayPrototype, {
	    some: function some(callbackfn/*, thisArg */) {
	        var object = ES.ToObject(this);
	        var self = splitString && isString(this) ? strSplit(this, '') : object;
	        var length = ES.ToUint32(self.length);
	        var T;
	        if (arguments.length > 1) {
	            T = arguments[1];
	        }
	
	        // If no callback function or if callback is not a callable function
	        if (!isCallable(callbackfn)) {
	            throw new TypeError('Array.prototype.some callback must be a function');
	        }
	
	        for (var i = 0; i < length; i++) {
	            if (i in self && (typeof T === 'undefined' ? callbackfn(self[i], i, object) : callbackfn.call(T, self[i], i, object))) {
	                return true;
	            }
	        }
	        return false;
	    }
	}, !properlyBoxesContext(ArrayPrototype.some));
	
	// ES5 15.4.4.21
	// http://es5.github.com/#x15.4.4.21
	// https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/reduce
	var reduceCoercesToObject = false;
	if (ArrayPrototype.reduce) {
	    reduceCoercesToObject = typeof ArrayPrototype.reduce.call('es5', function (_, __, ___, list) { return list; }) === 'object';
	}
	defineProperties(ArrayPrototype, {
	    reduce: function reduce(callbackfn/*, initialValue*/) {
	        var object = ES.ToObject(this);
	        var self = splitString && isString(this) ? strSplit(this, '') : object;
	        var length = ES.ToUint32(self.length);
	
	        // If no callback function or if callback is not a callable function
	        if (!isCallable(callbackfn)) {
	            throw new TypeError('Array.prototype.reduce callback must be a function');
	        }
	
	        // no value to return if no initial value and an empty array
	        if (length === 0 && arguments.length === 1) {
	            throw new TypeError('reduce of empty array with no initial value');
	        }
	
	        var i = 0;
	        var result;
	        if (arguments.length >= 2) {
	            result = arguments[1];
	        } else {
	            do {
	                if (i in self) {
	                    result = self[i++];
	                    break;
	                }
	
	                // if array contains no values, no initial value to return
	                if (++i >= length) {
	                    throw new TypeError('reduce of empty array with no initial value');
	                }
	            } while (true);
	        }
	
	        for (; i < length; i++) {
	            if (i in self) {
	                result = callbackfn(result, self[i], i, object);
	            }
	        }
	
	        return result;
	    }
	}, !reduceCoercesToObject);
	
	// ES5 15.4.4.22
	// http://es5.github.com/#x15.4.4.22
	// https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/reduceRight
	var reduceRightCoercesToObject = false;
	if (ArrayPrototype.reduceRight) {
	    reduceRightCoercesToObject = typeof ArrayPrototype.reduceRight.call('es5', function (_, __, ___, list) { return list; }) === 'object';
	}
	defineProperties(ArrayPrototype, {
	    reduceRight: function reduceRight(callbackfn/*, initial*/) {
	        var object = ES.ToObject(this);
	        var self = splitString && isString(this) ? strSplit(this, '') : object;
	        var length = ES.ToUint32(self.length);
	
	        // If no callback function or if callback is not a callable function
	        if (!isCallable(callbackfn)) {
	            throw new TypeError('Array.prototype.reduceRight callback must be a function');
	        }
	
	        // no value to return if no initial value, empty array
	        if (length === 0 && arguments.length === 1) {
	            throw new TypeError('reduceRight of empty array with no initial value');
	        }
	
	        var result;
	        var i = length - 1;
	        if (arguments.length >= 2) {
	            result = arguments[1];
	        } else {
	            do {
	                if (i in self) {
	                    result = self[i--];
	                    break;
	                }
	
	                // if array contains no values, no initial value to return
	                if (--i < 0) {
	                    throw new TypeError('reduceRight of empty array with no initial value');
	                }
	            } while (true);
	        }
	
	        if (i < 0) {
	            return result;
	        }
	
	        do {
	            if (i in self) {
	                result = callbackfn(result, self[i], i, object);
	            }
	        } while (i--);
	
	        return result;
	    }
	}, !reduceRightCoercesToObject);
	
	// ES5 15.4.4.14
	// http://es5.github.com/#x15.4.4.14
	// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf
	var hasFirefox2IndexOfBug = ArrayPrototype.indexOf && [0, 1].indexOf(1, 2) !== -1;
	defineProperties(ArrayPrototype, {
	    indexOf: function indexOf(searchElement/*, fromIndex */) {
	        var self = splitString && isString(this) ? strSplit(this, '') : ES.ToObject(this);
	        var length = ES.ToUint32(self.length);
	
	        if (length === 0) {
	            return -1;
	        }
	
	        var i = 0;
	        if (arguments.length > 1) {
	            i = ES.ToInteger(arguments[1]);
	        }
	
	        // handle negative indices
	        i = i >= 0 ? i : max(0, length + i);
	        for (; i < length; i++) {
	            if (i in self && self[i] === searchElement) {
	                return i;
	            }
	        }
	        return -1;
	    }
	}, hasFirefox2IndexOfBug);
	
	// ES5 15.4.4.15
	// http://es5.github.com/#x15.4.4.15
	// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/lastIndexOf
	var hasFirefox2LastIndexOfBug = ArrayPrototype.lastIndexOf && [0, 1].lastIndexOf(0, -3) !== -1;
	defineProperties(ArrayPrototype, {
	    lastIndexOf: function lastIndexOf(searchElement/*, fromIndex */) {
	        var self = splitString && isString(this) ? strSplit(this, '') : ES.ToObject(this);
	        var length = ES.ToUint32(self.length);
	
	        if (length === 0) {
	            return -1;
	        }
	        var i = length - 1;
	        if (arguments.length > 1) {
	            i = min(i, ES.ToInteger(arguments[1]));
	        }
	        // handle negative indices
	        i = i >= 0 ? i : length - Math.abs(i);
	        for (; i >= 0; i--) {
	            if (i in self && searchElement === self[i]) {
	                return i;
	            }
	        }
	        return -1;
	    }
	}, hasFirefox2LastIndexOfBug);
	
	// ES5 15.4.4.12
	// http://es5.github.com/#x15.4.4.12
	var spliceNoopReturnsEmptyArray = (function () {
	    var a = [1, 2];
	    var result = a.splice();
	    return a.length === 2 && isArray(result) && result.length === 0;
	}());
	defineProperties(ArrayPrototype, {
	    // Safari 5.0 bug where .splice() returns undefined
	    splice: function splice(start, deleteCount) {
	        if (arguments.length === 0) {
	            return [];
	        } else {
	            return array_splice.apply(this, arguments);
	        }
	    }
	}, !spliceNoopReturnsEmptyArray);
	
	var spliceWorksWithEmptyObject = (function () {
	    var obj = {};
	    ArrayPrototype.splice.call(obj, 0, 0, 1);
	    return obj.length === 1;
	}());
	defineProperties(ArrayPrototype, {
	    splice: function splice(start, deleteCount) {
	        if (arguments.length === 0) { return []; }
	        var args = arguments;
	        this.length = max(ES.ToInteger(this.length), 0);
	        if (arguments.length > 0 && typeof deleteCount !== 'number') {
	            args = arraySlice(arguments);
	            if (args.length < 2) {
	                push(args, this.length - start);
	            } else {
	                args[1] = ES.ToInteger(deleteCount);
	            }
	        }
	        return array_splice.apply(this, args);
	    }
	}, !spliceWorksWithEmptyObject);
	var spliceWorksWithLargeSparseArrays = (function () {
	    // Per https://github.com/es-shims/es5-shim/issues/295
	    // Safari 7/8 breaks with sparse arrays of size 1e5 or greater
	    var arr = new $Array(1e5);
	    // note: the index MUST be 8 or larger or the test will false pass
	    arr[8] = 'x';
	    arr.splice(1, 1);
	    // note: this test must be defined *after* the indexOf shim
	    // per https://github.com/es-shims/es5-shim/issues/313
	    return arr.indexOf('x') === 7;
	}());
	var spliceWorksWithSmallSparseArrays = (function () {
	    // Per https://github.com/es-shims/es5-shim/issues/295
	    // Opera 12.15 breaks on this, no idea why.
	    var n = 256;
	    var arr = [];
	    arr[n] = 'a';
	    arr.splice(n + 1, 0, 'b');
	    return arr[n] === 'a';
	}());
	defineProperties(ArrayPrototype, {
	    splice: function splice(start, deleteCount) {
	        var O = ES.ToObject(this);
	        var A = [];
	        var len = ES.ToUint32(O.length);
	        var relativeStart = ES.ToInteger(start);
	        var actualStart = relativeStart < 0 ? max((len + relativeStart), 0) : min(relativeStart, len);
	        var actualDeleteCount = min(max(ES.ToInteger(deleteCount), 0), len - actualStart);
	
	        var k = 0;
	        var from;
	        while (k < actualDeleteCount) {
	            from = $String(actualStart + k);
	            if (owns(O, from)) {
	                A[k] = O[from];
	            }
	            k += 1;
	        }
	
	        var items = arraySlice(arguments, 2);
	        var itemCount = items.length;
	        var to;
	        if (itemCount < actualDeleteCount) {
	            k = actualStart;
	            while (k < (len - actualDeleteCount)) {
	                from = $String(k + actualDeleteCount);
	                to = $String(k + itemCount);
	                if (owns(O, from)) {
	                    O[to] = O[from];
	                } else {
	                    delete O[to];
	                }
	                k += 1;
	            }
	            k = len;
	            while (k > (len - actualDeleteCount + itemCount)) {
	                delete O[k - 1];
	                k -= 1;
	            }
	        } else if (itemCount > actualDeleteCount) {
	            k = len - actualDeleteCount;
	            while (k > actualStart) {
	                from = $String(k + actualDeleteCount - 1);
	                to = $String(k + itemCount - 1);
	                if (owns(O, from)) {
	                    O[to] = O[from];
	                } else {
	                    delete O[to];
	                }
	                k -= 1;
	            }
	        }
	        k = actualStart;
	        for (var i = 0; i < items.length; ++i) {
	            O[k] = items[i];
	            k += 1;
	        }
	        O.length = len - actualDeleteCount + itemCount;
	
	        return A;
	    }
	}, !spliceWorksWithLargeSparseArrays || !spliceWorksWithSmallSparseArrays);
	
	var originalJoin = ArrayPrototype.join;
	var hasStringJoinBug;
	try {
	    hasStringJoinBug = Array.prototype.join.call('123', ',') !== '1,2,3';
	} catch (e) {
	    hasStringJoinBug = true;
	}
	if (hasStringJoinBug) {
	    defineProperties(ArrayPrototype, {
	        join: function join(separator) {
	            var sep = typeof separator === 'undefined' ? ',' : separator;
	            return originalJoin.call(isString(this) ? strSplit(this, '') : this, sep);
	        }
	    }, hasStringJoinBug);
	}
	
	var hasJoinUndefinedBug = [1, 2].join(undefined) !== '1,2';
	if (hasJoinUndefinedBug) {
	    defineProperties(ArrayPrototype, {
	        join: function join(separator) {
	            var sep = typeof separator === 'undefined' ? ',' : separator;
	            return originalJoin.call(this, sep);
	        }
	    }, hasJoinUndefinedBug);
	}
	
	var pushShim = function push(item) {
	    var O = ES.ToObject(this);
	    var n = ES.ToUint32(O.length);
	    var i = 0;
	    while (i < arguments.length) {
	        O[n + i] = arguments[i];
	        i += 1;
	    }
	    O.length = n + i;
	    return n + i;
	};
	
	var pushIsNotGeneric = (function () {
	    var obj = {};
	    var result = Array.prototype.push.call(obj, undefined);
	    return result !== 1 || obj.length !== 1 || typeof obj[0] !== 'undefined' || !owns(obj, 0);
	}());
	defineProperties(ArrayPrototype, {
	    push: function push(item) {
	        if (isArray(this)) {
	            return array_push.apply(this, arguments);
	        }
	        return pushShim.apply(this, arguments);
	    }
	}, pushIsNotGeneric);
	
	// This fixes a very weird bug in Opera 10.6 when pushing `undefined
	var pushUndefinedIsWeird = (function () {
	    var arr = [];
	    var result = arr.push(undefined);
	    return result !== 1 || arr.length !== 1 || typeof arr[0] !== 'undefined' || !owns(arr, 0);
	}());
	defineProperties(ArrayPrototype, { push: pushShim }, pushUndefinedIsWeird);
	
	// ES5 15.2.3.14
	// http://es5.github.io/#x15.4.4.10
	// Fix boxed string bug
	defineProperties(ArrayPrototype, {
	    slice: function (start, end) {
	        var arr = isString(this) ? strSplit(this, '') : this;
	        return arraySliceApply(arr, arguments);
	    }
	}, splitString);
	
	var sortIgnoresNonFunctions = (function () {
	    try {
	        [1, 2].sort(null);
	        [1, 2].sort({});
	        return true;
	    } catch (e) { /**/ }
	    return false;
	}());
	var sortThrowsOnRegex = (function () {
	    // this is a problem in Firefox 4, in which `typeof /a/ === 'function'`
	    try {
	        [1, 2].sort(/a/);
	        return false;
	    } catch (e) { /**/ }
	    return true;
	}());
	var sortIgnoresUndefined = (function () {
	    // applies in IE 8, for one.
	    try {
	        [1, 2].sort(undefined);
	        return true;
	    } catch (e) { /**/ }
	    return false;
	}());
	defineProperties(ArrayPrototype, {
	    sort: function sort(compareFn) {
	        if (typeof compareFn === 'undefined') {
	            return arraySort(this);
	        }
	        if (!isCallable(compareFn)) {
	            throw new TypeError('Array.prototype.sort callback must be a function');
	        }
	        return arraySort(this, compareFn);
	    }
	}, sortIgnoresNonFunctions || !sortIgnoresUndefined || !sortThrowsOnRegex);
	
	//
	// Object
	// ======
	//
	
	// ES5 15.2.3.14
	// http://es5.github.com/#x15.2.3.14
	
	// http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation
	var hasDontEnumBug = !({ 'toString': null }).propertyIsEnumerable('toString');
	var hasProtoEnumBug = function () {}.propertyIsEnumerable('prototype');
	var hasStringEnumBug = !owns('x', '0');
	var equalsConstructorPrototype = function (o) {
	    var ctor = o.constructor;
	    return ctor && ctor.prototype === o;
	};
	var blacklistedKeys = {
	    $window: true,
	    $console: true,
	    $parent: true,
	    $self: true,
	    $frame: true,
	    $frames: true,
	    $frameElement: true,
	    $webkitIndexedDB: true,
	    $webkitStorageInfo: true,
	    $external: true
	};
	var hasAutomationEqualityBug = (function () {
	    /* globals window */
	    if (typeof window === 'undefined') { return false; }
	    for (var k in window) {
	        try {
	            if (!blacklistedKeys['$' + k] && owns(window, k) && window[k] !== null && typeof window[k] === 'object') {
	                equalsConstructorPrototype(window[k]);
	            }
	        } catch (e) {
	            return true;
	        }
	    }
	    return false;
	}());
	var equalsConstructorPrototypeIfNotBuggy = function (object) {
	    if (typeof window === 'undefined' || !hasAutomationEqualityBug) { return equalsConstructorPrototype(object); }
	    try {
	        return equalsConstructorPrototype(object);
	    } catch (e) {
	        return false;
	    }
	};
	var dontEnums = [
	    'toString',
	    'toLocaleString',
	    'valueOf',
	    'hasOwnProperty',
	    'isPrototypeOf',
	    'propertyIsEnumerable',
	    'constructor'
	];
	var dontEnumsLength = dontEnums.length;
	
	// taken directly from https://github.com/ljharb/is-arguments/blob/master/index.js
	// can be replaced with require('is-arguments') if we ever use a build process instead
	var isStandardArguments = function isArguments(value) {
	    return toStr(value) === '[object Arguments]';
	};
	var isLegacyArguments = function isArguments(value) {
	    return value !== null &&
	        typeof value === 'object' &&
	        typeof value.length === 'number' &&
	        value.length >= 0 &&
	        !isArray(value) &&
	        isCallable(value.callee);
	};
	var isArguments = isStandardArguments(arguments) ? isStandardArguments : isLegacyArguments;
	
	defineProperties($Object, {
	    keys: function keys(object) {
	        var isFn = isCallable(object);
	        var isArgs = isArguments(object);
	        var isObject = object !== null && typeof object === 'object';
	        var isStr = isObject && isString(object);
	
	        if (!isObject && !isFn && !isArgs) {
	            throw new TypeError('Object.keys called on a non-object');
	        }
	
	        var theKeys = [];
	        var skipProto = hasProtoEnumBug && isFn;
	        if ((isStr && hasStringEnumBug) || isArgs) {
	            for (var i = 0; i < object.length; ++i) {
	                push(theKeys, $String(i));
	            }
	        }
	
	        if (!isArgs) {
	            for (var name in object) {
	                if (!(skipProto && name === 'prototype') && owns(object, name)) {
	                    push(theKeys, $String(name));
	                }
	            }
	        }
	
	        if (hasDontEnumBug) {
	            var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
	            for (var j = 0; j < dontEnumsLength; j++) {
	                var dontEnum = dontEnums[j];
	                if (!(skipConstructor && dontEnum === 'constructor') && owns(object, dontEnum)) {
	                    push(theKeys, dontEnum);
	                }
	            }
	        }
	        return theKeys;
	    }
	});
	
	var keysWorksWithArguments = $Object.keys && (function () {
	    // Safari 5.0 bug
	    return $Object.keys(arguments).length === 2;
	}(1, 2));
	var keysHasArgumentsLengthBug = $Object.keys && (function () {
	    var argKeys = $Object.keys(arguments);
	    return arguments.length !== 1 || argKeys.length !== 1 || argKeys[0] !== 1;
	}(1));
	var originalKeys = $Object.keys;
	defineProperties($Object, {
	    keys: function keys(object) {
	        if (isArguments(object)) {
	            return originalKeys(arraySlice(object));
	        } else {
	            return originalKeys(object);
	        }
	    }
	}, !keysWorksWithArguments || keysHasArgumentsLengthBug);
	
	//
	// Date
	// ====
	//
	
	// ES5 15.9.5.43
	// http://es5.github.com/#x15.9.5.43
	// This function returns a String value represent the instance in time
	// represented by this Date object. The format of the String is the Date Time
	// string format defined in 15.9.1.15. All fields are present in the String.
	// The time zone is always UTC, denoted by the suffix Z. If the time value of
	// this object is not a finite Number a RangeError exception is thrown.
	var negativeDate = -62198755200000;
	var negativeYearString = '-000001';
	var hasNegativeDateBug = Date.prototype.toISOString && new Date(negativeDate).toISOString().indexOf(negativeYearString) === -1;
	var hasSafari51DateBug = Date.prototype.toISOString && new Date(-1).toISOString() !== '1969-12-31T23:59:59.999Z';
	
	defineProperties(Date.prototype, {
	    toISOString: function toISOString() {
	        var result, length, value, year, month;
	        if (!isFinite(this)) {
	            throw new RangeError('Date.prototype.toISOString called on non-finite value.');
	        }
	
	        year = this.getUTCFullYear();
	
	        month = this.getUTCMonth();
	        // see https://github.com/es-shims/es5-shim/issues/111
	        year += Math.floor(month / 12);
	        month = (month % 12 + 12) % 12;
	
	        // the date time string format is specified in 15.9.1.15.
	        result = [month + 1, this.getUTCDate(), this.getUTCHours(), this.getUTCMinutes(), this.getUTCSeconds()];
	        year = (
	            (year < 0 ? '-' : (year > 9999 ? '+' : '')) +
	            strSlice('00000' + Math.abs(year), (0 <= year && year <= 9999) ? -4 : -6)
	        );
	
	        length = result.length;
	        while (length--) {
	            value = result[length];
	            // pad months, days, hours, minutes, and seconds to have two
	            // digits.
	            if (value < 10) {
	                result[length] = '0' + value;
	            }
	        }
	        // pad milliseconds to have three digits.
	        return (
	            year + '-' + arraySlice(result, 0, 2).join('-') +
	            'T' + arraySlice(result, 2).join(':') + '.' +
	            strSlice('000' + this.getUTCMilliseconds(), -3) + 'Z'
	        );
	    }
	}, hasNegativeDateBug || hasSafari51DateBug);
	
	// ES5 15.9.5.44
	// http://es5.github.com/#x15.9.5.44
	// This function provides a String representation of a Date object for use by
	// JSON.stringify (15.12.3).
	var dateToJSONIsSupported = (function () {
	    try {
	        return Date.prototype.toJSON &&
	            new Date(NaN).toJSON() === null &&
	            new Date(negativeDate).toJSON().indexOf(negativeYearString) !== -1 &&
	            Date.prototype.toJSON.call({ // generic
	                toISOString: function () { return true; }
	            });
	    } catch (e) {
	        return false;
	    }
	}());
	if (!dateToJSONIsSupported) {
	    Date.prototype.toJSON = function toJSON(key) {
	        // When the toJSON method is called with argument key, the following
	        // steps are taken:
	
	        // 1.  Let O be the result of calling ToObject, giving it the this
	        // value as its argument.
	        // 2. Let tv be ES.ToPrimitive(O, hint Number).
	        var O = $Object(this);
	        var tv = ES.ToPrimitive(O);
	        // 3. If tv is a Number and is not finite, return null.
	        if (typeof tv === 'number' && !isFinite(tv)) {
	            return null;
	        }
	        // 4. Let toISO be the result of calling the [[Get]] internal method of
	        // O with argument "toISOString".
	        var toISO = O.toISOString;
	        // 5. If IsCallable(toISO) is false, throw a TypeError exception.
	        if (!isCallable(toISO)) {
	            throw new TypeError('toISOString property is not callable');
	        }
	        // 6. Return the result of calling the [[Call]] internal method of
	        //  toISO with O as the this value and an empty argument list.
	        return toISO.call(O);
	
	        // NOTE 1 The argument is ignored.
	
	        // NOTE 2 The toJSON function is intentionally generic; it does not
	        // require that its this value be a Date object. Therefore, it can be
	        // transferred to other kinds of objects for use as a method. However,
	        // it does require that any such object have a toISOString method. An
	        // object is free to use the argument key to filter its
	        // stringification.
	    };
	}
	
	// ES5 15.9.4.2
	// http://es5.github.com/#x15.9.4.2
	// based on work shared by Daniel Friesen (dantman)
	// http://gist.github.com/303249
	var supportsExtendedYears = Date.parse('+033658-09-27T01:46:40.000Z') === 1e15;
	var acceptsInvalidDates = !isNaN(Date.parse('2012-04-04T24:00:00.500Z')) || !isNaN(Date.parse('2012-11-31T23:59:59.000Z')) || !isNaN(Date.parse('2012-12-31T23:59:60.000Z'));
	var doesNotParseY2KNewYear = isNaN(Date.parse('2000-01-01T00:00:00.000Z'));
	if (doesNotParseY2KNewYear || acceptsInvalidDates || !supportsExtendedYears) {
	    // XXX global assignment won't work in embeddings that use
	    // an alternate object for the context.
	    /* global Date: true */
	    /* eslint-disable no-undef */
	    var maxSafeUnsigned32Bit = Math.pow(2, 31) - 1;
	    var hasSafariSignedIntBug = isActualNaN(new Date(1970, 0, 1, 0, 0, 0, maxSafeUnsigned32Bit + 1).getTime());
	    Date = (function (NativeDate) {
	    /* eslint-enable no-undef */
	        // Date.length === 7
	        var DateShim = function Date(Y, M, D, h, m, s, ms) {
	            var length = arguments.length;
	            var date;
	            if (this instanceof NativeDate) {
	                var seconds = s;
	                var millis = ms;
	                if (hasSafariSignedIntBug && length >= 7 && ms > maxSafeUnsigned32Bit) {
	                    // work around a Safari 8/9 bug where it treats the seconds as signed
	                    var msToShift = Math.floor(ms / maxSafeUnsigned32Bit) * maxSafeUnsigned32Bit;
	                    var sToShift = Math.floor(msToShift / 1e3);
	                    seconds += sToShift;
	                    millis -= sToShift * 1e3;
	                }
	                date = length === 1 && $String(Y) === Y ? // isString(Y)
	                    // We explicitly pass it through parse:
	                    new NativeDate(DateShim.parse(Y)) :
	                    // We have to manually make calls depending on argument
	                    // length here
	                    length >= 7 ? new NativeDate(Y, M, D, h, m, seconds, millis) :
	                    length >= 6 ? new NativeDate(Y, M, D, h, m, seconds) :
	                    length >= 5 ? new NativeDate(Y, M, D, h, m) :
	                    length >= 4 ? new NativeDate(Y, M, D, h) :
	                    length >= 3 ? new NativeDate(Y, M, D) :
	                    length >= 2 ? new NativeDate(Y, M) :
	                    length >= 1 ? new NativeDate(Y) :
	                                  new NativeDate();
	            } else {
	                date = NativeDate.apply(this, arguments);
	            }
	            if (!isPrimitive(date)) {
	              // Prevent mixups with unfixed Date object
	              defineProperties(date, { constructor: DateShim }, true);
	            }
	            return date;
	        };
	
	        // 15.9.1.15 Date Time String Format.
	        var isoDateExpression = new RegExp('^' +
	            '(\\d{4}|[+-]\\d{6})' + // four-digit year capture or sign +
	                                      // 6-digit extended year
	            '(?:-(\\d{2})' + // optional month capture
	            '(?:-(\\d{2})' + // optional day capture
	            '(?:' + // capture hours:minutes:seconds.milliseconds
	                'T(\\d{2})' + // hours capture
	                ':(\\d{2})' + // minutes capture
	                '(?:' + // optional :seconds.milliseconds
	                    ':(\\d{2})' + // seconds capture
	                    '(?:(\\.\\d{1,}))?' + // milliseconds capture
	                ')?' +
	            '(' + // capture UTC offset component
	                'Z|' + // UTC capture
	                '(?:' + // offset specifier +/-hours:minutes
	                    '([-+])' + // sign capture
	                    '(\\d{2})' + // hours offset capture
	                    ':(\\d{2})' + // minutes offset capture
	                ')' +
	            ')?)?)?)?' +
	        '$');
	
	        var months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365];
	
	        var dayFromMonth = function dayFromMonth(year, month) {
	            var t = month > 1 ? 1 : 0;
	            return (
	                months[month] +
	                Math.floor((year - 1969 + t) / 4) -
	                Math.floor((year - 1901 + t) / 100) +
	                Math.floor((year - 1601 + t) / 400) +
	                365 * (year - 1970)
	            );
	        };
	
	        var toUTC = function toUTC(t) {
	            var s = 0;
	            var ms = t;
	            if (hasSafariSignedIntBug && ms > maxSafeUnsigned32Bit) {
	                // work around a Safari 8/9 bug where it treats the seconds as signed
	                var msToShift = Math.floor(ms / maxSafeUnsigned32Bit) * maxSafeUnsigned32Bit;
	                var sToShift = Math.floor(msToShift / 1e3);
	                s += sToShift;
	                ms -= sToShift * 1e3;
	            }
	            return $Number(new NativeDate(1970, 0, 1, 0, 0, s, ms));
	        };
	
	        // Copy any custom methods a 3rd party library may have added
	        for (var key in NativeDate) {
	            if (owns(NativeDate, key)) {
	                DateShim[key] = NativeDate[key];
	            }
	        }
	
	        // Copy "native" methods explicitly; they may be non-enumerable
	        defineProperties(DateShim, {
	            now: NativeDate.now,
	            UTC: NativeDate.UTC
	        }, true);
	        DateShim.prototype = NativeDate.prototype;
	        defineProperties(DateShim.prototype, {
	            constructor: DateShim
	        }, true);
	
	        // Upgrade Date.parse to handle simplified ISO 8601 strings
	        var parseShim = function parse(string) {
	            var match = isoDateExpression.exec(string);
	            if (match) {
	                // parse months, days, hours, minutes, seconds, and milliseconds
	                // provide default values if necessary
	                // parse the UTC offset component
	                var year = $Number(match[1]),
	                    month = $Number(match[2] || 1) - 1,
	                    day = $Number(match[3] || 1) - 1,
	                    hour = $Number(match[4] || 0),
	                    minute = $Number(match[5] || 0),
	                    second = $Number(match[6] || 0),
	                    millisecond = Math.floor($Number(match[7] || 0) * 1000),
	                    // When time zone is missed, local offset should be used
	                    // (ES 5.1 bug)
	                    // see https://bugs.ecmascript.org/show_bug.cgi?id=112
	                    isLocalTime = Boolean(match[4] && !match[8]),
	                    signOffset = match[9] === '-' ? 1 : -1,
	                    hourOffset = $Number(match[10] || 0),
	                    minuteOffset = $Number(match[11] || 0),
	                    result;
	                var hasMinutesOrSecondsOrMilliseconds = minute > 0 || second > 0 || millisecond > 0;
	                if (
	                    hour < (hasMinutesOrSecondsOrMilliseconds ? 24 : 25) &&
	                    minute < 60 && second < 60 && millisecond < 1000 &&
	                    month > -1 && month < 12 && hourOffset < 24 &&
	                    minuteOffset < 60 && // detect invalid offsets
	                    day > -1 &&
	                    day < (dayFromMonth(year, month + 1) - dayFromMonth(year, month))
	                ) {
	                    result = (
	                        (dayFromMonth(year, month) + day) * 24 +
	                        hour +
	                        hourOffset * signOffset
	                    ) * 60;
	                    result = (
	                        (result + minute + minuteOffset * signOffset) * 60 +
	                        second
	                    ) * 1000 + millisecond;
	                    if (isLocalTime) {
	                        result = toUTC(result);
	                    }
	                    if (-8.64e15 <= result && result <= 8.64e15) {
	                        return result;
	                    }
	                }
	                return NaN;
	            }
	            return NativeDate.parse.apply(this, arguments);
	        };
	        defineProperties(DateShim, { parse: parseShim });
	
	        return DateShim;
	    }(Date));
	    /* global Date: false */
	}
	
	// ES5 15.9.4.4
	// http://es5.github.com/#x15.9.4.4
	if (!Date.now) {
	    Date.now = function now() {
	        return new Date().getTime();
	    };
	}
	
	//
	// Number
	// ======
	//
	
	// ES5.1 15.7.4.5
	// http://es5.github.com/#x15.7.4.5
	var hasToFixedBugs = NumberPrototype.toFixed && (
	  (0.00008).toFixed(3) !== '0.000' ||
	  (0.9).toFixed(0) !== '1' ||
	  (1.255).toFixed(2) !== '1.25' ||
	  (1000000000000000128).toFixed(0) !== '1000000000000000128'
	);
	
	var toFixedHelpers = {
	  base: 1e7,
	  size: 6,
	  data: [0, 0, 0, 0, 0, 0],
	  multiply: function multiply(n, c) {
	      var i = -1;
	      var c2 = c;
	      while (++i < toFixedHelpers.size) {
	          c2 += n * toFixedHelpers.data[i];
	          toFixedHelpers.data[i] = c2 % toFixedHelpers.base;
	          c2 = Math.floor(c2 / toFixedHelpers.base);
	      }
	  },
	  divide: function divide(n) {
	      var i = toFixedHelpers.size, c = 0;
	      while (--i >= 0) {
	          c += toFixedHelpers.data[i];
	          toFixedHelpers.data[i] = Math.floor(c / n);
	          c = (c % n) * toFixedHelpers.base;
	      }
	  },
	  numToString: function numToString() {
	      var i = toFixedHelpers.size;
	      var s = '';
	      while (--i >= 0) {
	          if (s !== '' || i === 0 || toFixedHelpers.data[i] !== 0) {
	              var t = $String(toFixedHelpers.data[i]);
	              if (s === '') {
	                  s = t;
	              } else {
	                  s += strSlice('0000000', 0, 7 - t.length) + t;
	              }
	          }
	      }
	      return s;
	  },
	  pow: function pow(x, n, acc) {
	      return (n === 0 ? acc : (n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc)));
	  },
	  log: function log(x) {
	      var n = 0;
	      var x2 = x;
	      while (x2 >= 4096) {
	          n += 12;
	          x2 /= 4096;
	      }
	      while (x2 >= 2) {
	          n += 1;
	          x2 /= 2;
	      }
	      return n;
	  }
	};
	
	var toFixedShim = function toFixed(fractionDigits) {
	    var f, x, s, m, e, z, j, k;
	
	    // Test for NaN and round fractionDigits down
	    f = $Number(fractionDigits);
	    f = isActualNaN(f) ? 0 : Math.floor(f);
	
	    if (f < 0 || f > 20) {
	        throw new RangeError('Number.toFixed called with invalid number of decimals');
	    }
	
	    x = $Number(this);
	
	    if (isActualNaN(x)) {
	        return 'NaN';
	    }
	
	    // If it is too big or small, return the string value of the number
	    if (x <= -1e21 || x >= 1e21) {
	        return $String(x);
	    }
	
	    s = '';
	
	    if (x < 0) {
	        s = '-';
	        x = -x;
	    }
	
	    m = '0';
	
	    if (x > 1e-21) {
	        // 1e-21 < x < 1e21
	        // -70 < log2(x) < 70
	        e = toFixedHelpers.log(x * toFixedHelpers.pow(2, 69, 1)) - 69;
	        z = (e < 0 ? x * toFixedHelpers.pow(2, -e, 1) : x / toFixedHelpers.pow(2, e, 1));
	        z *= 0x10000000000000; // Math.pow(2, 52);
	        e = 52 - e;
	
	        // -18 < e < 122
	        // x = z / 2 ^ e
	        if (e > 0) {
	            toFixedHelpers.multiply(0, z);
	            j = f;
	
	            while (j >= 7) {
	                toFixedHelpers.multiply(1e7, 0);
	                j -= 7;
	            }
	
	            toFixedHelpers.multiply(toFixedHelpers.pow(10, j, 1), 0);
	            j = e - 1;
	
	            while (j >= 23) {
	                toFixedHelpers.divide(1 << 23);
	                j -= 23;
	            }
	
	            toFixedHelpers.divide(1 << j);
	            toFixedHelpers.multiply(1, 1);
	            toFixedHelpers.divide(2);
	            m = toFixedHelpers.numToString();
	        } else {
	            toFixedHelpers.multiply(0, z);
	            toFixedHelpers.multiply(1 << (-e), 0);
	            m = toFixedHelpers.numToString() + strSlice('0.00000000000000000000', 2, 2 + f);
	        }
	    }
	
	    if (f > 0) {
	        k = m.length;
	
	        if (k <= f) {
	            m = s + strSlice('0.0000000000000000000', 0, f - k + 2) + m;
	        } else {
	            m = s + strSlice(m, 0, k - f) + '.' + strSlice(m, k - f);
	        }
	    } else {
	        m = s + m;
	    }
	
	    return m;
	};
	defineProperties(NumberPrototype, { toFixed: toFixedShim }, hasToFixedBugs);
	
	var hasToPrecisionUndefinedBug = (function () {
	    try {
	        return 1.0.toPrecision(undefined) === '1';
	    } catch (e) {
	        return true;
	    }
	}());
	var originalToPrecision = NumberPrototype.toPrecision;
	defineProperties(NumberPrototype, {
	    toPrecision: function toPrecision(precision) {
	        return typeof precision === 'undefined' ? originalToPrecision.call(this) : originalToPrecision.call(this, precision);
	    }
	}, hasToPrecisionUndefinedBug);
	
	//
	// String
	// ======
	//
	
	// ES5 15.5.4.14
	// http://es5.github.com/#x15.5.4.14
	
	// [bugfix, IE lt 9, firefox 4, Konqueror, Opera, obscure browsers]
	// Many browsers do not split properly with regular expressions or they
	// do not perform the split correctly under obscure conditions.
	// See http://blog.stevenlevithan.com/archives/cross-browser-split
	// I've tested in many browsers and this seems to cover the deviant ones:
	//    'ab'.split(/(?:ab)*/) should be ["", ""], not [""]
	//    '.'.split(/(.?)(.?)/) should be ["", ".", "", ""], not ["", ""]
	//    'tesst'.split(/(s)*/) should be ["t", undefined, "e", "s", "t"], not
	//       [undefined, "t", undefined, "e", ...]
	//    ''.split(/.?/) should be [], not [""]
	//    '.'.split(/()()/) should be ["."], not ["", "", "."]
	
	if (
	    'ab'.split(/(?:ab)*/).length !== 2 ||
	    '.'.split(/(.?)(.?)/).length !== 4 ||
	    'tesst'.split(/(s)*/)[1] === 't' ||
	    'test'.split(/(?:)/, -1).length !== 4 ||
	    ''.split(/.?/).length ||
	    '.'.split(/()()/).length > 1
	) {
	    (function () {
	        var compliantExecNpcg = typeof (/()??/).exec('')[1] === 'undefined'; // NPCG: nonparticipating capturing group
	        var maxSafe32BitInt = Math.pow(2, 32) - 1;
	
	        StringPrototype.split = function (separator, limit) {
	            var string = String(this);
	            if (typeof separator === 'undefined' && limit === 0) {
	                return [];
	            }
	
	            // If `separator` is not a regex, use native split
	            if (!isRegex(separator)) {
	                return strSplit(this, separator, limit);
	            }
	
	            var output = [];
	            var flags = (separator.ignoreCase ? 'i' : '') +
	                        (separator.multiline ? 'm' : '') +
	                        (separator.unicode ? 'u' : '') + // in ES6
	                        (separator.sticky ? 'y' : ''), // Firefox 3+ and ES6
	                lastLastIndex = 0,
	                // Make `global` and avoid `lastIndex` issues by working with a copy
	                separator2, match, lastIndex, lastLength;
	            var separatorCopy = new RegExp(separator.source, flags + 'g');
	            if (!compliantExecNpcg) {
	                // Doesn't need flags gy, but they don't hurt
	                separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);
	            }
	            /* Values for `limit`, per the spec:
	             * If undefined: 4294967295 // maxSafe32BitInt
	             * If 0, Infinity, or NaN: 0
	             * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
	             * If negative number: 4294967296 - Math.floor(Math.abs(limit))
	             * If other: Type-convert, then use the above rules
	             */
	            var splitLimit = typeof limit === 'undefined' ? maxSafe32BitInt : ES.ToUint32(limit);
	            match = separatorCopy.exec(string);
	            while (match) {
	                // `separatorCopy.lastIndex` is not reliable cross-browser
	                lastIndex = match.index + match[0].length;
	                if (lastIndex > lastLastIndex) {
	                    push(output, strSlice(string, lastLastIndex, match.index));
	                    // Fix browsers whose `exec` methods don't consistently return `undefined` for
	                    // nonparticipating capturing groups
	                    if (!compliantExecNpcg && match.length > 1) {
	                        /* eslint-disable no-loop-func */
	                        match[0].replace(separator2, function () {
	                            for (var i = 1; i < arguments.length - 2; i++) {
	                                if (typeof arguments[i] === 'undefined') {
	                                    match[i] = void 0;
	                                }
	                            }
	                        });
	                        /* eslint-enable no-loop-func */
	                    }
	                    if (match.length > 1 && match.index < string.length) {
	                        array_push.apply(output, arraySlice(match, 1));
	                    }
	                    lastLength = match[0].length;
	                    lastLastIndex = lastIndex;
	                    if (output.length >= splitLimit) {
	                        break;
	                    }
	                }
	                if (separatorCopy.lastIndex === match.index) {
	                    separatorCopy.lastIndex++; // Avoid an infinite loop
	                }
	                match = separatorCopy.exec(string);
	            }
	            if (lastLastIndex === string.length) {
	                if (lastLength || !separatorCopy.test('')) {
	                    push(output, '');
	                }
	            } else {
	                push(output, strSlice(string, lastLastIndex));
	            }
	            return output.length > splitLimit ? strSlice(output, 0, splitLimit) : output;
	        };
	    }());
	
	// [bugfix, chrome]
	// If separator is undefined, then the result array contains just one String,
	// which is the this value (converted to a String). If limit is not undefined,
	// then the output array is truncated so that it contains no more than limit
	// elements.
	// "0".split(undefined, 0) -> []
	} else if ('0'.split(void 0, 0).length) {
	    StringPrototype.split = function split(separator, limit) {
	        if (typeof separator === 'undefined' && limit === 0) { return []; }
	        return strSplit(this, separator, limit);
	    };
	}
	
	var str_replace = StringPrototype.replace;
	var replaceReportsGroupsCorrectly = (function () {
	    var groups = [];
	    'x'.replace(/x(.)?/g, function (match, group) {
	        push(groups, group);
	    });
	    return groups.length === 1 && typeof groups[0] === 'undefined';
	}());
	
	if (!replaceReportsGroupsCorrectly) {
	    StringPrototype.replace = function replace(searchValue, replaceValue) {
	        var isFn = isCallable(replaceValue);
	        var hasCapturingGroups = isRegex(searchValue) && (/\)[*?]/).test(searchValue.source);
	        if (!isFn || !hasCapturingGroups) {
	            return str_replace.call(this, searchValue, replaceValue);
	        } else {
	            var wrappedReplaceValue = function (match) {
	                var length = arguments.length;
	                var originalLastIndex = searchValue.lastIndex;
	                searchValue.lastIndex = 0;
	                var args = searchValue.exec(match) || [];
	                searchValue.lastIndex = originalLastIndex;
	                push(args, arguments[length - 2], arguments[length - 1]);
	                return replaceValue.apply(this, args);
	            };
	            return str_replace.call(this, searchValue, wrappedReplaceValue);
	        }
	    };
	}
	
	// ECMA-262, 3rd B.2.3
	// Not an ECMAScript standard, although ECMAScript 3rd Edition has a
	// non-normative section suggesting uniform semantics and it should be
	// normalized across all browsers
	// [bugfix, IE lt 9] IE < 9 substr() with negative value not working in IE
	var string_substr = StringPrototype.substr;
	var hasNegativeSubstrBug = ''.substr && '0b'.substr(-1) !== 'b';
	defineProperties(StringPrototype, {
	    substr: function substr(start, length) {
	        var normalizedStart = start;
	        if (start < 0) {
	            normalizedStart = max(this.length + start, 0);
	        }
	        return string_substr.call(this, normalizedStart, length);
	    }
	}, hasNegativeSubstrBug);
	
	// ES5 15.5.4.20
	// whitespace from: http://es5.github.io/#x15.5.4.20
	var ws = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
	    '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028' +
	    '\u2029\uFEFF';
	var zeroWidth = '\u200b';
	var wsRegexChars = '[' + ws + ']';
	var trimBeginRegexp = new RegExp('^' + wsRegexChars + wsRegexChars + '*');
	var trimEndRegexp = new RegExp(wsRegexChars + wsRegexChars + '*$');
	var hasTrimWhitespaceBug = StringPrototype.trim && (ws.trim() || !zeroWidth.trim());
	defineProperties(StringPrototype, {
	    // http://blog.stevenlevithan.com/archives/faster-trim-javascript
	    // http://perfectionkills.com/whitespace-deviations/
	    trim: function trim() {
	        if (typeof this === 'undefined' || this === null) {
	            throw new TypeError("can't convert " + this + ' to object');
	        }
	        return $String(this).replace(trimBeginRegexp, '').replace(trimEndRegexp, '');
	    }
	}, hasTrimWhitespaceBug);
	
	var hasLastIndexBug = StringPrototype.lastIndexOf && 'abc'.lastIndexOf('', 2) !== -1;
	defineProperties(StringPrototype, {
	    lastIndexOf: function lastIndexOf(searchString) {
	        if (typeof this === 'undefined' || this === null) {
	            throw new TypeError("can't convert " + this + ' to object');
	        }
	        var S = $String(this);
	        var searchStr = $String(searchString);
	        var numPos = arguments.length > 1 ? $Number(arguments[1]) : NaN;
	        var pos = isActualNaN(numPos) ? Infinity : ES.ToInteger(numPos);
	        var start = min(max(pos, 0), S.length);
	        var searchLen = searchStr.length;
	        var k = start + searchLen;
	        while (k > 0) {
	            k = max(0, k - searchLen);
	            var index = strIndexOf(strSlice(S, k, start + searchLen), searchStr);
	            if (index !== -1) {
	                return k + index;
	            }
	        }
	        return -1;
	    }
	}, hasLastIndexBug);
	
	var originalLastIndexOf = StringPrototype.lastIndexOf;
	defineProperties(StringPrototype, {
	    lastIndexOf: function lastIndexOf(searchString) {
	        return originalLastIndexOf.apply(this, arguments);
	    }
	}, StringPrototype.lastIndexOf.length !== 1);
	
	// ES-5 15.1.2.2
	/* eslint-disable radix */
	if (parseInt(ws + '08') !== 8 || parseInt(ws + '0x16') !== 22) {
	/* eslint-enable radix */
	    /* global parseInt: true */
	    parseInt = (function (origParseInt) {
	        var hexRegex = /^[\-+]?0[xX]/;
	        return function parseInt(str, radix) {
	            var string = $String(str).trim();
	            var defaultedRadix = $Number(radix) || (hexRegex.test(string) ? 16 : 10);
	            return origParseInt(string, defaultedRadix);
	        };
	    }(parseInt));
	}
	
	if (String(new RangeError('test')) !== 'RangeError: test') {
	    var errorToStringShim = function toString() {
	        if (typeof this === 'undefined' || this === null) {
	            throw new TypeError("can't convert " + this + ' to object');
	        }
	        var name = this.name;
	        if (typeof name === 'undefined') {
	            name = 'Error';
	        } else if (typeof name !== 'string') {
	            name = $String(name);
	        }
	        var msg = this.message;
	        if (typeof msg === 'undefined') {
	            msg = '';
	        } else if (typeof msg !== 'string') {
	            msg = $String(msg);
	        }
	        if (!name) {
	            return msg;
	        }
	        if (!msg) {
	            return name;
	        }
	        return name + ': ' + msg;
	    };
	    // can't use defineProperties here because of toString enumeration issue in IE <= 8
	    Error.prototype.toString = errorToStringShim;
	}
	
	if (supportsDescriptors) {
	    var ensureNonEnumerable = function (obj, prop) {
	        if (isEnum(obj, prop)) {
	            var desc = Object.getOwnPropertyDescriptor(obj, prop);
	            desc.enumerable = false;
	            Object.defineProperty(obj, prop, desc);
	        }
	    };
	    ensureNonEnumerable(Error.prototype, 'message');
	    if (Error.prototype.message !== '') {
	      Error.prototype.message = '';
	    }
	    ensureNonEnumerable(Error.prototype, 'name');
	}
	
	if (String(/a/mig) !== '/a/gim') {
	    var regexToString = function toString() {
	        var str = '/' + this.source + '/';
	        if (this.global) {
	            str += 'g';
	        }
	        if (this.ignoreCase) {
	            str += 'i';
	        }
	        if (this.multiline) {
	            str += 'm';
	        }
	        return str;
	    };
	    // can't use defineProperties here because of toString enumeration issue in IE <= 8
	    RegExp.prototype.toString = regexToString;
	}
	
	}));


/***/ },
/* 6 */
/***/ function(module, exports) {

	module.exports = "/*\n * Support for source maps in V8 stack traces\n * https://github.com/evanw/node-source-map-support\n */\n(this.define||function(K,N){this.sourceMapSupport=N()})(\"browser-source-map-support\",function(K){(function n(w,t,e){function r(g,b){if(!t[g]){if(!w[g]){var f=\"function\"==typeof require&&require;if(!b&&f)return f(g,!0);if(l)return l(g,!0);throw Error(\"Cannot find module '\"+g+\"'\");}f=t[g]={exports:{}};w[g][0].call(f.exports,function(b){var a=w[g][1][b];return r(a?a:b)},f,f.exports,n,w,t,e)}return t[g].exports}for(var l=\"function\"==typeof require&&require,m=0;m<e.length;m++)r(e[m]);return r})({1:[function(n,\nw,t){K=n(\"./source-map-support\")},{\"./source-map-support\":18}],2:[function(n,w,t){(function(e,r){w.exports=function(l,m){function g(c,d){var a;if(c&&\".\"===c.charAt(0)&&d){a=d.split(\"/\");a=a.slice(0,a.length-1);var b=a=a.concat(c.split(\"/\")),f,k;for(f=0;b[f];f+=1)if(k=b[f],\".\"===k)b.splice(f,1),--f;else if(\"..\"===k)if(1!==f||\"..\"!==b[2]&&\"..\"!==b[0])0<f&&(b.splice(f-1,2),f-=2);else break;c=a.join(\"/\")}return c}function b(c){return function(a){return g(a,c)}}function f(c){function a(b){d[c]=b}a.fromText=\nfunction(c,a){throw Error(\"amdefine does not implement load.fromText\");};return a}function k(c,a,b){var f,k,g;if(c)k=d[c]={},g={id:c,uri:r,exports:k},f=A(m,k,g,c);else{if(y)throw Error(\"amdefine with no module ID cannot be called more than once per file.\");y=!0;k=l.exports;g=l;f=A(m,k,g,l.id)}a&&(a=a.map(function(c){return f(c)}));a=\"function\"===typeof b?b.apply(g.exports,a):b;void 0!==a&&(g.exports=a,c&&(d[c]=g.exports))}function a(a,d,b){Array.isArray(a)?(b=d,d=a,a=void 0):\"string\"!==typeof a&&\n(b=a,a=d=void 0);d&&!Array.isArray(d)&&(b=d,d=void 0);d||(d=[\"require\",\"exports\",\"module\"]);a?c[a]=[a,d,b]:k(a,d,b)}var c={},d={},y=!1,x=n(\"path\"),A,B;A=function(c,a,d,b){function f(k,g){if(\"string\"===typeof k)return B(c,a,d,k,b);k=k.map(function(f){return B(c,a,d,f,b)});g&&e.nextTick(function(){g.apply(null,k)})}f.toUrl=function(c){return 0===c.indexOf(\".\")?g(c,x.dirname(d.filename)):c};return f};m=m||function(){return l.require.apply(l,arguments)};B=function(a,e,y,m,x){var l=m.indexOf(\"!\"),r=m;\nif(-1===l){m=g(m,x);if(\"require\"===m)return A(a,e,y,x);if(\"exports\"===m)return e;if(\"module\"===m)return y;if(d.hasOwnProperty(m))return d[m];if(c[m])return k.apply(null,c[m]),d[m];if(a)return a(r);throw Error(\"No module with ID: \"+m);}r=m.substring(0,l);m=m.substring(l+1,m.length);l=B(a,e,y,r,x);m=l.normalize?l.normalize(m,b(x)):g(m,x);d[m]||l.load(m,A(a,e,y,x),f(m),{});return d[m]};a.require=function(a){if(d[a])return d[a];if(c[a])return k.apply(null,c[a]),d[a]};a.amd={};return a}}).call(this,n(\"node_modules/process/browser.js\"),\n\"/node_modules/amdefine/amdefine.js\")},{\"node_modules/process/browser.js\":8,path:7}],3:[function(n,w,t){(function(e){function r(e){e=e.charCodeAt(0);if(43===e||45===e)return 62;if(47===e||95===e)return 63;if(48>e)return-1;if(58>e)return e-48+52;if(91>e)return e-65;if(123>e)return e-97+26}var l=\"undefined\"!==typeof Uint8Array?Uint8Array:Array;e.toByteArray=function(e){function g(a){c[d++]=a}var b,f,k,a,c;if(0<e.length%4)throw Error(\"Invalid string. Length must be a multiple of 4\");b=e.length;a=\"=\"===\ne.charAt(b-2)?2:\"=\"===e.charAt(b-1)?1:0;c=new l(3*e.length/4-a);f=0<a?e.length-4:e.length;var d=0;for(b=0;b<f;b+=4)k=r(e.charAt(b))<<18|r(e.charAt(b+1))<<12|r(e.charAt(b+2))<<6|r(e.charAt(b+3)),g((k&16711680)>>16),g((k&65280)>>8),g(k&255);2===a?(k=r(e.charAt(b))<<2|r(e.charAt(b+1))>>4,g(k&255)):1===a&&(k=r(e.charAt(b))<<10|r(e.charAt(b+1))<<4|r(e.charAt(b+2))>>2,g(k>>8&255),g(k&255));return c};e.fromByteArray=function(e){var g,b=e.length%3,f=\"\",k,a;g=0;for(a=e.length-b;g<a;g+=3)k=(e[g]<<16)+(e[g+\n1]<<8)+e[g+2],k=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".charAt(k>>18&63)+\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".charAt(k>>12&63)+\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".charAt(k>>6&63)+\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".charAt(k&63),f+=k;switch(b){case 1:k=e[e.length-1];f+=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".charAt(k>>2);f+=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".charAt(k<<\n4&63);f+=\"==\";break;case 2:k=(e[e.length-2]<<8)+e[e.length-1],f+=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".charAt(k>>10),f+=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".charAt(k>>4&63),f+=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".charAt(k<<2&63),f+=\"=\"}return f}})(\"undefined\"===typeof t?this.base64js={}:t)},{}],4:[function(n,w,t){},{}],5:[function(n,w,t){function e(h,q,c){if(!(this instanceof e))return new e(h,q,c);var a=typeof h;\nif(\"base64\"===q&&\"string\"===a)for(h=h.trim?h.trim():h.replace(/^\\s+|\\s+$/g,\"\");0!==h.length%4;)h+=\"=\";var d;if(\"number\"===a)d=F(h);else if(\"string\"===a)d=e.byteLength(h,q);else if(\"object\"===a)d=F(h.length);else throw Error(\"First argument needs to be a number, array or string.\");var b;e._useTypedArrays?b=e._augment(new Uint8Array(d)):(b=this,b.length=d,b._isBuffer=!0);if(e._useTypedArrays&&\"number\"===typeof h.byteLength)b._set(h);else{var f=h;if(E(f)||e.isBuffer(f)||f&&\"object\"===typeof f&&\"number\"===\ntypeof f.length)for(q=0;q<d;q++)e.isBuffer(h)?b[q]=h.readUInt8(q):b[q]=h[q];else if(\"string\"===a)b.write(h,0,q);else if(\"number\"===a&&!e._useTypedArrays&&!c)for(q=0;q<d;q++)b[q]=0}return b}function r(h,q,c){var a=\"\";for(c=Math.min(h.length,c);q<c;q++)a+=String.fromCharCode(h[q]);return a}function l(h,q,c,a){a||(p(\"boolean\"===typeof c,\"missing or invalid endian\"),p(void 0!==q&&null!==q,\"missing offset\"),p(q+1<h.length,\"Trying to read beyond buffer length\"));a=h.length;if(!(q>=a))return c?(c=h[q],q+\n1<a&&(c|=h[q+1]<<8)):(c=h[q]<<8,q+1<a&&(c|=h[q+1])),c}function m(h,q,c,a){a||(p(\"boolean\"===typeof c,\"missing or invalid endian\"),p(void 0!==q&&null!==q,\"missing offset\"),p(q+3<h.length,\"Trying to read beyond buffer length\"));a=h.length;if(!(q>=a)){var d;c?(q+2<a&&(d=h[q+2]<<16),q+1<a&&(d|=h[q+1]<<8),d|=h[q],q+3<a&&(d+=h[q+3]<<24>>>0)):(q+1<a&&(d=h[q+1]<<16),q+2<a&&(d|=h[q+2]<<8),q+3<a&&(d|=h[q+3]),d+=h[q]<<24>>>0);return d}}function g(h,q,a,c){c||(p(\"boolean\"===typeof a,\"missing or invalid endian\"),\np(void 0!==q&&null!==q,\"missing offset\"),p(q+1<h.length,\"Trying to read beyond buffer length\"));if(!(q>=h.length))return h=l(h,q,a,!0),h&32768?-1*(65535-h+1):h}function b(h,q,a,c){c||(p(\"boolean\"===typeof a,\"missing or invalid endian\"),p(void 0!==q&&null!==q,\"missing offset\"),p(q+3<h.length,\"Trying to read beyond buffer length\"));if(!(q>=h.length))return h=m(h,q,a,!0),h&2147483648?-1*(4294967295-h+1):h}function f(h,q,a,c){c||(p(\"boolean\"===typeof a,\"missing or invalid endian\"),p(q+3<h.length,\"Trying to read beyond buffer length\"));\nreturn I.read(h,q,a,23,4)}function k(h,q,a,c){c||(p(\"boolean\"===typeof a,\"missing or invalid endian\"),p(q+7<h.length,\"Trying to read beyond buffer length\"));return I.read(h,q,a,52,8)}function a(h,a,c,d,b){b||(p(void 0!==a&&null!==a,\"missing value\"),p(\"boolean\"===typeof d,\"missing or invalid endian\"),p(void 0!==c&&null!==c,\"missing offset\"),p(c+1<h.length,\"trying to write beyond buffer length\"),H(a,65535));var f=h.length;if(!(c>=f))for(b=0,f=Math.min(f-c,2);b<f;b++)h[c+b]=(a&255<<8*(d?b:1-b))>>>8*\n(d?b:1-b)}function c(h,a,c,d,b){b||(p(void 0!==a&&null!==a,\"missing value\"),p(\"boolean\"===typeof d,\"missing or invalid endian\"),p(void 0!==c&&null!==c,\"missing offset\"),p(c+3<h.length,\"trying to write beyond buffer length\"),H(a,4294967295));var f=h.length;if(!(c>=f))for(b=0,f=Math.min(f-c,4);b<f;b++)h[c+b]=a>>>8*(d?b:3-b)&255}function d(h,c,d,b,f){f||(p(void 0!==c&&null!==c,\"missing value\"),p(\"boolean\"===typeof b,\"missing or invalid endian\"),p(void 0!==d&&null!==d,\"missing offset\"),p(d+1<h.length,\n\"Trying to write beyond buffer length\"),L(c,32767,-32768));d>=h.length||(0<=c?a(h,c,d,b,f):a(h,65535+c+1,d,b,f))}function y(h,a,d,b,f){f||(p(void 0!==a&&null!==a,\"missing value\"),p(\"boolean\"===typeof b,\"missing or invalid endian\"),p(void 0!==d&&null!==d,\"missing offset\"),p(d+3<h.length,\"Trying to write beyond buffer length\"),L(a,2147483647,-2147483648));d>=h.length||(0<=a?c(h,a,d,b,f):c(h,4294967295+a+1,d,b,f))}function x(h,a,c,d,b){b||(p(void 0!==a&&null!==a,\"missing value\"),p(\"boolean\"===typeof d,\n\"missing or invalid endian\"),p(void 0!==c&&null!==c,\"missing offset\"),p(c+3<h.length,\"Trying to write beyond buffer length\"),M(a,3.4028234663852886E38,-3.4028234663852886E38));c>=h.length||I.write(h,a,c,d,23,4)}function A(h,c,a,d,b){b||(p(void 0!==c&&null!==c,\"missing value\"),p(\"boolean\"===typeof d,\"missing or invalid endian\"),p(void 0!==a&&null!==a,\"missing offset\"),p(a+7<h.length,\"Trying to write beyond buffer length\"),M(c,1.7976931348623157E308,-1.7976931348623157E308));a>=h.length||I.write(h,\nc,a,d,52,8)}function B(h,a,c){if(\"number\"!==typeof h)return c;h=~~h;if(h>=a)return a;if(0<=h)return h;h+=a;return 0<=h?h:0}function F(h){h=~~Math.ceil(+h);return 0>h?0:h}function E(h){return(Array.isArray||function(h){return\"[object Array]\"===Object.prototype.toString.call(h)})(h)}function G(h){return 16>h?\"0\"+h.toString(16):h.toString(16)}function u(h){for(var a=[],c=0;c<h.length;c++){var d=h.charCodeAt(c);if(127>=d)a.push(h.charCodeAt(c));else{var b=c;55296<=d&&57343>=d&&c++;d=encodeURIComponent(h.slice(b,\nc+1)).substr(1).split(\"%\");for(b=0;b<d.length;b++)a.push(parseInt(d[b],16))}}return a}function C(h){for(var c=[],a=0;a<h.length;a++)c.push(h.charCodeAt(a)&255);return c}function z(h,c,a,d){for(var b=0;b<d&&!(b+a>=c.length||b>=h.length);b++)c[b+a]=h[b];return b}function D(h){try{return decodeURIComponent(h)}catch(c){return String.fromCharCode(65533)}}function H(h,c){p(\"number\"===typeof h,\"cannot write a non-number as a number\");p(0<=h,\"specified a negative value for writing an unsigned value\");p(h<=\nc,\"value is larger than maximum value for type\");p(Math.floor(h)===h,\"value has a fractional component\")}function L(h,c,a){p(\"number\"===typeof h,\"cannot write a non-number as a number\");p(h<=c,\"value larger than maximum allowed value\");p(h>=a,\"value smaller than minimum allowed value\");p(Math.floor(h)===h,\"value has a fractional component\")}function M(h,c,a){p(\"number\"===typeof h,\"cannot write a non-number as a number\");p(h<=c,\"value larger than maximum allowed value\");p(h>=a,\"value smaller than minimum allowed value\")}\nfunction p(h,c){if(!h)throw Error(c||\"Failed assertion\");}var J=n(\"base64-js\"),I=n(\"ieee754\");t.Buffer=e;t.SlowBuffer=e;t.INSPECT_MAX_BYTES=50;e.poolSize=8192;e._useTypedArrays=function(){try{var h=new ArrayBuffer(0),c=new Uint8Array(h);c.foo=function(){return 42};return 42===c.foo()&&\"function\"===typeof c.subarray}catch(a){return!1}}();e.isEncoding=function(h){switch(String(h).toLowerCase()){case \"hex\":case \"utf8\":case \"utf-8\":case \"ascii\":case \"binary\":case \"base64\":case \"raw\":case \"ucs2\":case \"ucs-2\":case \"utf16le\":case \"utf-16le\":return!0;\ndefault:return!1}};e.isBuffer=function(h){return!(null===h||void 0===h||!h._isBuffer)};e.byteLength=function(h,c){var a;h+=\"\";switch(c||\"utf8\"){case \"hex\":a=h.length/2;break;case \"utf8\":case \"utf-8\":a=u(h).length;break;case \"ascii\":case \"binary\":case \"raw\":a=h.length;break;case \"base64\":a=J.toByteArray(h).length;break;case \"ucs2\":case \"ucs-2\":case \"utf16le\":case \"utf-16le\":a=2*h.length;break;default:throw Error(\"Unknown encoding\");}return a};e.concat=function(h,c){p(E(h),\"Usage: Buffer.concat(list, [totalLength])\\nlist should be an Array.\");\nif(0===h.length)return new e(0);if(1===h.length)return h[0];var a;if(\"number\"!==typeof c)for(a=c=0;a<h.length;a++)c+=h[a].length;var d=new e(c),b=0;for(a=0;a<h.length;a++){var f=h[a];f.copy(d,b);b+=f.length}return d};e.prototype.write=function(h,c,a,d){if(isFinite(c))isFinite(a)||(d=a,a=void 0);else{var b=d;d=c;c=a;a=b}c=Number(c)||0;b=this.length-c;a?(a=Number(a),a>b&&(a=b)):a=b;d=String(d||\"utf8\").toLowerCase();switch(d){case \"hex\":c=Number(c)||0;d=this.length-c;a?(a=Number(a),a>d&&(a=d)):a=d;d=\nh.length;p(0===d%2,\"Invalid hex string\");a>d/2&&(a=d/2);for(d=0;d<a;d++)b=parseInt(h.substr(2*d,2),16),p(!isNaN(b),\"Invalid hex string\"),this[c+d]=b;e._charsWritten=2*d;h=d;break;case \"utf8\":case \"utf-8\":h=e._charsWritten=z(u(h),this,c,a);break;case \"ascii\":h=e._charsWritten=z(C(h),this,c,a);break;case \"binary\":h=e._charsWritten=z(C(h),this,c,a);break;case \"base64\":h=e._charsWritten=z(J.toByteArray(h),this,c,a);break;case \"ucs2\":case \"ucs-2\":case \"utf16le\":case \"utf-16le\":for(var f,b=[],k=0;k<h.length;k++)f=\nh.charCodeAt(k),d=f>>8,f%=256,b.push(f),b.push(d);h=e._charsWritten=z(b,this,c,a);break;default:throw Error(\"Unknown encoding\");}return h};e.prototype.toString=function(a,c,d){a=String(a||\"utf8\").toLowerCase();c=Number(c)||0;d=void 0!==d?Number(d):d=this.length;if(d===c)return\"\";switch(a){case \"hex\":a=this.length;if(!c||0>c)c=0;if(!d||0>d||d>a)d=a;for(a=\"\";c<d;c++)a+=G(this[c]);d=a;break;case \"utf8\":case \"utf-8\":var b=a=\"\";for(d=Math.min(this.length,d);c<d;c++)127>=this[c]?(a+=D(b)+String.fromCharCode(this[c]),\nb=\"\"):b+=\"%\"+this[c].toString(16);d=a+D(b);break;case \"ascii\":d=r(this,c,d);break;case \"binary\":d=r(this,c,d);break;case \"base64\":d=0===c&&d===this.length?J.fromByteArray(this):J.fromByteArray(this.slice(c,d));break;case \"ucs2\":case \"ucs-2\":case \"utf16le\":case \"utf-16le\":d=this.slice(c,d);c=\"\";for(a=0;a<d.length;a+=2)c+=String.fromCharCode(d[a]+256*d[a+1]);d=c;break;default:throw Error(\"Unknown encoding\");}return d};e.prototype.toJSON=function(){return{type:\"Buffer\",data:Array.prototype.slice.call(this._arr||\nthis,0)}};e.prototype.copy=function(a,c,d,b){d||(d=0);b||0===b||(b=this.length);c||(c=0);if(b!==d&&0!==a.length&&0!==this.length)if(p(b>=d,\"sourceEnd < sourceStart\"),p(0<=c&&c<a.length,\"targetStart out of bounds\"),p(0<=d&&d<this.length,\"sourceStart out of bounds\"),p(0<=b&&b<=this.length,\"sourceEnd out of bounds\"),b>this.length&&(b=this.length),a.length-c<b-d&&(b=a.length-c+d),b-=d,100>b||!e._useTypedArrays)for(var f=0;f<b;f++)a[f+c]=this[f+d];else a._set(this.subarray(d,d+b),c)};e.prototype.slice=\nfunction(a,c){var d=this.length;a=B(a,d,0);c=B(c,d,d);if(e._useTypedArrays)return e._augment(this.subarray(a,c));for(var d=c-a,b=new e(d,void 0,!0),f=0;f<d;f++)b[f]=this[f+a];return b};e.prototype.get=function(a){console.log(\".get() is deprecated. Access using array indexes instead.\");return this.readUInt8(a)};e.prototype.set=function(a,c){console.log(\".set() is deprecated. Access using array indexes instead.\");return this.writeUInt8(a,c)};e.prototype.readUInt8=function(a,c){c||(p(void 0!==a&&null!==\na,\"missing offset\"),p(a<this.length,\"Trying to read beyond buffer length\"));if(!(a>=this.length))return this[a]};e.prototype.readUInt16LE=function(a,c){return l(this,a,!0,c)};e.prototype.readUInt16BE=function(a,c){return l(this,a,!1,c)};e.prototype.readUInt32LE=function(a,c){return m(this,a,!0,c)};e.prototype.readUInt32BE=function(a,c){return m(this,a,!1,c)};e.prototype.readInt8=function(a,c){c||(p(void 0!==a&&null!==a,\"missing offset\"),p(a<this.length,\"Trying to read beyond buffer length\"));if(!(a>=\nthis.length))return this[a]&128?-1*(255-this[a]+1):this[a]};e.prototype.readInt16LE=function(a,c){return g(this,a,!0,c)};e.prototype.readInt16BE=function(a,c){return g(this,a,!1,c)};e.prototype.readInt32LE=function(a,c){return b(this,a,!0,c)};e.prototype.readInt32BE=function(a,c){return b(this,a,!1,c)};e.prototype.readFloatLE=function(a,c){return f(this,a,!0,c)};e.prototype.readFloatBE=function(a,c){return f(this,a,!1,c)};e.prototype.readDoubleLE=function(a,c){return k(this,a,!0,c)};e.prototype.readDoubleBE=\nfunction(a,c){return k(this,a,!1,c)};e.prototype.writeUInt8=function(a,c,d){d||(p(void 0!==a&&null!==a,\"missing value\"),p(void 0!==c&&null!==c,\"missing offset\"),p(c<this.length,\"trying to write beyond buffer length\"),H(a,255));c>=this.length||(this[c]=a)};e.prototype.writeUInt16LE=function(c,d,b){a(this,c,d,!0,b)};e.prototype.writeUInt16BE=function(c,d,b){a(this,c,d,!1,b)};e.prototype.writeUInt32LE=function(a,d,b){c(this,a,d,!0,b)};e.prototype.writeUInt32BE=function(a,d,b){c(this,a,d,!1,b)};e.prototype.writeInt8=\nfunction(a,c,d){d||(p(void 0!==a&&null!==a,\"missing value\"),p(void 0!==c&&null!==c,\"missing offset\"),p(c<this.length,\"Trying to write beyond buffer length\"),L(a,127,-128));c>=this.length||(0<=a?this.writeUInt8(a,c,d):this.writeUInt8(255+a+1,c,d))};e.prototype.writeInt16LE=function(a,c,b){d(this,a,c,!0,b)};e.prototype.writeInt16BE=function(a,c,b){d(this,a,c,!1,b)};e.prototype.writeInt32LE=function(a,c,d){y(this,a,c,!0,d)};e.prototype.writeInt32BE=function(a,c,d){y(this,a,c,!1,d)};e.prototype.writeFloatLE=\nfunction(a,c,d){x(this,a,c,!0,d)};e.prototype.writeFloatBE=function(a,c,d){x(this,a,c,!1,d)};e.prototype.writeDoubleLE=function(a,c,d){A(this,a,c,!0,d)};e.prototype.writeDoubleBE=function(a,c,d){A(this,a,c,!1,d)};e.prototype.fill=function(a,c,d){a||(a=0);c||(c=0);d||(d=this.length);\"string\"===typeof a&&(a=a.charCodeAt(0));p(\"number\"===typeof a&&!isNaN(a),\"value is not a number\");p(d>=c,\"end < start\");if(d!==c&&0!==this.length)for(p(0<=c&&c<this.length,\"start out of bounds\"),p(0<=d&&d<=this.length,\n\"end out of bounds\");c<d;c++)this[c]=a};e.prototype.inspect=function(){for(var a=[],c=this.length,d=0;d<c;d++)if(a[d]=G(this[d]),d===t.INSPECT_MAX_BYTES){a[d+1]=\"...\";break}return\"<Buffer \"+a.join(\" \")+\">\"};e.prototype.toArrayBuffer=function(){if(\"undefined\"!==typeof Uint8Array){if(e._useTypedArrays)return(new e(this)).buffer;for(var a=new Uint8Array(this.length),c=0,d=a.length;c<d;c+=1)a[c]=this[c];return a.buffer}throw Error(\"Buffer.toArrayBuffer not supported in this browser\");};var v=e.prototype;\ne._augment=function(a){a._isBuffer=!0;a._get=a.get;a._set=a.set;a.get=v.get;a.set=v.set;a.write=v.write;a.toString=v.toString;a.toLocaleString=v.toString;a.toJSON=v.toJSON;a.copy=v.copy;a.slice=v.slice;a.readUInt8=v.readUInt8;a.readUInt16LE=v.readUInt16LE;a.readUInt16BE=v.readUInt16BE;a.readUInt32LE=v.readUInt32LE;a.readUInt32BE=v.readUInt32BE;a.readInt8=v.readInt8;a.readInt16LE=v.readInt16LE;a.readInt16BE=v.readInt16BE;a.readInt32LE=v.readInt32LE;a.readInt32BE=v.readInt32BE;a.readFloatLE=v.readFloatLE;\na.readFloatBE=v.readFloatBE;a.readDoubleLE=v.readDoubleLE;a.readDoubleBE=v.readDoubleBE;a.writeUInt8=v.writeUInt8;a.writeUInt16LE=v.writeUInt16LE;a.writeUInt16BE=v.writeUInt16BE;a.writeUInt32LE=v.writeUInt32LE;a.writeUInt32BE=v.writeUInt32BE;a.writeInt8=v.writeInt8;a.writeInt16LE=v.writeInt16LE;a.writeInt16BE=v.writeInt16BE;a.writeInt32LE=v.writeInt32LE;a.writeInt32BE=v.writeInt32BE;a.writeFloatLE=v.writeFloatLE;a.writeFloatBE=v.writeFloatBE;a.writeDoubleLE=v.writeDoubleLE;a.writeDoubleBE=v.writeDoubleBE;\na.fill=v.fill;a.inspect=v.inspect;a.toArrayBuffer=v.toArrayBuffer;return a}},{\"base64-js\":3,ieee754:6}],6:[function(n,w,t){t.read=function(e,r,l,m,g){var b;b=8*g-m-1;var f=(1<<b)-1,k=f>>1,a=-7;g=l?g-1:0;var c=l?-1:1,d=e[r+g];g+=c;l=d&(1<<-a)-1;d>>=-a;for(a+=b;0<a;l=256*l+e[r+g],g+=c,a-=8);b=l&(1<<-a)-1;l>>=-a;for(a+=m;0<a;b=256*b+e[r+g],g+=c,a-=8);if(0===l)l=1-k;else{if(l===f)return b?NaN:Infinity*(d?-1:1);b+=Math.pow(2,m);l-=k}return(d?-1:1)*b*Math.pow(2,l-m)};t.write=function(e,r,l,m,g,b){var f,\nk=8*b-g-1,a=(1<<k)-1,c=a>>1,d=23===g?Math.pow(2,-24)-Math.pow(2,-77):0;b=m?0:b-1;var y=m?1:-1,x=0>r||0===r&&0>1/r?1:0;r=Math.abs(r);isNaN(r)||Infinity===r?(r=isNaN(r)?1:0,m=a):(m=Math.floor(Math.log(r)/Math.LN2),1>r*(f=Math.pow(2,-m))&&(m--,f*=2),r=1<=m+c?r+d/f:r+d*Math.pow(2,1-c),2<=r*f&&(m++,f/=2),m+c>=a?(r=0,m=a):1<=m+c?(r=(r*f-1)*Math.pow(2,g),m+=c):(r=r*Math.pow(2,c-1)*Math.pow(2,g),m=0));for(;8<=g;e[l+b]=r&255,b+=y,r/=256,g-=8);m=m<<g|r;for(k+=g;0<k;e[l+b]=m&255,b+=y,m/=256,k-=8);e[l+b-y]|=\n128*x}},{}],7:[function(n,w,t){(function(e){function r(b,f){for(var e=0,a=b.length-1;0<=a;a--){var c=b[a];\".\"===c?b.splice(a,1):\"..\"===c?(b.splice(a,1),e++):e&&(b.splice(a,1),e--)}if(f)for(;e--;e)b.unshift(\"..\");return b}function l(b,f){if(b.filter)return b.filter(f);for(var e=[],a=0;a<b.length;a++)f(b[a],a,b)&&e.push(b[a]);return e}var m=/^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;t.resolve=function(){for(var b=\"\",f=!1,k=arguments.length-1;-1<=k&&!f;k--){var a=0<=k?arguments[k]:\ne.cwd();if(\"string\"!==typeof a)throw new TypeError(\"Arguments to path.resolve must be strings\");a&&(b=a+\"/\"+b,f=\"/\"===a.charAt(0))}b=r(l(b.split(\"/\"),function(a){return!!a}),!f).join(\"/\");return(f?\"/\":\"\")+b||\".\"};t.normalize=function(b){var f=t.isAbsolute(b),e=\"/\"===g(b,-1);(b=r(l(b.split(\"/\"),function(a){return!!a}),!f).join(\"/\"))||f||(b=\".\");b&&e&&(b+=\"/\");return(f?\"/\":\"\")+b};t.isAbsolute=function(b){return\"/\"===b.charAt(0)};t.join=function(){var b=Array.prototype.slice.call(arguments,0);return t.normalize(l(b,\nfunction(b,e){if(\"string\"!==typeof b)throw new TypeError(\"Arguments to path.join must be strings\");return b}).join(\"/\"))};t.relative=function(b,f){function e(a){for(var c=0;c<a.length&&\"\"===a[c];c++);for(var d=a.length-1;0<=d&&\"\"===a[d];d--);return c>d?[]:a.slice(c,d-c+1)}b=t.resolve(b).substr(1);f=t.resolve(f).substr(1);for(var a=e(b.split(\"/\")),c=e(f.split(\"/\")),d=Math.min(a.length,c.length),g=d,x=0;x<d;x++)if(a[x]!==c[x]){g=x;break}d=[];for(x=g;x<a.length;x++)d.push(\"..\");d=d.concat(c.slice(g));\nreturn d.join(\"/\")};t.sep=\"/\";t.delimiter=\":\";t.dirname=function(b){var f=m.exec(b).slice(1);b=f[0];f=f[1];if(!b&&!f)return\".\";f&&(f=f.substr(0,f.length-1));return b+f};t.basename=function(b,f){var e=m.exec(b).slice(1)[2];f&&e.substr(-1*f.length)===f&&(e=e.substr(0,e.length-f.length));return e};t.extname=function(b){return m.exec(b).slice(1)[3]};var g=\"b\"===\"ab\".substr(-1)?function(b,f,e){return b.substr(f,e)}:function(b,f,e){0>f&&(f=b.length+f);return b.substr(f,e)}}).call(this,n(\"node_modules/process/browser.js\"))},\n{\"node_modules/process/browser.js\":8}],8:[function(n,w,t){function e(){}n=w.exports={};n.nextTick=function(){if(\"undefined\"!==typeof window&&window.setImmediate)return function(e){return window.setImmediate(e)};if(\"undefined\"!==typeof window&&window.postMessage&&window.addEventListener){var e=[];window.addEventListener(\"message\",function(l){var m=l.source;m!==window&&null!==m||\"process-tick\"!==l.data||(l.stopPropagation(),0<e.length&&e.shift()())},!0);return function(l){e.push(l);window.postMessage(\"process-tick\",\n\"*\")}}return function(e){setTimeout(e,0)}}();n.title=\"browser\";n.browser=!0;n.env={};n.argv=[];n.on=e;n.once=e;n.off=e;n.emit=e;n.binding=function(e){throw Error(\"process.binding is not supported\");};n.cwd=function(){return\"/\"};n.chdir=function(e){throw Error(\"process.chdir is not supported\");}},{}],9:[function(n,w,t){t.SourceMapGenerator=n(\"./source-map/source-map-generator\").SourceMapGenerator;t.SourceMapConsumer=n(\"./source-map/source-map-consumer\").SourceMapConsumer;t.SourceNode=n(\"./source-map/source-node\").SourceNode},\n{\"./source-map/source-map-consumer\":14,\"./source-map/source-map-generator\":15,\"./source-map/source-node\":16}],10:[function(n,w,t){if(\"function\"!==typeof e)var e=n(\"amdefine\")(w,n);e(function(e,l,m){function g(){this._array=[];this._set={}}var b=e(\"./util\");g.fromArray=function(b,e){for(var a=new g,c=0,d=b.length;c<d;c++)a.add(b[c],e);return a};g.prototype.add=function(f,e){var a=this.has(f),c=this._array.length;a&&!e||this._array.push(f);a||(this._set[b.toSetString(f)]=c)};g.prototype.has=function(f){return Object.prototype.hasOwnProperty.call(this._set,\nb.toSetString(f))};g.prototype.indexOf=function(f){if(this.has(f))return this._set[b.toSetString(f)];throw Error('\"'+f+'\" is not in the set.');};g.prototype.at=function(b){if(0<=b&&b<this._array.length)return this._array[b];throw Error(\"No element indexed by \"+b);};g.prototype.toArray=function(){return this._array.slice()};l.ArraySet=g})},{\"./util\":17,amdefine:2}],11:[function(n,w,t){if(\"function\"!==typeof e)var e=n(\"amdefine\")(w,n);e(function(e,l,m){var g=e(\"./base64\");l.encode=function(b){var e=\n\"\",k=0>b?(-b<<1)+1:(b<<1)+0;do b=k&31,k>>>=5,0<k&&(b|=32),e+=g.encode(b);while(0<k);return e};l.decode=function(b){var e=0,k=b.length,a=0,c=0,d,y;do{if(e>=k)throw Error(\"Expected more digits in base 64 VLQ value.\");y=g.decode(b.charAt(e++));d=!!(y&32);y&=31;a+=y<<c;c+=5}while(d);k=a>>1;return{value:1===(a&1)?-k:k,rest:b.slice(e)}}})},{\"./base64\":12,amdefine:2}],12:[function(n,w,t){if(\"function\"!==typeof e)var e=n(\"amdefine\")(w,n);e(function(e,l,m){var g={},b={};\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".split(\"\").forEach(function(e,\nk){g[e]=k;b[k]=e});l.encode=function(e){if(e in b)return b[e];throw new TypeError(\"Must be between 0 and 63: \"+e);};l.decode=function(b){if(b in g)return g[b];throw new TypeError(\"Not a valid base 64 digit: \"+b);}})},{amdefine:2}],13:[function(n,w,t){if(\"function\"!==typeof e)var e=n(\"amdefine\")(w,n);e(function(e,l,m){function g(b,e,k,a,c){var d=Math.floor((e-b)/2)+b,y=c(k,a[d],!0);return 0===y?a[d]:0<y?1<e-d?g(d,e,k,a,c):a[d]:1<d-b?g(b,d,k,a,c):0>b?null:a[b]}l.search=function(b,e,k){return 0<e.length?\ng(-1,e.length,b,e,k):null}})},{amdefine:2}],14:[function(n,w,t){if(\"function\"!==typeof e)var e=n(\"amdefine\")(w,n);e(function(e,l,m){function g(a){var d=a;\"string\"===typeof a&&(d=JSON.parse(a.replace(/^\\)\\]\\}'/,\"\")));a=b.getArg(d,\"version\");var e=b.getArg(d,\"sources\"),f=b.getArg(d,\"names\",[]),g=b.getArg(d,\"sourceRoot\",null),l=b.getArg(d,\"sourcesContent\",null),m=b.getArg(d,\"mappings\"),d=b.getArg(d,\"file\",null);if(a!=this._version)throw Error(\"Unsupported version: \"+a);this._names=k.fromArray(f,!0);\nthis._sources=k.fromArray(e,!0);this.sourceRoot=g;this.sourcesContent=l;this._mappings=m;this.file=d}var b=e(\"./util\"),f=e(\"./binary-search\"),k=e(\"./array-set\").ArraySet,a=e(\"./base64-vlq\");g.fromSourceMap=function(a){var d=Object.create(g.prototype);d._names=k.fromArray(a._names.toArray(),!0);d._sources=k.fromArray(a._sources.toArray(),!0);d.sourceRoot=a._sourceRoot;d.sourcesContent=a._generateSourcesContent(d._sources.toArray(),d.sourceRoot);d.file=a._file;d.__generatedMappings=a._mappings.slice().sort(b.compareByGeneratedPositions);\nd.__originalMappings=a._mappings.slice().sort(b.compareByOriginalPositions);return d};g.prototype._version=3;Object.defineProperty(g.prototype,\"sources\",{get:function(){return this._sources.toArray().map(function(a){return this.sourceRoot?b.join(this.sourceRoot,a):a},this)}});g.prototype.__generatedMappings=null;Object.defineProperty(g.prototype,\"_generatedMappings\",{get:function(){this.__generatedMappings||(this.__generatedMappings=[],this.__originalMappings=[],this._parseMappings(this._mappings,\nthis.sourceRoot));return this.__generatedMappings}});g.prototype.__originalMappings=null;Object.defineProperty(g.prototype,\"_originalMappings\",{get:function(){this.__originalMappings||(this.__generatedMappings=[],this.__originalMappings=[],this._parseMappings(this._mappings,this.sourceRoot));return this.__originalMappings}});g.prototype._parseMappings=function(c,d){for(var e=1,f=0,g=0,k=0,l=0,m=0,r=/^[,;]/,u=c,n;0<u.length;)if(\";\"===u.charAt(0))e++,u=u.slice(1),f=0;else if(\",\"===u.charAt(0))u=u.slice(1);\nelse{n={};n.generatedLine=e;u=a.decode(u);n.generatedColumn=f+u.value;f=n.generatedColumn;u=u.rest;if(0<u.length&&!r.test(u.charAt(0))){u=a.decode(u);n.source=this._sources.at(l+u.value);l+=u.value;u=u.rest;if(0===u.length||r.test(u.charAt(0)))throw Error(\"Found a source, but no line and column\");u=a.decode(u);n.originalLine=g+u.value;g=n.originalLine;n.originalLine+=1;u=u.rest;if(0===u.length||r.test(u.charAt(0)))throw Error(\"Found a source and line, but no column\");u=a.decode(u);n.originalColumn=\nk+u.value;k=n.originalColumn;u=u.rest;0<u.length&&!r.test(u.charAt(0))&&(u=a.decode(u),n.name=this._names.at(m+u.value),m+=u.value,u=u.rest)}this.__generatedMappings.push(n);\"number\"===typeof n.originalLine&&this.__originalMappings.push(n)}this.__generatedMappings.sort(b.compareByGeneratedPositions);this.__originalMappings.sort(b.compareByOriginalPositions)};g.prototype._findMapping=function(a,d,b,e,g){if(0>=a[b])throw new TypeError(\"Line must be greater than or equal to 1, got \"+a[b]);if(0>a[e])throw new TypeError(\"Column must be greater than or equal to 0, got \"+\na[e]);return f.search(a,d,g)};g.prototype.originalPositionFor=function(a){a={generatedLine:b.getArg(a,\"line\"),generatedColumn:b.getArg(a,\"column\")};if(a=this._findMapping(a,this._generatedMappings,\"generatedLine\",\"generatedColumn\",b.compareByGeneratedPositions)){var d=b.getArg(a,\"source\",null);d&&this.sourceRoot&&(d=b.join(this.sourceRoot,d));return{source:d,line:b.getArg(a,\"originalLine\",null),column:b.getArg(a,\"originalColumn\",null),name:b.getArg(a,\"name\",null)}}return{source:null,line:null,column:null,\nname:null}};g.prototype.sourceContentFor=function(a){if(!this.sourcesContent)return null;this.sourceRoot&&(a=b.relative(this.sourceRoot,a));if(this._sources.has(a))return this.sourcesContent[this._sources.indexOf(a)];var d;if(this.sourceRoot&&(d=b.urlParse(this.sourceRoot))){var e=a.replace(/^file:\\/\\//,\"\");if(\"file\"==d.scheme&&this._sources.has(e))return this.sourcesContent[this._sources.indexOf(e)];if((!d.path||\"/\"==d.path)&&this._sources.has(\"/\"+a))return this.sourcesContent[this._sources.indexOf(\"/\"+\na)]}throw Error('\"'+a+'\" is not in the SourceMap.');};g.prototype.generatedPositionFor=function(a){a={source:b.getArg(a,\"source\"),originalLine:b.getArg(a,\"line\"),originalColumn:b.getArg(a,\"column\")};this.sourceRoot&&(a.source=b.relative(this.sourceRoot,a.source));return(a=this._findMapping(a,this._originalMappings,\"originalLine\",\"originalColumn\",b.compareByOriginalPositions))?{line:b.getArg(a,\"generatedLine\",null),column:b.getArg(a,\"generatedColumn\",null)}:{line:null,column:null}};g.GENERATED_ORDER=\n1;g.ORIGINAL_ORDER=2;g.prototype.eachMapping=function(a,d,e){d=d||null;switch(e||g.GENERATED_ORDER){case g.GENERATED_ORDER:e=this._generatedMappings;break;case g.ORIGINAL_ORDER:e=this._originalMappings;break;default:throw Error(\"Unknown order of iteration.\");}var f=this.sourceRoot;e.map(function(a){var c=a.source;c&&f&&(c=b.join(f,c));return{source:c,generatedLine:a.generatedLine,generatedColumn:a.generatedColumn,originalLine:a.originalLine,originalColumn:a.originalColumn,name:a.name}}).forEach(a,\nd)};l.SourceMapConsumer=g})},{\"./array-set\":10,\"./base64-vlq\":11,\"./binary-search\":13,\"./util\":17,amdefine:2}],15:[function(n,w,t){if(\"function\"!==typeof e)var e=n(\"amdefine\")(w,n);e(function(e,l,m){function g(a){this._file=f.getArg(a,\"file\");this._sourceRoot=f.getArg(a,\"sourceRoot\",null);this._sources=new k;this._names=new k;this._mappings=[];this._sourcesContents=null}var b=e(\"./base64-vlq\"),f=e(\"./util\"),k=e(\"./array-set\").ArraySet;g.prototype._version=3;g.fromSourceMap=function(a){var c=a.sourceRoot,\nd=new g({file:a.file,sourceRoot:c});a.eachMapping(function(a){var b={generated:{line:a.generatedLine,column:a.generatedColumn}};a.source&&(b.source=a.source,c&&(b.source=f.relative(c,b.source)),b.original={line:a.originalLine,column:a.originalColumn},a.name&&(b.name=a.name));d.addMapping(b)});a.sources.forEach(function(c){var b=a.sourceContentFor(c);b&&d.setSourceContent(c,b)});return d};g.prototype.addMapping=function(a){var c=f.getArg(a,\"generated\"),d=f.getArg(a,\"original\",null),b=f.getArg(a,\"source\",\nnull);a=f.getArg(a,\"name\",null);this._validateMapping(c,d,b,a);b&&!this._sources.has(b)&&this._sources.add(b);a&&!this._names.has(a)&&this._names.add(a);this._mappings.push({generatedLine:c.line,generatedColumn:c.column,originalLine:null!=d&&d.line,originalColumn:null!=d&&d.column,source:b,name:a})};g.prototype.setSourceContent=function(a,c){var d=a;this._sourceRoot&&(d=f.relative(this._sourceRoot,d));null!==c?(this._sourcesContents||(this._sourcesContents={}),this._sourcesContents[f.toSetString(d)]=\nc):(delete this._sourcesContents[f.toSetString(d)],0===Object.keys(this._sourcesContents).length&&(this._sourcesContents=null))};g.prototype.applySourceMap=function(a,c){c||(c=a.file);var d=this._sourceRoot;d&&(c=f.relative(d,c));var b=new k,e=new k;this._mappings.forEach(function(g){if(g.source===c&&g.originalLine){var k=a.originalPositionFor({line:g.originalLine,column:g.originalColumn});null!==k.source&&(g.source=d?f.relative(d,k.source):k.source,g.originalLine=k.line,g.originalColumn=k.column,\nnull!==k.name&&null!==g.name&&(g.name=k.name))}(k=g.source)&&!b.has(k)&&b.add(k);(g=g.name)&&!e.has(g)&&e.add(g)},this);this._sources=b;this._names=e;a.sources.forEach(function(c){var b=a.sourceContentFor(c);b&&(d&&(c=f.relative(d,c)),this.setSourceContent(c,b))},this)};g.prototype._validateMapping=function(a,c,d,b){if(!(a&&\"line\"in a&&\"column\"in a&&0<a.line&&0<=a.column&&!c&&!d&&!b||a&&\"line\"in a&&\"column\"in a&&c&&\"line\"in c&&\"column\"in c&&0<a.line&&0<=a.column&&0<c.line&&0<=c.column&&d))throw Error(\"Invalid mapping: \"+\nJSON.stringify({generated:a,source:d,original:c,name:b}));};g.prototype._serializeMappings=function(){var a=0,c=1,d=0,e=0,g=0,k=0,l=\"\",m;this._mappings.sort(f.compareByGeneratedPositions);for(var n=0,r=this._mappings.length;n<r;n++){m=this._mappings[n];if(m.generatedLine!==c)for(a=0;m.generatedLine!==c;)l+=\";\",c++;else if(0<n){if(!f.compareByGeneratedPositions(m,this._mappings[n-1]))continue;l+=\",\"}l+=b.encode(m.generatedColumn-a);a=m.generatedColumn;m.source&&(l+=b.encode(this._sources.indexOf(m.source)-\nk),k=this._sources.indexOf(m.source),l+=b.encode(m.originalLine-1-e),e=m.originalLine-1,l+=b.encode(m.originalColumn-d),d=m.originalColumn,m.name&&(l+=b.encode(this._names.indexOf(m.name)-g),g=this._names.indexOf(m.name)))}return l};g.prototype._generateSourcesContent=function(a,c){return a.map(function(a){if(!this._sourcesContents)return null;c&&(a=f.relative(c,a));a=f.toSetString(a);return Object.prototype.hasOwnProperty.call(this._sourcesContents,a)?this._sourcesContents[a]:null},this)};g.prototype.toJSON=\nfunction(){var a={version:this._version,file:this._file,sources:this._sources.toArray(),names:this._names.toArray(),mappings:this._serializeMappings()};this._sourceRoot&&(a.sourceRoot=this._sourceRoot);this._sourcesContents&&(a.sourcesContent=this._generateSourcesContent(a.sources,a.sourceRoot));return a};g.prototype.toString=function(){return JSON.stringify(this)};l.SourceMapGenerator=g})},{\"./array-set\":10,\"./base64-vlq\":11,\"./util\":17,amdefine:2}],16:[function(n,w,t){if(\"function\"!==typeof e)var e=\nn(\"amdefine\")(w,n);e(function(e,l,m){function g(b,a,c,d,e){this.children=[];this.sourceContents={};this.line=void 0===b?null:b;this.column=void 0===a?null:a;this.source=void 0===c?null:c;this.name=void 0===e?null:e;null!=d&&this.add(d)}var b=e(\"./source-map-generator\").SourceMapGenerator,f=e(\"./util\");g.fromStringWithSourceMap=function(b,a){function c(a,c){null===a||void 0===a.source?d.add(c):d.add(new g(a.originalLine,a.originalColumn,a.source,c,a.name))}var d=new g,e=b.split(\"\\n\"),f=1,l=0,m=null;\na.eachMapping(function(a){if(null===m){for(;f<a.generatedLine;)d.add(e.shift()+\"\\n\"),f++;if(l<a.generatedColumn){var b=e[0];d.add(b.substr(0,a.generatedColumn));e[0]=b.substr(a.generatedColumn);l=a.generatedColumn}}else{if(f<a.generatedLine){var g=\"\";do g+=e.shift()+\"\\n\",f++,l=0;while(f<a.generatedLine);l<a.generatedColumn&&(b=e[0],g+=b.substr(0,a.generatedColumn),e[0]=b.substr(a.generatedColumn),l=a.generatedColumn)}else b=e[0],g=b.substr(0,a.generatedColumn-l),e[0]=b.substr(a.generatedColumn-l),\nl=a.generatedColumn;c(m,g)}m=a},this);c(m,e.join(\"\\n\"));a.sources.forEach(function(c){var b=a.sourceContentFor(c);b&&d.setSourceContent(c,b)});return d};g.prototype.add=function(b){if(Array.isArray(b))b.forEach(function(a){this.add(a)},this);else if(b instanceof g||\"string\"===typeof b)b&&this.children.push(b);else throw new TypeError(\"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \"+b);return this};g.prototype.prepend=function(b){if(Array.isArray(b))for(var a=b.length-\n1;0<=a;a--)this.prepend(b[a]);else if(b instanceof g||\"string\"===typeof b)this.children.unshift(b);else throw new TypeError(\"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \"+b);return this};g.prototype.walk=function(b){for(var a,c=0,d=this.children.length;c<d;c++)a=this.children[c],a instanceof g?a.walk(b):\"\"!==a&&b(a,{source:this.source,line:this.line,column:this.column,name:this.name})};g.prototype.join=function(b){var a,c,d=this.children.length;if(0<d){a=[];for(c=0;c<\nd-1;c++)a.push(this.children[c]),a.push(b);a.push(this.children[c]);this.children=a}return this};g.prototype.replaceRight=function(b,a){var c=this.children[this.children.length-1];c instanceof g?c.replaceRight(b,a):\"string\"===typeof c?this.children[this.children.length-1]=c.replace(b,a):this.children.push(\"\".replace(b,a));return this};g.prototype.setSourceContent=function(b,a){this.sourceContents[f.toSetString(b)]=a};g.prototype.walkSourceContents=function(b){for(var a=0,c=this.children.length;a<\nc;a++)this.children[a]instanceof g&&this.children[a].walkSourceContents(b);for(var d=Object.keys(this.sourceContents),a=0,c=d.length;a<c;a++)b(f.fromSetString(d[a]),this.sourceContents[d[a]])};g.prototype.toString=function(){var b=\"\";this.walk(function(a){b+=a});return b};g.prototype.toStringWithSourceMap=function(e){var a=\"\",c=1,d=0,f=new b(e),g=!1,l=null,m=null,n=null,r=null;this.walk(function(b,e){a+=b;null!==e.source&&null!==e.line&&null!==e.column?(l===e.source&&m===e.line&&n===e.column&&r===\ne.name||f.addMapping({source:e.source,original:{line:e.line,column:e.column},generated:{line:c,column:d},name:e.name}),l=e.source,m=e.line,n=e.column,r=e.name,g=!0):g&&(f.addMapping({generated:{line:c,column:d}}),l=null,g=!1);b.split(\"\").forEach(function(a){\"\\n\"===a?(c++,d=0):d++})});this.walkSourceContents(function(a,c){f.setSourceContent(a,c)});return{code:a,map:f}};l.SourceNode=g})},{\"./source-map-generator\":15,\"./util\":17,amdefine:2}],17:[function(n,w,t){if(\"function\"!==typeof e)var e=n(\"amdefine\")(w,\nn);e(function(e,l,m){function g(a){return(a=a.match(k))?{scheme:a[1],auth:a[3],host:a[4],port:a[6],path:a[7]}:null}function b(a){var b=a.scheme+\"://\";a.auth&&(b+=a.auth+\"@\");a.host&&(b+=a.host);a.port&&(b+=\":\"+a.port);a.path&&(b+=a.path);return b}function f(a,b){var e=a||\"\",f=b||\"\";return(e>f)-(e<f)}l.getArg=function(a,b,e){if(b in a)return a[b];if(3===arguments.length)return e;throw Error('\"'+b+'\" is a required argument.');};var k=/([\\w+\\-.]+):\\/\\/((\\w+:\\w+)@)?([\\w.]+)?(:(\\d+))?(\\S+)?/,a=/^data:.+\\,.+/;\nl.urlParse=g;l.urlGenerate=b;l.join=function(c,d){var e;return d.match(k)||d.match(a)?d:\"/\"===d.charAt(0)&&(e=g(c))?(e.path=d,b(e)):c.replace(/\\/$/,\"\")+\"/\"+d};l.toSetString=function(a){return\"$\"+a};l.fromSetString=function(a){return a.substr(1)};l.relative=function(a,b){a=a.replace(/\\/$/,\"\");var e=g(a);return\"/\"==b.charAt(0)&&e&&\"/\"==e.path?b.slice(1):0===b.indexOf(a+\"/\")?b.substr(a.length+1):b};l.compareByOriginalPositions=function(a,b,e){var g;return(g=f(a.source,b.source))||(g=a.originalLine-b.originalLine)||\n(g=a.originalColumn-b.originalColumn)||e||(g=f(a.name,b.name))?g:(g=a.generatedLine-b.generatedLine)?g:a.generatedColumn-b.generatedColumn};l.compareByGeneratedPositions=function(a,b,e){var g;return(g=a.generatedLine-b.generatedLine)||(g=a.generatedColumn-b.generatedColumn)||e||(g=f(a.source,b.source))||(g=a.originalLine-b.originalLine)?g:(g=a.originalColumn-b.originalColumn)?g:f(a.name,b.name)}})},{amdefine:2}],18:[function(n,w,t){(function(e,r){function l(){return\"browser\"===C?!0:\"node\"===C?!1:\n\"undefined\"!==typeof window&&\"function\"===typeof XMLHttpRequest}function m(a){a=a.trim();if(a in z)return z[a];try{if(l()){var b=new XMLHttpRequest;b.open(\"GET\",a,!1);b.send(null);var c=null;4===b.readyState&&200===b.status&&(c=b.responseText)}else c=E.readFileSync(a,\"utf8\")}catch(d){c=null}return z[a]=c}function g(a,b){if(!a)return b;var c=F.dirname(a),d=/^\\w+:\\/\\/[^\\/]*/.exec(c),d=d?d[0]:\"\";return d+F.resolve(c.slice(d.length),b)}function b(a){var b;a:{var c;if(l()&&(c=new XMLHttpRequest,c.open(\"GET\",\na,!1),c.send(null),c=c.getResponseHeader(\"SourceMap\")||c.getResponseHeader(\"X-SourceMap\"))){b=c;break a}c=m(a);for(var d=/(?:\\/\\/[@#][ \\t]+sourceMappingURL=([^\\s'\"]+?)[ \\t]*$)|(?:\\/\\*[@#][ \\t]+sourceMappingURL=([^\\*]+?)[ \\t]*(?:\\*\\/)[ \\t]*$)/mg,e;e=d.exec(c);)b=e;b=b?b[1]:null}if(!b)return null;H.test(b)?(a=b.slice(b.indexOf(\",\")+1),a=(new r(a,\"base64\")).toString(),b=null):(b=g(a,b),a=m(b));return a?{url:b,map:a}:null}function f(a){var c=D[a.source];if(!c){var d=b(a.source);d?(c=D[a.source]={url:d.url,\nmap:new B(d.map)},c.map.sourcesContent&&c.map.sources.forEach(function(a,b){var d=c.map.sourcesContent[b];if(d){var e=g(c.url,a);z[e]=d}})):c=D[a.source]={url:null,map:null}}return c&&c.map&&(d=c.map.originalPositionFor(a),null!==d.source)?(d.source=g(c.url,d.source),d):a}function k(a){var b=/^eval at ([^(]+) \\((.+):(\\d+):(\\d+)\\)$/.exec(a);return b?(a=f({source:b[2],line:b[3],column:b[4]-1}),\"eval at \"+b[1]+\" (\"+a.source+\":\"+a.line+\":\"+(a.column+1)+\")\"):(b=/^eval at ([^(]+) \\((.+)\\)$/.exec(a))?\"eval at \"+\nb[1]+\" (\"+k(b[2])+\")\":a}function a(){var a,b=\"\";this.isNative()?b=\"native\":(a=this.getScriptNameOrSourceURL(),!a&&this.isEval()&&(b=this.getEvalOrigin(),b+=\", \"),b=a?b+a:b+\"<anonymous>\",a=this.getLineNumber(),null!=a&&(b+=\":\"+a,(a=this.getColumnNumber())&&(b+=\":\"+a)));a=\"\";var c=this.getFunctionName(),d=!0,e=this.isConstructor();if(this.isToplevel()||e)e?a+=\"new \"+(c||\"<anonymous>\"):c?a+=c:(a+=b,d=!1);else{var e=this.getTypeName(),f=this.getMethodName();c?(e&&0!=c.indexOf(e)&&(a+=e+\".\"),a+=c,f&&c.indexOf(\".\"+\nf)!=c.length-f.length-1&&(a+=\" [as \"+f+\"]\")):a+=e+\".\"+(f||\"<anonymous>\")}d&&(a+=\" (\"+b+\")\");return a}function c(b){var c={};Object.getOwnPropertyNames(Object.getPrototypeOf(b)).forEach(function(a){c[a]=/^(?:is|get)/.test(a)?function(){return b[a].call(b)}:b[a]});c.toString=a;return c}function d(a){var b=a.getFileName()||a.getScriptNameOrSourceURL();if(b){var d=a.getLineNumber(),e=a.getColumnNumber()-1;1!==d||l()||a.isEval()||(e-=62);var g=f({source:b,line:d,column:e});a=c(a);a.getFileName=function(){return g.source};\na.getLineNumber=function(){return g.line};a.getColumnNumber=function(){return g.column+1};a.getScriptNameOrSourceURL=function(){return g.source};return a}var m=a.isEval()&&a.getEvalOrigin();m&&(m=k(m),a=c(a),a.getEvalOrigin=function(){return m});return a}function w(a,b){u&&(z={},D={});return a+b.map(function(a){return\"\\n    at \"+d(a)}).join(\"\")}function x(a){var b=/\\n    at [^(]+ \\((.*):(\\d+):(\\d+)\\)/.exec(a.stack);if(b){a=b[1];var c=+b[2],b=+b[3],d=z[a];!d&&E.existsSync(a)&&(d=E.readFileSync(a,\"utf8\"));\nif(d&&(d=d.split(/(?:\\r\\n|\\r|\\n)/)[c-1]))return a+\":\"+c+\"\\n\"+d+\"\\n\"+Array(b).join(\" \")+\"^\"}return null}function A(){var a=e.emit;e.emit=function(b){if(\"uncaughtException\"===b){var c=arguments[1]&&arguments[1].stack,d=0<this.listeners(b).length;if(c&&!d){c=arguments[1];if(d=x(c))console.error(),console.error(d);console.error(c.stack);e.exit(1);return}}return a.apply(this,arguments)}}var B=n(\"source-map\").SourceMapConsumer,F=n(\"path\"),E=n(\"fs\"),G=!1,u=!1,C=\"auto\",z={},D={},H=/^data:application\\/json[^,]+base64,/;\nt.wrapCallSite=d;t.getErrorSource=x;t.mapSourcePosition=f;t.retrieveSourceMap=b;t.install=function(a){if(!G){G=!0;Error.prepareStackTrace=w;a=a||{};var c=\"handleUncaughtExceptions\"in a?a.handleUncaughtExceptions:!0;u=\"emptyCacheBetweenOperations\"in a?a.emptyCacheBetweenOperations:!1;if(a.environment&&(C=a.environment,-1===[\"node\",\"browser\",\"auto\"].indexOf(C)))throw Error(\"environment \"+C+\" was unknown. Available options are {auto, browser, node}\");a.retrieveFile&&(m=a.retrieveFile);a.retrieveSourceMap&&\n(b=a.retrieveSourceMap);c&&\"object\"===typeof e&&null!==e&&\"function\"===typeof e.on&&A()}}}).call(this,n(\"node_modules/process/browser.js\"),n(\"buffer\").Buffer)},{\"node_modules/process/browser.js\":8,buffer:5,fs:4,path:7,\"source-map\":9}]},{},[1]);return K});\n"

/***/ },
/* 7 */
/***/ function(module, exports) {

	"use strict";
	
	module.exports = "/*\nCopyright (c) 2008-2015 Pivotal Labs\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\nvar getJasmineRequireObj = (function (jasmineGlobal) {\n  var jasmineRequire;\n\n  if (typeof module !== 'undefined' && module.exports) {\n    jasmineGlobal = global;\n    jasmineRequire = exports;\n  } else {\n    if (typeof window !== 'undefined' && typeof window.toString === 'function' && window.toString() === '[object GjsGlobal]') {\n      jasmineGlobal = window;\n    }\n    jasmineRequire = jasmineGlobal.jasmineRequire = jasmineGlobal.jasmineRequire || {};\n  }\n\n  function getJasmineRequire() {\n    return jasmineRequire;\n  }\n\n  getJasmineRequire().core = function(jRequire) {\n    var j$ = {};\n\n    jRequire.base(j$, jasmineGlobal);\n    j$.util = jRequire.util();\n    j$.errors = jRequire.errors();\n    j$.Any = jRequire.Any(j$);\n    j$.Anything = jRequire.Anything(j$);\n    j$.CallTracker = jRequire.CallTracker();\n    j$.MockDate = jRequire.MockDate();\n    j$.Clock = jRequire.Clock();\n    j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler();\n    j$.Env = jRequire.Env(j$);\n    j$.ExceptionFormatter = jRequire.ExceptionFormatter();\n    j$.Expectation = jRequire.Expectation();\n    j$.buildExpectationResult = jRequire.buildExpectationResult();\n    j$.JsApiReporter = jRequire.JsApiReporter();\n    j$.matchersUtil = jRequire.matchersUtil(j$);\n    j$.ObjectContaining = jRequire.ObjectContaining(j$);\n    j$.ArrayContaining = jRequire.ArrayContaining(j$);\n    j$.pp = jRequire.pp(j$);\n    j$.QueueRunner = jRequire.QueueRunner(j$);\n    j$.ReportDispatcher = jRequire.ReportDispatcher();\n    j$.Spec = jRequire.Spec(j$);\n    j$.SpyRegistry = jRequire.SpyRegistry(j$);\n    j$.SpyStrategy = jRequire.SpyStrategy();\n    j$.StringMatching = jRequire.StringMatching(j$);\n    j$.Suite = jRequire.Suite(j$);\n    j$.Timer = jRequire.Timer();\n    j$.TreeProcessor = jRequire.TreeProcessor();\n    j$.version = jRequire.version();\n\n    j$.matchers = jRequire.requireMatchers(jRequire, j$);\n\n    return j$;\n  };\n\n  return getJasmineRequire;\n})(this);\n\ngetJasmineRequireObj().requireMatchers = function(jRequire, j$) {\n  var availableMatchers = [\n      'toBe',\n      'toBeCloseTo',\n      'toBeDefined',\n      'toBeFalsy',\n      'toBeGreaterThan',\n      'toBeLessThan',\n      'toBeNaN',\n      'toBeNull',\n      'toBeTruthy',\n      'toBeUndefined',\n      'toContain',\n      'toEqual',\n      'toHaveBeenCalled',\n      'toHaveBeenCalledWith',\n      'toMatch',\n      'toThrow',\n      'toThrowError'\n    ],\n    matchers = {};\n\n  for (var i = 0; i < availableMatchers.length; i++) {\n    var name = availableMatchers[i];\n    matchers[name] = jRequire[name](j$);\n  }\n\n  return matchers;\n};\n\ngetJasmineRequireObj().base = function(j$, jasmineGlobal) {\n  j$.unimplementedMethod_ = function() {\n    throw new Error('unimplemented method');\n  };\n\n  j$.MAX_PRETTY_PRINT_DEPTH = 40;\n  j$.MAX_PRETTY_PRINT_ARRAY_LENGTH = 100;\n  j$.DEFAULT_TIMEOUT_INTERVAL = 5000;\n\n  j$.getGlobal = function() {\n    return jasmineGlobal;\n  };\n\n  j$.getEnv = function(options) {\n    var env = j$.currentEnv_ = j$.currentEnv_ || new j$.Env(options);\n    //jasmine. singletons in here (setTimeout blah blah).\n    return env;\n  };\n\n  j$.isArray_ = function(value) {\n    return j$.isA_('Array', value);\n  };\n\n  j$.isString_ = function(value) {\n    return j$.isA_('String', value);\n  };\n\n  j$.isNumber_ = function(value) {\n    return j$.isA_('Number', value);\n  };\n\n  j$.isA_ = function(typeName, value) {\n    return Object.prototype.toString.apply(value) === '[object ' + typeName + ']';\n  };\n\n  j$.isDomNode = function(obj) {\n    return obj.nodeType > 0;\n  };\n\n  j$.fnNameFor = function(func) {\n    return func.name || func.toString().match(/^\\s*function\\s*(\\w*)\\s*\\(/)[1];\n  };\n\n  j$.any = function(clazz) {\n    return new j$.Any(clazz);\n  };\n\n  j$.anything = function() {\n    return new j$.Anything();\n  };\n\n  j$.objectContaining = function(sample) {\n    return new j$.ObjectContaining(sample);\n  };\n\n  j$.stringMatching = function(expected) {\n    return new j$.StringMatching(expected);\n  };\n\n  j$.arrayContaining = function(sample) {\n    return new j$.ArrayContaining(sample);\n  };\n\n  j$.createSpy = function(name, originalFn) {\n\n    var spyStrategy = new j$.SpyStrategy({\n        name: name,\n        fn: originalFn,\n        getSpy: function() { return spy; }\n      }),\n      callTracker = new j$.CallTracker(),\n      spy = function() {\n        var callData = {\n          object: this,\n          args: Array.prototype.slice.apply(arguments)\n        };\n\n        callTracker.track(callData);\n        var returnValue = spyStrategy.exec.apply(this, arguments);\n        callData.returnValue = returnValue;\n\n        return returnValue;\n      };\n\n    for (var prop in originalFn) {\n      if (prop === 'and' || prop === 'calls') {\n        throw new Error('Jasmine spies would overwrite the \\'and\\' and \\'calls\\' properties on the object being spied upon');\n      }\n\n      spy[prop] = originalFn[prop];\n    }\n\n    spy.and = spyStrategy;\n    spy.calls = callTracker;\n\n    return spy;\n  };\n\n  j$.isSpy = function(putativeSpy) {\n    if (!putativeSpy) {\n      return false;\n    }\n    return putativeSpy.and instanceof j$.SpyStrategy &&\n      putativeSpy.calls instanceof j$.CallTracker;\n  };\n\n  j$.createSpyObj = function(baseName, methodNames) {\n    if (j$.isArray_(baseName) && j$.util.isUndefined(methodNames)) {\n      methodNames = baseName;\n      baseName = 'unknown';\n    }\n\n    if (!j$.isArray_(methodNames) || methodNames.length === 0) {\n      throw 'createSpyObj requires a non-empty array of method names to create spies for';\n    }\n    var obj = {};\n    for (var i = 0; i < methodNames.length; i++) {\n      obj[methodNames[i]] = j$.createSpy(baseName + '.' + methodNames[i]);\n    }\n    return obj;\n  };\n};\n\ngetJasmineRequireObj().util = function() {\n\n  var util = {};\n\n  util.inherit = function(childClass, parentClass) {\n    var Subclass = function() {\n    };\n    Subclass.prototype = parentClass.prototype;\n    childClass.prototype = new Subclass();\n  };\n\n  util.htmlEscape = function(str) {\n    if (!str) {\n      return str;\n    }\n    return str.replace(/&/g, '&amp;')\n      .replace(/</g, '&lt;')\n      .replace(/>/g, '&gt;');\n  };\n\n  util.argsToArray = function(args) {\n    var arrayOfArgs = [];\n    for (var i = 0; i < args.length; i++) {\n      arrayOfArgs.push(args[i]);\n    }\n    return arrayOfArgs;\n  };\n\n  util.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  util.arrayContains = function(array, search) {\n    var i = array.length;\n    while (i--) {\n      if (array[i] === search) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  util.clone = function(obj) {\n    if (Object.prototype.toString.apply(obj) === '[object Array]') {\n      return obj.slice();\n    }\n\n    var cloned = {};\n    for (var prop in obj) {\n      if (obj.hasOwnProperty(prop)) {\n        cloned[prop] = obj[prop];\n      }\n    }\n\n    return cloned;\n  };\n\n  return util;\n};\n\ngetJasmineRequireObj().Spec = function(j$) {\n  function Spec(attrs) {\n    this.expectationFactory = attrs.expectationFactory;\n    this.resultCallback = attrs.resultCallback || function() {};\n    this.id = attrs.id;\n    this.description = attrs.description || '';\n    this.queueableFn = attrs.queueableFn;\n    this.beforeAndAfterFns = attrs.beforeAndAfterFns || function() { return {befores: [], afters: []}; };\n    this.userContext = attrs.userContext || function() { return {}; };\n    this.onStart = attrs.onStart || function() {};\n    this.getSpecName = attrs.getSpecName || function() { return ''; };\n    this.expectationResultFactory = attrs.expectationResultFactory || function() { };\n    this.queueRunnerFactory = attrs.queueRunnerFactory || function() {};\n    this.catchingExceptions = attrs.catchingExceptions || function() { return true; };\n    this.throwOnExpectationFailure = !!attrs.throwOnExpectationFailure;\n\n    if (!this.queueableFn.fn) {\n      this.pend();\n    }\n\n    this.result = {\n      id: this.id,\n      description: this.description,\n      fullName: this.getFullName(),\n      failedExpectations: [],\n      passedExpectations: [],\n      pendingReason: ''\n    };\n  }\n\n  Spec.prototype.addExpectationResult = function(passed, data, isError) {\n    var expectationResult = this.expectationResultFactory(data);\n    if (passed) {\n      this.result.passedExpectations.push(expectationResult);\n    } else {\n      this.result.failedExpectations.push(expectationResult);\n\n      if (this.throwOnExpectationFailure && !isError) {\n        throw new j$.errors.ExpectationFailed();\n      }\n    }\n  };\n\n  Spec.prototype.expect = function(actual) {\n    return this.expectationFactory(actual, this);\n  };\n\n  Spec.prototype.execute = function(onComplete, enabled) {\n    var self = this;\n\n    this.onStart(this);\n\n    if (!this.isExecutable() || this.markedPending || enabled === false) {\n      complete(enabled);\n      return;\n    }\n\n    var fns = this.beforeAndAfterFns();\n    var allFns = fns.befores.concat(this.queueableFn).concat(fns.afters);\n\n    this.queueRunnerFactory({\n      queueableFns: allFns,\n      onException: function() { self.onException.apply(self, arguments); },\n      onComplete: complete,\n      userContext: this.userContext()\n    });\n\n    function complete(enabledAgain) {\n      self.result.status = self.status(enabledAgain);\n      self.resultCallback(self.result);\n\n      if (onComplete) {\n        onComplete();\n      }\n    }\n  };\n\n  Spec.prototype.onException = function onException(e) {\n    if (Spec.isPendingSpecException(e)) {\n      this.pend(extractCustomPendingMessage(e));\n      return;\n    }\n\n    if (e instanceof j$.errors.ExpectationFailed) {\n      return;\n    }\n\n    this.addExpectationResult(false, {\n      matcherName: '',\n      passed: false,\n      expected: '',\n      actual: '',\n      error: e\n    }, true);\n  };\n\n  Spec.prototype.disable = function() {\n    this.disabled = true;\n  };\n\n  Spec.prototype.pend = function(message) {\n    this.markedPending = true;\n    if (message) {\n      this.result.pendingReason = message;\n    }\n  };\n\n  Spec.prototype.getResult = function() {\n    this.result.status = this.status();\n    return this.result;\n  };\n\n  Spec.prototype.status = function(enabled) {\n    if (this.disabled || enabled === false) {\n      return 'disabled';\n    }\n\n    if (this.markedPending) {\n      return 'pending';\n    }\n\n    if (this.result.failedExpectations.length > 0) {\n      return 'failed';\n    } else {\n      return 'passed';\n    }\n  };\n\n  Spec.prototype.isExecutable = function() {\n    return !this.disabled;\n  };\n\n  Spec.prototype.getFullName = function() {\n    return this.getSpecName(this);\n  };\n\n  var extractCustomPendingMessage = function(e) {\n    var fullMessage = e.toString(),\n        boilerplateStart = fullMessage.indexOf(Spec.pendingSpecExceptionMessage),\n        boilerplateEnd = boilerplateStart + Spec.pendingSpecExceptionMessage.length;\n\n    return fullMessage.substr(boilerplateEnd);\n  };\n\n  Spec.pendingSpecExceptionMessage = '=> marked Pending';\n\n  Spec.isPendingSpecException = function(e) {\n    return !!(e && e.toString && e.toString().indexOf(Spec.pendingSpecExceptionMessage) !== -1);\n  };\n\n  return Spec;\n};\n\nif (typeof window == void 0 && typeof exports == 'object') {\n  exports.Spec = jasmineRequire.Spec;\n}\n\ngetJasmineRequireObj().Env = function(j$) {\n  function Env(options) {\n    options = options || {};\n\n    var self = this;\n    var global = options.global || j$.getGlobal();\n\n    var totalSpecsDefined = 0;\n\n    var catchExceptions = true;\n\n    var realSetTimeout = j$.getGlobal().setTimeout;\n    var realClearTimeout = j$.getGlobal().clearTimeout;\n    this.clock = new j$.Clock(global, function () { return new j$.DelayedFunctionScheduler(); }, new j$.MockDate(global));\n\n    var runnableLookupTable = {};\n    var runnableResources = {};\n\n    var currentSpec = null;\n    var currentlyExecutingSuites = [];\n    var currentDeclarationSuite = null;\n    var throwOnExpectationFailure = false;\n\n    var currentSuite = function() {\n      return currentlyExecutingSuites[currentlyExecutingSuites.length - 1];\n    };\n\n    var currentRunnable = function() {\n      return currentSpec || currentSuite();\n    };\n\n    var reporter = new j$.ReportDispatcher([\n      'jasmineStarted',\n      'jasmineDone',\n      'suiteStarted',\n      'suiteDone',\n      'specStarted',\n      'specDone'\n    ]);\n\n    this.specFilter = function() {\n      return true;\n    };\n\n    this.addCustomEqualityTester = function(tester) {\n      if(!currentRunnable()) {\n        throw new Error('Custom Equalities must be added in a before function or a spec');\n      }\n      runnableResources[currentRunnable().id].customEqualityTesters.push(tester);\n    };\n\n    this.addMatchers = function(matchersToAdd) {\n      if(!currentRunnable()) {\n        throw new Error('Matchers must be added in a before function or a spec');\n      }\n      var customMatchers = runnableResources[currentRunnable().id].customMatchers;\n      for (var matcherName in matchersToAdd) {\n        customMatchers[matcherName] = matchersToAdd[matcherName];\n      }\n    };\n\n    j$.Expectation.addCoreMatchers(j$.matchers);\n\n    var nextSpecId = 0;\n    var getNextSpecId = function() {\n      return 'spec' + nextSpecId++;\n    };\n\n    var nextSuiteId = 0;\n    var getNextSuiteId = function() {\n      return 'suite' + nextSuiteId++;\n    };\n\n    var expectationFactory = function(actual, spec) {\n      return j$.Expectation.Factory({\n        util: j$.matchersUtil,\n        customEqualityTesters: runnableResources[spec.id].customEqualityTesters,\n        customMatchers: runnableResources[spec.id].customMatchers,\n        actual: actual,\n        addExpectationResult: addExpectationResult\n      });\n\n      function addExpectationResult(passed, result) {\n        return spec.addExpectationResult(passed, result);\n      }\n    };\n\n    var defaultResourcesForRunnable = function(id, parentRunnableId) {\n      var resources = {spies: [], customEqualityTesters: [], customMatchers: {}};\n\n      if(runnableResources[parentRunnableId]){\n        resources.customEqualityTesters = j$.util.clone(runnableResources[parentRunnableId].customEqualityTesters);\n        resources.customMatchers = j$.util.clone(runnableResources[parentRunnableId].customMatchers);\n      }\n\n      runnableResources[id] = resources;\n    };\n\n    var clearResourcesForRunnable = function(id) {\n        spyRegistry.clearSpies();\n        delete runnableResources[id];\n    };\n\n    var beforeAndAfterFns = function(suite) {\n      return function() {\n        var befores = [],\n          afters = [];\n\n        while(suite) {\n          befores = befores.concat(suite.beforeFns);\n          afters = afters.concat(suite.afterFns);\n\n          suite = suite.parentSuite;\n        }\n\n        return {\n          befores: befores.reverse(),\n          afters: afters\n        };\n      };\n    };\n\n    var getSpecName = function(spec, suite) {\n      return suite.getFullName() + ' ' + spec.description;\n    };\n\n    // TODO: we may just be able to pass in the fn instead of wrapping here\n    var buildExpectationResult = j$.buildExpectationResult,\n        exceptionFormatter = new j$.ExceptionFormatter(),\n        expectationResultFactory = function(attrs) {\n          attrs.messageFormatter = exceptionFormatter.message;\n          attrs.stackFormatter = exceptionFormatter.stack;\n\n          return buildExpectationResult(attrs);\n        };\n\n    // TODO: fix this naming, and here's where the value comes in\n    this.catchExceptions = function(value) {\n      catchExceptions = !!value;\n      return catchExceptions;\n    };\n\n    this.catchingExceptions = function() {\n      return catchExceptions;\n    };\n\n    var maximumSpecCallbackDepth = 20;\n    var currentSpecCallbackDepth = 0;\n\n    function clearStack(fn) {\n      currentSpecCallbackDepth++;\n      if (currentSpecCallbackDepth >= maximumSpecCallbackDepth) {\n        currentSpecCallbackDepth = 0;\n        realSetTimeout(fn, 0);\n      } else {\n        fn();\n      }\n    }\n\n    var catchException = function(e) {\n      return j$.Spec.isPendingSpecException(e) || catchExceptions;\n    };\n\n    this.throwOnExpectationFailure = function(value) {\n      throwOnExpectationFailure = !!value;\n    };\n\n    this.throwingExpectationFailures = function() {\n      return throwOnExpectationFailure;\n    };\n\n    var queueRunnerFactory = function(options) {\n      options.catchException = catchException;\n      options.clearStack = options.clearStack || clearStack;\n      options.timeout = {setTimeout: realSetTimeout, clearTimeout: realClearTimeout};\n      options.fail = self.fail;\n\n      new j$.QueueRunner(options).execute();\n    };\n\n    var topSuite = new j$.Suite({\n      env: this,\n      id: getNextSuiteId(),\n      description: 'Jasmine__TopLevel__Suite',\n      queueRunner: queueRunnerFactory\n    });\n    runnableLookupTable[topSuite.id] = topSuite;\n    defaultResourcesForRunnable(topSuite.id);\n    currentDeclarationSuite = topSuite;\n\n    this.topSuite = function() {\n      return topSuite;\n    };\n\n    this.execute = function(runnablesToRun) {\n      if(!runnablesToRun) {\n        if (focusedRunnables.length) {\n          runnablesToRun = focusedRunnables;\n        } else {\n          runnablesToRun = [topSuite.id];\n        }\n      }\n      var processor = new j$.TreeProcessor({\n        tree: topSuite,\n        runnableIds: runnablesToRun,\n        queueRunnerFactory: queueRunnerFactory,\n        nodeStart: function(suite) {\n          currentlyExecutingSuites.push(suite);\n          defaultResourcesForRunnable(suite.id, suite.parentSuite.id);\n          reporter.suiteStarted(suite.result);\n        },\n        nodeComplete: function(suite, result) {\n          if (!suite.disabled) {\n            clearResourcesForRunnable(suite.id);\n          }\n          currentlyExecutingSuites.pop();\n          reporter.suiteDone(result);\n        }\n      });\n\n      if(!processor.processTree().valid) {\n        throw new Error('Invalid order: would cause a beforeAll or afterAll to be run multiple times');\n      }\n\n      reporter.jasmineStarted({\n        totalSpecsDefined: totalSpecsDefined\n      });\n\n      processor.execute(reporter.jasmineDone);\n    };\n\n    this.addReporter = function(reporterToAdd) {\n      reporter.addReporter(reporterToAdd);\n    };\n\n    var spyRegistry = new j$.SpyRegistry({currentSpies: function() {\n      if(!currentRunnable()) {\n        throw new Error('Spies must be created in a before function or a spec');\n      }\n      return runnableResources[currentRunnable().id].spies;\n    }});\n\n    this.spyOn = function() {\n      return spyRegistry.spyOn.apply(spyRegistry, arguments);\n    };\n\n    var suiteFactory = function(description) {\n      var suite = new j$.Suite({\n        env: self,\n        id: getNextSuiteId(),\n        description: description,\n        parentSuite: currentDeclarationSuite,\n        expectationFactory: expectationFactory,\n        expectationResultFactory: expectationResultFactory,\n        throwOnExpectationFailure: throwOnExpectationFailure\n      });\n\n      runnableLookupTable[suite.id] = suite;\n      return suite;\n    };\n\n    this.describe = function(description, specDefinitions) {\n      var suite = suiteFactory(description);\n      addSpecsToSuite(suite, specDefinitions);\n      return suite;\n    };\n\n    this.xdescribe = function(description, specDefinitions) {\n      var suite = this.describe(description, specDefinitions);\n      suite.disable();\n      return suite;\n    };\n\n    var focusedRunnables = [];\n\n    this.fdescribe = function(description, specDefinitions) {\n      var suite = suiteFactory(description);\n      suite.isFocused = true;\n\n      focusedRunnables.push(suite.id);\n      unfocusAncestor();\n      addSpecsToSuite(suite, specDefinitions);\n\n      return suite;\n    };\n\n    function addSpecsToSuite(suite, specDefinitions) {\n      var parentSuite = currentDeclarationSuite;\n      parentSuite.addChild(suite);\n      currentDeclarationSuite = suite;\n\n      var declarationError = null;\n      try {\n        specDefinitions.call(suite);\n      } catch (e) {\n        declarationError = e;\n      }\n\n      if (declarationError) {\n        self.it('encountered a declaration exception', function() {\n          throw declarationError;\n        });\n      }\n\n      currentDeclarationSuite = parentSuite;\n    }\n\n    function findFocusedAncestor(suite) {\n      while (suite) {\n        if (suite.isFocused) {\n          return suite.id;\n        }\n        suite = suite.parentSuite;\n      }\n\n      return null;\n    }\n\n    function unfocusAncestor() {\n      var focusedAncestor = findFocusedAncestor(currentDeclarationSuite);\n      if (focusedAncestor) {\n        for (var i = 0; i < focusedRunnables.length; i++) {\n          if (focusedRunnables[i] === focusedAncestor) {\n            focusedRunnables.splice(i, 1);\n            break;\n          }\n        }\n      }\n    }\n\n    var specFactory = function(description, fn, suite, timeout) {\n      totalSpecsDefined++;\n      var spec = new j$.Spec({\n        id: getNextSpecId(),\n        beforeAndAfterFns: beforeAndAfterFns(suite),\n        expectationFactory: expectationFactory,\n        resultCallback: specResultCallback,\n        getSpecName: function(spec) {\n          return getSpecName(spec, suite);\n        },\n        onStart: specStarted,\n        description: description,\n        expectationResultFactory: expectationResultFactory,\n        queueRunnerFactory: queueRunnerFactory,\n        userContext: function() { return suite.clonedSharedUserContext(); },\n        queueableFn: {\n          fn: fn,\n          timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\n        },\n        throwOnExpectationFailure: throwOnExpectationFailure\n      });\n\n      runnableLookupTable[spec.id] = spec;\n\n      if (!self.specFilter(spec)) {\n        spec.disable();\n      }\n\n      return spec;\n\n      function specResultCallback(result) {\n        clearResourcesForRunnable(spec.id);\n        currentSpec = null;\n        reporter.specDone(result);\n      }\n\n      function specStarted(spec) {\n        currentSpec = spec;\n        defaultResourcesForRunnable(spec.id, suite.id);\n        reporter.specStarted(spec.result);\n      }\n    };\n\n    this.it = function(description, fn, timeout) {\n      var spec = specFactory(description, fn, currentDeclarationSuite, timeout);\n      currentDeclarationSuite.addChild(spec);\n      return spec;\n    };\n\n    this.xit = function() {\n      var spec = this.it.apply(this, arguments);\n      spec.pend();\n      return spec;\n    };\n\n    this.fit = function(){\n      var spec = this.it.apply(this, arguments);\n\n      focusedRunnables.push(spec.id);\n      unfocusAncestor();\n      return spec;\n    };\n\n    this.expect = function(actual) {\n      if (!currentRunnable()) {\n        throw new Error('\\'expect\\' was used when there was no current spec, this could be because an asynchronous test timed out');\n      }\n\n      return currentRunnable().expect(actual);\n    };\n\n    this.beforeEach = function(beforeEachFunction, timeout) {\n      currentDeclarationSuite.beforeEach({\n        fn: beforeEachFunction,\n        timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\n      });\n    };\n\n    this.beforeAll = function(beforeAllFunction, timeout) {\n      currentDeclarationSuite.beforeAll({\n        fn: beforeAllFunction,\n        timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\n      });\n    };\n\n    this.afterEach = function(afterEachFunction, timeout) {\n      currentDeclarationSuite.afterEach({\n        fn: afterEachFunction,\n        timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\n      });\n    };\n\n    this.afterAll = function(afterAllFunction, timeout) {\n      currentDeclarationSuite.afterAll({\n        fn: afterAllFunction,\n        timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\n      });\n    };\n\n    this.pending = function(message) {\n      var fullMessage = j$.Spec.pendingSpecExceptionMessage;\n      if(message) {\n        fullMessage += message;\n      }\n      throw fullMessage;\n    };\n\n    this.fail = function(error) {\n      var message = 'Failed';\n      if (error) {\n        message += ': ';\n        message += error.message || error;\n      }\n\n      currentRunnable().addExpectationResult(false, {\n        matcherName: '',\n        passed: false,\n        expected: '',\n        actual: '',\n        message: message,\n        error: error && error.message ? error : null\n      });\n    };\n  }\n\n  return Env;\n};\n\ngetJasmineRequireObj().JsApiReporter = function() {\n\n  var noopTimer = {\n    start: function(){},\n    elapsed: function(){ return 0; }\n  };\n\n  function JsApiReporter(options) {\n    var timer = options.timer || noopTimer,\n        status = 'loaded';\n\n    this.started = false;\n    this.finished = false;\n\n    this.jasmineStarted = function() {\n      this.started = true;\n      status = 'started';\n      timer.start();\n    };\n\n    var executionTime;\n\n    this.jasmineDone = function() {\n      this.finished = true;\n      executionTime = timer.elapsed();\n      status = 'done';\n    };\n\n    this.status = function() {\n      return status;\n    };\n\n    var suites = [],\n      suites_hash = {};\n\n    this.suiteStarted = function(result) {\n      suites_hash[result.id] = result;\n    };\n\n    this.suiteDone = function(result) {\n      storeSuite(result);\n    };\n\n    this.suiteResults = function(index, length) {\n      return suites.slice(index, index + length);\n    };\n\n    function storeSuite(result) {\n      suites.push(result);\n      suites_hash[result.id] = result;\n    }\n\n    this.suites = function() {\n      return suites_hash;\n    };\n\n    var specs = [];\n\n    this.specDone = function(result) {\n      specs.push(result);\n    };\n\n    this.specResults = function(index, length) {\n      return specs.slice(index, index + length);\n    };\n\n    this.specs = function() {\n      return specs;\n    };\n\n    this.executionTime = function() {\n      return executionTime;\n    };\n\n  }\n\n  return JsApiReporter;\n};\n\ngetJasmineRequireObj().CallTracker = function() {\n\n  function CallTracker() {\n    var calls = [];\n\n    this.track = function(context) {\n      calls.push(context);\n    };\n\n    this.any = function() {\n      return !!calls.length;\n    };\n\n    this.count = function() {\n      return calls.length;\n    };\n\n    this.argsFor = function(index) {\n      var call = calls[index];\n      return call ? call.args : [];\n    };\n\n    this.all = function() {\n      return calls;\n    };\n\n    this.allArgs = function() {\n      var callArgs = [];\n      for(var i = 0; i < calls.length; i++){\n        callArgs.push(calls[i].args);\n      }\n\n      return callArgs;\n    };\n\n    this.first = function() {\n      return calls[0];\n    };\n\n    this.mostRecent = function() {\n      return calls[calls.length - 1];\n    };\n\n    this.reset = function() {\n      calls = [];\n    };\n  }\n\n  return CallTracker;\n};\n\ngetJasmineRequireObj().Clock = function() {\n  function Clock(global, delayedFunctionSchedulerFactory, mockDate) {\n    var self = this,\n      realTimingFunctions = {\n        setTimeout: global.setTimeout,\n        clearTimeout: global.clearTimeout,\n        setInterval: global.setInterval,\n        clearInterval: global.clearInterval\n      },\n      fakeTimingFunctions = {\n        setTimeout: setTimeout,\n        clearTimeout: clearTimeout,\n        setInterval: setInterval,\n        clearInterval: clearInterval\n      },\n      installed = false,\n      delayedFunctionScheduler,\n      timer;\n\n\n    self.install = function() {\n      if(!originalTimingFunctionsIntact()) {\n        throw new Error('Jasmine Clock was unable to install over custom global timer functions. Is the clock already installed?');\n      }\n      replace(global, fakeTimingFunctions);\n      timer = fakeTimingFunctions;\n      delayedFunctionScheduler = delayedFunctionSchedulerFactory();\n      installed = true;\n\n      return self;\n    };\n\n    self.uninstall = function() {\n      delayedFunctionScheduler = null;\n      mockDate.uninstall();\n      replace(global, realTimingFunctions);\n\n      timer = realTimingFunctions;\n      installed = false;\n    };\n\n    self.withMock = function(closure) {\n      this.install();\n      try {\n        closure();\n      } finally {\n        this.uninstall();\n      }\n    };\n\n    self.mockDate = function(initialDate) {\n      mockDate.install(initialDate);\n    };\n\n    self.setTimeout = function(fn, delay, params) {\n      if (legacyIE()) {\n        if (arguments.length > 2) {\n          throw new Error('IE < 9 cannot support extra params to setTimeout without a polyfill');\n        }\n        return timer.setTimeout(fn, delay);\n      }\n      return Function.prototype.apply.apply(timer.setTimeout, [global, arguments]);\n    };\n\n    self.setInterval = function(fn, delay, params) {\n      if (legacyIE()) {\n        if (arguments.length > 2) {\n          throw new Error('IE < 9 cannot support extra params to setInterval without a polyfill');\n        }\n        return timer.setInterval(fn, delay);\n      }\n      return Function.prototype.apply.apply(timer.setInterval, [global, arguments]);\n    };\n\n    self.clearTimeout = function(id) {\n      return Function.prototype.call.apply(timer.clearTimeout, [global, id]);\n    };\n\n    self.clearInterval = function(id) {\n      return Function.prototype.call.apply(timer.clearInterval, [global, id]);\n    };\n\n    self.tick = function(millis) {\n      if (installed) {\n        mockDate.tick(millis);\n        delayedFunctionScheduler.tick(millis);\n      } else {\n        throw new Error('Mock clock is not installed, use jasmine.clock().install()');\n      }\n    };\n\n    return self;\n\n    function originalTimingFunctionsIntact() {\n      return global.setTimeout === realTimingFunctions.setTimeout &&\n        global.clearTimeout === realTimingFunctions.clearTimeout &&\n        global.setInterval === realTimingFunctions.setInterval &&\n        global.clearInterval === realTimingFunctions.clearInterval;\n    }\n\n    function legacyIE() {\n      //if these methods are polyfilled, apply will be present\n      return !(realTimingFunctions.setTimeout || realTimingFunctions.setInterval).apply;\n    }\n\n    function replace(dest, source) {\n      for (var prop in source) {\n        dest[prop] = source[prop];\n      }\n    }\n\n    function setTimeout(fn, delay) {\n      return delayedFunctionScheduler.scheduleFunction(fn, delay, argSlice(arguments, 2));\n    }\n\n    function clearTimeout(id) {\n      return delayedFunctionScheduler.removeFunctionWithId(id);\n    }\n\n    function setInterval(fn, interval) {\n      return delayedFunctionScheduler.scheduleFunction(fn, interval, argSlice(arguments, 2), true);\n    }\n\n    function clearInterval(id) {\n      return delayedFunctionScheduler.removeFunctionWithId(id);\n    }\n\n    function argSlice(argsObj, n) {\n      return Array.prototype.slice.call(argsObj, n);\n    }\n  }\n\n  return Clock;\n};\n\ngetJasmineRequireObj().DelayedFunctionScheduler = function() {\n  function DelayedFunctionScheduler() {\n    var self = this;\n    var scheduledLookup = [];\n    var scheduledFunctions = {};\n    var currentTime = 0;\n    var delayedFnCount = 0;\n\n    self.tick = function(millis) {\n      millis = millis || 0;\n      var endTime = currentTime + millis;\n\n      runScheduledFunctions(endTime);\n      currentTime = endTime;\n    };\n\n    self.scheduleFunction = function(funcToCall, millis, params, recurring, timeoutKey, runAtMillis) {\n      var f;\n      if (typeof(funcToCall) === 'string') {\n        /* jshint evil: true */\n        f = function() { return eval(funcToCall); };\n        /* jshint evil: false */\n      } else {\n        f = funcToCall;\n      }\n\n      millis = millis || 0;\n      timeoutKey = timeoutKey || ++delayedFnCount;\n      runAtMillis = runAtMillis || (currentTime + millis);\n\n      var funcToSchedule = {\n        runAtMillis: runAtMillis,\n        funcToCall: f,\n        recurring: recurring,\n        params: params,\n        timeoutKey: timeoutKey,\n        millis: millis\n      };\n\n      if (runAtMillis in scheduledFunctions) {\n        scheduledFunctions[runAtMillis].push(funcToSchedule);\n      } else {\n        scheduledFunctions[runAtMillis] = [funcToSchedule];\n        scheduledLookup.push(runAtMillis);\n        scheduledLookup.sort(function (a, b) {\n          return a - b;\n        });\n      }\n\n      return timeoutKey;\n    };\n\n    self.removeFunctionWithId = function(timeoutKey) {\n      for (var runAtMillis in scheduledFunctions) {\n        var funcs = scheduledFunctions[runAtMillis];\n        var i = indexOfFirstToPass(funcs, function (func) {\n          return func.timeoutKey === timeoutKey;\n        });\n\n        if (i > -1) {\n          if (funcs.length === 1) {\n            delete scheduledFunctions[runAtMillis];\n            deleteFromLookup(runAtMillis);\n          } else {\n            funcs.splice(i, 1);\n          }\n\n          // intervals get rescheduled when executed, so there's never more\n          // than a single scheduled function with a given timeoutKey\n          break;\n        }\n      }\n    };\n\n    return self;\n\n    function indexOfFirstToPass(array, testFn) {\n      var index = -1;\n\n      for (var i = 0; i < array.length; ++i) {\n        if (testFn(array[i])) {\n          index = i;\n          break;\n        }\n      }\n\n      return index;\n    }\n\n    function deleteFromLookup(key) {\n      var value = Number(key);\n      var i = indexOfFirstToPass(scheduledLookup, function (millis) {\n        return millis === value;\n      });\n\n      if (i > -1) {\n        scheduledLookup.splice(i, 1);\n      }\n    }\n\n    function reschedule(scheduledFn) {\n      self.scheduleFunction(scheduledFn.funcToCall,\n        scheduledFn.millis,\n        scheduledFn.params,\n        true,\n        scheduledFn.timeoutKey,\n        scheduledFn.runAtMillis + scheduledFn.millis);\n    }\n\n    function forEachFunction(funcsToRun, callback) {\n      for (var i = 0; i < funcsToRun.length; ++i) {\n        callback(funcsToRun[i]);\n      }\n    }\n\n    function runScheduledFunctions(endTime) {\n      if (scheduledLookup.length === 0 || scheduledLookup[0] > endTime) {\n        return;\n      }\n\n      do {\n        currentTime = scheduledLookup.shift();\n\n        var funcsToRun = scheduledFunctions[currentTime];\n        delete scheduledFunctions[currentTime];\n\n        forEachFunction(funcsToRun, function(funcToRun) {\n          if (funcToRun.recurring) {\n            reschedule(funcToRun);\n          }\n        });\n\n        forEachFunction(funcsToRun, function(funcToRun) {\n          funcToRun.funcToCall.apply(null, funcToRun.params || []);\n        });\n      } while (scheduledLookup.length > 0 &&\n              // checking first if we're out of time prevents setTimeout(0)\n              // scheduled in a funcToRun from forcing an extra iteration\n                 currentTime !== endTime  &&\n                 scheduledLookup[0] <= endTime);\n    }\n  }\n\n  return DelayedFunctionScheduler;\n};\n\ngetJasmineRequireObj().ExceptionFormatter = function() {\n  function ExceptionFormatter() {\n    this.message = function(error) {\n      var message = '';\n\n      if (error.name && error.message) {\n        message += error.name + ': ' + error.message;\n      } else {\n        message += error.toString() + ' thrown';\n      }\n\n      if (error.fileName || error.sourceURL) {\n        message += ' in ' + (error.fileName || error.sourceURL);\n      }\n\n      if (error.line || error.lineNumber) {\n        message += ' (line ' + (error.line || error.lineNumber) + ')';\n      }\n\n      return message;\n    };\n\n    this.stack = function(error) {\n      return error ? error.stack : null;\n    };\n  }\n\n  return ExceptionFormatter;\n};\n\ngetJasmineRequireObj().Expectation = function() {\n\n  function Expectation(options) {\n    this.util = options.util || { buildFailureMessage: function() {} };\n    this.customEqualityTesters = options.customEqualityTesters || [];\n    this.actual = options.actual;\n    this.addExpectationResult = options.addExpectationResult || function(){};\n    this.isNot = options.isNot;\n\n    var customMatchers = options.customMatchers || {};\n    for (var matcherName in customMatchers) {\n      this[matcherName] = Expectation.prototype.wrapCompare(matcherName, customMatchers[matcherName]);\n    }\n  }\n\n  Expectation.prototype.wrapCompare = function(name, matcherFactory) {\n    return function() {\n      var args = Array.prototype.slice.call(arguments, 0),\n        expected = args.slice(0),\n        message = '';\n\n      args.unshift(this.actual);\n\n      var matcher = matcherFactory(this.util, this.customEqualityTesters),\n          matcherCompare = matcher.compare;\n\n      function defaultNegativeCompare() {\n        var result = matcher.compare.apply(null, args);\n        result.pass = !result.pass;\n        return result;\n      }\n\n      if (this.isNot) {\n        matcherCompare = matcher.negativeCompare || defaultNegativeCompare;\n      }\n\n      var result = matcherCompare.apply(null, args);\n\n      if (!result.pass) {\n        if (!result.message) {\n          args.unshift(this.isNot);\n          args.unshift(name);\n          message = this.util.buildFailureMessage.apply(null, args);\n        } else {\n          if (Object.prototype.toString.apply(result.message) === '[object Function]') {\n            message = result.message();\n          } else {\n            message = result.message;\n          }\n        }\n      }\n\n      if (expected.length == 1) {\n        expected = expected[0];\n      }\n\n      // TODO: how many of these params are needed?\n      this.addExpectationResult(\n        result.pass,\n        {\n          matcherName: name,\n          passed: result.pass,\n          message: message,\n          actual: this.actual,\n          expected: expected // TODO: this may need to be arrayified/sliced\n        }\n      );\n    };\n  };\n\n  Expectation.addCoreMatchers = function(matchers) {\n    var prototype = Expectation.prototype;\n    for (var matcherName in matchers) {\n      var matcher = matchers[matcherName];\n      prototype[matcherName] = prototype.wrapCompare(matcherName, matcher);\n    }\n  };\n\n  Expectation.Factory = function(options) {\n    options = options || {};\n\n    var expect = new Expectation(options);\n\n    // TODO: this would be nice as its own Object - NegativeExpectation\n    // TODO: copy instead of mutate options\n    options.isNot = true;\n    expect.not = new Expectation(options);\n\n    return expect;\n  };\n\n  return Expectation;\n};\n\n//TODO: expectation result may make more sense as a presentation of an expectation.\ngetJasmineRequireObj().buildExpectationResult = function() {\n  function buildExpectationResult(options) {\n    var messageFormatter = options.messageFormatter || function() {},\n      stackFormatter = options.stackFormatter || function() {};\n\n    var result = {\n      matcherName: options.matcherName,\n      message: message(),\n      stack: stack(),\n      passed: options.passed\n    };\n\n    if(!result.passed) {\n      result.expected = options.expected;\n      result.actual = options.actual;\n    }\n\n    return result;\n\n    function message() {\n      if (options.passed) {\n        return 'Passed.';\n      } else if (options.message) {\n        return options.message;\n      } else if (options.error) {\n        return messageFormatter(options.error);\n      }\n      return '';\n    }\n\n    function stack() {\n      if (options.passed) {\n        return '';\n      }\n\n      var error = options.error;\n      if (!error) {\n        try {\n          throw new Error(message());\n        } catch (e) {\n          error = e;\n        }\n      }\n      return stackFormatter(error);\n    }\n  }\n\n  return buildExpectationResult;\n};\n\ngetJasmineRequireObj().MockDate = function() {\n  function MockDate(global) {\n    var self = this;\n    var currentTime = 0;\n\n    if (!global || !global.Date) {\n      self.install = function() {};\n      self.tick = function() {};\n      self.uninstall = function() {};\n      return self;\n    }\n\n    var GlobalDate = global.Date;\n\n    self.install = function(mockDate) {\n      if (mockDate instanceof GlobalDate) {\n        currentTime = mockDate.getTime();\n      } else {\n        currentTime = new GlobalDate().getTime();\n      }\n\n      global.Date = FakeDate;\n    };\n\n    self.tick = function(millis) {\n      millis = millis || 0;\n      currentTime = currentTime + millis;\n    };\n\n    self.uninstall = function() {\n      currentTime = 0;\n      global.Date = GlobalDate;\n    };\n\n    createDateProperties();\n\n    return self;\n\n    function FakeDate() {\n      switch(arguments.length) {\n        case 0:\n          return new GlobalDate(currentTime);\n        case 1:\n          return new GlobalDate(arguments[0]);\n        case 2:\n          return new GlobalDate(arguments[0], arguments[1]);\n        case 3:\n          return new GlobalDate(arguments[0], arguments[1], arguments[2]);\n        case 4:\n          return new GlobalDate(arguments[0], arguments[1], arguments[2], arguments[3]);\n        case 5:\n          return new GlobalDate(arguments[0], arguments[1], arguments[2], arguments[3],\n                                arguments[4]);\n        case 6:\n          return new GlobalDate(arguments[0], arguments[1], arguments[2], arguments[3],\n                                arguments[4], arguments[5]);\n        default:\n          return new GlobalDate(arguments[0], arguments[1], arguments[2], arguments[3],\n                                arguments[4], arguments[5], arguments[6]);\n      }\n    }\n\n    function createDateProperties() {\n      FakeDate.prototype = GlobalDate.prototype;\n\n      FakeDate.now = function() {\n        if (GlobalDate.now) {\n          return currentTime;\n        } else {\n          throw new Error('Browser does not support Date.now()');\n        }\n      };\n\n      FakeDate.toSource = GlobalDate.toSource;\n      FakeDate.toString = GlobalDate.toString;\n      FakeDate.parse = GlobalDate.parse;\n      FakeDate.UTC = GlobalDate.UTC;\n    }\n\t}\n\n  return MockDate;\n};\n\ngetJasmineRequireObj().pp = function(j$) {\n\n  function PrettyPrinter() {\n    this.ppNestLevel_ = 0;\n    this.seen = [];\n  }\n\n  PrettyPrinter.prototype.format = function(value) {\n    this.ppNestLevel_++;\n    try {\n      if (j$.util.isUndefined(value)) {\n        this.emitScalar('undefined');\n      } else if (value === null) {\n        this.emitScalar('null');\n      } else if (value === 0 && 1/value === -Infinity) {\n        this.emitScalar('-0');\n      } else if (value === j$.getGlobal()) {\n        this.emitScalar('<global>');\n      } else if (value.jasmineToString) {\n        this.emitScalar(value.jasmineToString());\n      } else if (typeof value === 'string') {\n        this.emitString(value);\n      } else if (j$.isSpy(value)) {\n        this.emitScalar('spy on ' + value.and.identity());\n      } else if (value instanceof RegExp) {\n        this.emitScalar(value.toString());\n      } else if (typeof value === 'function') {\n        this.emitScalar('Function');\n      } else if (typeof value.nodeType === 'number') {\n        this.emitScalar('HTMLNode');\n      } else if (value instanceof Date) {\n        this.emitScalar('Date(' + value + ')');\n      } else if (j$.util.arrayContains(this.seen, value)) {\n        this.emitScalar('<circular reference: ' + (j$.isArray_(value) ? 'Array' : 'Object') + '>');\n      } else if (j$.isArray_(value) || j$.isA_('Object', value)) {\n        this.seen.push(value);\n        if (j$.isArray_(value)) {\n          this.emitArray(value);\n        } else {\n          this.emitObject(value);\n        }\n        this.seen.pop();\n      } else {\n        this.emitScalar(value.toString());\n      }\n    } finally {\n      this.ppNestLevel_--;\n    }\n  };\n\n  PrettyPrinter.prototype.iterateObject = function(obj, fn) {\n    for (var property in obj) {\n      if (!Object.prototype.hasOwnProperty.call(obj, property)) { continue; }\n      fn(property, obj.__lookupGetter__ ? (!j$.util.isUndefined(obj.__lookupGetter__(property)) &&\n          obj.__lookupGetter__(property) !== null) : false);\n    }\n  };\n\n  PrettyPrinter.prototype.emitArray = j$.unimplementedMethod_;\n  PrettyPrinter.prototype.emitObject = j$.unimplementedMethod_;\n  PrettyPrinter.prototype.emitScalar = j$.unimplementedMethod_;\n  PrettyPrinter.prototype.emitString = j$.unimplementedMethod_;\n\n  function StringPrettyPrinter() {\n    PrettyPrinter.call(this);\n\n    this.string = '';\n  }\n\n  j$.util.inherit(StringPrettyPrinter, PrettyPrinter);\n\n  StringPrettyPrinter.prototype.emitScalar = function(value) {\n    this.append(value);\n  };\n\n  StringPrettyPrinter.prototype.emitString = function(value) {\n    this.append('\\'' + value + '\\'');\n  };\n\n  StringPrettyPrinter.prototype.emitArray = function(array) {\n    if (this.ppNestLevel_ > j$.MAX_PRETTY_PRINT_DEPTH) {\n      this.append('Array');\n      return;\n    }\n    var length = Math.min(array.length, j$.MAX_PRETTY_PRINT_ARRAY_LENGTH);\n    this.append('[ ');\n    for (var i = 0; i < length; i++) {\n      if (i > 0) {\n        this.append(', ');\n      }\n      this.format(array[i]);\n    }\n    if(array.length > length){\n      this.append(', ...');\n    }\n\n    var self = this;\n    var first = array.length === 0;\n    this.iterateObject(array, function(property, isGetter) {\n      if (property.match(/^\\d+$/)) {\n        return;\n      }\n\n      if (first) {\n        first = false;\n      } else {\n        self.append(', ');\n      }\n\n      self.formatProperty(array, property, isGetter);\n    });\n\n    this.append(' ]');\n  };\n\n  StringPrettyPrinter.prototype.emitObject = function(obj) {\n    var constructorName = obj.constructor ? j$.fnNameFor(obj.constructor) : 'null';\n    this.append(constructorName);\n\n    if (this.ppNestLevel_ > j$.MAX_PRETTY_PRINT_DEPTH) {\n      return;\n    }\n\n    var self = this;\n    this.append('({ ');\n    var first = true;\n\n    this.iterateObject(obj, function(property, isGetter) {\n      if (first) {\n        first = false;\n      } else {\n        self.append(', ');\n      }\n\n      self.formatProperty(obj, property, isGetter);\n    });\n\n    this.append(' })');\n  };\n\n  StringPrettyPrinter.prototype.formatProperty = function(obj, property, isGetter) {\n      this.append(property);\n      this.append(': ');\n      if (isGetter) {\n        this.append('<getter>');\n      } else {\n        this.format(obj[property]);\n      }\n  };\n\n  StringPrettyPrinter.prototype.append = function(value) {\n    this.string += value;\n  };\n\n  return function(value) {\n    var stringPrettyPrinter = new StringPrettyPrinter();\n    stringPrettyPrinter.format(value);\n    return stringPrettyPrinter.string;\n  };\n};\n\ngetJasmineRequireObj().QueueRunner = function(j$) {\n\n  function once(fn) {\n    var called = false;\n    return function() {\n      if (!called) {\n        called = true;\n        fn();\n      }\n    };\n  }\n\n  function QueueRunner(attrs) {\n    this.queueableFns = attrs.queueableFns || [];\n    this.onComplete = attrs.onComplete || function() {};\n    this.clearStack = attrs.clearStack || function(fn) {fn();};\n    this.onException = attrs.onException || function() {};\n    this.catchException = attrs.catchException || function() { return true; };\n    this.userContext = attrs.userContext || {};\n    this.timeout = attrs.timeout || {setTimeout: setTimeout, clearTimeout: clearTimeout};\n    this.fail = attrs.fail || function() {};\n  }\n\n  QueueRunner.prototype.execute = function() {\n    this.run(this.queueableFns, 0);\n  };\n\n  QueueRunner.prototype.run = function(queueableFns, recursiveIndex) {\n    var length = queueableFns.length,\n      self = this,\n      iterativeIndex;\n\n\n    for(iterativeIndex = recursiveIndex; iterativeIndex < length; iterativeIndex++) {\n      var queueableFn = queueableFns[iterativeIndex];\n      if (queueableFn.fn.length > 0) {\n        attemptAsync(queueableFn);\n        return;\n      } else {\n        attemptSync(queueableFn);\n      }\n    }\n\n    var runnerDone = iterativeIndex >= length;\n\n    if (runnerDone) {\n      this.clearStack(this.onComplete);\n    }\n\n    function attemptSync(queueableFn) {\n      try {\n        queueableFn.fn.call(self.userContext);\n      } catch (e) {\n        handleException(e, queueableFn);\n      }\n    }\n\n    function attemptAsync(queueableFn) {\n      var clearTimeout = function () {\n          Function.prototype.apply.apply(self.timeout.clearTimeout, [j$.getGlobal(), [timeoutId]]);\n        },\n        next = once(function () {\n          clearTimeout(timeoutId);\n          self.run(queueableFns, iterativeIndex + 1);\n        }),\n        timeoutId;\n\n      next.fail = function() {\n        self.fail.apply(null, arguments);\n        next();\n      };\n\n      if (queueableFn.timeout) {\n        timeoutId = Function.prototype.apply.apply(self.timeout.setTimeout, [j$.getGlobal(), [function() {\n          var error = new Error('Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL.');\n          onException(error, queueableFn);\n          next();\n        }, queueableFn.timeout()]]);\n      }\n\n      try {\n        queueableFn.fn.call(self.userContext, next);\n      } catch (e) {\n        handleException(e, queueableFn);\n        next();\n      }\n    }\n\n    function onException(e, queueableFn) {\n      self.onException(e);\n    }\n\n    function handleException(e, queueableFn) {\n      onException(e, queueableFn);\n      if (!self.catchException(e)) {\n        //TODO: set a var when we catch an exception and\n        //use a finally block to close the loop in a nice way..\n        throw e;\n      }\n    }\n  };\n\n  return QueueRunner;\n};\n\ngetJasmineRequireObj().ReportDispatcher = function() {\n  function ReportDispatcher(methods) {\n\n    var dispatchedMethods = methods || [];\n\n    for (var i = 0; i < dispatchedMethods.length; i++) {\n      var method = dispatchedMethods[i];\n      this[method] = (function(m) {\n        return function() {\n          dispatch(m, arguments);\n        };\n      }(method));\n    }\n\n    var reporters = [];\n\n    this.addReporter = function(reporter) {\n      reporters.push(reporter);\n    };\n\n    return this;\n\n    function dispatch(method, args) {\n      for (var i = 0; i < reporters.length; i++) {\n        var reporter = reporters[i];\n        if (reporter[method]) {\n          reporter[method].apply(reporter, args);\n        }\n      }\n    }\n  }\n\n  return ReportDispatcher;\n};\n\n\ngetJasmineRequireObj().SpyRegistry = function(j$) {\n\n  function SpyRegistry(options) {\n    options = options || {};\n    var currentSpies = options.currentSpies || function() { return []; };\n\n    this.spyOn = function(obj, methodName) {\n      if (j$.util.isUndefined(obj)) {\n        throw new Error('spyOn could not find an object to spy upon for ' + methodName + '()');\n      }\n\n      if (j$.util.isUndefined(methodName)) {\n        throw new Error('No method name supplied');\n      }\n\n      if (j$.util.isUndefined(obj[methodName])) {\n        throw new Error(methodName + '() method does not exist');\n      }\n\n      if (obj[methodName] && j$.isSpy(obj[methodName])) {\n        //TODO?: should this return the current spy? Downside: may cause user confusion about spy state\n        throw new Error(methodName + ' has already been spied upon');\n      }\n\n      var spy = j$.createSpy(methodName, obj[methodName]);\n\n      currentSpies().push({\n        spy: spy,\n        baseObj: obj,\n        methodName: methodName,\n        originalValue: obj[methodName]\n      });\n\n      obj[methodName] = spy;\n\n      return spy;\n    };\n\n    this.clearSpies = function() {\n      var spies = currentSpies();\n      for (var i = 0; i < spies.length; i++) {\n        var spyEntry = spies[i];\n        spyEntry.baseObj[spyEntry.methodName] = spyEntry.originalValue;\n      }\n    };\n  }\n\n  return SpyRegistry;\n};\n\ngetJasmineRequireObj().SpyStrategy = function() {\n\n  function SpyStrategy(options) {\n    options = options || {};\n\n    var identity = options.name || 'unknown',\n        originalFn = options.fn || function() {},\n        getSpy = options.getSpy || function() {},\n        plan = function() {};\n\n    this.identity = function() {\n      return identity;\n    };\n\n    this.exec = function() {\n      return plan.apply(this, arguments);\n    };\n\n    this.callThrough = function() {\n      plan = originalFn;\n      return getSpy();\n    };\n\n    this.returnValue = function(value) {\n      plan = function() {\n        return value;\n      };\n      return getSpy();\n    };\n\n    this.returnValues = function() {\n      var values = Array.prototype.slice.call(arguments);\n      plan = function () {\n        return values.shift();\n      };\n      return getSpy();\n    };\n\n    this.throwError = function(something) {\n      var error = (something instanceof Error) ? something : new Error(something);\n      plan = function() {\n        throw error;\n      };\n      return getSpy();\n    };\n\n    this.callFake = function(fn) {\n      plan = fn;\n      return getSpy();\n    };\n\n    this.stub = function(fn) {\n      plan = function() {};\n      return getSpy();\n    };\n  }\n\n  return SpyStrategy;\n};\n\ngetJasmineRequireObj().Suite = function(j$) {\n  function Suite(attrs) {\n    this.env = attrs.env;\n    this.id = attrs.id;\n    this.parentSuite = attrs.parentSuite;\n    this.description = attrs.description;\n    this.expectationFactory = attrs.expectationFactory;\n    this.expectationResultFactory = attrs.expectationResultFactory;\n    this.throwOnExpectationFailure = !!attrs.throwOnExpectationFailure;\n\n    this.beforeFns = [];\n    this.afterFns = [];\n    this.beforeAllFns = [];\n    this.afterAllFns = [];\n    this.disabled = false;\n\n    this.children = [];\n\n    this.result = {\n      id: this.id,\n      description: this.description,\n      fullName: this.getFullName(),\n      failedExpectations: []\n    };\n  }\n\n  Suite.prototype.expect = function(actual) {\n    return this.expectationFactory(actual, this);\n  };\n\n  Suite.prototype.getFullName = function() {\n    var fullName = this.description;\n    for (var parentSuite = this.parentSuite; parentSuite; parentSuite = parentSuite.parentSuite) {\n      if (parentSuite.parentSuite) {\n        fullName = parentSuite.description + ' ' + fullName;\n      }\n    }\n    return fullName;\n  };\n\n  Suite.prototype.disable = function() {\n    this.disabled = true;\n  };\n\n  Suite.prototype.beforeEach = function(fn) {\n    this.beforeFns.unshift(fn);\n  };\n\n  Suite.prototype.beforeAll = function(fn) {\n    this.beforeAllFns.push(fn);\n  };\n\n  Suite.prototype.afterEach = function(fn) {\n    this.afterFns.unshift(fn);\n  };\n\n  Suite.prototype.afterAll = function(fn) {\n    this.afterAllFns.push(fn);\n  };\n\n  Suite.prototype.addChild = function(child) {\n    this.children.push(child);\n  };\n\n  Suite.prototype.status = function() {\n    if (this.disabled) {\n      return 'disabled';\n    }\n\n    if (this.result.failedExpectations.length > 0) {\n      return 'failed';\n    } else {\n      return 'finished';\n    }\n  };\n\n  Suite.prototype.isExecutable = function() {\n    return !this.disabled;\n  };\n\n  Suite.prototype.canBeReentered = function() {\n    return this.beforeAllFns.length === 0 && this.afterAllFns.length === 0;\n  };\n\n  Suite.prototype.getResult = function() {\n    this.result.status = this.status();\n    return this.result;\n  };\n\n  Suite.prototype.sharedUserContext = function() {\n    if (!this.sharedContext) {\n      this.sharedContext = this.parentSuite ? clone(this.parentSuite.sharedUserContext()) : {};\n    }\n\n    return this.sharedContext;\n  };\n\n  Suite.prototype.clonedSharedUserContext = function() {\n    return clone(this.sharedUserContext());\n  };\n\n  Suite.prototype.onException = function() {\n    if (arguments[0] instanceof j$.errors.ExpectationFailed) {\n      return;\n    }\n\n    if(isAfterAll(this.children)) {\n      var data = {\n        matcherName: '',\n        passed: false,\n        expected: '',\n        actual: '',\n        error: arguments[0]\n      };\n      this.result.failedExpectations.push(this.expectationResultFactory(data));\n    } else {\n      for (var i = 0; i < this.children.length; i++) {\n        var child = this.children[i];\n        child.onException.apply(child, arguments);\n      }\n    }\n  };\n\n  Suite.prototype.addExpectationResult = function () {\n    if(isAfterAll(this.children) && isFailure(arguments)){\n      var data = arguments[1];\n      this.result.failedExpectations.push(this.expectationResultFactory(data));\n      if(this.throwOnExpectationFailure) {\n        throw new j$.errors.ExpectationFailed();\n      }\n    } else {\n      for (var i = 0; i < this.children.length; i++) {\n        var child = this.children[i];\n        try {\n          child.addExpectationResult.apply(child, arguments);\n        } catch(e) {\n          // keep going\n        }\n      }\n    }\n  };\n\n  function isAfterAll(children) {\n    return children && children[0].result.status;\n  }\n\n  function isFailure(args) {\n    return !args[0];\n  }\n\n  function clone(obj) {\n    var clonedObj = {};\n    for (var prop in obj) {\n      if (obj.hasOwnProperty(prop)) {\n        clonedObj[prop] = obj[prop];\n      }\n    }\n\n    return clonedObj;\n  }\n\n  return Suite;\n};\n\nif (typeof window == void 0 && typeof exports == 'object') {\n  exports.Suite = jasmineRequire.Suite;\n}\n\ngetJasmineRequireObj().Timer = function() {\n  var defaultNow = (function(Date) {\n    return function() { return new Date().getTime(); };\n  })(Date);\n\n  function Timer(options) {\n    options = options || {};\n\n    var now = options.now || defaultNow,\n      startTime;\n\n    this.start = function() {\n      startTime = now();\n    };\n\n    this.elapsed = function() {\n      return now() - startTime;\n    };\n  }\n\n  return Timer;\n};\n\ngetJasmineRequireObj().TreeProcessor = function() {\n  function TreeProcessor(attrs) {\n    var tree = attrs.tree,\n        runnableIds = attrs.runnableIds,\n        queueRunnerFactory = attrs.queueRunnerFactory,\n        nodeStart = attrs.nodeStart || function() {},\n        nodeComplete = attrs.nodeComplete || function() {},\n        stats = { valid: true },\n        processed = false,\n        defaultMin = Infinity,\n        defaultMax = 1 - Infinity;\n\n    this.processTree = function() {\n      processNode(tree, false);\n      processed = true;\n      return stats;\n    };\n\n    this.execute = function(done) {\n      if (!processed) {\n        this.processTree();\n      }\n\n      if (!stats.valid) {\n        throw 'invalid order';\n      }\n\n      var childFns = wrapChildren(tree, 0);\n\n      queueRunnerFactory({\n        queueableFns: childFns,\n        userContext: tree.sharedUserContext(),\n        onException: function() {\n          tree.onException.apply(tree, arguments);\n        },\n        onComplete: done\n      });\n    };\n\n    function runnableIndex(id) {\n      for (var i = 0; i < runnableIds.length; i++) {\n        if (runnableIds[i] === id) {\n          return i;\n        }\n      }\n    }\n\n    function processNode(node, parentEnabled) {\n      var executableIndex = runnableIndex(node.id);\n\n      if (executableIndex !== undefined) {\n        parentEnabled = true;\n      }\n\n      parentEnabled = parentEnabled && node.isExecutable();\n\n      if (!node.children) {\n        stats[node.id] = {\n          executable: parentEnabled && node.isExecutable(),\n          segments: [{\n            index: 0,\n            owner: node,\n            nodes: [node],\n            min: startingMin(executableIndex),\n            max: startingMax(executableIndex)\n          }]\n        };\n      } else {\n        var hasExecutableChild = false;\n\n        for (var i = 0; i < node.children.length; i++) {\n          var child = node.children[i];\n\n          processNode(child, parentEnabled);\n\n          if (!stats.valid) {\n            return;\n          }\n\n          var childStats = stats[child.id];\n\n          hasExecutableChild = hasExecutableChild || childStats.executable;\n        }\n\n        stats[node.id] = {\n          executable: hasExecutableChild\n        };\n\n        segmentChildren(node, stats[node.id], executableIndex);\n\n        if (!node.canBeReentered() && stats[node.id].segments.length > 1) {\n          stats = { valid: false };\n        }\n      }\n    }\n\n    function startingMin(executableIndex) {\n      return executableIndex === undefined ? defaultMin : executableIndex;\n    }\n\n    function startingMax(executableIndex) {\n      return executableIndex === undefined ? defaultMax : executableIndex;\n    }\n\n    function segmentChildren(node, nodeStats, executableIndex) {\n      var currentSegment = { index: 0, owner: node, nodes: [], min: startingMin(executableIndex), max: startingMax(executableIndex) },\n          result = [currentSegment],\n          lastMax = defaultMax,\n          orderedChildSegments = orderChildSegments(node.children);\n\n      function isSegmentBoundary(minIndex) {\n        return lastMax !== defaultMax && minIndex !== defaultMin && lastMax < minIndex - 1;\n      }\n\n      for (var i = 0; i < orderedChildSegments.length; i++) {\n        var childSegment = orderedChildSegments[i],\n          maxIndex = childSegment.max,\n          minIndex = childSegment.min;\n\n        if (isSegmentBoundary(minIndex)) {\n          currentSegment = {index: result.length, owner: node, nodes: [], min: defaultMin, max: defaultMax};\n          result.push(currentSegment);\n        }\n\n        currentSegment.nodes.push(childSegment);\n        currentSegment.min = Math.min(currentSegment.min, minIndex);\n        currentSegment.max = Math.max(currentSegment.max, maxIndex);\n        lastMax = maxIndex;\n      }\n\n      nodeStats.segments = result;\n    }\n\n    function orderChildSegments(children) {\n      var specifiedOrder = [],\n          unspecifiedOrder = [];\n\n      for (var i = 0; i < children.length; i++) {\n        var child = children[i],\n            segments = stats[child.id].segments;\n\n        for (var j = 0; j < segments.length; j++) {\n          var seg = segments[j];\n\n          if (seg.min === defaultMin) {\n            unspecifiedOrder.push(seg);\n          } else {\n            specifiedOrder.push(seg);\n          }\n        }\n      }\n\n      specifiedOrder.sort(function(a, b) {\n        return a.min - b.min;\n      });\n\n      return specifiedOrder.concat(unspecifiedOrder);\n    }\n\n    function executeNode(node, segmentNumber) {\n      if (node.children) {\n        return {\n          fn: function(done) {\n            nodeStart(node);\n\n            queueRunnerFactory({\n              onComplete: function() {\n                nodeComplete(node, node.getResult());\n                done();\n              },\n              queueableFns: wrapChildren(node, segmentNumber),\n              userContext: node.sharedUserContext(),\n              onException: function() {\n                node.onException.apply(node, arguments);\n              }\n            });\n          }\n        };\n      } else {\n        return {\n          fn: function(done) { node.execute(done, stats[node.id].executable); }\n        };\n      }\n    }\n\n    function wrapChildren(node, segmentNumber) {\n      var result = [],\n          segmentChildren = stats[node.id].segments[segmentNumber].nodes;\n\n      for (var i = 0; i < segmentChildren.length; i++) {\n        result.push(executeNode(segmentChildren[i].owner, segmentChildren[i].index));\n      }\n\n      if (!stats[node.id].executable) {\n        return result;\n      }\n\n      return node.beforeAllFns.concat(result).concat(node.afterAllFns);\n    }\n  }\n\n  return TreeProcessor;\n};\n\ngetJasmineRequireObj().Any = function(j$) {\n\n  function Any(expectedObject) {\n    this.expectedObject = expectedObject;\n  }\n\n  Any.prototype.asymmetricMatch = function(other) {\n    if (this.expectedObject == String) {\n      return typeof other == 'string' || other instanceof String;\n    }\n\n    if (this.expectedObject == Number) {\n      return typeof other == 'number' || other instanceof Number;\n    }\n\n    if (this.expectedObject == Function) {\n      return typeof other == 'function' || other instanceof Function;\n    }\n\n    if (this.expectedObject == Object) {\n      return typeof other == 'object';\n    }\n\n    if (this.expectedObject == Boolean) {\n      return typeof other == 'boolean';\n    }\n\n    return other instanceof this.expectedObject;\n  };\n\n  Any.prototype.jasmineToString = function() {\n    return '<jasmine.any(' + j$.fnNameFor(this.expectedObject) + ')>';\n  };\n\n  return Any;\n};\n\ngetJasmineRequireObj().Anything = function(j$) {\n\n  function Anything() {}\n\n  Anything.prototype.asymmetricMatch = function(other) {\n    return !j$.util.isUndefined(other) && other !== null;\n  };\n\n  Anything.prototype.jasmineToString = function() {\n    return '<jasmine.anything>';\n  };\n\n  return Anything;\n};\n\ngetJasmineRequireObj().ArrayContaining = function(j$) {\n  function ArrayContaining(sample) {\n    this.sample = sample;\n  }\n\n  ArrayContaining.prototype.asymmetricMatch = function(other) {\n    var className = Object.prototype.toString.call(this.sample);\n    if (className !== '[object Array]') { throw new Error('You must provide an array to arrayContaining, not \\'' + this.sample + '\\'.'); }\n\n    for (var i = 0; i < this.sample.length; i++) {\n      var item = this.sample[i];\n      if (!j$.matchersUtil.contains(other, item)) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  ArrayContaining.prototype.jasmineToString = function () {\n    return '<jasmine.arrayContaining(' + jasmine.pp(this.sample) +')>';\n  };\n\n  return ArrayContaining;\n};\n\ngetJasmineRequireObj().ObjectContaining = function(j$) {\n\n  function ObjectContaining(sample) {\n    this.sample = sample;\n  }\n\n  function getPrototype(obj) {\n    if (Object.getPrototypeOf) {\n      return Object.getPrototypeOf(obj);\n    }\n\n    if (obj.constructor.prototype == obj) {\n      return null;\n    }\n\n    return obj.constructor.prototype;\n  }\n\n  function hasProperty(obj, property) {\n    if (!obj) {\n      return false;\n    }\n\n    if (Object.prototype.hasOwnProperty.call(obj, property)) {\n      return true;\n    }\n\n    return hasProperty(getPrototype(obj), property);\n  }\n\n  ObjectContaining.prototype.asymmetricMatch = function(other) {\n    if (typeof(this.sample) !== 'object') { throw new Error('You must provide an object to objectContaining, not \\''+this.sample+'\\'.'); }\n\n    for (var property in this.sample) {\n      if (!hasProperty(other, property) ||\n          !j$.matchersUtil.equals(this.sample[property], other[property])) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  ObjectContaining.prototype.jasmineToString = function() {\n    return '<jasmine.objectContaining(' + j$.pp(this.sample) + ')>';\n  };\n\n  return ObjectContaining;\n};\n\ngetJasmineRequireObj().StringMatching = function(j$) {\n\n  function StringMatching(expected) {\n    if (!j$.isString_(expected) && !j$.isA_('RegExp', expected)) {\n      throw new Error('Expected is not a String or a RegExp');\n    }\n\n    this.regexp = new RegExp(expected);\n  }\n\n  StringMatching.prototype.asymmetricMatch = function(other) {\n    return this.regexp.test(other);\n  };\n\n  StringMatching.prototype.jasmineToString = function() {\n    return '<jasmine.stringMatching(' + this.regexp + ')>';\n  };\n\n  return StringMatching;\n};\n\ngetJasmineRequireObj().errors = function() {\n  function ExpectationFailed() {}\n\n  ExpectationFailed.prototype = new Error();\n  ExpectationFailed.prototype.constructor = ExpectationFailed;\n\n  return {\n    ExpectationFailed: ExpectationFailed\n  };\n};\ngetJasmineRequireObj().matchersUtil = function(j$) {\n  // TODO: what to do about jasmine.pp not being inject? move to JSON.stringify? gut PrettyPrinter?\n\n  return {\n    equals: function(a, b, customTesters) {\n      customTesters = customTesters || [];\n\n      return eq(a, b, [], [], customTesters);\n    },\n\n    contains: function(haystack, needle, customTesters) {\n      customTesters = customTesters || [];\n\n      if ((Object.prototype.toString.apply(haystack) === '[object Array]') ||\n        (!!haystack && !haystack.indexOf))\n      {\n        for (var i = 0; i < haystack.length; i++) {\n          if (eq(haystack[i], needle, [], [], customTesters)) {\n            return true;\n          }\n        }\n        return false;\n      }\n\n      return !!haystack && haystack.indexOf(needle) >= 0;\n    },\n\n    buildFailureMessage: function() {\n      var args = Array.prototype.slice.call(arguments, 0),\n        matcherName = args[0],\n        isNot = args[1],\n        actual = args[2],\n        expected = args.slice(3),\n        englishyPredicate = matcherName.replace(/[A-Z]/g, function(s) { return ' ' + s.toLowerCase(); });\n\n      var message = 'Expected ' +\n        j$.pp(actual) +\n        (isNot ? ' not ' : ' ') +\n        englishyPredicate;\n\n      if (expected.length > 0) {\n        for (var i = 0; i < expected.length; i++) {\n          if (i > 0) {\n            message += ',';\n          }\n          message += ' ' + j$.pp(expected[i]);\n        }\n      }\n\n      return message + '.';\n    }\n  };\n\n  function isAsymmetric(obj) {\n    return obj && j$.isA_('Function', obj.asymmetricMatch);\n  }\n\n  function asymmetricMatch(a, b) {\n    var asymmetricA = isAsymmetric(a),\n        asymmetricB = isAsymmetric(b);\n\n    if (asymmetricA && asymmetricB) {\n      return undefined;\n    }\n\n    if (asymmetricA) {\n      return a.asymmetricMatch(b);\n    }\n\n    if (asymmetricB) {\n      return b.asymmetricMatch(a);\n    }\n  }\n\n  // Equality function lovingly adapted from isEqual in\n  //   [Underscore](http://underscorejs.org)\n  function eq(a, b, aStack, bStack, customTesters) {\n    var result = true;\n\n    var asymmetricResult = asymmetricMatch(a, b);\n    if (!j$.util.isUndefined(asymmetricResult)) {\n      return asymmetricResult;\n    }\n\n    for (var i = 0; i < customTesters.length; i++) {\n      var customTesterResult = customTesters[i](a, b);\n      if (!j$.util.isUndefined(customTesterResult)) {\n        return customTesterResult;\n      }\n    }\n\n    if (a instanceof Error && b instanceof Error) {\n      return a.message == b.message;\n    }\n\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\n    if (a === b) { return a !== 0 || 1 / a == 1 / b; }\n    // A strict comparison is necessary because `null == undefined`.\n    if (a === null || b === null) { return a === b; }\n    var className = Object.prototype.toString.call(a);\n    if (className != Object.prototype.toString.call(b)) { return false; }\n    switch (className) {\n      // Strings, numbers, dates, and booleans are compared by value.\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return a == String(b);\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\n        // other numeric values.\n        return a != +a ? b != +b : (a === 0 ? 1 / a == 1 / b : a == +b);\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a == +b;\n      // RegExps are compared by their source patterns and flags.\n      case '[object RegExp]':\n        return a.source == b.source &&\n          a.global == b.global &&\n          a.multiline == b.multiline &&\n          a.ignoreCase == b.ignoreCase;\n    }\n    if (typeof a != 'object' || typeof b != 'object') { return false; }\n\n    var aIsDomNode = j$.isDomNode(a);\n    var bIsDomNode = j$.isDomNode(b);\n    if (aIsDomNode && bIsDomNode) {\n      // At first try to use DOM3 method isEqualNode\n      if (a.isEqualNode) {\n        return a.isEqualNode(b);\n      }\n      // IE8 doesn't support isEqualNode, try to use outerHTML && innerText\n      var aIsElement = a instanceof Element;\n      var bIsElement = b instanceof Element;\n      if (aIsElement && bIsElement) {\n        return a.outerHTML == b.outerHTML;\n      }\n      if (aIsElement || bIsElement) {\n        return false;\n      }\n      return a.innerText == b.innerText && a.textContent == b.textContent;\n    }\n    if (aIsDomNode || bIsDomNode) {\n      return false;\n    }\n\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n    var length = aStack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (aStack[length] == a) { return bStack[length] == b; }\n    }\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n    var size = 0;\n    // Recursively compare objects and arrays.\n    // Compare array lengths to determine if a deep comparison is necessary.\n    if (className == '[object Array]' && a.length !== b.length) {\n      result = false;\n    }\n\n    if (result) {\n      // Objects with different constructors are not equivalent, but `Object`s\n      // or `Array`s from different frames are.\n      if (className !== '[object Array]') {\n        var aCtor = a.constructor, bCtor = b.constructor;\n        if (aCtor !== bCtor && !(isFunction(aCtor) && aCtor instanceof aCtor &&\n               isFunction(bCtor) && bCtor instanceof bCtor)) {\n          return false;\n        }\n      }\n      // Deep compare objects.\n      for (var key in a) {\n        if (has(a, key)) {\n          // Count the expected number of properties.\n          size++;\n          // Deep compare each member.\n          if (!(result = has(b, key) && eq(a[key], b[key], aStack, bStack, customTesters))) { break; }\n        }\n      }\n      // Ensure that both objects contain the same number of properties.\n      if (result) {\n        for (key in b) {\n          if (has(b, key) && !(size--)) { break; }\n        }\n        result = !size;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n\n    return result;\n\n    function has(obj, key) {\n      return Object.prototype.hasOwnProperty.call(obj, key);\n    }\n\n    function isFunction(obj) {\n      return typeof obj === 'function';\n    }\n  }\n};\n\ngetJasmineRequireObj().toBe = function() {\n  function toBe() {\n    return {\n      compare: function(actual, expected) {\n        return {\n          pass: actual === expected\n        };\n      }\n    };\n  }\n\n  return toBe;\n};\n\ngetJasmineRequireObj().toBeCloseTo = function() {\n\n  function toBeCloseTo() {\n    return {\n      compare: function(actual, expected, precision) {\n        if (precision !== 0) {\n          precision = precision || 2;\n        }\n\n        return {\n          pass: Math.abs(expected - actual) < (Math.pow(10, -precision) / 2)\n        };\n      }\n    };\n  }\n\n  return toBeCloseTo;\n};\n\ngetJasmineRequireObj().toBeDefined = function() {\n  function toBeDefined() {\n    return {\n      compare: function(actual) {\n        return {\n          pass: (void 0 !== actual)\n        };\n      }\n    };\n  }\n\n  return toBeDefined;\n};\n\ngetJasmineRequireObj().toBeFalsy = function() {\n  function toBeFalsy() {\n    return {\n      compare: function(actual) {\n        return {\n          pass: !!!actual\n        };\n      }\n    };\n  }\n\n  return toBeFalsy;\n};\n\ngetJasmineRequireObj().toBeGreaterThan = function() {\n\n  function toBeGreaterThan() {\n    return {\n      compare: function(actual, expected) {\n        return {\n          pass: actual > expected\n        };\n      }\n    };\n  }\n\n  return toBeGreaterThan;\n};\n\n\ngetJasmineRequireObj().toBeLessThan = function() {\n  function toBeLessThan() {\n    return {\n\n      compare: function(actual, expected) {\n        return {\n          pass: actual < expected\n        };\n      }\n    };\n  }\n\n  return toBeLessThan;\n};\ngetJasmineRequireObj().toBeNaN = function(j$) {\n\n  function toBeNaN() {\n    return {\n      compare: function(actual) {\n        var result = {\n          pass: (actual !== actual)\n        };\n\n        if (result.pass) {\n          result.message = 'Expected actual not to be NaN.';\n        } else {\n          result.message = function() { return 'Expected ' + j$.pp(actual) + ' to be NaN.'; };\n        }\n\n        return result;\n      }\n    };\n  }\n\n  return toBeNaN;\n};\n\ngetJasmineRequireObj().toBeNull = function() {\n\n  function toBeNull() {\n    return {\n      compare: function(actual) {\n        return {\n          pass: actual === null\n        };\n      }\n    };\n  }\n\n  return toBeNull;\n};\n\ngetJasmineRequireObj().toBeTruthy = function() {\n\n  function toBeTruthy() {\n    return {\n      compare: function(actual) {\n        return {\n          pass: !!actual\n        };\n      }\n    };\n  }\n\n  return toBeTruthy;\n};\n\ngetJasmineRequireObj().toBeUndefined = function() {\n\n  function toBeUndefined() {\n    return {\n      compare: function(actual) {\n        return {\n          pass: void 0 === actual\n        };\n      }\n    };\n  }\n\n  return toBeUndefined;\n};\n\ngetJasmineRequireObj().toContain = function() {\n  function toContain(util, customEqualityTesters) {\n    customEqualityTesters = customEqualityTesters || [];\n\n    return {\n      compare: function(actual, expected) {\n\n        return {\n          pass: util.contains(actual, expected, customEqualityTesters)\n        };\n      }\n    };\n  }\n\n  return toContain;\n};\n\ngetJasmineRequireObj().toEqual = function() {\n\n  function toEqual(util, customEqualityTesters) {\n    customEqualityTesters = customEqualityTesters || [];\n\n    return {\n      compare: function(actual, expected) {\n        var result = {\n          pass: false\n        };\n\n        result.pass = util.equals(actual, expected, customEqualityTesters);\n\n        return result;\n      }\n    };\n  }\n\n  return toEqual;\n};\n\ngetJasmineRequireObj().toHaveBeenCalled = function(j$) {\n\n  function toHaveBeenCalled() {\n    return {\n      compare: function(actual) {\n        var result = {};\n\n        if (!j$.isSpy(actual)) {\n          throw new Error('Expected a spy, but got ' + j$.pp(actual) + '.');\n        }\n\n        if (arguments.length > 1) {\n          throw new Error('toHaveBeenCalled does not take arguments, use toHaveBeenCalledWith');\n        }\n\n        result.pass = actual.calls.any();\n\n        result.message = result.pass ?\n          'Expected spy ' + actual.and.identity() + ' not to have been called.' :\n          'Expected spy ' + actual.and.identity() + ' to have been called.';\n\n        return result;\n      }\n    };\n  }\n\n  return toHaveBeenCalled;\n};\n\ngetJasmineRequireObj().toHaveBeenCalledWith = function(j$) {\n\n  function toHaveBeenCalledWith(util, customEqualityTesters) {\n    return {\n      compare: function() {\n        var args = Array.prototype.slice.call(arguments, 0),\n          actual = args[0],\n          expectedArgs = args.slice(1),\n          result = { pass: false };\n\n        if (!j$.isSpy(actual)) {\n          throw new Error('Expected a spy, but got ' + j$.pp(actual) + '.');\n        }\n\n        if (!actual.calls.any()) {\n          result.message = function() { return 'Expected spy ' + actual.and.identity() + ' to have been called with ' + j$.pp(expectedArgs) + ' but it was never called.'; };\n          return result;\n        }\n\n        if (util.contains(actual.calls.allArgs(), expectedArgs, customEqualityTesters)) {\n          result.pass = true;\n          result.message = function() { return 'Expected spy ' + actual.and.identity() + ' not to have been called with ' + j$.pp(expectedArgs) + ' but it was.'; };\n        } else {\n          result.message = function() { return 'Expected spy ' + actual.and.identity() + ' to have been called with ' + j$.pp(expectedArgs) + ' but actual calls were ' + j$.pp(actual.calls.allArgs()).replace(/^\\[ | \\]$/g, '') + '.'; };\n        }\n\n        return result;\n      }\n    };\n  }\n\n  return toHaveBeenCalledWith;\n};\n\ngetJasmineRequireObj().toMatch = function(j$) {\n\n  function toMatch() {\n    return {\n      compare: function(actual, expected) {\n        if (!j$.isString_(expected) && !j$.isA_('RegExp', expected)) {\n          throw new Error('Expected is not a String or a RegExp');\n        }\n\n        var regexp = new RegExp(expected);\n\n        return {\n          pass: regexp.test(actual)\n        };\n      }\n    };\n  }\n\n  return toMatch;\n};\n\ngetJasmineRequireObj().toThrow = function(j$) {\n\n  function toThrow(util) {\n    return {\n      compare: function(actual, expected) {\n        var result = { pass: false },\n          threw = false,\n          thrown;\n\n        if (typeof actual != 'function') {\n          throw new Error('Actual is not a Function');\n        }\n\n        try {\n          actual();\n        } catch (e) {\n          threw = true;\n          thrown = e;\n        }\n\n        if (!threw) {\n          result.message = 'Expected function to throw an exception.';\n          return result;\n        }\n\n        if (arguments.length == 1) {\n          result.pass = true;\n          result.message = function() { return 'Expected function not to throw, but it threw ' + j$.pp(thrown) + '.'; };\n\n          return result;\n        }\n\n        if (util.equals(thrown, expected)) {\n          result.pass = true;\n          result.message = function() { return 'Expected function not to throw ' + j$.pp(expected) + '.'; };\n        } else {\n          result.message = function() { return 'Expected function to throw ' + j$.pp(expected) + ', but it threw ' +  j$.pp(thrown) + '.'; };\n        }\n\n        return result;\n      }\n    };\n  }\n\n  return toThrow;\n};\n\ngetJasmineRequireObj().toThrowError = function(j$) {\n  function toThrowError (util) {\n    return {\n      compare: function(actual) {\n        var threw = false,\n          pass = {pass: true},\n          fail = {pass: false},\n          thrown;\n\n        if (typeof actual != 'function') {\n          throw new Error('Actual is not a Function');\n        }\n\n        var errorMatcher = getMatcher.apply(null, arguments);\n\n        try {\n          actual();\n        } catch (e) {\n          threw = true;\n          thrown = e;\n        }\n\n        if (!threw) {\n          fail.message = 'Expected function to throw an Error.';\n          return fail;\n        }\n\n        if (!(thrown instanceof Error)) {\n          fail.message = function() { return 'Expected function to throw an Error, but it threw ' + j$.pp(thrown) + '.'; };\n          return fail;\n        }\n\n        if (errorMatcher.hasNoSpecifics()) {\n          pass.message = 'Expected function not to throw an Error, but it threw ' + j$.fnNameFor(thrown) + '.';\n          return pass;\n        }\n\n        if (errorMatcher.matches(thrown)) {\n          pass.message = function() {\n            return 'Expected function not to throw ' + errorMatcher.errorTypeDescription + errorMatcher.messageDescription() + '.';\n          };\n          return pass;\n        } else {\n          fail.message = function() {\n            return 'Expected function to throw ' + errorMatcher.errorTypeDescription + errorMatcher.messageDescription() +\n              ', but it threw ' + errorMatcher.thrownDescription(thrown) + '.';\n          };\n          return fail;\n        }\n      }\n    };\n\n    function getMatcher() {\n      var expected = null,\n          errorType = null;\n\n      if (arguments.length == 2) {\n        expected = arguments[1];\n        if (isAnErrorType(expected)) {\n          errorType = expected;\n          expected = null;\n        }\n      } else if (arguments.length > 2) {\n        errorType = arguments[1];\n        expected = arguments[2];\n        if (!isAnErrorType(errorType)) {\n          throw new Error('Expected error type is not an Error.');\n        }\n      }\n\n      if (expected && !isStringOrRegExp(expected)) {\n        if (errorType) {\n          throw new Error('Expected error message is not a string or RegExp.');\n        } else {\n          throw new Error('Expected is not an Error, string, or RegExp.');\n        }\n      }\n\n      function messageMatch(message) {\n        if (typeof expected == 'string') {\n          return expected == message;\n        } else {\n          return expected.test(message);\n        }\n      }\n\n      return {\n        errorTypeDescription: errorType ? j$.fnNameFor(errorType) : 'an exception',\n        thrownDescription: function(thrown) {\n          var thrownName = errorType ? j$.fnNameFor(thrown.constructor) : 'an exception',\n              thrownMessage = '';\n\n          if (expected) {\n            thrownMessage = ' with message ' + j$.pp(thrown.message);\n          }\n\n          return thrownName + thrownMessage;\n        },\n        messageDescription: function() {\n          if (expected === null) {\n            return '';\n          } else if (expected instanceof RegExp) {\n            return ' with a message matching ' + j$.pp(expected);\n          } else {\n            return ' with message ' + j$.pp(expected);\n          }\n        },\n        hasNoSpecifics: function() {\n          return expected === null && errorType === null;\n        },\n        matches: function(error) {\n          return (errorType === null || error instanceof errorType) &&\n            (expected === null || messageMatch(error.message));\n        }\n      };\n    }\n\n    function isStringOrRegExp(potential) {\n      return potential instanceof RegExp || (typeof potential == 'string');\n    }\n\n    function isAnErrorType(type) {\n      if (typeof type !== 'function') {\n        return false;\n      }\n\n      var Surrogate = function() {};\n      Surrogate.prototype = type.prototype;\n      return (new Surrogate()) instanceof Error;\n    }\n  }\n\n  return toThrowError;\n};\n\ngetJasmineRequireObj().interface = function(jasmine, env) {\n  var jasmineInterface = {\n    describe: function(description, specDefinitions) {\n      return env.describe(description, specDefinitions);\n    },\n\n    xdescribe: function(description, specDefinitions) {\n      return env.xdescribe(description, specDefinitions);\n    },\n\n    fdescribe: function(description, specDefinitions) {\n      return env.fdescribe(description, specDefinitions);\n    },\n\n    it: function() {\n      return env.it.apply(env, arguments);\n    },\n\n    xit: function() {\n      return env.xit.apply(env, arguments);\n    },\n\n    fit: function() {\n      return env.fit.apply(env, arguments);\n    },\n\n    beforeEach: function() {\n      return env.beforeEach.apply(env, arguments);\n    },\n\n    afterEach: function() {\n      return env.afterEach.apply(env, arguments);\n    },\n\n    beforeAll: function() {\n      return env.beforeAll.apply(env, arguments);\n    },\n\n    afterAll: function() {\n      return env.afterAll.apply(env, arguments);\n    },\n\n    expect: function(actual) {\n      return env.expect(actual);\n    },\n\n    pending: function() {\n      return env.pending.apply(env, arguments);\n    },\n\n    fail: function() {\n      return env.fail.apply(env, arguments);\n    },\n\n    spyOn: function(obj, methodName) {\n      return env.spyOn(obj, methodName);\n    },\n\n    jsApiReporter: new jasmine.JsApiReporter({\n      timer: new jasmine.Timer()\n    }),\n\n    jasmine: jasmine\n  };\n\n  jasmine.addCustomEqualityTester = function(tester) {\n    env.addCustomEqualityTester(tester);\n  };\n\n  jasmine.addMatchers = function(matchers) {\n    return env.addMatchers(matchers);\n  };\n\n  jasmine.clock = function() {\n    return env.clock;\n  };\n\n  return jasmineInterface;\n};\n\ngetJasmineRequireObj().version = function() {\n  return '2.3.4';\n};\n";

/***/ },
/* 8 */
/***/ function(module, exports) {

	"use strict";
	
	module.exports = "/*\nCopyright (c) 2008-2015 Pivotal Labs\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\njasmineRequire.html = function(j$) {\n  j$.ResultsNode = jasmineRequire.ResultsNode();\n  j$.HtmlReporter = jasmineRequire.HtmlReporter(j$);\n  j$.QueryString = jasmineRequire.QueryString();\n  j$.HtmlSpecFilter = jasmineRequire.HtmlSpecFilter();\n};\n\njasmineRequire.HtmlReporter = function(j$) {\n\n  var noopTimer = {\n    start: function() {},\n    elapsed: function() { return 0; }\n  };\n\n  function HtmlReporter(options) {\n    var env = options.env || {},\n      getContainer = options.getContainer,\n      createElement = options.createElement,\n      createTextNode = options.createTextNode,\n      onRaiseExceptionsClick = options.onRaiseExceptionsClick || function() {},\n      onThrowExpectationsClick = options.onThrowExpectationsClick || function() {},\n      addToExistingQueryString = options.addToExistingQueryString || defaultQueryString,\n      timer = options.timer || noopTimer,\n      results = [],\n      specsExecuted = 0,\n      failureCount = 0,\n      pendingSpecCount = 0,\n      htmlReporterMain,\n      symbols,\n      failedSuites = [];\n\n    this.initialize = function() {\n      clearPrior();\n      htmlReporterMain = createDom('div', {className: 'jasmine_html-reporter'},\n        createDom('div', {className: 'banner'},\n          createDom('a', {className: 'title', href: 'http://jasmine.github.io/', target: '_blank'}),\n          createDom('span', {className: 'version'}, j$.version)\n        ),\n        createDom('ul', {className: 'symbol-summary'}),\n        createDom('div', {className: 'alert'}),\n        createDom('div', {className: 'results'},\n          createDom('div', {className: 'failures'})\n        )\n      );\n      getContainer().appendChild(htmlReporterMain);\n\n      symbols = find('.symbol-summary');\n    };\n\n    var totalSpecsDefined;\n    this.jasmineStarted = function(options) {\n      totalSpecsDefined = options.totalSpecsDefined || 0;\n      timer.start();\n    };\n\n    var summary = createDom('div', {className: 'summary'});\n\n    var topResults = new j$.ResultsNode({}, '', null),\n      currentParent = topResults;\n\n    this.suiteStarted = function(result) {\n      currentParent.addChild(result, 'suite');\n      currentParent = currentParent.last();\n    };\n\n    this.suiteDone = function(result) {\n      if (result.status == 'failed') {\n        failedSuites.push(result);\n      }\n\n      if (currentParent == topResults) {\n        return;\n      }\n\n      currentParent = currentParent.parent;\n    };\n\n    this.specStarted = function(result) {\n      currentParent.addChild(result, 'spec');\n    };\n\n    var failures = [];\n    this.specDone = function(result) {\n      if(noExpectations(result) && typeof console !== 'undefined' && typeof console.error !== 'undefined') {\n        console.error('Spec \\'' + result.fullName + '\\' has no expectations.');\n      }\n\n      if (result.status != 'disabled') {\n        specsExecuted++;\n      }\n\n      symbols.appendChild(createDom('li', {\n          className: noExpectations(result) ? 'empty' : result.status,\n          id: 'spec_' + result.id,\n          title: result.fullName\n        }\n      ));\n\n      if (result.status == 'failed') {\n        failureCount++;\n\n        var failure =\n          createDom('div', {className: 'spec-detail failed'},\n            createDom('div', {className: 'description'},\n              createDom('a', {title: result.fullName, href: specHref(result)}, result.fullName)\n            ),\n            createDom('div', {className: 'messages'})\n          );\n        var messages = failure.childNodes[1];\n\n        for (var i = 0; i < result.failedExpectations.length; i++) {\n          var expectation = result.failedExpectations[i];\n          messages.appendChild(createDom('div', {className: 'result-message'}, expectation.message));\n          messages.appendChild(createDom('div', {className: 'stack-trace'}, expectation.stack));\n        }\n\n        failures.push(failure);\n      }\n\n      if (result.status == 'pending') {\n        pendingSpecCount++;\n      }\n    };\n\n    this.jasmineDone = function() {\n      var banner = find('.banner');\n      var alert = find('.alert');\n      alert.appendChild(createDom('span', {className: 'duration'}, 'finished in ' + timer.elapsed() / 1000 + 's'));\n\n      banner.appendChild(\n        createDom('div', { className: 'run-options' },\n          createDom('span', { className: 'trigger' }, 'Options'),\n          createDom('div', { className: 'payload' },\n            createDom('div', { className: 'exceptions' },\n              createDom('input', {\n                className: 'raise',\n                id: 'raise-exceptions',\n                type: 'checkbox'\n              }),\n              createDom('label', { className: 'label', 'for': 'raise-exceptions' }, 'raise exceptions')),\n            createDom('div', { className: 'throw-failures' },\n              createDom('input', {\n                className: 'throw',\n                id: 'throw-failures',\n                type: 'checkbox'\n              }),\n              createDom('label', { className: 'label', 'for': 'throw-failures' }, 'stop spec on expectation failure'))\n          )\n        ));\n\n      var raiseCheckbox = find('#raise-exceptions');\n\n      raiseCheckbox.checked = !env.catchingExceptions();\n      raiseCheckbox.onclick = onRaiseExceptionsClick;\n\n      var throwCheckbox = find('#throw-failures');\n      throwCheckbox.checked = env.throwingExpectationFailures();\n      throwCheckbox.onclick = onThrowExpectationsClick;\n\n      var optionsMenu = find('.run-options'),\n          optionsTrigger = optionsMenu.querySelector('.trigger'),\n          optionsPayload = optionsMenu.querySelector('.payload'),\n          isOpen = /\\bopen\\b/;\n\n      optionsTrigger.onclick = function() {\n        if (isOpen.test(optionsPayload.className)) {\n          optionsPayload.className = optionsPayload.className.replace(isOpen, '');\n        } else {\n          optionsPayload.className += ' open';\n        }\n      };\n\n      if (specsExecuted < totalSpecsDefined) {\n        var skippedMessage = 'Ran ' + specsExecuted + ' of ' + totalSpecsDefined + ' specs - run all';\n        alert.appendChild(\n          createDom('span', {className: 'bar skipped'},\n            createDom('a', {href: '?', title: 'Run all specs'}, skippedMessage)\n          )\n        );\n      }\n      var statusBarMessage = '';\n      var statusBarClassName = 'bar ';\n\n      if (totalSpecsDefined > 0) {\n        statusBarMessage += pluralize('spec', specsExecuted) + ', ' + pluralize('failure', failureCount);\n        if (pendingSpecCount) { statusBarMessage += ', ' + pluralize('pending spec', pendingSpecCount); }\n        statusBarClassName += (failureCount > 0) ? 'failed' : 'passed';\n      } else {\n        statusBarClassName += 'skipped';\n        statusBarMessage += 'No specs found';\n      }\n\n      alert.appendChild(createDom('span', {className: statusBarClassName}, statusBarMessage));\n\n      for(i = 0; i < failedSuites.length; i++) {\n        var failedSuite = failedSuites[i];\n        for(var j = 0; j < failedSuite.failedExpectations.length; j++) {\n          var errorBarMessage = 'AfterAll ' + failedSuite.failedExpectations[j].message;\n          var errorBarClassName = 'bar errored';\n          alert.appendChild(createDom('span', {className: errorBarClassName}, errorBarMessage));\n        }\n      }\n\n      var results = find('.results');\n      results.appendChild(summary);\n\n      summaryList(topResults, summary);\n\n      function summaryList(resultsTree, domParent) {\n        var specListNode;\n        for (var i = 0; i < resultsTree.children.length; i++) {\n          var resultNode = resultsTree.children[i];\n          if (resultNode.type == 'suite') {\n            var suiteListNode = createDom('ul', {className: 'suite', id: 'suite-' + resultNode.result.id},\n              createDom('li', {className: 'suite-detail'},\n                createDom('a', {href: specHref(resultNode.result)}, resultNode.result.description)\n              )\n            );\n\n            summaryList(resultNode, suiteListNode);\n            domParent.appendChild(suiteListNode);\n          }\n          if (resultNode.type == 'spec') {\n            if (domParent.getAttribute('class') != 'specs') {\n              specListNode = createDom('ul', {className: 'specs'});\n              domParent.appendChild(specListNode);\n            }\n            var specDescription = resultNode.result.description;\n            if(noExpectations(resultNode.result)) {\n              specDescription = 'SPEC HAS NO EXPECTATIONS ' + specDescription;\n            }\n            if(resultNode.result.status === 'pending' && resultNode.result.pendingReason !== '') {\n              specDescription = specDescription + ' PENDING WITH MESSAGE: ' + resultNode.result.pendingReason;\n            }\n            specListNode.appendChild(\n              createDom('li', {\n                  className: resultNode.result.status,\n                  id: 'spec-' + resultNode.result.id\n                },\n                createDom('a', {href: specHref(resultNode.result)}, specDescription)\n              )\n            );\n          }\n        }\n      }\n\n      if (failures.length) {\n        alert.appendChild(\n          createDom('span', {className: 'menu bar spec-list'},\n            createDom('span', {}, 'Spec List | '),\n            createDom('a', {className: 'failures-menu', href: '#'}, 'Failures')));\n        alert.appendChild(\n          createDom('span', {className: 'menu bar failure-list'},\n            createDom('a', {className: 'spec-list-menu', href: '#'}, 'Spec List'),\n            createDom('span', {}, ' | Failures ')));\n\n        find('.failures-menu').onclick = function() {\n          setMenuModeTo('failure-list');\n        };\n        find('.spec-list-menu').onclick = function() {\n          setMenuModeTo('spec-list');\n        };\n\n        setMenuModeTo('failure-list');\n\n        var failureNode = find('.failures');\n        for (var i = 0; i < failures.length; i++) {\n          failureNode.appendChild(failures[i]);\n        }\n      }\n    };\n\n    return this;\n\n    function find(selector) {\n      return getContainer().querySelector('.jasmine_html-reporter ' + selector);\n    }\n\n    function clearPrior() {\n      // return the reporter\n      var oldReporter = find('');\n\n      if(oldReporter) {\n        getContainer().removeChild(oldReporter);\n      }\n    }\n\n    function createDom(type, attrs, childrenVarArgs) {\n      var el = createElement(type);\n\n      for (var i = 2; i < arguments.length; i++) {\n        var child = arguments[i];\n\n        if (typeof child === 'string') {\n          el.appendChild(createTextNode(child));\n        } else {\n          if (child) {\n            el.appendChild(child);\n          }\n        }\n      }\n\n      for (var attr in attrs) {\n        if (attr == 'className') {\n          el[attr] = attrs[attr];\n        } else {\n          el.setAttribute(attr, attrs[attr]);\n        }\n      }\n\n      return el;\n    }\n\n    function pluralize(singular, count) {\n      var word = (count == 1 ? singular : singular + 's');\n\n      return '' + count + ' ' + word;\n    }\n\n    function specHref(result) {\n      return addToExistingQueryString('spec', result.fullName);\n    }\n\n    function defaultQueryString(key, value) {\n      return '?' + key + '=' + value;\n    }\n\n    function setMenuModeTo(mode) {\n      htmlReporterMain.setAttribute('class', 'jasmine_html-reporter ' + mode);\n    }\n\n    function noExpectations(result) {\n      return (result.failedExpectations.length + result.passedExpectations.length) === 0 &&\n        result.status === 'passed';\n    }\n  }\n\n  return HtmlReporter;\n};\n\njasmineRequire.HtmlSpecFilter = function() {\n  function HtmlSpecFilter(options) {\n    var filterString = options && options.filterString() && options.filterString().replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n    var filterPattern = new RegExp(filterString);\n\n    this.matches = function(specName) {\n      return filterPattern.test(specName);\n    };\n  }\n\n  return HtmlSpecFilter;\n};\n\njasmineRequire.ResultsNode = function() {\n  function ResultsNode(result, type, parent) {\n    this.result = result;\n    this.type = type;\n    this.parent = parent;\n\n    this.children = [];\n\n    this.addChild = function(result, type) {\n      this.children.push(new ResultsNode(result, type, this));\n    };\n\n    this.last = function() {\n      return this.children[this.children.length - 1];\n    };\n  }\n\n  return ResultsNode;\n};\n\njasmineRequire.QueryString = function() {\n  function QueryString(options) {\n\n    this.navigateWithNewParam = function(key, value) {\n      options.getWindowLocation().search = this.fullStringWithNewParam(key, value);\n    };\n\n    this.fullStringWithNewParam = function(key, value) {\n      var paramMap = queryStringToParamMap();\n      paramMap[key] = value;\n      return toQueryString(paramMap);\n    };\n\n    this.getParam = function(key) {\n      return queryStringToParamMap()[key];\n    };\n\n    return this;\n\n    function toQueryString(paramMap) {\n      var qStrPairs = [];\n      for (var prop in paramMap) {\n        qStrPairs.push(encodeURIComponent(prop) + '=' + encodeURIComponent(paramMap[prop]));\n      }\n      return '?' + qStrPairs.join('&');\n    }\n\n    function queryStringToParamMap() {\n      var paramStr = options.getWindowLocation().search.substring(1),\n        params = [],\n        paramMap = {};\n\n      if (paramStr.length > 0) {\n        params = paramStr.split('&');\n        for (var i = 0; i < params.length; i++) {\n          var p = params[i].split('=');\n          var value = decodeURIComponent(p[1]);\n          if (value === 'true' || value === 'false') {\n            value = JSON.parse(value);\n          }\n          paramMap[decodeURIComponent(p[0])] = value;\n        }\n      }\n\n      return paramMap;\n    }\n\n  }\n\n  return QueryString;\n};\n";

/***/ },
/* 9 */
/***/ function(module, exports) {

	"use strict";
	
	module.exports = "/**\n Starting with version 2.0, this file \"boots\" Jasmine, performing all of the necessary initialization before executing the loaded environment and all of a project's specs. This file should be loaded after `jasmine.js` and `jasmine_html.js`, but before any project source files or spec files are loaded. Thus this file can also be used to customize Jasmine for a project.\n\n If a project is using Jasmine via the standalone distribution, this file can be customized directly. If a project is using Jasmine via the [Ruby gem][jasmine-gem], this file can be copied into the support directory via `jasmine copy_boot_js`. Other environments (e.g., Python) will have different mechanisms.\n\n The location of `boot.js` can be specified and/or overridden in `jasmine.yml`.\n\n [jasmine-gem]: http://github.com/pivotal/jasmine-gem\n */\n\n(function() {\n\n  /**\n   * ## Require &amp; Instantiate\n   *\n   * Require Jasmine's core files. Specifically, this requires and attaches all of Jasmine's code to the `jasmine` reference.\n   */\n  window.jasmine = jasmineRequire.core(jasmineRequire);\n\n  /**\n   * Since this is being run in a browser and the results should populate to an HTML page, require the HTML-specific Jasmine code, injecting the same reference.\n   */\n  jasmineRequire.html(jasmine);\n\n  /**\n   * Create the Jasmine environment. This is used to run all specs in a project.\n   */\n  var env = jasmine.getEnv();\n\n  /**\n   * ## The Global Interface\n   *\n   * Build up the functions that will be exposed as the Jasmine public interface. A project can customize, rename or alias any of these functions as desired, provided the implementation remains unchanged.\n   */\n  var jasmineInterface = jasmineRequire.interface(jasmine, env);\n\n  /**\n   * Add all of the Jasmine global/public interface to the global scope, so a project can use the public interface directly. For example, calling `describe` in specs instead of `jasmine.getEnv().describe`.\n   */\n  extend(window, jasmineInterface);\n\n  /**\n   * ## Runner Parameters\n   *\n   * More browser specific code - wrap the query string in an object and to allow for getting/setting parameters from the runner user interface.\n   */\n\n  var queryString = new jasmine.QueryString({\n    getWindowLocation: function() { return window.location; }\n  });\n\n  var catchingExceptions = queryString.getParam(\"catch\");\n  env.catchExceptions(typeof catchingExceptions === \"undefined\" ? true : catchingExceptions);\n\n  var throwingExpectationFailures = queryString.getParam(\"throwFailures\");\n  env.throwOnExpectationFailure(throwingExpectationFailures);\n\n  /**\n   * ## Reporters\n   * The `HtmlReporter` builds all of the HTML UI for the runner page. This reporter paints the dots, stars, and x's for specs, as well as all spec names and all failures (if any).\n   */\n  var htmlReporter = new jasmine.HtmlReporter({\n    env: env,\n    onRaiseExceptionsClick: function() { queryString.navigateWithNewParam(\"catch\", !env.catchingExceptions()); },\n    onThrowExpectationsClick: function() { queryString.navigateWithNewParam(\"throwFailures\", !env.throwingExpectationFailures()); },\n    addToExistingQueryString: function(key, value) { return queryString.fullStringWithNewParam(key, value); },\n    getContainer: function() { return document.body; },\n    createElement: function() { return document.createElement.apply(document, arguments); },\n    createTextNode: function() { return document.createTextNode.apply(document, arguments); },\n    timer: new jasmine.Timer()\n  });\n\n  /**\n   * The `jsApiReporter` also receives spec results, and is used by any environment that needs to extract the results  from JavaScript.\n   */\n  env.addReporter(jasmineInterface.jsApiReporter);\n  env.addReporter(htmlReporter);\n\n  /**\n   * Filter which specs will be run by matching the start of the full name against the `spec` query param.\n   */\n  var specFilter = new jasmine.HtmlSpecFilter({\n    filterString: function() { return queryString.getParam(\"spec\"); }\n  });\n\n  env.specFilter = function(spec) {\n    return specFilter.matches(spec.getFullName());\n  };\n\n  /**\n   * Setting up timing functions to be able to be overridden. Certain browsers (Safari, IE 8, phantomjs) require this hack.\n   */\n  window.setTimeout = window.setTimeout;\n  window.setInterval = window.setInterval;\n  window.clearTimeout = window.clearTimeout;\n  window.clearInterval = window.clearInterval;\n\n  /**\n   * ## Execution\n   *\n   * Replace the browser window's `onload`, ensure it's called, and then run all of the loaded specs. This includes initializing the `HtmlReporter` instance and then executing the loaded Jasmine environment. All of this will happen after all of the specs are loaded.\n   */\n  var currentWindowOnload = window.onload;\n\n  window.onload = function() {\n    if (currentWindowOnload) {\n      currentWindowOnload();\n    }\n    htmlReporter.initialize();\n    env.execute();\n  };\n\n  /**\n   * Helper function for readability above.\n   */\n  function extend(destination, source) {\n    for (var property in source) destination[property] = source[property];\n    return destination;\n  }\n\n}());\n";

/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgNjM2ZGZkODQyODJmMmFhZWNhMDkiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Jyb3dzZXItamFzbWluZS10ZXN0aW5nLmpzIiwid2VicGFjazovLy8uL3NyYy9saWIvamFzbWluZS0yLjMuNC9qYXNtaW5lLmNzcz9lMDhjIiwid2VicGFjazovLy8uL3NyYy9saWIvamFzbWluZS0yLjMuNC9qYXNtaW5lLmNzcyIsIndlYnBhY2s6Ly8vLi9+L2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzIiwid2VicGFjazovLy8uL34vc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNS1zaGltL2VzNS1zaGltLmpzIiwid2VicGFjazovLy8uL34vc291cmNlLW1hcC1zdXBwb3J0L2Jyb3dzZXItc291cmNlLW1hcC1zdXBwb3J0LmpzIiwid2VicGFjazovLy8uL3NyYy9saWIvamFzbWluZS0yLjMuNC9qYXNtaW5lLmpzIiwid2VicGFjazovLy8uL3NyYy9saWIvamFzbWluZS0yLjMuNC9qYXNtaW5lLWh0bWwuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi9qYXNtaW5lLTIuMy40L2Jvb3QuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7OztBQ3RDQSxvQkFBTyxDQUFDLENBQWlDLENBQUMsQ0FBQztBQUMzQyxvQkFBTyxDQUFDLENBQVUsQ0FBQyxDQUFDO0FBQ3BCLEtBQUksT0FBTyxHQUFHLENBQ1YsbUJBQU8sQ0FBQyxDQUFrRCxDQUFDLEVBQzNELG1CQUFPLENBQUMsQ0FBZ0MsQ0FBQyxFQUN6QyxtQkFBTyxDQUFDLENBQXFDLENBQUMsRUFDOUMsbUJBQU8sQ0FBQyxDQUE2QixDQUFDLENBQ3pDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDOztBQUVaLEtBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0FBQzNCLGlCQUFnQixDQUFDLE9BQU8sRUFBRSxDOzs7Ozs7O0FDVjFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQXNGO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsaUNBQWdDLFVBQVUsRUFBRTtBQUM1QyxFOzs7Ozs7QUNwQkE7QUFDQTs7O0FBR0E7QUFDQSxpQ0FBZ0Msb0JBQW9CLEVBQUUsNEJBQTRCLHdCQUF3QixjQUFjLGNBQWMsaUJBQWlCLG9EQUFvRCxtQkFBbUIsYUFBYSxFQUFFLDRCQUE0Qix1QkFBdUIsRUFBRSxrQ0FBa0MsNEJBQTRCLEVBQUUsOExBQThMLFdBQVcsbUJBQW1CLEVBQUUseVRBQXlULG1CQUFtQixvQkFBb0IsRUFBRSxrQ0FBa0Msb0JBQW9CLEVBQUUseUNBQXlDLGlDQUFpQyxvd0VBQW93RSxxQ0FBcUMsOGhYQUE4aFgsNEJBQTRCLDBCQUEwQiwrQkFBK0IsdUJBQXVCLGdCQUFnQixhQUFhLGFBQWEsY0FBYyxFQUFFLDJDQUEyQyxtQkFBbUIsb0JBQW9CLFVBQVUsRUFBRSwyQ0FBMkMsaUJBQWlCLGFBQWEsRUFBRSxtQ0FBbUMsYUFBYSxFQUFFLGtDQUFrQyxrQkFBa0IsRUFBRSxvQ0FBb0MsYUFBYSxjQUFjLG1CQUFtQixvQkFBb0IsRUFBRSwwQ0FBMEMsa0JBQWtCLFVBQVUsZ0JBQWdCLEVBQUUsNkNBQTZDLHVCQUF1QixhQUFhLGFBQWEsaUJBQWlCLEVBQUUsb0RBQW9ELGlCQUFpQixFQUFFLDJEQUEyRCxnQkFBZ0IscUJBQXFCLEVBQUUsb0RBQW9ELGtCQUFrQixFQUFFLDJEQUEyRCxnQkFBZ0IsbUJBQW1CLG1CQUFtQixtQkFBbUIsRUFBRSxzREFBc0QsaUJBQWlCLEVBQUUsNkRBQTZELGdCQUFnQixxQkFBcUIsRUFBRSxxREFBcUQsbUJBQW1CLEVBQUUsNERBQTRELGdCQUFnQixnQkFBZ0IsRUFBRSxtREFBbUQsaUJBQWlCLEVBQUUsMERBQTBELGdCQUFnQixxQkFBcUIsRUFBRSx1Q0FBdUMsY0FBYyxtQkFBbUIsMkJBQTJCLGdCQUFnQixvQkFBb0IsbUJBQW1CLEVBQUUsZ0RBQWdELGlCQUFpQixtQkFBbUIsRUFBRSxnREFBZ0Qsb0JBQW9CLGVBQWUsYUFBYSwyQkFBMkIsd0JBQXdCLHFCQUFxQixrQkFBa0IsRUFBRSxxREFBcUQsZ0JBQWdCLEVBQUUsK0JBQStCLG1CQUFtQixpQkFBaUIsZ0JBQWdCLGFBQWEsRUFBRSxzQ0FBc0MsMkJBQTJCLEVBQUUsc0NBQXNDLDJCQUEyQixFQUFFLHVDQUF1QywyQkFBMkIsRUFBRSx1Q0FBdUMsMkJBQTJCLEVBQUUsb0NBQW9DLHdCQUF3QixhQUFhLEVBQUUsc0NBQXNDLGFBQWEsRUFBRSxpQ0FBaUMsY0FBYyxFQUFFLGdIQUFnSCxlQUFlLEVBQUUseUdBQXlHLGVBQWUsRUFBRSxtQ0FBbUMsa0JBQWtCLEVBQUUsbUNBQW1DLGtCQUFrQixFQUFFLHNDQUFzQyx1QkFBdUIsbUJBQW1CLGdCQUFnQixpQkFBaUIsRUFBRSw0Q0FBNEMsaUJBQWlCLG9CQUFvQixFQUFFLCtDQUErQyxnQkFBZ0IsRUFBRSwrQ0FBK0MsZ0JBQWdCLEVBQUUsOENBQThDLGdCQUFnQixFQUFFLGdEQUFnRCxnQkFBZ0IsRUFBRSxpREFBaUQsZ0JBQWdCLEVBQUUsZ0RBQWdELGVBQWUsRUFBRSxpQ0FBaUMsa0JBQWtCLEVBQUUsbUNBQW1DLGFBQWEsRUFBRSxpREFBaUQscUJBQXFCLEVBQUUsOERBQThELDJCQUEyQixFQUFFLGdFQUFnRSxjQUFjLEVBQUUsMENBQTBDLG1CQUFtQixhQUFhLGtCQUFrQixFQUFFLHNEQUFzRCxnQkFBZ0IsRUFBRSx1Q0FBdUMsbUJBQW1CLG1CQUFtQixnQkFBZ0IsbUJBQW1CLGFBQWEsd0JBQXdCLG1CQUFtQixrQkFBa0IsRUFBRTs7QUFFL2ttQjs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBLHlDQUF3QyxnQkFBZ0I7QUFDeEQsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZLG9CQUFvQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQixzQkFBc0I7QUFDdEM7QUFDQTtBQUNBLG1CQUFrQiwyQkFBMkI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWUsbUJBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCLDJCQUEyQjtBQUM1QztBQUNBO0FBQ0EsU0FBUSx1QkFBdUI7QUFDL0I7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLGtCQUFpQix1QkFBdUI7QUFDeEM7QUFDQTtBQUNBLDRCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQSxpQ0FBZ0Msc0JBQXNCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0RBQXVEO0FBQ3ZEOztBQUVBLDhCQUE2QixtQkFBbUI7O0FBRWhEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7OztBQ3ZQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWUsb0pBQW9KLE1BQU0scUJBQXFCLGFBQWEsRUFBRSxZQUFZLGNBQWMsRUFBRSxFQUFFLHlFQUF5RSwwQ0FBMEMsbUNBQW1DLGNBQWMsRUFBRSxzQkFBc0IsaUNBQWlDLEVBQUUsc0NBQXNDLHNEQUFzRDtBQUN0aUIsYUFBWSxtSUFBbUksTUFBTSx1QkFBdUIsYUFBYSxFQUFFLFlBQVksY0FBYyxFQUFFLEVBQUUsaUNBQWlDLG9DQUFvQyxpQ0FBaUMsY0FBYyxFQUFFLG9GQUFvRjtBQUNuYSxjQUFhLDRJQUE0SSxNQUFNLHNCQUFzQixhQUFhLEVBQUUsWUFBWSxjQUFjLEVBQUUsRUFBRSxrQ0FBa0Msc0NBQXNDLGlDQUFpQyxhQUFhLEVBQUUsaUNBQWlDLGNBQWMsRUFBRSx3RkFBd0Y7O0FBRW5lO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTBDLGdDQUFnQztBQUMxRSw2QkFBNEIsY0FBYztBQUMxQztBQUNBLE1BQUssWUFBWTtBQUNqQjtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFpRCxRQUFRO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQSxJQUFHO0FBQ0g7QUFDQSxrREFBaUQsUUFBUTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrREFBaUQsZ0JBQWdCOztBQUVqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsZ0NBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBa0Ysc0NBQXNDLEVBQUU7O0FBRTFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNEQUFxRDtBQUNyRCxzRUFBcUU7QUFDckU7QUFDQTtBQUNBLHlEQUF3RDtBQUN4RCwrRUFBOEU7QUFDOUU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsMkJBQTBCLG1CQUFtQjs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQThDLGdDQUFnQztBQUM5RSxVQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBdUIsWUFBWTtBQUNuQztBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF1QixZQUFZO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF1QixZQUFZO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF1QixZQUFZO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFrRyxhQUFhLEVBQUU7QUFDakg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7O0FBRUEsZUFBYyxZQUFZO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2R0FBNEcsYUFBYSxFQUFFO0FBQzNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWMsWUFBWTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0Esc0NBQXFDLFdBQVc7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1QixrQkFBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNELG1DQUFrQyxpQkFBaUI7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLHVCQUFzQjtBQUN0QjtBQUNBLE1BQUssWUFBWTtBQUNqQjtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSyxZQUFZO0FBQ2pCO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLLFlBQVk7QUFDakI7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBd0IsbUJBQW1CO0FBQzNDLHFDQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQSxzRUFBcUUsMkNBQTJDO0FBQ2hIO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUEyQixtQkFBbUI7QUFDOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBMkIscUJBQXFCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXdDO0FBQ3hDLDJDQUEwQyxhQUFhO0FBQ3ZELGNBQWE7QUFDYixNQUFLO0FBQ0w7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxnRUFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBc0Msd0JBQXdCO0FBQzlEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQWtCLEVBQUUsU0FBUyxFQUFFO0FBQy9CO0FBQ0EsdUJBQXNCLEVBQUU7QUFDeEIsdUJBQXNCLEVBQUU7QUFDeEI7QUFDQSx3QkFBdUIsRUFBRTtBQUN6Qix3QkFBdUIsRUFBRTtBQUN6QjtBQUNBLDRCQUEyQixFQUFFO0FBQzdCLGlDQUFnQyxHQUFHO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMEIsRUFBRTtBQUM1Qiw0QkFBMkIsRUFBRTtBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQW9DLG1CQUFtQjs7QUFFdkQ7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBOEI7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW1DLHVCQUF1Qjs7QUFFMUQ7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE0RTtBQUM1RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUEyQywwQkFBMEI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQSwrREFBOEQsV0FBVztBQUN6RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFDOzs7Ozs7O0FDdHlERCw0SkFBMkosMEJBQTBCLDZDQUE2QyxtQkFBbUIsZ0JBQWdCLFVBQVUsVUFBVSw0Q0FBNEMsd0JBQXdCLG9CQUFvQiwrQ0FBK0MsUUFBUSxZQUFZLG1DQUFtQyxpQkFBaUIsZ0JBQWdCLHNCQUFzQixvQkFBb0Isb0RBQW9ELFdBQVcsWUFBWSxTQUFTLEdBQUcscUJBQXFCLDhCQUE4QixFQUFFLDRCQUE0QixxQkFBcUIsZUFBZSx3QkFBd0IsZ0JBQWdCLE1BQU0sOEJBQThCLGlCQUFpQix3QkFBd0IscUNBQXFDLFFBQVEsS0FBSywyQ0FBMkMsc0ZBQXNGLFdBQVcsZ0JBQWdCLFNBQVMsY0FBYyxtQkFBbUIsZUFBZSxjQUFjLGNBQWMsT0FBTywyQkFBMkIsNkRBQTZELFNBQVMsa0JBQWtCLFVBQVUsY0FBYyxJQUFJLHFCQUFxQixjQUFjLEtBQUssMkZBQTJGLEtBQUssWUFBWSxJQUFJLGdCQUFnQix3QkFBd0IsWUFBWSxHQUFHLGlEQUFpRCw4Q0FBOEMsa0JBQWtCLDhFQUE4RSxxQ0FBcUMsNENBQTRDLHdCQUF3QixRQUFRLEtBQUssd0JBQXdCLG9CQUFvQixnQkFBZ0IsNkNBQTZDLG9CQUFvQixvQkFBb0IsRUFBRSx5QkFBeUIsZ0JBQWdCLEVBQUUsb0JBQW9CLDBEQUEwRCxVQUFVLGdCQUFnQixxQ0FBcUMsc0JBQXNCLDJCQUEyQixhQUFhLFNBQVMscUNBQXFDLDRCQUE0QiwyQkFBMkIsbUNBQW1DLHVDQUF1QyxpQkFBaUIsd0NBQXdDLG1CQUFtQiw0QkFBNEIsZUFBZSx5Q0FBeUMsaUNBQWlDLEVBQUUsYUFBYSxzQkFBc0Isb0JBQW9CLHdDQUF3QyxTQUFTLFVBQVUsNkZBQTZGLEVBQUUsNkNBQTZDLHFCQUFxQixhQUFhLGNBQWMsa0JBQWtCLDRCQUE0Qiw0QkFBNEIsaUJBQWlCLHVCQUF1QixvQkFBb0Isd0JBQXdCLHlEQUF5RCwwQkFBMEIsY0FBYyxTQUFTLGNBQWMsZ0ZBQWdGLFdBQVcsc0RBQXNELHdCQUF3QiwwQkFBMEIsUUFBUSxRQUFRLElBQUksaUlBQWlJLG9KQUFvSixVQUFVLDRCQUE0Qiw4QkFBOEIsSUFBSSxpQkFBaUIsSUFBSSxpWUFBaVksVUFBVSx1QkFBdUIscUZBQXFGLDBGQUEwRixVQUFVLE1BQU0seVRBQXlULFVBQVUsMkNBQTJDLElBQUksR0FBRyxzQkFBc0IsR0FBRyxxQkFBcUIsa0JBQWtCLDRDQUE0QyxlQUFlLHlGQUF5RixlQUFlLFVBQVUsTUFBTSx5QkFBeUIsMkNBQTJDLHFDQUFxQyw0RUFBNEUsTUFBTSxxRkFBcUYsaUVBQWlFLEtBQUssUUFBUSx5RkFBeUYsSUFBSSxnREFBZ0Qsc0NBQXNDLHVEQUF1RCxJQUFJLFdBQVcsU0FBUyxrQkFBa0IsV0FBVywyQkFBMkIsSUFBSSxpQ0FBaUMsU0FBUyxvQkFBb0IsZ0tBQWdLLFdBQVcsc0ZBQXNGLG9CQUFvQixnS0FBZ0ssV0FBVyxZQUFZLE1BQU0sb0tBQW9LLFVBQVUsb0JBQW9CLGtLQUFrSyxnRUFBZ0Usb0JBQW9CLGdLQUFnSywwRUFBMEUsb0JBQW9CLHFIQUFxSCw0QkFBNEIsb0JBQW9CLHFIQUFxSCwwQkFBMEIsc0JBQXNCLHNOQUFzTixlQUFlLHFDQUFxQyxJQUFJLGdEQUFnRCxzQkFBc0IsMk5BQTJOLGVBQWUscUNBQXFDLElBQUksK0JBQStCLHNCQUFzQiwrTkFBK04sc0RBQXNELHNCQUFzQix1T0FBdU8sMkRBQTJELHNCQUFzQiwrUEFBK1AsbUNBQW1DLHNCQUFzQiwrUEFBK1AscUNBQXFDLGtCQUFrQixrQ0FBa0MsTUFBTSxpQkFBaUIsaUJBQWlCLEtBQUssZ0JBQWdCLGNBQWMsa0JBQWtCLGVBQWUsY0FBYyxrQ0FBa0MsNkRBQTZELEtBQUssY0FBYyxnREFBZ0QsY0FBYyxpQkFBaUIsV0FBVyxLQUFLLHNCQUFzQixrQ0FBa0MsS0FBSyxRQUFRLHdCQUF3Qiw4REFBOEQsUUFBUSxXQUFXLCtCQUErQixTQUFTLGNBQWMsaUJBQWlCLFdBQVcsZ0NBQWdDLFNBQVMsb0JBQW9CLFlBQVksbUNBQW1DLGdCQUFnQixTQUFTLGNBQWMsSUFBSSw2QkFBNkIsU0FBUyxtQ0FBbUMsZ0JBQWdCLG1FQUFtRSxxRUFBcUUsMERBQTBELDBEQUEwRCxrQkFBa0IsbUVBQW1FLG9EQUFvRCxxREFBcUQsMERBQTBELGtCQUFrQixtRUFBbUUsb0RBQW9ELHFEQUFxRCxrQkFBa0IsNENBQTRDLHdDQUF3QyxXQUFXLGVBQWUsdUJBQXVCLGdCQUFnQiw2QkFBNkIsSUFBSSw2Q0FBNkMsaUJBQWlCLFdBQVcsc0RBQXNELFNBQVMsVUFBVSxHQUFHLHlCQUF5QixnQ0FBZ0MsK0tBQStLLHFCQUFxQix1QkFBdUIsNkNBQTZDLDJCQUEyQixNQUFNLFFBQVEsb0JBQW9CLDBCQUEwQixNQUFNLDJDQUEyQyxNQUFNLHVEQUF1RCxNQUFNLDBDQUEwQyxNQUFNLDZFQUE2RSxNQUFNLDJDQUEyQyxVQUFVLHVCQUF1QixpRkFBaUYsa0NBQWtDLDRCQUE0QixNQUFNLG1DQUFtQyxXQUFXLG1CQUFtQixtQkFBbUIsUUFBUSxXQUFXLEtBQUssV0FBVyxZQUFZLFlBQVksVUFBVSxvQ0FBb0MsMkNBQTJDLEtBQUssUUFBUSxJQUFJLElBQUksSUFBSSxlQUFlLGdCQUFnQiwrQkFBK0Isb0NBQW9DLFVBQVUsNEJBQTRCLGdCQUFnQiwrQkFBK0IsYUFBYSxrQ0FBa0MsZUFBZSxRQUFRLElBQUksbUZBQW1GLG9CQUFvQixJQUFJLE1BQU0sZ0VBQWdFLE1BQU0sa0RBQWtELE1BQU0sbURBQW1ELE1BQU0sK0RBQStELE1BQU0sbUZBQW1GLFdBQVcsMERBQTBELGdDQUFnQyxNQUFNLDJDQUEyQyxVQUFVLHFDQUFxQyxvQ0FBb0MsZUFBZSxxQ0FBcUMsb0JBQW9CLFVBQVUsMkJBQTJCLGVBQWUsb0JBQW9CLFdBQVcsSUFBSSxrQkFBa0IsSUFBSSxNQUFNLDBDQUEwQyw4QkFBOEIsSUFBSSwrRkFBK0YsU0FBUyxNQUFNLDZCQUE2QixNQUFNLDhCQUE4QixNQUFNLGdHQUFnRyxNQUFNLGtGQUFrRixPQUFPLFFBQVEsV0FBVyw2Q0FBNkMsSUFBSSxNQUFNLDJDQUEyQyxVQUFVLDhCQUE4QixPQUFPLHVFQUF1RSxtQ0FBbUMsU0FBUywwQkFBMEIsU0FBUyxxVkFBcVYsSUFBSSxxQkFBcUIscUNBQXFDLGtDQUFrQyxrQkFBa0IsV0FBVyxXQUFXLDJEQUEyRCx1Q0FBdUMsSUFBSSxtQkFBbUIsVUFBVSw0QkFBNEIsMkVBQTJFLDBCQUEwQiw4QkFBOEIsMkVBQTJFLDZCQUE2QixvQ0FBb0MsMkdBQTJHLHFDQUFxQyx1Q0FBdUMsdUJBQXVCLHVDQUF1Qyx1QkFBdUIsdUNBQXVDLHVCQUF1Qix1Q0FBdUMsdUJBQXVCLG1DQUFtQyx5R0FBeUcsc0VBQXNFLHNDQUFzQyx1QkFBdUIsc0NBQXNDLHVCQUF1QixzQ0FBc0MsdUJBQXVCLHNDQUFzQyx1QkFBdUIsc0NBQXNDLHVCQUF1QixzQ0FBc0MsdUJBQXVCLHVDQUF1Qyx1QkFBdUIseUNBQXlDLHVCQUF1Qix1Q0FBdUMsNkpBQTZKLDZCQUE2QiwwQ0FBMEMsa0JBQWtCLDBDQUEwQyxrQkFBa0IsMENBQTBDLGtCQUFrQiwwQ0FBMEMsa0JBQWtCLHdDQUF3QyxrS0FBa0ssNEVBQTRFLHlDQUF5QyxrQkFBa0IseUNBQXlDLGtCQUFrQix5Q0FBeUMsa0JBQWtCLHlDQUF5QyxrQkFBa0IsMkNBQTJDLGtCQUFrQix5Q0FBeUMsa0JBQWtCLDBDQUEwQyxrQkFBa0IsMENBQTBDLGtCQUFrQixpQ0FBaUMsU0FBUyxTQUFTLG1CQUFtQiwyQ0FBMkMsOERBQThELHdCQUF3Qiw2SEFBNkgsSUFBSSxlQUFlLCtCQUErQiwrQkFBK0IsSUFBSSxnREFBZ0QsZUFBZSxNQUFNLHdDQUF3QyxxQ0FBcUMsc0NBQXNDLGdEQUFnRCxxREFBcUQsSUFBSSxrQkFBa0IsZ0JBQWdCLHNFQUFzRSxrQkFBa0IseUJBQXlCLGVBQWUsYUFBYSxhQUFhLFlBQVksWUFBWSxnQkFBZ0Isc0JBQXNCLDRCQUE0QixrQkFBa0IsY0FBYyxnQkFBZ0Isd0JBQXdCLDhCQUE4Qiw4QkFBOEIsOEJBQThCLDhCQUE4QixzQkFBc0IsNEJBQTRCLDRCQUE0Qiw0QkFBNEIsNEJBQTRCLDRCQUE0Qiw4QkFBOEIsOEJBQThCLDhCQUE4QiwwQkFBMEIsZ0NBQWdDLGdDQUFnQyxnQ0FBZ0MsZ0NBQWdDLHdCQUF3Qiw4QkFBOEIsOEJBQThCLDhCQUE4Qiw4QkFBOEIsOEJBQThCLDhCQUE4QixnQ0FBZ0MsZ0NBQWdDLGdCQUFnQixvQkFBb0IsZ0NBQWdDLFVBQVUsRUFBRSwwQkFBMEIscUJBQXFCLDJCQUEyQixNQUFNLFVBQVUsMkJBQTJCLFVBQVUsc0JBQXNCLEtBQUssY0FBYyxPQUFPLFNBQVMsSUFBSSwwQkFBMEIsY0FBYyxPQUFPLFNBQVMsSUFBSSwwQkFBMEIsZUFBZSxLQUFLLHdDQUF3QyxpQkFBaUIsS0FBSyxrQ0FBa0MsOEJBQThCLCtFQUErRSxVQUFVLHFDQUFxQyxjQUFjLHlRQUF5USxLQUFLLEtBQUssK0JBQStCLFNBQVMsU0FBUyxJQUFJLCtCQUErQixtQkFBbUIsR0FBRyxxQkFBcUIsYUFBYSxnQkFBZ0IseUJBQXlCLEtBQUssS0FBSyxXQUFXLDhFQUE4RSxVQUFVLElBQUksb0JBQW9CLFNBQVMsZ0JBQWdCLCtCQUErQixpQkFBaUIsV0FBVyw4QkFBOEIsU0FBUyxtQ0FBbUMsSUFBSSx1Q0FBdUMscUJBQXFCLHlDQUF5QyxVQUFVLEtBQUssa0NBQWtDLDRGQUE0Rix1Q0FBdUMsaUNBQWlDLFVBQVUsa0JBQWtCLCtCQUErQix3QkFBd0Isd0NBQXdDLGtDQUFrQyxVQUFVLGlDQUFpQyxpQkFBaUIsd0JBQXdCLHlCQUF5QiwyQkFBMkIsa0JBQWtCLDhDQUE4Qyx1Q0FBdUMseUZBQXlGLFNBQVMsZ0JBQWdCLHlCQUF5QixjQUFjLFlBQVksd0JBQXdCLEtBQUsscUJBQXFCLGtCQUFrQixLQUFLLCtCQUErQix5QkFBeUIseUJBQXlCLHNGQUFzRixJQUFJLG9CQUFvQixJQUFJLE1BQU0sS0FBSyxRQUFRLFdBQVcsbUJBQW1CLHVCQUF1Qix3QkFBd0IsWUFBWSxrQkFBa0Isc0JBQXNCLHlCQUF5QixPQUFPLE9BQU8sc0JBQXNCLDhCQUE4QixZQUFZLHlCQUF5Qiw0QkFBNEIsZ0VBQWdFLFVBQVUsc0JBQXNCLDhCQUE4QixnREFBZ0QscUJBQXFCLGlCQUFpQixvQkFBb0Isc0JBQXNCLG9EQUFvRCxJQUFJLHNDQUFzQyxxQkFBcUIsY0FBYyxlQUFlLHNCQUFzQix5RUFBeUUsK0JBQStCLCtFQUErRSxTQUFTLGdEQUFnRCxlQUFlLCtGQUErRixLQUFLLG1CQUFtQixVQUFVLDhDQUE4QyxtQkFBbUIsaUJBQWlCLEdBQUcsb0JBQW9CLGFBQWEsU0FBUyxVQUFVLE9BQU8sU0FBUyxRQUFRLFNBQVMsc0JBQXNCLG9EQUFvRCxpQkFBaUIsYUFBYSxvQkFBb0Isa0RBQWtELEdBQUcscUJBQXFCLGlGQUFpRiw4RUFBOEUsd0RBQXdELElBQUksaUhBQWlILHNCQUFzQixzREFBc0Qsa0JBQWtCLGFBQWEsZUFBZSxhQUFhLG9CQUFvQiwwQkFBMEIsK0JBQStCLElBQUksa0JBQWtCLFVBQVUsOEJBQThCLHVDQUF1QywyQkFBMkIsb0NBQW9DLDRCQUE0QiwyRUFBMkUsZ0NBQWdDLGtEQUFrRCw4Q0FBOEMsMkJBQTJCLG9EQUFvRCw0Q0FBNEMsK0JBQStCLDRCQUE0QixhQUFhLEVBQUUsRUFBRSx5QkFBeUIsc0JBQXNCLHNEQUFzRCxrQkFBa0Isc0JBQXNCLHFCQUFxQixzQ0FBc0MsNkNBQTZDLFdBQVcsVUFBVSxxQkFBcUIsK0JBQStCLEdBQUcsb0VBQW9FLDBCQUEwQixXQUFXLE1BQU0sUUFBUSxLQUFLLFNBQVMsT0FBTyxPQUFPLHVDQUF1QyxFQUFFLEVBQUUsMkJBQTJCLHNCQUFzQixzREFBc0Qsa0JBQWtCLFFBQVEsTUFBTSx5R0FBeUcsT0FBTyxPQUFPLEVBQUUscUJBQXFCLHNCQUFzQix3REFBd0QscUJBQXFCLHNCQUFzQix5REFBeUQsRUFBRSxFQUFFLFdBQVcsc0JBQXNCLHNEQUFzRCxrQkFBa0Isc0JBQXNCLDJDQUEyQywrRUFBK0UseUJBQXlCLCtDQUErQyxFQUFFLEVBQUUsV0FBVyxzQkFBc0Isc0RBQXNELGtCQUFrQixjQUFjLFFBQVEsMERBQTBELFdBQVcsMEJBQTBCLHdMQUF3TCw2REFBNkQsOEJBQThCLGtDQUFrQyxrQkFBa0Isc0JBQXNCLGlCQUFpQixZQUFZLGlHQUFpRyw0QkFBNEIsaUNBQWlDLDRDQUE0QyxnREFBZ0QsMkJBQTJCLDhFQUE4RSxlQUFlLDhFQUE4RSw4RUFBOEUsVUFBVSx1QkFBdUIsK0NBQStDLGVBQWUsK0NBQStDLG1EQUFtRCxRQUFRLEVBQUUscUNBQXFDLDBEQUEwRCxlQUFlLHlJQUF5SSxpQ0FBaUMsRUFBRSxvQ0FBb0MseURBQXlELGVBQWUsc0lBQXNJLGdDQUFnQyxFQUFFLHlDQUF5Qyx1Q0FBdUMsU0FBUyxXQUFXLE9BQU8sc0NBQXNDLHlDQUF5QyxPQUFPLEtBQUssa0JBQWtCLGNBQWMsNEJBQTRCLG9CQUFvQixTQUFTLHFDQUFxQyxjQUFjLHFDQUFxQyxXQUFXLFNBQVMsNkZBQTZGLGNBQWMseUJBQXlCLGlCQUFpQixrQkFBa0IsU0FBUyw2RkFBNkYsY0FBYyw2QkFBNkIsbUJBQW1CLFNBQVMsdUdBQXVHLGlDQUFpQyxvRUFBb0UsNkRBQTZELDREQUE0RCw2Q0FBNkMsdUZBQXVGLDBGQUEwRix3QkFBd0IsNENBQTRDLEdBQUcsMkVBQTJFLHVIQUF1SCxrQ0FBa0Msa0RBQWtELE9BQU8sMkhBQTJILE9BQU8sZ0RBQWdELHlDQUF5QyxvQ0FBb0MsbURBQW1ELDZFQUE2RSxNQUFNLHFEQUFxRCxxQ0FBcUMsaUdBQWlHLHFIQUFxSCxvREFBb0QsNkNBQTZDLEdBQUcsdUdBQXVHLGlFQUFpRSx3SEFBd0gsb0ZBQW9GLEVBQUUsd0JBQXdCLHNCQUFzQixtQkFBbUIsd0NBQXdDLFVBQVUsNkJBQTZCLGlEQUFpRCxNQUFNLCtDQUErQyxNQUFNLHNEQUFzRCxzQkFBc0Isa0JBQWtCLGVBQWUsc0JBQXNCLE9BQU8sa0pBQWtKLGtCQUFrQixzQkFBc0IsRUFBRSxFQUFFLHVGQUF1RixzQkFBc0Isc0RBQXNELGtCQUFrQixjQUFjLGdDQUFnQyxpREFBaUQsb0JBQW9CLGtCQUFrQixrQkFBa0IsMkJBQTJCLHdFQUF3RSx1QkFBdUIsNEJBQTRCLDhCQUE4Qix5QkFBeUIsRUFBRSwwQkFBMEIsT0FBTyxXQUFXLGdEQUFnRCw4RUFBOEUsNENBQTRDLDBCQUEwQixnQkFBZ0IsRUFBRSw4QkFBOEIsNEJBQTRCLDJCQUEyQixFQUFFLFVBQVUsbUNBQW1DLGdHQUFnRyw0QkFBNEIsK0JBQStCLCtDQUErQywyQ0FBMkMscUJBQXFCLDRIQUE0SCxHQUFHLDJDQUEyQyxRQUFRLHFEQUFxRCwwREFBMEQsNktBQTZLLHlDQUF5QyxjQUFjLHVCQUF1Qix1QkFBdUIsb0JBQW9CLG1DQUFtQyxpQ0FBaUMsNkJBQTZCLDRDQUE0QyxFQUFFLDhKQUE4SixrQ0FBa0MsZ0NBQWdDLE9BQU8sZ0JBQWdCLGNBQWMsOEJBQThCLDRCQUE0Qix1REFBdUQsUUFBUSwrQ0FBK0MsZ1BBQWdQLHVDQUF1QyxLQUFLLDBDQUEwQyxxQ0FBcUMsbURBQW1ELG9DQUFvQyxJQUFJLEtBQUssb0JBQW9CLCtCQUErQixvQkFBb0IsT0FBTyxPQUFPLGFBQWEsa0VBQWtFLFNBQVMsaUNBQWlDLG9CQUFvQix3UkFBd1IsVUFBVSxrREFBa0QseUJBQXlCLHNDQUFzQyx1QkFBdUIsbUJBQW1CLG1HQUFtRyxRQUFRLGdDQUFnQyxPQUFPLHNJQUFzSSxrREFBa0QsK0ZBQStGLFVBQVUsZ0NBQWdDLDZCQUE2Qix1QkFBdUIsRUFBRSxFQUFFLGdFQUFnRSxzQkFBc0Isd0RBQXdELGtCQUFrQixzQkFBc0IsaUJBQWlCLHVCQUF1Qiw0QkFBNEIsOEJBQThCLDhCQUE4Qiw0QkFBNEIscUJBQXFCLHVFQUF1RSx3Q0FBd0MsZ0JBQWdCLHFHQUFxRyw4Q0FBOEMsNEJBQTRCLGFBQWEsS0FBSyxrQkFBa0IsOEJBQThCLHdCQUF3QixXQUFXLHFDQUFxQyxpQ0FBaUMscUJBQXFCLEtBQUssc0JBQXNCLFdBQVcsZ0NBQWdDLHlCQUF5QixvSEFBb0gsdUdBQXVHLE9BQU8sSUFBSSxPQUFPLHFCQUFxQiw4QkFBOEIsNEJBQTRCLDJCQUEyQixFQUFFLFVBQVUsNEJBQTRCLDBDQUEwQyxZQUFZLE9BQU8sdUVBQXVFLDRHQUE0RyxhQUFhLGdDQUFnQywyQ0FBMkMsS0FBSyx1QkFBdUIsdUVBQXVFLDRHQUE0RyxhQUFhLDZCQUE2QixxQ0FBcUMsSUFBSSwrREFBK0Qsb0VBQW9FLEdBQUcsNkJBQTZCLCtCQUErQixRQUFRLEtBQUssUUFBUSxRQUFRLHVDQUF1Qyx5QkFBeUIsZ0JBQWdCLGFBQWEsdUNBQXVDLDRDQUE0QyxvSkFBb0osYUFBYSwyQ0FBMkMseUNBQXlDLDJDQUEyQyxtQ0FBbUMsTUFBTSx5RUFBeUUsMERBQTBELElBQUksd0RBQXdELGdDQUFnQyxXQUFXLHNCQUFzQixLQUFLLEVBQUUsVUFBVSw4Q0FBOEMsK0RBQStELHdCQUF3QixLQUFLLHFIQUFxSCwwQkFBMEIsNEJBQTRCLFlBQVksZ0JBQWdCLGFBQWEsa0VBQWtFLFdBQVcsaUJBQWlCLGVBQWUsa0NBQWtDLDBCQUEwQixFQUFFLEVBQUUsc0NBQXNDLHdCQUF3QixFQUFFLE9BQU8sZUFBZSxlQUFlLEVBQUUsRUFBRSx1REFBdUQsc0JBQXNCLHdEQUF3RCxrQkFBa0IsY0FBYyxzQkFBc0Isb0RBQW9ELE1BQU0sY0FBYyx1QkFBdUIsMEJBQTBCLG9CQUFvQiwwQkFBMEIsb0JBQW9CLFNBQVMsZ0JBQWdCLHdCQUF3QixrQkFBa0IseUJBQXlCLHNCQUFzQixpQ0FBaUMsbURBQW1ELHlGQUF5RixlQUFlLGdCQUFnQixxQkFBcUIsTUFBTSw4R0FBOEcsMEJBQTBCLGVBQWUsNEJBQTRCLG9CQUFvQix5QkFBeUIseUJBQXlCLFdBQVcscUdBQXFHLDZDQUE2QyxNQUFNLGlOQUFpTiw4Q0FBOEMsTUFBTSwrTUFBK00sRUFBRSxFQUFFLFdBQVcsc0JBQXNCLGVBQWUsYUFBYSwrR0FBK0csY0FBYyxXQUFXLHNCQUFzQixJQUFJLFFBQVEseUJBQXlCLHFCQUFxQixhQUFhLFdBQVcscURBQXFELGtDQUFrQyxTQUFTLE9BQU8sY0FBYyxnQkFBZ0IsZUFBZSxpRUFBaUUsd0NBQXdDLGNBQWMsTUFBTSxHQUFHLE1BQU0sK0lBQStJLElBQUksUUFBUSxPQUFPLHNKQUFzSixZQUFZLEtBQUssY0FBYyxrQkFBa0Isc0dBQXNHLFVBQVUsWUFBWSxNQUFNLGNBQWMsa0JBQWtCLE9BQU8sa0JBQWtCLGtCQUFrQiw2QkFBNkIsMkRBQTJELDhCQUE4QixNQUFNLGlCQUFpQixRQUFRLGtCQUFrQixtQkFBbUIsbUdBQW1HLGNBQWMsMkRBQTJELGVBQWUsb0NBQW9DLGlLQUFpSyxhQUFhLGFBQWEsdU9BQXVPLE9BQU8seURBQXlELDhFQUE4RSxLQUFLLGdEQUFnRCwrSUFBK0ksdUJBQXVCLFNBQVMsY0FBYyxTQUFTLHlFQUF5RSxzQ0FBc0Msb0JBQW9CLE1BQU0sRUFBRSxhQUFhLFNBQVMsY0FBYyxvREFBb0QsTUFBTSxnREFBZ0QsZ0NBQWdDLFNBQVMseUJBQXlCLEVBQUUsT0FBTyx5QkFBeUIsaUJBQWlCLDZCQUE2QixlQUFlLDZCQUE2QixtQkFBbUIsc0NBQXNDLGlCQUFpQixTQUFTLG9DQUFvQyw2Q0FBNkMsU0FBUyxFQUFFLFNBQVMsZ0JBQWdCLFFBQVEsS0FBSyxFQUFFLDJCQUEyQiwwQkFBMEIsYUFBYSxjQUFjLCtEQUErRCxNQUFNLE9BQU8sMkJBQTJCLG9EQUFvRCw2R0FBNkcsWUFBWSxhQUFhLGFBQWEsbUJBQW1CLDhCQUE4QixvRUFBb0UsVUFBVSxlQUFlLDJDQUEyQyx1QkFBdUIsVUFBVSxRQUFRLGdDQUFnQyw2RkFBNkYsS0FBSywwQ0FBMEMsbUJBQW1CLG1CQUFtQixzQkFBc0Isc0JBQXNCLHNCQUFzQixPQUFPLEtBQUssMEJBQTBCLFFBQVEscUVBQXFFLHVFQUF1RSwwSkFBMEosb0JBQW9CLElBQUksbUNBQW1DLCtDQUErQyxzRUFBc0UseUVBQXlFLEVBQUUsNEVBQTRFLEVBQUUsR0FBRyxNQUFNLFNBQVMsRUFBRSxHOzs7Ozs7OztBQ0FuazNDLE9BQU0sQ0FBQyxPQUFPLEdBQUcsdXR4RkFBdXR4RixDOzs7Ozs7OztBQ0F4dXhGLE9BQU0sQ0FBQyxPQUFPLEdBQUcsazFkQUFrMWQsQzs7Ozs7Ozs7QUNBbjJkLE9BQU0sQ0FBQyxPQUFPLEdBQUcsNGxLQUE0bEssQyIsImZpbGUiOiJicm93c2VyLWphc21pbmUtdGVzdGluZy5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRpZDogbW9kdWxlSWQsXG4gXHRcdFx0bG9hZGVkOiBmYWxzZVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogd2VicGFjay9ib290c3RyYXAgNjM2ZGZkODQyODJmMmFhZWNhMDlcbiAqKi8iLCJyZXF1aXJlKCcuL2xpYi9qYXNtaW5lLTIuMy40L2phc21pbmUuY3NzJyk7XG5yZXF1aXJlKCdlczUtc2hpbScpO1xudmFyIHNjcmlwdHMgPSBbXG4gICAgcmVxdWlyZSgnc291cmNlLW1hcC1zdXBwb3J0L2Jyb3dzZXItc291cmNlLW1hcC1zdXBwb3J0LmpzJyksXG4gICAgcmVxdWlyZSgnLi9saWIvamFzbWluZS0yLjMuNC9qYXNtaW5lLmpzJyksXG4gICAgcmVxdWlyZSgnLi9saWIvamFzbWluZS0yLjMuNC9qYXNtaW5lLWh0bWwuanMnKSxcbiAgICByZXF1aXJlKCcuL2xpYi9qYXNtaW5lLTIuMy40L2Jvb3QuanMnKSxcbl0uam9pbignOycpO1xuXG5ldmFsLmNhbGwoZ2xvYmFsLCBzY3JpcHRzKTtcbnNvdXJjZU1hcFN1cHBvcnQuaW5zdGFsbCgpO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvYnJvd3Nlci1qYXNtaW5lLXRlc3RpbmcuanNcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2phc21pbmUuY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2phc21pbmUuY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vamFzbWluZS5jc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvbGliL2phc21pbmUtMi4zLjQvamFzbWluZS5jc3NcbiAqKiBtb2R1bGUgaWQgPSAxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcImJvZHkgeyBvdmVyZmxvdy15OiBzY3JvbGw7IH1cXG5cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIHsgYmFja2dyb3VuZC1jb2xvcjogI2VlZTsgcGFkZGluZzogNXB4OyBtYXJnaW46IC04cHg7IGZvbnQtc2l6ZTogMTFweDsgZm9udC1mYW1pbHk6IE1vbmFjbywgXFxcIkx1Y2lkYSBDb25zb2xlXFxcIiwgbW9ub3NwYWNlOyBsaW5lLWhlaWdodDogMTRweDsgY29sb3I6ICMzMzM7IH1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIGEgeyB0ZXh0LWRlY29yYXRpb246IG5vbmU7IH1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIGE6aG92ZXIgeyB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTsgfVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgcCwgLmphc21pbmVfaHRtbC1yZXBvcnRlciBoMSwgLmphc21pbmVfaHRtbC1yZXBvcnRlciBoMiwgLmphc21pbmVfaHRtbC1yZXBvcnRlciBoMywgLmphc21pbmVfaHRtbC1yZXBvcnRlciBoNCwgLmphc21pbmVfaHRtbC1yZXBvcnRlciBoNSwgLmphc21pbmVfaHRtbC1yZXBvcnRlciBoNiB7IG1hcmdpbjogMDsgbGluZS1oZWlnaHQ6IDE0cHg7IH1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5iYW5uZXIsIC5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLnN5bWJvbC1zdW1tYXJ5LCAuamFzbWluZV9odG1sLXJlcG9ydGVyIC5zdW1tYXJ5LCAuamFzbWluZV9odG1sLXJlcG9ydGVyIC5yZXN1bHQtbWVzc2FnZSwgLmphc21pbmVfaHRtbC1yZXBvcnRlciAuc3BlYyAuZGVzY3JpcHRpb24sIC5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLnNwZWMtZGV0YWlsIC5kZXNjcmlwdGlvbiwgLmphc21pbmVfaHRtbC1yZXBvcnRlciAuYWxlcnQgLmJhciwgLmphc21pbmVfaHRtbC1yZXBvcnRlciAuc3RhY2stdHJhY2UgeyBwYWRkaW5nLWxlZnQ6IDlweDsgcGFkZGluZy1yaWdodDogOXB4OyB9XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuYmFubmVyIHsgcG9zaXRpb246IHJlbGF0aXZlOyB9XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuYmFubmVyIC50aXRsZSB7IGJhY2tncm91bmQ6IHVybCgnZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFGb0FBQUFaQ0FNQUFBQ0d1c255QUFBQ2RsQk1WRVgvLy8vL0FQK0FnSUNxVmFxQVFJQ1pNNW1BVllDU1NaS0FRSUNPT1k2QVRZQ0xSb3VBUUlDSk80bVNTWUNJUklpUFFJQ0hQSWVPUjRDR1E0YU1RSUNHUFlhTFJvQ0ZRNFdLUUlDUFBZV0pSWUNPUW9TSlFJQ05Qb1NJUklDTVFvU0hRSUNIUklDS1FvT0hRSUNLUG9PSk80T0pRWU9NUUlDTVE0Q0lRWUtMUUlDSVBvS0xRNENLUUlDTlBvS0pRSVNNUTRLSlFvU0xRWUtKUUlTTFE0S0lRb1NLUVlLSVFJQ0lRSVNNUW9TS1FZS0xRSU9MUW9PSlFZR0xRSU9LUUlPTVFvR0tRWU9MUVlHS1FJT0xRb0dKUVlPSlFJT0tRWUdKUUlPS1FvR0tRSUdMUUlLTFE0S0tRb0dMUVlLSlFJR0tRWUtKUUlHS1FJS0pRb0dLUVlLTFFJR0tRWUtMUUlPSlFvS0tRb09KUVlLS1FJT0pRb0tLUW9PS1FJT0xRb0tLUVlPTFFZS0pRSU9LUW9LS1FZS0tRb0tKUVlPS1FZS0xRSU9LUW9LTFFZT0tRWUtMUUlPSlFvR0tRWUtKUVlHSlFvR0tRWUtMUW9HTFFZR0tRb0dKUVlLS1FZR0pRSUtLUW9HSlFZS0xRSUtLUVlHTFFZS0tRWUdLUVlHS1FZS0pRWU9LUW9LSlFZT0tRWUtMUVlPTFFZT0tRWUtMUVlPS1FvS0tRWUtLUVlPS1FZT0pRWUtLUVlLTFFZS0tRSUtLUW9LS1FZS0tRWUtLUW9LSlFJS0tRWUtMUVlLS1FZS0tRSUtLUVlLS1FZS0tRWUtLUUlLS1FZS0pRWUdMUVlHS1FZS0tRWUtLUVlHS1FJS0tRWUdLUVlPSlFvS0tRWU9MUVlLS1FZT0tRb0tLUVlLS1FvS0tRWUtLUVlLSlFZS0xRWUtLUVlLS1FZS0tRWUtLUVlLS1FZS0tRWUtLUVlLS1FZS0pRWUtLUVlLS1FZS0tRWUtLUVlLS1FZS0tRWUtLUVlLS1FZS0tRWUtLUVlLS1FZS0xRWUtLUVlLS1FZS0tRWUtLUVlLS1FZS0tRWUtLUVlLS1FZS0tRWUtLUVlLS1FZS0tRWUttSURwRUFBQUEwWFJTVGxNQUFRSURCQVVHQndnSkNnc01EUTRQRUJFU0V4UVZGaGNZR1JvYkhCMGVIeUFpSXlRbEp5Y29LaXNzTFM0d01UUTFOamM0T1RvN1BEdytQMEJDUTBSSVNVcExURTFPVUZOVVZWZFlXRmxhVzE1ZllHRmlZMlpuYUdscWEyeHRiM0J4Y25OMGRuaDVlbnQ4Zlg1L2dJR0NoSVdJaW95TmpvK1FrWk9VbFphWW1acWJuSjJlb0tHaW82V21xS21zcmE2dnNMR3p0cmU0dWJxN3ZMMit3TUhEeE1qSnlzdk56cy9RMGRMVTF0ZlkyZHZjM3QvZzRlTGo1ZWJuNk9ucTYrenQ3dS93OHZQMDlmYjMrUG42Ky96OS92a1ZRWEFBQUFNYVNVUkJWSGhlNWRYeFYxTjFHTWZ4ejJBQmJEZ0lBbTVWREpPeVZESUpMVU1hVnBCV1VaVWFHYm1xb0dwWlJTaUdpUldwNktvWjVBQjBaWTUwUkltWlFJbGFoS2tNWVh2L1I5MGRCdkVUL3JKZk9yM091Yzh2OTl6UGVjNTl6dmY1NmordllLbFZpU2Y3MjUwWDRNcjNPMjlUZ3EwOEJkR0I0RGhjZWtFSjVZa1FLRnNnV1pkdGo5SnBWK0k4eFBqTEZxa3JzRUlxTzhQSFNwaXMzNmpXYXpjcWpFc2ZKamt2UnNzVlUzN1NkSU91NFhDZjV2RUpQc253SnBuUk5VOUpteGhNazhsMWdlaElycTdoVEZqek9EK1ZmODg2MjlxS01KVk5sdEluRmVSZXhSUXlKbE5lcWQxaUdEbFN6cklVSXlYYnlGZm0zUllwcmNRUmU3bHF0V3lHWWJmYzZkVDBSMnZtZE9Pa1gzdTU1QzFyUDM3ZnRpSCt0RGJ5NHIvUkJUMHc4VHlFa3IrZXBCOVhnUERtU1lZV2JyaEN1RllhSXl3M2ZEUUFYVG5Ta2grQU5vZmlIbVdmOWwrRlkxSTkwRmRRVGV0c3RPMDBvMjNub3Z6VnNKN3VCMy9DNVRrYmpSd1o1SmVyd1Y0aVJXcTlIRmJGTWFLL2QwVFlxYXlSaVFQdUl4eFMzQnU4SldVOTAvNjB0S2k3dmtoYXpuZXowYS9UYlZPS2o1Q2FPWmg2ZldHNi9MeXY5Qi9aTFIxZ3cvUy9mcGJlVkQzTUNXMWxpNlN2V0RPbjY1dHI5OS91dld0QlMwWERtNHMxdCtzT0hwRzBrcEJLeC9sNzd3T1NueExwY3g2VFhtWExUUFFPS1lPZjlRMWRmcjgvU0oybUZkQ3ZsMVlsOTNEaUhVWnZYZUxKYkdTell1NWdWSjJzbGJTYWtPUjhkeENxNWFkUTJvRkxxc0U5RXgzTDRxUU8wZU9QZVU1eDU2YnlwWHA0b25TRWI1T2tJQ1g2bERhdDU1VGVvenROS1FjSmFha3J6OUtDYjk1b0Q2OUlLcSt5S1c0WFBqa25hUzUyVjBUWnFFMmNUdFhqY0hTQ1JtVU84OGUrODVoajNFUDc0aTlwOHB5bHc3bHhnTUR5eWw2T1Y3WmVqbmpOTWZhdHU4N0x4UmJIMElTMzVndDJhNFpqbUdwVkJkS0szV3I2SU5rOGpXV1NHcWJBNTVDS2dqQlJDNkU5dzc4eWRUZzNBQlMzQUZWMVFOMFk0QWEycGdFalduUVVSajlMMGF5SzZSMnlzRXF4SFVLelluTHZ2eVUraTlLTTJKSEp6RTR2eVpPeURjT3dPc3lTYWplTFBjOHNOdlBKa0ZseUpkMjB3cHFBelplQWZaM29XeWJ4ZCtQLzNqK1NHM3VTQmRmMlZRQUFBQUJKUlU1RXJrSmdnZz09Jykgbm8tcmVwZWF0OyBiYWNrZ3JvdW5kOiB1cmwoJ2RhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEQ5NGJXd2dkbVZ5YzJsdmJqMGlNUzR3SWlCbGJtTnZaR2x1WnowaVZWUkdMVGdpSUhOMFlXNWtZV3h2Ym1VOUltNXZJajgrQ2p3aExTMGdRM0psWVhSbFpDQjNhWFJvSUVsdWEzTmpZWEJsSUNob2RIUndPaTh2ZDNkM0xtbHVhM05qWVhCbExtOXlaeThwSUMwdFBnb0tQSE4yWndvZ0lDQjRiV3h1Y3pwa1l6MGlhSFIwY0RvdkwzQjFjbXd1YjNKbkwyUmpMMlZzWlcxbGJuUnpMekV1TVM4aUNpQWdJSGh0Ykc1ek9tTmpQU0pvZEhSd09pOHZZM0psWVhScGRtVmpiMjF0YjI1ekxtOXlaeTl1Y3lNaUNpQWdJSGh0Ykc1ek9uSmtaajBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TVRrNU9TOHdNaTh5TWkxeVpHWXRjM2x1ZEdGNExXNXpJeUlLSUNBZ2VHMXNibk02YzNablBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHlNREF3TDNOMlp5SUtJQ0FnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JZ29nSUNCNGJXeHVjenBwYm10elkyRndaVDBpYUhSMGNEb3ZMM2QzZHk1cGJtdHpZMkZ3WlM1dmNtY3ZibUZ0WlhOd1lXTmxjeTlwYm10elkyRndaU0lLSUNBZ2RtVnljMmx2YmowaU1TNHhJZ29nSUNCM2FXUjBhRDBpTmpneExqazJNalV5SWdvZ0lDQm9aV2xuYUhROUlqRTROeTQxSWdvZ0lDQnBaRDBpYzNabk1pSUtJQ0FnZUcxc09uTndZV05sUFNKd2NtVnpaWEoyWlNJK1BHMWxkR0ZrWVhSaENpQWdJQ0FnYVdROUltMWxkR0ZrWVhSaE9DSStQSEprWmpwU1JFWStQR05qT2xkdmNtc0tJQ0FnSUNBZ0lDQWdjbVJtT21GaWIzVjBQU0lpUGp4a1l6cG1iM0p0WVhRK2FXMWhaMlV2YzNabkszaHRiRHd2WkdNNlptOXliV0YwUGp4a1l6cDBlWEJsQ2lBZ0lDQWdJQ0FnSUNBZ2NtUm1PbkpsYzI5MWNtTmxQU0pvZEhSd09pOHZjSFZ5YkM1dmNtY3ZaR012WkdOdGFYUjVjR1V2VTNScGJHeEpiV0ZuWlNJZ0x6NDhMMk5qT2xkdmNtcytQQzl5WkdZNlVrUkdQand2YldWMFlXUmhkR0UrUEdSbFpuTUtJQ0FnSUNCcFpEMGlaR1ZtY3pZaVBqeGpiR2x3VUdGMGFBb2dJQ0FnSUNBZ2FXUTlJbU5zYVhCUVlYUm9NVGdpUGp4d1lYUm9DaUFnSUNBZ0lDQWdJR1E5SWswZ01Dd3hOVEF3SURBc01DQnNJRFUwTlRVdU56UXNNQ0F3TERFMU1EQWdUQ0F3TERFMU1EQWdlaUlLSUNBZ0lDQWdJQ0FnYVc1cmMyTmhjR1U2WTI5dWJtVmpkRzl5TFdOMWNuWmhkSFZ5WlQwaU1DSUtJQ0FnSUNBZ0lDQWdhV1E5SW5CaGRHZ3lNQ0lnTHo0OEwyTnNhWEJRWVhSb1Bqd3ZaR1ZtY3o0OFp3b2dJQ0FnSUhSeVlXNXpabTl5YlQwaWJXRjBjbWw0S0RFdU1qVXNNQ3d3TEMweExqSTFMREFzTVRnM0xqVXBJZ29nSUNBZ0lHbGtQU0puTVRBaVBqeG5DaUFnSUNBZ0lDQjBjbUZ1YzJadmNtMDlJbk5qWVd4bEtEQXVNU3d3TGpFcElnb2dJQ0FnSUNBZ2FXUTlJbWN4TWlJK1BHY0tJQ0FnSUNBZ0lDQWdhV1E5SW1jeE5DSStQR2NLSUNBZ0lDQWdJQ0FnSUNCamJHbHdMWEJoZEdnOUluVnliQ2dqWTJ4cGNGQmhkR2d4T0NraUNpQWdJQ0FnSUNBZ0lDQWdhV1E5SW1jeE5pSStQSEJoZEdnS0lDQWdJQ0FnSUNBZ0lDQWdJR1E5SW0wZ01UVTBOQ3cxT1RrdU5ETTBJR01nTUM0NU1pd3ROREF1TXpVeUlESTFMalk0TEMwNE1TNDJNRElnTnpFdU5UTXNMVGd4TGpZd01pQXlOeTQxTVN3d0lEUTNMalk0TERFeUxqZ3pNaUEyTVM0ME5Dd3pOUzQzTlRRZ01USXVPRE1zTWpJdU9UTWdNVEl1T0RNc05UWXVPRFV5SURFeUxqZ3pMRGd5TGpVeU55QnNJREFzTXpJNUxqRTROQ0F0TnpFdU5USXNNQ0F3TERFd05DNDFORE1nTWpZMkxqZ3pMREFnTUN3dE1UQTBMalUwTXlBdE56QXVOaXd3SURBc0xUTTBOQzQzTnlCaklEQXNMVFU0TGpZNU1TQXRNeTQyT0N3dE1UQTBMalV6TVNBdE5EUXVPVE1zTFRFMU1pNHlNVGdnTFRNMkxqWTRMQzAwTWk0eE9DQXRPVFl1TWpnc0xUWTJMakF5SUMweE5UTXVNVFFzTFRZMkxqQXlJQzB4TVRjdU16Y3NNQ0F0TWpBM0xqSTBMRGMzTGprME1TQXRNakF5TGpZMExERTVOeTR4TkRVZ2JDQXhNekF1TWl3d0lnb2dJQ0FnSUNBZ0lDQWdJQ0FnYVc1cmMyTmhjR1U2WTI5dWJtVmpkRzl5TFdOMWNuWmhkSFZ5WlQwaU1DSUtJQ0FnSUNBZ0lDQWdJQ0FnSUdsa1BTSndZWFJvTWpJaUNpQWdJQ0FnSUNBZ0lDQWdJQ0J6ZEhsc1pUMGlabWxzYkRvak9HRTBNVGd5TzJacGJHd3RiM0JoWTJsMGVUb3hPMlpwYkd3dGNuVnNaVHB1YjI1NlpYSnZPM04wY205clpUcHViMjVsSWlBdlBqeHdZWFJvQ2lBZ0lDQWdJQ0FnSUNBZ0lDQmtQU0p0SURJek1ERXVOQ3cyTmpJdU5qazFJR01nTUN3NE1DNDNNRE1nTFRZMkxqazBMREUwTlM0NE1UTWdMVEUwTnk0Mk15d3hORFV1T0RFeklDMDRNeTQwTkN3d0lDMHhORGN1TmpNc0xUWTRMamM0TVNBdE1UUTNMall6TEMweE5URXVNekF4SURBc0xUYzVMamM0TlNBMk5pNDVOQ3d0TVRRMUxqZ3dNU0F4TkRVdU9Dd3RNVFExTGpnd01TQTROQzR6TlN3d0lERTBPUzQwTml3Mk55NDROVElnTVRRNUxqUTJMREUxTVM0eU9Ea2dlaUJ0SUMweExqZ3pMQzB4T0RFdU5UUTNJR01nTFRNMUxqYzNMQzAxTkM0d09UY2dMVGt6TGpVekxDMDNPQzQ0TlRrZ0xURTFOeTQzTWl3dE56Z3VPRFU1SUMweE5EQXVNeXd3SUMweU5URXVNalFzTVRFMkxqUTBPU0F0TWpVeExqSTBMREkxTkM0NU1UZ2dNQ3d4TkRJdU1USTVJREV4TXk0M0xESTJNQzQwTVNBeU5UWXVOelFzTWpZd0xqUXhJRFl6TGpJM0xEQWdNVEU0TGpJNUxDMHlPUzR6TXpZZ01UVXlMakl5TEMwNE1pNDFNak1nYkNBd0xEWTVMalk0TnlBeE56VXVNVFFzTUNBd0xDMHhNRFF1TlRJM0lDMDJNUzQwTkN3d0lEQXNMVEk0TUM0MU9UZ2dOakV1TkRRc01DQXdMQzB4TURRdU5USTNJQzB4TnpVdU1UUXNNQ0F3TERZMkxqQXhPU0lLSUNBZ0lDQWdJQ0FnSUNBZ0lHbHVhM05qWVhCbE9tTnZibTVsWTNSdmNpMWpkWEoyWVhSMWNtVTlJakFpQ2lBZ0lDQWdJQ0FnSUNBZ0lDQnBaRDBpY0dGMGFESTBJZ29nSUNBZ0lDQWdJQ0FnSUNBZ2MzUjViR1U5SW1acGJHdzZJemhoTkRFNE1qdG1hV3hzTFc5d1lXTnBkSGs2TVR0bWFXeHNMWEoxYkdVNmJtOXVlbVZ5Ynp0emRISnZhMlU2Ym05dVpTSWdMejQ4Y0dGMGFBb2dJQ0FnSUNBZ0lDQWdJQ0FnWkQwaWJTQXlOakl5TGpNekxEVTFOeTR5TlRnZ1l5QXpMalkzTEMwME5DNHdNVFlnTXpNdU1ERXNMVGN6TGpNME9DQTNPQzQ0Tml3dE56TXVNelE0SURNekxqa3pMREFnTmpZdU9UTXNNak11T0RJMElEWTJMamt6TERZd0xqVXdOQ0F3TERRNExqWXdOaUF0TkRVdU9EUXNOVFl1T0RVMklDMDRNeTQwTkN3Mk5pNDVOREVnTFRnMUxqSTRMREl5TGpBd05DQXRNVGM0TGpneExEUTRMall3TmlBdE1UYzRMamd4TERFMU5TNDROemtnTUN3NU15NDFNellnTnpndU9EWXNNVFEzTGpZek15QXhOalV1T1Rnc01UUTNMall6TXlBME5Dd3dJRGd6TGpRekxDMDVMakUzTmlBeE1UQXVPVFFzTFRRMExqQXdPQ0JzSURBc016TXVPVEl5SURneUxqVXpMREFnTUN3dE1UTXlMamsyTlNBdE1UQTRMakl4TERBZ1l5QXRNUzQ0TXl3ek5DNDROVFlnTFRJNExqUXlMRFUzTGpjM05DQXROak11TWpZc05UY3VOemMwSUMwek1DNHlOaXd3SUMwMk1pNHpOU3d0TVRjdU5ESXlJQzAyTWk0ek5Td3ROVEV1TXpRNElEQXNMVFExTGpnME55QTBOQzQ1TXl3dE5UVXVPVE1nT0RBdU5qa3NMVFkwTGpFNElEZzRMakF5TEMweU1DNHhOelVnTVRneUxqUTNMQzAwTnk0Mk9UVWdNVGd5TGpRM0xDMHhOVGN1TnpNMElEQXNMVGs1TGpBeU55QXRPRE11TkRRc0xURTFOQzR3TXprZ0xURTNOUzR4TXl3dE1UVTBMakF6T1NBdE5Ea3VOVE1zTUNBdE9UUXVORFlzTVRVdU5UZ3lJQzB4TWpZdU5UVXNOVE11TVRnZ2JDQXdMQzAwTUM0ek5DQXRPRFV1TWpjc01DQXdMREUwTWk0eE1qa2dNVEUwTGpZeUxEQWlDaUFnSUNBZ0lDQWdJQ0FnSUNCcGJtdHpZMkZ3WlRwamIyNXVaV04wYjNJdFkzVnlkbUYwZFhKbFBTSXdJZ29nSUNBZ0lDQWdJQ0FnSUNBZ2FXUTlJbkJoZEdneU5pSUtJQ0FnSUNBZ0lDQWdJQ0FnSUhOMGVXeGxQU0ptYVd4c09pTTRZVFF4T0RJN1ptbHNiQzF2Y0dGamFYUjVPakU3Wm1sc2JDMXlkV3hsT201dmJucGxjbTg3YzNSeWIydGxPbTV2Ym1VaUlDOCtQSEJoZEdnS0lDQWdJQ0FnSUNBZ0lDQWdJR1E5SW0wZ01qazRPQzR4T0N3NE1EQXVNalUwSUMwMk15NHlOaXd3SURBc01UQTBMalV5TnlBeE5qVXVNRFVzTUNBd0xDMDNNeTR6TlRVZ1l5QXpNUzR4T0N3MU1TNHpORGNnTnpndU9EWXNPRFV1TWpjM0lERTBNUzR5TVN3NE5TNHlOemNnTmpjdU9EVXNNQ0F4TWpRdU56RXNMVFF4TGpJMU9DQXhOVEl1TWpFc0xURXdNaTQyT1RrZ01qWXVOaXcyTWk0ek5URWdPVEl1TmpJc01UQXlMalk1T1NBeE5qQXVORGNzTVRBeUxqWTVPU0ExTXk0eE9Td3dJREV3TlM0ME5pd3RNaklnTVRReExqSXhMQzAyTWk0ek5URWdNemd1TlRJc0xUUTBMamt6T0NBek9DNDFNaXd0T1RNdU5UTXlJRE00TGpVeUxDMHhORGt1TkRVM0lHd2dNQ3d0TVRnMUxqSXpPU0EyTXk0eU55d3dJREFzTFRFd05DNDFNamNnTFRJek9DNDBNaXd3SURBc01UQTBMalV5TnlBMk15NHlPQ3d3SURBc01UVTNMamN4TlNCaklEQXNNekl1TVRBeUlEQXNOakF1TlRJM0lDMHhOQzQyTnl3NE9DNDVOVGNnTFRFNExqTTBMREkyTGpVNE1pQXRORGd1TmpFc05EQXVNelEwSUMwM09TNDNOeXcwTUM0ek5EUWdMVE13TGpJMkxEQWdMVFl6TGpJNExDMHhNaTQ0TkRRZ0xUZ3lMalV6TEMwek5pNDJOeklnTFRJeUxqa3pMQzB5T1M0ek5UVWdMVEl5TGprekxDMDFOaTQ0TmpNZ0xUSXlMamt6TEMwNU1pNDJNamtnYkNBd0xDMHhOVGN1TnpFMUlEWXpMakkzTERBZ01Dd3RNVEEwTGpVeU55QXRNak00TGpReExEQWdNQ3d4TURRdU5USTNJRFl6TGpJNExEQWdNQ3d4TlRBdU16Z3pJR01nTUN3eU9TNHpORGdnTUN3Mk5pNHdNak1nTFRFMExqWTNMRGt4TGpZNU9TQXRNVFV1TlRrc01qa3VNek0ySUMwME55NDJPU3cwTkM0NU16UWdMVGd3TGpjc05EUXVPVE0wSUMwek1TNHhPQ3d3SUMwMU55NDNOeXd0TVRFdU1EQTRJQzAzTnk0NU5Dd3RNelV1TnpjMElDMHlOQzQzTnl3dE16QXVNalV6SUMweU5pNDJMQzAyTWk0ek5ETWdMVEkyTGpZc0xUazVMamswTVNCc0lEQXNMVEUxTVM0ek1ERWdOak11TWpjc01DQXdMQzB4TURRdU5USTNJQzB5TXpndU5Dd3dJREFzTVRBMExqVXlOeUEyTXk0eU5pd3dJREFzTWpnd0xqVTVPQ0lLSUNBZ0lDQWdJQ0FnSUNBZ0lHbHVhM05qWVhCbE9tTnZibTVsWTNSdmNpMWpkWEoyWVhSMWNtVTlJakFpQ2lBZ0lDQWdJQ0FnSUNBZ0lDQnBaRDBpY0dGMGFESTRJZ29nSUNBZ0lDQWdJQ0FnSUNBZ2MzUjViR1U5SW1acGJHdzZJemhoTkRFNE1qdG1hV3hzTFc5d1lXTnBkSGs2TVR0bWFXeHNMWEoxYkdVNmJtOXVlbVZ5Ynp0emRISnZhMlU2Ym05dVpTSWdMejQ4Y0dGMGFBb2dJQ0FnSUNBZ0lDQWdJQ0FnWkQwaWJTQXpPVGs0TGpZMkxEazFNUzQxTkRjZ0xURXhNUzQ0Tnl3d0lEQXNNVEU0TGpJNU15QXhNVEV1T0Rjc01DQXdMQzB4TVRndU1qa3pJSG9nYlNBd0xDMDBNekV1T0RreElEWXpMakkzTERBZ01Dd3RNVEEwTGpVeU55QXRNak01TGpNekxEQWdNQ3d4TURRdU5USTNJRFkwTGpFNUxEQWdNQ3d5T0RBdU5UazRJQzAyTXk0eU55d3dJREFzTVRBMExqVXlOeUF4TnpVdU1UUXNNQ0F3TEMwek9EVXVNVEkxSWdvZ0lDQWdJQ0FnSUNBZ0lDQWdhVzVyYzJOaGNHVTZZMjl1Ym1WamRHOXlMV04xY25aaGRIVnlaVDBpTUNJS0lDQWdJQ0FnSUNBZ0lDQWdJR2xrUFNKd1lYUm9NekFpQ2lBZ0lDQWdJQ0FnSUNBZ0lDQnpkSGxzWlQwaVptbHNiRG9qT0dFME1UZ3lPMlpwYkd3dGIzQmhZMmwwZVRveE8yWnBiR3d0Y25Wc1pUcHViMjU2WlhKdk8zTjBjbTlyWlRwdWIyNWxJaUF2UGp4d1lYUm9DaUFnSUNBZ0lDQWdJQ0FnSUNCa1BTSnRJRFF4TlRrdU1USXNPREF3TGpJMU5DQXROak11TWpjc01DQXdMREV3TkM0MU1qY2dNVGMxTGpFMExEQWdNQ3d0TmprdU5qZzNJR01nTWprdU16VXNOVFF1TVRBeElEZzBMak0yTERnd0xqWTVPU0F4TkRRdU9EY3NPREF1TmprNUlEVXpMakU1TERBZ01UQTFMalExTEMweU1pNHdNVFlnTVRReExqSXlMQzAyTUM0MU1qY2dOREF1TXpRc0xUUTBMamt6TkNBME1TNHlOaXd0T0RndU1ETXlJRFF4TGpJMkxDMHhORE11T1RVM0lHd2dNQ3d0TVRreExqWTFNeUEyTXk0eU55d3dJREFzTFRFd05DNDFNamNnTFRJek9DNDBMREFnTUN3eE1EUXVOVEkzSURZekxqSTJMREFnTUN3eE5UZ3VOak0zSUdNZ01Dd3pNQzR5TmpJZ01DdzJNUzQwTXpRZ0xURTVMakkyTERnNExqQXpOU0F0TWpBdU1UY3NNall1TlRneUlDMDFNeTR4T0N3ek9TNDBNVFFnTFRnMkxqRTVMRE01TGpReE5DQXRNek11T1RNc01DQXROamd1Tnpjc0xURXpMamMxSUMwNE9DNDVOQ3d0TkRFdU1qVWdMVEl4TGpBNUxDMHlOeTQxSUMweU1TNHdPU3d0TmprdU5qZzNJQzB5TVM0d09Td3RNVEF5TGpjd055QnNJREFzTFRFME1pNHhNamtnTmpNdU1qWXNNQ0F3TEMweE1EUXVOVEkzSUMweU16Z3VOQ3d3SURBc01UQTBMalV5TnlBMk15NHlOeXd3SURBc01qZ3dMalU1T0NJS0lDQWdJQ0FnSUNBZ0lDQWdJR2x1YTNOallYQmxPbU52Ym01bFkzUnZjaTFqZFhKMllYUjFjbVU5SWpBaUNpQWdJQ0FnSUNBZ0lDQWdJQ0JwWkQwaWNHRjBhRE15SWdvZ0lDQWdJQ0FnSUNBZ0lDQWdjM1I1YkdVOUltWnBiR3c2SXpoaE5ERTRNanRtYVd4c0xXOXdZV05wZEhrNk1UdG1hV3hzTFhKMWJHVTZibTl1ZW1WeWJ6dHpkSEp2YTJVNmJtOXVaU0lnTHo0OGNHRjBhQW9nSUNBZ0lDQWdJQ0FnSUNBZ1pEMGliU0ExTURneUxqUTRMRGN3TXk0NU5qVWdZeUF0TVRrdU1qUXNOekF1TmpBMUlDMDRNUzQyTERFeE5TNDFORGNnTFRFMU5DNHdOQ3d4TVRVdU5UUTNJQzAyTmk0d05Dd3dJQzB4TWprdU15d3ROVEV1TXpRNElDMHhORE11TURVc0xURXhOUzQxTkRjZ2JDQXlPVGN1TURrc01DQjZJRzBnT0RVdU1qY3NMVEUwTkM0NE9ETWdZeUF0TXpndU5URXNMVGt6TGpVeU15QXRNVEk1TGpJM0xDMHhOVFl1TnpreklDMHlNekV1TURVc0xURTFOaTQzT1RNZ0xURTBNeTR3Tnl3d0lDMHlOVGN1Tmpnc01URXhMamczTVNBdE1qVTNMalk0TERJMU5TNDRNellnTUN3eE5EUXVPRGd6SURFd09TNHhNaXd5TmpFdU16STRJREkxTkM0NU1Td3lOakV1TXpJNElEWTNMamczTERBZ01UTTFMamN5TEMwek1DNHlOVGdnTVRnekxqTTVMQzAzT0M0NE5qTWdORGd1TmpJc0xUVXhMak0wTkNBMk9DNDNPU3d0TVRFekxqWTVOU0EyT0M0M09Td3RNVGd6TGpNNE15QnNJQzB6TGpZM0xDMHpPUzQwTXpRZ0xUTTVOaTR4TXl3d0lHTWdNVFF1Tmpjc0xUWTNMamcyTXlBM055NHdNeXd0TVRFM0xqTTJNeUF4TkRZdU56SXNMVEV4Tnk0ek5qTWdORGd1TlRrc01DQTVNQzQzTml3eE9DNHpNamdnTVRFNExqSTRMRFU0TGpZM01pQnNJREV4Tmk0ME5Dd3dJZ29nSUNBZ0lDQWdJQ0FnSUNBZ2FXNXJjMk5oY0dVNlkyOXVibVZqZEc5eUxXTjFjblpoZEhWeVpUMGlNQ0lLSUNBZ0lDQWdJQ0FnSUNBZ0lHbGtQU0p3WVhSb016UWlDaUFnSUNBZ0lDQWdJQ0FnSUNCemRIbHNaVDBpWm1sc2JEb2pPR0UwTVRneU8yWnBiR3d0YjNCaFkybDBlVG94TzJacGJHd3RjblZzWlRwdWIyNTZaWEp2TzNOMGNtOXJaVHB1YjI1bElpQXZQanh3WVhSb0NpQWdJQ0FnSUNBZ0lDQWdJQ0JrUFNKdElEWTVNQzQ0T1RVc09EVXdMamN3TXlBNU1DNDNOU3d3SURJeUxqVTBNeXd6TVM0d016VWdNQ3d5TkRNdU1USXlJQzB4TXpVdU9ESTVMREFnTUN3dE1qUXpMakUwTVNBeU1pNDFNellzTFRNeExqQXhOaUlLSUNBZ0lDQWdJQ0FnSUNBZ0lHbHVhM05qWVhCbE9tTnZibTVsWTNSdmNpMWpkWEoyWVhSMWNtVTlJakFpQ2lBZ0lDQWdJQ0FnSUNBZ0lDQnBaRDBpY0dGMGFETTJJZ29nSUNBZ0lDQWdJQ0FnSUNBZ2MzUjViR1U5SW1acGJHdzZJemhoTkRFNE1qdG1hV3hzTFc5d1lXTnBkSGs2TVR0bWFXeHNMWEoxYkdVNmJtOXVlbVZ5Ynp0emRISnZhMlU2Ym05dVpTSWdMejQ4Y0dGMGFBb2dJQ0FnSUNBZ0lDQWdJQ0FnWkQwaWJTQTJNekl1TXprMUxEYzBNaTR5TlRnZ01qZ3VNRE01TERnMkxqTXdOQ0F0TWpJdU5UVXhMRE14TGpBMElDMHlNekV1TWpJekxEYzFMakV5T0NBdE5ERXVPVGMyTEMweE1qa3VNVGd6SURJek1TNHlOVGNzTFRjMUxqRXpOeUF6Tmk0ME5UUXNNVEV1T0RRNElnb2dJQ0FnSUNBZ0lDQWdJQ0FnYVc1cmMyTmhjR1U2WTI5dWJtVmpkRzl5TFdOMWNuWmhkSFZ5WlQwaU1DSUtJQ0FnSUNBZ0lDQWdJQ0FnSUdsa1BTSndZWFJvTXpnaUNpQWdJQ0FnSUNBZ0lDQWdJQ0J6ZEhsc1pUMGlabWxzYkRvak9HRTBNVGd5TzJacGJHd3RiM0JoWTJsMGVUb3hPMlpwYkd3dGNuVnNaVHB1YjI1NlpYSnZPM04wY205clpUcHViMjVsSWlBdlBqeHdZWFJvQ2lBZ0lDQWdJQ0FnSUNBZ0lDQmtQU0p0SURjeE55NDBORGtzTmpVekxqRXdOU0F0TnpNdU5ERXNOVE11TXpZZ0xUTTJMalE0T0N3dE1URXVPRGMxSUMweE5ESXVPVEF6TEMweE9UWXVOamt5SURFd09TNDRPRE1zTFRjNUxqZ3lPQ0F4TkRJdU9URTRMREU1Tmk0M01ETWdNQ3d6T0M0ek16SWlDaUFnSUNBZ0lDQWdJQ0FnSUNCcGJtdHpZMkZ3WlRwamIyNXVaV04wYjNJdFkzVnlkbUYwZFhKbFBTSXdJZ29nSUNBZ0lDQWdJQ0FnSUNBZ2FXUTlJbkJoZEdnME1DSUtJQ0FnSUNBZ0lDQWdJQ0FnSUhOMGVXeGxQU0ptYVd4c09pTTRZVFF4T0RJN1ptbHNiQzF2Y0dGamFYUjVPakU3Wm1sc2JDMXlkV3hsT201dmJucGxjbTg3YzNSeWIydGxPbTV2Ym1VaUlDOCtQSEJoZEdnS0lDQWdJQ0FnSUNBZ0lDQWdJR1E5SW0wZ09ESTRMalV5TERjd05pNDBOalVnTFRjekxqUXlOaXd0TlRNdU16UWdNQzR3TVRFc0xUTTRMak0xT1NCTUlEZzVPQzR3TURRc05ERTRMakEzSURFd01EY3VPU3cwT1RjdU9EazRJRGcyTkM0NU56TXNOamswTGpZd09TQTRNamd1TlRJc056QTJMalEyTlNJS0lDQWdJQ0FnSUNBZ0lDQWdJR2x1YTNOallYQmxPbU52Ym01bFkzUnZjaTFqZFhKMllYUjFjbVU5SWpBaUNpQWdJQ0FnSUNBZ0lDQWdJQ0JwWkQwaWNHRjBhRFF5SWdvZ0lDQWdJQ0FnSUNBZ0lDQWdjM1I1YkdVOUltWnBiR3c2SXpoaE5ERTRNanRtYVd4c0xXOXdZV05wZEhrNk1UdG1hV3hzTFhKMWJHVTZibTl1ZW1WeWJ6dHpkSEp2YTJVNmJtOXVaU0lnTHo0OGNHRjBhQW9nSUNBZ0lDQWdJQ0FnSUNBZ1pEMGliU0E0TVRJdU1EZzJMRGd5T0M0MU9EWWdNamd1TURVMUxDMDROaTR6TWlBek5pNDBPRFFzTFRFeExqZ3pOaUF5TXpFdU1qSTFMRGMxTGpFeE55QXROREV1T1Rjc01USTVMakU0TXlBdE1qTXhMakl6T1N3dE56VXVNVFFnTFRJeUxqVTFOU3d0TXpFdU1EQTBJZ29nSUNBZ0lDQWdJQ0FnSUNBZ2FXNXJjMk5oY0dVNlkyOXVibVZqZEc5eUxXTjFjblpoZEhWeVpUMGlNQ0lLSUNBZ0lDQWdJQ0FnSUNBZ0lHbGtQU0p3WVhSb05EUWlDaUFnSUNBZ0lDQWdJQ0FnSUNCemRIbHNaVDBpWm1sc2JEb2pPR0UwTVRneU8yWnBiR3d0YjNCaFkybDBlVG94TzJacGJHd3RjblZzWlRwdWIyNTZaWEp2TzNOMGNtOXJaVHB1YjI1bElpQXZQanh3WVhSb0NpQWdJQ0FnSUNBZ0lDQWdJQ0JrUFNKdElEY3pOaTR6TURFc01UTXpOUzQ0T0NCaklDMHpNak11TURRM0xEQWdMVFU0TlM0NE56VXNMVEkyTWk0M09DQXROVGcxTGpnM05Td3ROVGcxTGpjNE1pQXdMQzB6TWpNdU1URTRJREkyTWk0NE1qZ3NMVFU0TlM0NU56Y2dOVGcxTGpnM05Td3ROVGcxTGprM055QXpNak11TURFNUxEQWdOVGcxTGpnd09Td3lOakl1T0RVNUlEVTROUzQ0TURrc05UZzFMamszTnlBd0xETXlNeTR3TURJZ0xUSTJNaTQzT1N3MU9EVXVOemd5SUMwMU9EVXVPREE1TERVNE5TNDNPRElnYkNBd0xEQWdlaUJ0SURBc0xURXhPQzQyTVNCaklESTFOeTQ1TnpJc01DQTBOamN1TVRnNUxDMHlNRGt1TVRNZ05EWTNMakU0T1N3dE5EWTNMakUzTWlBd0xDMHlOVGd1TVRJNUlDMHlNRGt1TWpFM0xDMDBOamN1TXpRNElDMDBOamN1TVRnNUxDMDBOamN1TXpRNElDMHlOVGd1TURjMExEQWdMVFEyTnk0eU5UUXNNakE1TGpJeE9TQXRORFkzTGpJMU5DdzBOamN1TXpRNElEQXNNalU0TGpBME1pQXlNRGt1TVRnc05EWTNMakUzTWlBME5qY3VNalUwTERRMk55NHhOeklpQ2lBZ0lDQWdJQ0FnSUNBZ0lDQnBibXR6WTJGd1pUcGpiMjV1WldOMGIzSXRZM1Z5ZG1GMGRYSmxQU0l3SWdvZ0lDQWdJQ0FnSUNBZ0lDQWdhV1E5SW5CaGRHZzBOaUlLSUNBZ0lDQWdJQ0FnSUNBZ0lITjBlV3hsUFNKbWFXeHNPaU00WVRReE9ESTdabWxzYkMxdmNHRmphWFI1T2pFN1ptbHNiQzF5ZFd4bE9tNXZibnBsY204N2MzUnliMnRsT201dmJtVWlJQzgrUEhCaGRHZ0tJQ0FnSUNBZ0lDQWdJQ0FnSUdROUltMGdNVEE1TVM0eE15dzJNVGt1T0RneklDMHhOelV1TnpjeExEVTNMakV5TVNBeE1TNDJNamtzTXpVdU9EQTRJREUzTlM0M05qSXNMVFUzTGpFeU1TQXRNVEV1TmpJc0xUTTFMamd3T0NJS0lDQWdJQ0FnSUNBZ0lDQWdJR2x1YTNOallYQmxPbU52Ym01bFkzUnZjaTFqZFhKMllYUjFjbVU5SWpBaUNpQWdJQ0FnSUNBZ0lDQWdJQ0JwWkQwaWNHRjBhRFE0SWdvZ0lDQWdJQ0FnSUNBZ0lDQWdjM1I1YkdVOUltWnBiR3c2SXpoaE5ERTRNanRtYVd4c0xXOXdZV05wZEhrNk1UdG1hV3hzTFhKMWJHVTZibTl1ZW1WeWJ6dHpkSEp2YTJVNmJtOXVaU0lnTHo0OGNHRjBhQW9nSUNBZ0lDQWdJQ0FnSUNBZ1pEMGlUU0E0TmpZdU9UVTNMRGt3TWk0d056UWdPRE0yTGpVc09USTBMakU1T1NBNU5EVXVNVEl4TERFd056TXVOek1nT1RjMUxqVTROaXd4TURVeExqWXhJRGcyTmk0NU5UY3NPVEF5TGpBM05DSUtJQ0FnSUNBZ0lDQWdJQ0FnSUdsdWEzTmpZWEJsT21OdmJtNWxZM1J2Y2kxamRYSjJZWFIxY21VOUlqQWlDaUFnSUNBZ0lDQWdJQ0FnSUNCcFpEMGljR0YwYURVd0lnb2dJQ0FnSUNBZ0lDQWdJQ0FnYzNSNWJHVTlJbVpwYkd3Nkl6aGhOREU0TWp0bWFXeHNMVzl3WVdOcGRIazZNVHRtYVd4c0xYSjFiR1U2Ym05dWVtVnlienR6ZEhKdmEyVTZibTl1WlNJZ0x6NDhjR0YwYUFvZ0lDQWdJQ0FnSUNBZ0lDQWdaRDBpVFNBMk1EY3VORFkxTERrd015NDBORFVnTkRrNExqZzFOU3d4TURVeUxqazNJRFV5T1M0ek1pd3hNRGMxTGpFZ05qTTNMamt6TERreU5TNDFOallnTmpBM0xqUTJOU3c1TURNdU5EUTFJZ29nSUNBZ0lDQWdJQ0FnSUNBZ2FXNXJjMk5oY0dVNlkyOXVibVZqZEc5eUxXTjFjblpoZEhWeVpUMGlNQ0lLSUNBZ0lDQWdJQ0FnSUNBZ0lHbGtQU0p3WVhSb05USWlDaUFnSUNBZ0lDQWdJQ0FnSUNCemRIbHNaVDBpWm1sc2JEb2pPR0UwTVRneU8yWnBiR3d0YjNCaFkybDBlVG94TzJacGJHd3RjblZzWlRwdWIyNTZaWEp2TzNOMGNtOXJaVHB1YjI1bElpQXZQanh3WVhSb0NpQWdJQ0FnSUNBZ0lDQWdJQ0JrUFNKdElETTRNQzQyT0Rnc05qSXlMakV5T1NBdE1URXVOakkyTERNMUxqZ3dNU0F4TnpVdU56VTRMRFUzTGpBNUlERXhMall5TVN3dE16VXVPREF4SUMweE56VXVOelV6TEMwMU55NHdPU0lLSUNBZ0lDQWdJQ0FnSUNBZ0lHbHVhM05qWVhCbE9tTnZibTVsWTNSdmNpMWpkWEoyWVhSMWNtVTlJakFpQ2lBZ0lDQWdJQ0FnSUNBZ0lDQnBaRDBpY0dGMGFEVTBJZ29nSUNBZ0lDQWdJQ0FnSUNBZ2MzUjViR1U5SW1acGJHdzZJemhoTkRFNE1qdG1hV3hzTFc5d1lXTnBkSGs2TVR0bWFXeHNMWEoxYkdVNmJtOXVlbVZ5Ynp0emRISnZhMlU2Ym05dVpTSWdMejQ4Y0dGMGFBb2dJQ0FnSUNBZ0lDQWdJQ0FnWkQwaWJTQTNNVFl1TWpnNUxETTNOaTQxT1NBek55NDJOREEyTERBZ01Dd3hPRFF1T0RFMklDMHpOeTQyTkRBMkxEQWdNQ3d0TVRnMExqZ3hOaUI2SWdvZ0lDQWdJQ0FnSUNBZ0lDQWdhVzVyYzJOaGNHVTZZMjl1Ym1WamRHOXlMV04xY25aaGRIVnlaVDBpTUNJS0lDQWdJQ0FnSUNBZ0lDQWdJR2xrUFNKd1lYUm9OVFlpQ2lBZ0lDQWdJQ0FnSUNBZ0lDQnpkSGxzWlQwaVptbHNiRG9qT0dFME1UZ3lPMlpwYkd3dGIzQmhZMmwwZVRveE8yWnBiR3d0Y25Wc1pUcHViMjU2WlhKdk8zTjBjbTlyWlRwdWIyNWxJaUF2UGp3dlp6NDhMMmMrUEM5blBqd3ZaejQ4TDNOMlp6ND0nKSBuby1yZXBlYXQsIG5vbmU7IC1tb3otYmFja2dyb3VuZC1zaXplOiAxMDAlOyAtby1iYWNrZ3JvdW5kLXNpemU6IDEwMCU7IC13ZWJraXQtYmFja2dyb3VuZC1zaXplOiAxMDAlOyBiYWNrZ3JvdW5kLXNpemU6IDEwMCU7IGRpc3BsYXk6IGJsb2NrOyBmbG9hdDogbGVmdDsgd2lkdGg6IDkwcHg7IGhlaWdodDogMjVweDsgfVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmJhbm5lciAudmVyc2lvbiB7IG1hcmdpbi1sZWZ0OiAxNHB4OyBwb3NpdGlvbjogcmVsYXRpdmU7IHRvcDogNnB4OyB9XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAjamFzbWluZV9jb250ZW50IHsgcG9zaXRpb246IGZpeGVkOyByaWdodDogMTAwJTsgfVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLnZlcnNpb24geyBjb2xvcjogI2FhYTsgfVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmJhbm5lciB7IG1hcmdpbi10b3A6IDE0cHg7IH1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5kdXJhdGlvbiB7IGNvbG9yOiAjZmZmOyBmbG9hdDogcmlnaHQ7IGxpbmUtaGVpZ2h0OiAyOHB4OyBwYWRkaW5nLXJpZ2h0OiA5cHg7IH1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5zeW1ib2wtc3VtbWFyeSB7IG92ZXJmbG93OiBoaWRkZW47ICp6b29tOiAxOyBtYXJnaW46IDE0cHggMDsgfVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLnN5bWJvbC1zdW1tYXJ5IGxpIHsgZGlzcGxheTogaW5saW5lLWJsb2NrOyBoZWlnaHQ6IDhweDsgd2lkdGg6IDE0cHg7IGZvbnQtc2l6ZTogMTZweDsgfVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLnN5bWJvbC1zdW1tYXJ5IGxpLnBhc3NlZCB7IGZvbnQtc2l6ZTogMTRweDsgfVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLnN5bWJvbC1zdW1tYXJ5IGxpLnBhc3NlZDpiZWZvcmUgeyBjb2xvcjogIzAwNzA2OTsgY29udGVudDogXFxcIlxcXFwyMDIyXFxcIjsgfVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLnN5bWJvbC1zdW1tYXJ5IGxpLmZhaWxlZCB7IGxpbmUtaGVpZ2h0OiA5cHg7IH1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5zeW1ib2wtc3VtbWFyeSBsaS5mYWlsZWQ6YmVmb3JlIHsgY29sb3I6ICNjYTNhMTE7IGNvbnRlbnQ6IFxcXCJcXFxcRDdcXFwiOyBmb250LXdlaWdodDogYm9sZDsgbWFyZ2luLWxlZnQ6IC0xcHg7IH1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5zeW1ib2wtc3VtbWFyeSBsaS5kaXNhYmxlZCB7IGZvbnQtc2l6ZTogMTRweDsgfVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLnN5bWJvbC1zdW1tYXJ5IGxpLmRpc2FibGVkOmJlZm9yZSB7IGNvbG9yOiAjYmFiYWJhOyBjb250ZW50OiBcXFwiXFxcXDIwMjJcXFwiOyB9XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuc3ltYm9sLXN1bW1hcnkgbGkucGVuZGluZyB7IGxpbmUtaGVpZ2h0OiAxN3B4OyB9XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuc3ltYm9sLXN1bW1hcnkgbGkucGVuZGluZzpiZWZvcmUgeyBjb2xvcjogI2JhOWQzNzsgY29udGVudDogXFxcIipcXFwiOyB9XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuc3ltYm9sLXN1bW1hcnkgbGkuZW1wdHkgeyBmb250LXNpemU6IDE0cHg7IH1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5zeW1ib2wtc3VtbWFyeSBsaS5lbXB0eTpiZWZvcmUgeyBjb2xvcjogI2JhOWQzNzsgY29udGVudDogXFxcIlxcXFwyMDIyXFxcIjsgfVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLnJ1bi1vcHRpb25zIHsgZmxvYXQ6IHJpZ2h0OyBtYXJnaW4tcmlnaHQ6IDVweDsgYm9yZGVyOiAxcHggc29saWQgIzhhNDE4MjsgY29sb3I6ICM4YTQxODI7IHBvc2l0aW9uOiByZWxhdGl2ZTsgbGluZS1oZWlnaHQ6IDIwcHg7IH1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5ydW4tb3B0aW9ucyAudHJpZ2dlciB7IGN1cnNvcjogcG9pbnRlcjsgcGFkZGluZzogOHB4IDE2cHg7IH1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5ydW4tb3B0aW9ucyAucGF5bG9hZCB7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgZGlzcGxheTogbm9uZTsgcmlnaHQ6IC0xcHg7IGJvcmRlcjogMXB4IHNvbGlkICM4YTQxODI7IGJhY2tncm91bmQtY29sb3I6ICNlZWU7IHdoaXRlLXNwYWNlOiBub3dyYXA7IHBhZGRpbmc6IDRweCA4cHg7IH1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5ydW4tb3B0aW9ucyAucGF5bG9hZC5vcGVuIHsgZGlzcGxheTogYmxvY2s7IH1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5iYXIgeyBsaW5lLWhlaWdodDogMjhweDsgZm9udC1zaXplOiAxNHB4OyBkaXNwbGF5OiBibG9jazsgY29sb3I6ICNlZWU7IH1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5iYXIuZmFpbGVkIHsgYmFja2dyb3VuZC1jb2xvcjogI2NhM2ExMTsgfVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmJhci5wYXNzZWQgeyBiYWNrZ3JvdW5kLWNvbG9yOiAjMDA3MDY5OyB9XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuYmFyLnNraXBwZWQgeyBiYWNrZ3JvdW5kLWNvbG9yOiAjYmFiYWJhOyB9XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuYmFyLmVycm9yZWQgeyBiYWNrZ3JvdW5kLWNvbG9yOiAjY2EzYTExOyB9XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuYmFyLm1lbnUgeyBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmOyBjb2xvcjogI2FhYTsgfVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmJhci5tZW51IGEgeyBjb2xvcjogIzMzMzsgfVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmJhciBhIHsgY29sb3I6IHdoaXRlOyB9XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlci5zcGVjLWxpc3QgLmJhci5tZW51LmZhaWx1cmUtbGlzdCwgLmphc21pbmVfaHRtbC1yZXBvcnRlci5zcGVjLWxpc3QgLnJlc3VsdHMgLmZhaWx1cmVzIHsgZGlzcGxheTogbm9uZTsgfVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIuZmFpbHVyZS1saXN0IC5iYXIubWVudS5zcGVjLWxpc3QsIC5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIuZmFpbHVyZS1saXN0IC5zdW1tYXJ5IHsgZGlzcGxheTogbm9uZTsgfVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLnJlc3VsdHMgeyBtYXJnaW4tdG9wOiAxNHB4OyB9XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuc3VtbWFyeSB7IG1hcmdpbi10b3A6IDE0cHg7IH1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5zdW1tYXJ5IHVsIHsgbGlzdC1zdHlsZS10eXBlOiBub25lOyBtYXJnaW4tbGVmdDogMTRweDsgcGFkZGluZy10b3A6IDA7IHBhZGRpbmctbGVmdDogMDsgfVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLnN1bW1hcnkgdWwuc3VpdGUgeyBtYXJnaW4tdG9wOiA3cHg7IG1hcmdpbi1ib3R0b206IDdweDsgfVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLnN1bW1hcnkgbGkucGFzc2VkIGEgeyBjb2xvcjogIzAwNzA2OTsgfVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLnN1bW1hcnkgbGkuZmFpbGVkIGEgeyBjb2xvcjogI2NhM2ExMTsgfVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLnN1bW1hcnkgbGkuZW1wdHkgYSB7IGNvbG9yOiAjYmE5ZDM3OyB9XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuc3VtbWFyeSBsaS5wZW5kaW5nIGEgeyBjb2xvcjogI2JhOWQzNzsgfVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLnN1bW1hcnkgbGkuZGlzYWJsZWQgYSB7IGNvbG9yOiAjYmFiYWJhOyB9XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuZGVzY3JpcHRpb24gKyAuc3VpdGUgeyBtYXJnaW4tdG9wOiAwOyB9XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuc3VpdGUgeyBtYXJnaW4tdG9wOiAxNHB4OyB9XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuc3VpdGUgYSB7IGNvbG9yOiAjMzMzOyB9XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuZmFpbHVyZXMgLnNwZWMtZGV0YWlsIHsgbWFyZ2luLWJvdHRvbTogMjhweDsgfVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmZhaWx1cmVzIC5zcGVjLWRldGFpbCAuZGVzY3JpcHRpb24geyBiYWNrZ3JvdW5kLWNvbG9yOiAjY2EzYTExOyB9XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuZmFpbHVyZXMgLnNwZWMtZGV0YWlsIC5kZXNjcmlwdGlvbiBhIHsgY29sb3I6IHdoaXRlOyB9XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAucmVzdWx0LW1lc3NhZ2UgeyBwYWRkaW5nLXRvcDogMTRweDsgY29sb3I6ICMzMzM7IHdoaXRlLXNwYWNlOiBwcmU7IH1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5yZXN1bHQtbWVzc2FnZSBzcGFuLnJlc3VsdCB7IGRpc3BsYXk6IGJsb2NrOyB9XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuc3RhY2stdHJhY2UgeyBtYXJnaW46IDVweCAwIDAgMDsgbWF4LWhlaWdodDogMjI0cHg7IG92ZXJmbG93OiBhdXRvOyBsaW5lLWhlaWdodDogMThweDsgY29sb3I6ICM2NjY7IGJvcmRlcjogMXB4IHNvbGlkICNkZGQ7IGJhY2tncm91bmQ6IHdoaXRlOyB3aGl0ZS1zcGFjZTogcHJlOyB9XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY3NzLWxvYWRlciEuL3NyYy9saWIvamFzbWluZS0yLjMuNC9qYXNtaW5lLmNzc1xuICoqIG1vZHVsZSBpZCA9IDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGxpc3QgPSBbXTtcclxuXHJcblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xyXG5cdGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcclxuXHRcdHZhciByZXN1bHQgPSBbXTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBpdGVtID0gdGhpc1tpXTtcclxuXHRcdFx0aWYoaXRlbVsyXSkge1xyXG5cdFx0XHRcdHJlc3VsdC5wdXNoKFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgaXRlbVsxXSArIFwifVwiKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRyZXN1bHQucHVzaChpdGVtWzFdKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJlc3VsdC5qb2luKFwiXCIpO1xyXG5cdH07XHJcblxyXG5cdC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XHJcblx0bGlzdC5pID0gZnVuY3Rpb24obW9kdWxlcywgbWVkaWFRdWVyeSkge1xyXG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXHJcblx0XHRcdG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIFwiXCJdXTtcclxuXHRcdHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaWQgPSB0aGlzW2ldWzBdO1xyXG5cdFx0XHRpZih0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIpXHJcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xyXG5cdFx0fVxyXG5cdFx0Zm9yKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XHJcblx0XHRcdC8vIHNraXAgYWxyZWFkeSBpbXBvcnRlZCBtb2R1bGVcclxuXHRcdFx0Ly8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcclxuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cclxuXHRcdFx0Ly8gIEkgaG9wZSB0aGlzIHdpbGwgbmV2ZXIgb2NjdXIgKEhleSB0aGlzIHdheSB3ZSBoYXZlIHNtYWxsZXIgYnVuZGxlcylcclxuXHRcdFx0aWYodHlwZW9mIGl0ZW1bMF0gIT09IFwibnVtYmVyXCIgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcclxuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XHJcblx0XHRcdFx0XHRpdGVtWzJdID0gbWVkaWFRdWVyeTtcclxuXHRcdFx0XHR9IGVsc2UgaWYobWVkaWFRdWVyeSkge1xyXG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRsaXN0LnB1c2goaXRlbSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG5cdHJldHVybiBsaXN0O1xyXG59O1xyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1xuICoqIG1vZHVsZSBpZCA9IDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbnZhciBzdHlsZXNJbkRvbSA9IHt9LFxyXG5cdG1lbW9pemUgPSBmdW5jdGlvbihmbikge1xyXG5cdFx0dmFyIG1lbW87XHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRpZiAodHlwZW9mIG1lbW8gPT09IFwidW5kZWZpbmVkXCIpIG1lbW8gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG5cdFx0XHRyZXR1cm4gbWVtbztcclxuXHRcdH07XHJcblx0fSxcclxuXHRpc09sZElFID0gbWVtb2l6ZShmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiAvbXNpZSBbNi05XVxcYi8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKTtcclxuXHR9KSxcclxuXHRnZXRIZWFkRWxlbWVudCA9IG1lbW9pemUoZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdO1xyXG5cdH0pLFxyXG5cdHNpbmdsZXRvbkVsZW1lbnQgPSBudWxsLFxyXG5cdHNpbmdsZXRvbkNvdW50ZXIgPSAwLFxyXG5cdHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wID0gW107XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcclxuXHRpZih0eXBlb2YgREVCVUcgIT09IFwidW5kZWZpbmVkXCIgJiYgREVCVUcpIHtcclxuXHRcdGlmKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xyXG5cdH1cclxuXHJcblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblx0Ly8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XHJcblx0Ly8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxyXG5cdGlmICh0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24gPT09IFwidW5kZWZpbmVkXCIpIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xyXG5cclxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSBib3R0b20gb2YgPGhlYWQ+LlxyXG5cdGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJ1bmRlZmluZWRcIikgb3B0aW9ucy5pbnNlcnRBdCA9IFwiYm90dG9tXCI7XHJcblxyXG5cdHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCk7XHJcblx0YWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XHJcblx0XHR2YXIgbWF5UmVtb3ZlID0gW107XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xyXG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcclxuXHRcdFx0ZG9tU3R5bGUucmVmcy0tO1xyXG5cdFx0XHRtYXlSZW1vdmUucHVzaChkb21TdHlsZSk7XHJcblx0XHR9XHJcblx0XHRpZihuZXdMaXN0KSB7XHJcblx0XHRcdHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCk7XHJcblx0XHRcdGFkZFN0eWxlc1RvRG9tKG5ld1N0eWxlcywgb3B0aW9ucyk7XHJcblx0XHR9XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBkb21TdHlsZSA9IG1heVJlbW92ZVtpXTtcclxuXHRcdFx0aWYoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xyXG5cdFx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKylcclxuXHRcdFx0XHRcdGRvbVN0eWxlLnBhcnRzW2pdKCk7XHJcblx0XHRcdFx0ZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucykge1xyXG5cdGZvcih2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xyXG5cdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XHJcblx0XHRpZihkb21TdHlsZSkge1xyXG5cdFx0XHRkb21TdHlsZS5yZWZzKys7XHJcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzW2pdKGl0ZW0ucGFydHNbal0pO1xyXG5cdFx0XHR9XHJcblx0XHRcdGZvcig7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0ZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHZhciBwYXJ0cyA9IFtdO1xyXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHN0eWxlc0luRG9tW2l0ZW0uaWRdID0ge2lkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHN9O1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gbGlzdFRvU3R5bGVzKGxpc3QpIHtcclxuXHR2YXIgc3R5bGVzID0gW107XHJcblx0dmFyIG5ld1N0eWxlcyA9IHt9O1xyXG5cdGZvcih2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XHJcblx0XHR2YXIgaXRlbSA9IGxpc3RbaV07XHJcblx0XHR2YXIgaWQgPSBpdGVtWzBdO1xyXG5cdFx0dmFyIGNzcyA9IGl0ZW1bMV07XHJcblx0XHR2YXIgbWVkaWEgPSBpdGVtWzJdO1xyXG5cdFx0dmFyIHNvdXJjZU1hcCA9IGl0ZW1bM107XHJcblx0XHR2YXIgcGFydCA9IHtjc3M6IGNzcywgbWVkaWE6IG1lZGlhLCBzb3VyY2VNYXA6IHNvdXJjZU1hcH07XHJcblx0XHRpZighbmV3U3R5bGVzW2lkXSlcclxuXHRcdFx0c3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHtpZDogaWQsIHBhcnRzOiBbcGFydF19KTtcclxuXHRcdGVsc2VcclxuXHRcdFx0bmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpO1xyXG5cdH1cclxuXHRyZXR1cm4gc3R5bGVzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGVFbGVtZW50KSB7XHJcblx0dmFyIGhlYWQgPSBnZXRIZWFkRWxlbWVudCgpO1xyXG5cdHZhciBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCA9IHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wW3N0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLmxlbmd0aCAtIDFdO1xyXG5cdGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcInRvcFwiKSB7XHJcblx0XHRpZighbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3ApIHtcclxuXHRcdFx0aGVhZC5pbnNlcnRCZWZvcmUoc3R5bGVFbGVtZW50LCBoZWFkLmZpcnN0Q2hpbGQpO1xyXG5cdFx0fSBlbHNlIGlmKGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKSB7XHJcblx0XHRcdGhlYWQuaW5zZXJ0QmVmb3JlKHN0eWxlRWxlbWVudCwgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xyXG5cdFx0fVxyXG5cdFx0c3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AucHVzaChzdHlsZUVsZW1lbnQpO1xyXG5cdH0gZWxzZSBpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJib3R0b21cIikge1xyXG5cdFx0aGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgJ2luc2VydEF0Jy4gTXVzdCBiZSAndG9wJyBvciAnYm90dG9tJy5cIik7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KSB7XHJcblx0c3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KTtcclxuXHR2YXIgaWR4ID0gc3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AuaW5kZXhPZihzdHlsZUVsZW1lbnQpO1xyXG5cdGlmKGlkeCA+PSAwKSB7XHJcblx0XHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5zcGxpY2UoaWR4LCAxKTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSB7XHJcblx0dmFyIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcclxuXHRzdHlsZUVsZW1lbnQudHlwZSA9IFwidGV4dC9jc3NcIjtcclxuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGVFbGVtZW50KTtcclxuXHRyZXR1cm4gc3R5bGVFbGVtZW50O1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKSB7XHJcblx0dmFyIGxpbmtFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XHJcblx0bGlua0VsZW1lbnQucmVsID0gXCJzdHlsZXNoZWV0XCI7XHJcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIGxpbmtFbGVtZW50KTtcclxuXHRyZXR1cm4gbGlua0VsZW1lbnQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZFN0eWxlKG9iaiwgb3B0aW9ucykge1xyXG5cdHZhciBzdHlsZUVsZW1lbnQsIHVwZGF0ZSwgcmVtb3ZlO1xyXG5cclxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcclxuXHRcdHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xyXG5cdFx0c3R5bGVFbGVtZW50ID0gc2luZ2xldG9uRWxlbWVudCB8fCAoc2luZ2xldG9uRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSk7XHJcblx0XHR1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBzdHlsZUluZGV4LCBmYWxzZSk7XHJcblx0XHRyZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBzdHlsZUluZGV4LCB0cnVlKTtcclxuXHR9IGVsc2UgaWYob2JqLnNvdXJjZU1hcCAmJlxyXG5cdFx0dHlwZW9mIFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXHJcblx0XHR0eXBlb2YgVVJMLmNyZWF0ZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXHJcblx0XHR0eXBlb2YgVVJMLnJldm9rZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXHJcblx0XHR0eXBlb2YgQmxvYiA9PT0gXCJmdW5jdGlvblwiICYmXHJcblx0XHR0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcblx0XHRzdHlsZUVsZW1lbnQgPSBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKTtcclxuXHRcdHVwZGF0ZSA9IHVwZGF0ZUxpbmsuYmluZChudWxsLCBzdHlsZUVsZW1lbnQpO1xyXG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpO1xyXG5cdFx0XHRpZihzdHlsZUVsZW1lbnQuaHJlZilcclxuXHRcdFx0XHRVUkwucmV2b2tlT2JqZWN0VVJMKHN0eWxlRWxlbWVudC5ocmVmKTtcclxuXHRcdH07XHJcblx0fSBlbHNlIHtcclxuXHRcdHN0eWxlRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKTtcclxuXHRcdHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQpO1xyXG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpO1xyXG5cdFx0fTtcclxuXHR9XHJcblxyXG5cdHVwZGF0ZShvYmopO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUobmV3T2JqKSB7XHJcblx0XHRpZihuZXdPYmopIHtcclxuXHRcdFx0aWYobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKVxyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0dXBkYXRlKG9iaiA9IG5ld09iaik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZW1vdmUoKTtcclxuXHRcdH1cclxuXHR9O1xyXG59XHJcblxyXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdHZhciB0ZXh0U3RvcmUgPSBbXTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcclxuXHRcdHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcclxuXHRcdHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xyXG5cdH07XHJcbn0pKCk7XHJcblxyXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnKHN0eWxlRWxlbWVudCwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XHJcblx0dmFyIGNzcyA9IHJlbW92ZSA/IFwiXCIgOiBvYmouY3NzO1xyXG5cclxuXHRpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcclxuXHRcdHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0dmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xyXG5cdFx0dmFyIGNoaWxkTm9kZXMgPSBzdHlsZUVsZW1lbnQuY2hpbGROb2RlcztcclxuXHRcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcclxuXHRcdGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xyXG5cdFx0XHRzdHlsZUVsZW1lbnQuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChjc3NOb2RlKTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFwcGx5VG9UYWcoc3R5bGVFbGVtZW50LCBvYmopIHtcclxuXHR2YXIgY3NzID0gb2JqLmNzcztcclxuXHR2YXIgbWVkaWEgPSBvYmoubWVkaWE7XHJcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XHJcblxyXG5cdGlmKG1lZGlhKSB7XHJcblx0XHRzdHlsZUVsZW1lbnQuc2V0QXR0cmlidXRlKFwibWVkaWFcIiwgbWVkaWEpXHJcblx0fVxyXG5cclxuXHRpZihzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xyXG5cdFx0c3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcclxuXHR9IGVsc2Uge1xyXG5cdFx0d2hpbGUoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpIHtcclxuXHRcdFx0c3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKTtcclxuXHRcdH1cclxuXHRcdHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZUxpbmsobGlua0VsZW1lbnQsIG9iaikge1xyXG5cdHZhciBjc3MgPSBvYmouY3NzO1xyXG5cdHZhciBtZWRpYSA9IG9iai5tZWRpYTtcclxuXHR2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcclxuXHJcblx0aWYoc291cmNlTWFwKSB7XHJcblx0XHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxyXG5cdFx0Y3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyBcIiAqL1wiO1xyXG5cdH1cclxuXHJcblx0dmFyIGJsb2IgPSBuZXcgQmxvYihbY3NzXSwgeyB0eXBlOiBcInRleHQvY3NzXCIgfSk7XHJcblxyXG5cdHZhciBvbGRTcmMgPSBsaW5rRWxlbWVudC5ocmVmO1xyXG5cclxuXHRsaW5rRWxlbWVudC5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcclxuXHJcblx0aWYob2xkU3JjKVxyXG5cdFx0VVJMLnJldm9rZU9iamVjdFVSTChvbGRTcmMpO1xyXG59XHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcbiAqKiBtb2R1bGUgaWQgPSA0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKiFcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbVxuICogQGxpY2Vuc2UgZXM1LXNoaW0gQ29weXJpZ2h0IDIwMDktMjAxNSBieSBjb250cmlidXRvcnMsIE1JVCBMaWNlbnNlXG4gKiBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqL1xuXG4vLyB2aW06IHRzPTQgc3RzPTQgc3c9NCBleHBhbmR0YWJcblxuLy8gQWRkIHNlbWljb2xvbiB0byBwcmV2ZW50IElJRkUgZnJvbSBiZWluZyBwYXNzZWQgYXMgYXJndW1lbnQgdG8gY29uY2F0ZW5hdGVkIGNvZGUuXG47XG5cbi8vIFVNRCAoVW5pdmVyc2FsIE1vZHVsZSBEZWZpbml0aW9uKVxuLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91bWRqcy91bWQvYmxvYi9tYXN0ZXIvdGVtcGxhdGVzL3JldHVybkV4cG9ydHMuanNcbihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8qIGdsb2JhbCBkZWZpbmUsIGV4cG9ydHMsIG1vZHVsZSAqL1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgICAgICBkZWZpbmUoZmFjdG9yeSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgLy8gTm9kZS4gRG9lcyBub3Qgd29yayB3aXRoIHN0cmljdCBDb21tb25KUywgYnV0XG4gICAgICAgIC8vIG9ubHkgQ29tbW9uSlMtbGlrZSBlbnZpcm9tZW50cyB0aGF0IHN1cHBvcnQgbW9kdWxlLmV4cG9ydHMsXG4gICAgICAgIC8vIGxpa2UgTm9kZS5cbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQnJvd3NlciBnbG9iYWxzIChyb290IGlzIHdpbmRvdylcbiAgICAgICAgcm9vdC5yZXR1cm5FeHBvcnRzID0gZmFjdG9yeSgpO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24gKCkge1xuXG4vKipcbiAqIEJyaW5ncyBhbiBlbnZpcm9ubWVudCBhcyBjbG9zZSB0byBFQ01BU2NyaXB0IDUgY29tcGxpYW5jZVxuICogYXMgaXMgcG9zc2libGUgd2l0aCB0aGUgZmFjaWxpdGllcyBvZiBlcnN0d2hpbGUgZW5naW5lcy5cbiAqXG4gKiBBbm5vdGF0ZWQgRVM1OiBodHRwOi8vZXM1LmdpdGh1Yi5jb20vIChzcGVjaWZpYyBsaW5rcyBiZWxvdylcbiAqIEVTNSBTcGVjOiBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvcHVibGljYXRpb25zL2ZpbGVzL0VDTUEtU1QvRWNtYS0yNjIucGRmXG4gKiBSZXF1aXJlZCByZWFkaW5nOiBodHRwOi8vamF2YXNjcmlwdHdlYmxvZy53b3JkcHJlc3MuY29tLzIwMTEvMTIvMDUvZXh0ZW5kaW5nLWphdmFzY3JpcHQtbmF0aXZlcy9cbiAqL1xuXG4vLyBTaG9ydGN1dCB0byBhbiBvZnRlbiBhY2Nlc3NlZCBwcm9wZXJ0aWVzLCBpbiBvcmRlciB0byBhdm9pZCBtdWx0aXBsZVxuLy8gZGVyZWZlcmVuY2UgdGhhdCBjb3N0cyB1bml2ZXJzYWxseS4gVGhpcyBhbHNvIGhvbGRzIGEgcmVmZXJlbmNlIHRvIGtub3duLWdvb2Rcbi8vIGZ1bmN0aW9ucy5cbnZhciAkQXJyYXkgPSBBcnJheTtcbnZhciBBcnJheVByb3RvdHlwZSA9ICRBcnJheS5wcm90b3R5cGU7XG52YXIgJE9iamVjdCA9IE9iamVjdDtcbnZhciBPYmplY3RQcm90b3R5cGUgPSAkT2JqZWN0LnByb3RvdHlwZTtcbnZhciBGdW5jdGlvblByb3RvdHlwZSA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbnZhciAkU3RyaW5nID0gU3RyaW5nO1xudmFyIFN0cmluZ1Byb3RvdHlwZSA9ICRTdHJpbmcucHJvdG90eXBlO1xudmFyICROdW1iZXIgPSBOdW1iZXI7XG52YXIgTnVtYmVyUHJvdG90eXBlID0gJE51bWJlci5wcm90b3R5cGU7XG52YXIgYXJyYXlfc2xpY2UgPSBBcnJheVByb3RvdHlwZS5zbGljZTtcbnZhciBhcnJheV9zcGxpY2UgPSBBcnJheVByb3RvdHlwZS5zcGxpY2U7XG52YXIgYXJyYXlfcHVzaCA9IEFycmF5UHJvdG90eXBlLnB1c2g7XG52YXIgYXJyYXlfdW5zaGlmdCA9IEFycmF5UHJvdG90eXBlLnVuc2hpZnQ7XG52YXIgYXJyYXlfY29uY2F0ID0gQXJyYXlQcm90b3R5cGUuY29uY2F0O1xudmFyIGNhbGwgPSBGdW5jdGlvblByb3RvdHlwZS5jYWxsO1xudmFyIGFwcGx5ID0gRnVuY3Rpb25Qcm90b3R5cGUuYXBwbHk7XG52YXIgbWF4ID0gTWF0aC5tYXg7XG52YXIgbWluID0gTWF0aC5taW47XG5cbi8vIEhhdmluZyBhIHRvU3RyaW5nIGxvY2FsIHZhcmlhYmxlIG5hbWUgYnJlYWtzIGluIE9wZXJhIHNvIHVzZSB0b19zdHJpbmcuXG52YXIgdG9fc3RyaW5nID0gT2JqZWN0UHJvdG90eXBlLnRvU3RyaW5nO1xuXG52YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnO1xudmFyIGlzQ2FsbGFibGU7IC8qIGlubGluZWQgZnJvbSBodHRwczovL25wbWpzLmNvbS9pcy1jYWxsYWJsZSAqLyB2YXIgZm5Ub1N0ciA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZywgdHJ5RnVuY3Rpb25PYmplY3QgPSBmdW5jdGlvbiB0cnlGdW5jdGlvbk9iamVjdCh2YWx1ZSkgeyB0cnkgeyBmblRvU3RyLmNhbGwodmFsdWUpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfSwgZm5DbGFzcyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsIGdlbkNsYXNzID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJzsgaXNDYWxsYWJsZSA9IGZ1bmN0aW9uIGlzQ2FsbGFibGUodmFsdWUpIHsgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH0gaWYgKGhhc1RvU3RyaW5nVGFnKSB7IHJldHVybiB0cnlGdW5jdGlvbk9iamVjdCh2YWx1ZSk7IH0gdmFyIHN0ckNsYXNzID0gdG9fc3RyaW5nLmNhbGwodmFsdWUpOyByZXR1cm4gc3RyQ2xhc3MgPT09IGZuQ2xhc3MgfHwgc3RyQ2xhc3MgPT09IGdlbkNsYXNzOyB9O1xudmFyIGlzUmVnZXg7IC8qIGlubGluZWQgZnJvbSBodHRwczovL25wbWpzLmNvbS9pcy1yZWdleCAqLyB2YXIgcmVnZXhFeGVjID0gUmVnRXhwLnByb3RvdHlwZS5leGVjLCB0cnlSZWdleEV4ZWMgPSBmdW5jdGlvbiB0cnlSZWdleEV4ZWModmFsdWUpIHsgdHJ5IHsgcmVnZXhFeGVjLmNhbGwodmFsdWUpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfSwgcmVnZXhDbGFzcyA9ICdbb2JqZWN0IFJlZ0V4cF0nOyBpc1JlZ2V4ID0gZnVuY3Rpb24gaXNSZWdleCh2YWx1ZSkgeyBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JykgeyByZXR1cm4gZmFsc2U7IH0gcmV0dXJuIGhhc1RvU3RyaW5nVGFnID8gdHJ5UmVnZXhFeGVjKHZhbHVlKSA6IHRvX3N0cmluZy5jYWxsKHZhbHVlKSA9PT0gcmVnZXhDbGFzczsgfTtcbnZhciBpc1N0cmluZzsgLyogaW5saW5lZCBmcm9tIGh0dHBzOi8vbnBtanMuY29tL2lzLXN0cmluZyAqLyB2YXIgc3RyVmFsdWUgPSBTdHJpbmcucHJvdG90eXBlLnZhbHVlT2YsIHRyeVN0cmluZ09iamVjdCA9IGZ1bmN0aW9uIHRyeVN0cmluZ09iamVjdCh2YWx1ZSkgeyB0cnkgeyBzdHJWYWx1ZS5jYWxsKHZhbHVlKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH0sIHN0cmluZ0NsYXNzID0gJ1tvYmplY3QgU3RyaW5nXSc7IGlzU3RyaW5nID0gZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHsgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHsgcmV0dXJuIHRydWU7IH0gaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHsgcmV0dXJuIGZhbHNlOyB9IHJldHVybiBoYXNUb1N0cmluZ1RhZyA/IHRyeVN0cmluZ09iamVjdCh2YWx1ZSkgOiB0b19zdHJpbmcuY2FsbCh2YWx1ZSkgPT09IHN0cmluZ0NsYXNzOyB9O1xuXG4vKiBpbmxpbmVkIGZyb20gaHR0cDovL25wbWpzLmNvbS9kZWZpbmUtcHJvcGVydGllcyAqL1xudmFyIHN1cHBvcnRzRGVzY3JpcHRvcnMgPSAkT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIChmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIG9iaiA9IHt9O1xuICAgICAgICAkT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgJ3gnLCB7IGVudW1lcmFibGU6IGZhbHNlLCB2YWx1ZTogb2JqIH0pO1xuICAgICAgICBmb3IgKHZhciBfIGluIG9iaikgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgICAgcmV0dXJuIG9iai54ID09PSBvYmo7XG4gICAgfSBjYXRjaCAoZSkgeyAvKiB0aGlzIGlzIEVTMyAqL1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufSgpKTtcbnZhciBkZWZpbmVQcm9wZXJ0aWVzID0gKGZ1bmN0aW9uIChoYXMpIHtcbiAgLy8gRGVmaW5lIGNvbmZpZ3VyYWJsZSwgd3JpdGFibGUsIGFuZCBub24tZW51bWVyYWJsZSBwcm9wc1xuICAvLyBpZiB0aGV5IGRvbid0IGV4aXN0LlxuICB2YXIgZGVmaW5lUHJvcGVydHk7XG4gIGlmIChzdXBwb3J0c0Rlc2NyaXB0b3JzKSB7XG4gICAgICBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUsIG1ldGhvZCwgZm9yY2VBc3NpZ24pIHtcbiAgICAgICAgICBpZiAoIWZvcmNlQXNzaWduICYmIChuYW1lIGluIG9iamVjdCkpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgJE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIG5hbWUsIHtcbiAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgIHZhbHVlOiBtZXRob2RcbiAgICAgICAgICB9KTtcbiAgICAgIH07XG4gIH0gZWxzZSB7XG4gICAgICBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUsIG1ldGhvZCwgZm9yY2VBc3NpZ24pIHtcbiAgICAgICAgICBpZiAoIWZvcmNlQXNzaWduICYmIChuYW1lIGluIG9iamVjdCkpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgb2JqZWN0W25hbWVdID0gbWV0aG9kO1xuICAgICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhvYmplY3QsIG1hcCwgZm9yY2VBc3NpZ24pIHtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gbWFwKSB7XG4gICAgICAgICAgaWYgKGhhcy5jYWxsKG1hcCwgbmFtZSkpIHtcbiAgICAgICAgICAgIGRlZmluZVByb3BlcnR5KG9iamVjdCwgbmFtZSwgbWFwW25hbWVdLCBmb3JjZUFzc2lnbik7XG4gICAgICAgICAgfVxuICAgICAgfVxuICB9O1xufShPYmplY3RQcm90b3R5cGUuaGFzT3duUHJvcGVydHkpKTtcblxuLy9cbi8vIFV0aWxcbi8vID09PT09PVxuLy9cblxuLyogcmVwbGFjZWFibGUgd2l0aCBodHRwczovL25wbWpzLmNvbS9wYWNrYWdlL2VzLWFic3RyYWN0IC9oZWxwZXJzL2lzUHJpbWl0aXZlICovXG52YXIgaXNQcmltaXRpdmUgPSBmdW5jdGlvbiBpc1ByaW1pdGl2ZShpbnB1dCkge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIGlucHV0O1xuICAgIHJldHVybiBpbnB1dCA9PT0gbnVsbCB8fCAodHlwZSAhPT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gJ2Z1bmN0aW9uJyk7XG59O1xuXG52YXIgaXNBY3R1YWxOYU4gPSAkTnVtYmVyLmlzTmFOIHx8IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4ICE9PSB4OyB9O1xuXG52YXIgRVMgPSB7XG4gICAgLy8gRVM1IDkuNFxuICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDkuNFxuICAgIC8vIGh0dHA6Ly9qc3BlcmYuY29tL3RvLWludGVnZXJcbiAgICAvKiByZXBsYWNlYWJsZSB3aXRoIGh0dHBzOi8vbnBtanMuY29tL3BhY2thZ2UvZXMtYWJzdHJhY3QgRVM1LlRvSW50ZWdlciAqL1xuICAgIFRvSW50ZWdlcjogZnVuY3Rpb24gVG9JbnRlZ2VyKG51bSkge1xuICAgICAgICB2YXIgbiA9ICtudW07XG4gICAgICAgIGlmIChpc0FjdHVhbE5hTihuKSkge1xuICAgICAgICAgICAgbiA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAobiAhPT0gMCAmJiBuICE9PSAoMSAvIDApICYmIG4gIT09IC0oMSAvIDApKSB7XG4gICAgICAgICAgICBuID0gKG4gPiAwIHx8IC0xKSAqIE1hdGguZmxvb3IoTWF0aC5hYnMobikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuO1xuICAgIH0sXG5cbiAgICAvKiByZXBsYWNlYWJsZSB3aXRoIGh0dHBzOi8vbnBtanMuY29tL3BhY2thZ2UvZXMtYWJzdHJhY3QgRVM1LlRvUHJpbWl0aXZlICovXG4gICAgVG9QcmltaXRpdmU6IGZ1bmN0aW9uIFRvUHJpbWl0aXZlKGlucHV0KSB7XG4gICAgICAgIHZhciB2YWwsIHZhbHVlT2YsIHRvU3RyO1xuICAgICAgICBpZiAoaXNQcmltaXRpdmUoaW5wdXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVPZiA9IGlucHV0LnZhbHVlT2Y7XG4gICAgICAgIGlmIChpc0NhbGxhYmxlKHZhbHVlT2YpKSB7XG4gICAgICAgICAgICB2YWwgPSB2YWx1ZU9mLmNhbGwoaW5wdXQpO1xuICAgICAgICAgICAgaWYgKGlzUHJpbWl0aXZlKHZhbCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRvU3RyID0gaW5wdXQudG9TdHJpbmc7XG4gICAgICAgIGlmIChpc0NhbGxhYmxlKHRvU3RyKSkge1xuICAgICAgICAgICAgdmFsID0gdG9TdHIuY2FsbChpbnB1dCk7XG4gICAgICAgICAgICBpZiAoaXNQcmltaXRpdmUodmFsKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgIH0sXG5cbiAgICAvLyBFUzUgOS45XG4gICAgLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4OS45XG4gICAgLyogcmVwbGFjZWFibGUgd2l0aCBodHRwczovL25wbWpzLmNvbS9wYWNrYWdlL2VzLWFic3RyYWN0IEVTNS5Ub09iamVjdCAqL1xuICAgIFRvT2JqZWN0OiBmdW5jdGlvbiAobykge1xuICAgICAgICBpZiAobyA9PSBudWxsKSB7IC8vIHRoaXMgbWF0Y2hlcyBib3RoIG51bGwgYW5kIHVuZGVmaW5lZFxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbid0IGNvbnZlcnQgXCIgKyBvICsgJyB0byBvYmplY3QnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJE9iamVjdChvKTtcbiAgICB9LFxuXG4gICAgLyogcmVwbGFjZWFibGUgd2l0aCBodHRwczovL25wbWpzLmNvbS9wYWNrYWdlL2VzLWFic3RyYWN0IEVTNS5Ub1VpbnQzMiAqL1xuICAgIFRvVWludDMyOiBmdW5jdGlvbiBUb1VpbnQzMih4KSB7XG4gICAgICAgIHJldHVybiB4ID4+PiAwO1xuICAgIH1cbn07XG5cbi8vXG4vLyBGdW5jdGlvblxuLy8gPT09PT09PT1cbi8vXG5cbi8vIEVTLTUgMTUuMy40LjVcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjMuNC41XG5cbnZhciBFbXB0eSA9IGZ1bmN0aW9uIEVtcHR5KCkge307XG5cbmRlZmluZVByb3BlcnRpZXMoRnVuY3Rpb25Qcm90b3R5cGUsIHtcbiAgICBiaW5kOiBmdW5jdGlvbiBiaW5kKHRoYXQpIHsgLy8gLmxlbmd0aCBpcyAxXG4gICAgICAgIC8vIDEuIExldCBUYXJnZXQgYmUgdGhlIHRoaXMgdmFsdWUuXG4gICAgICAgIHZhciB0YXJnZXQgPSB0aGlzO1xuICAgICAgICAvLyAyLiBJZiBJc0NhbGxhYmxlKFRhcmdldCkgaXMgZmFsc2UsIHRocm93IGEgVHlwZUVycm9yIGV4Y2VwdGlvbi5cbiAgICAgICAgaWYgKCFpc0NhbGxhYmxlKHRhcmdldCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kIGNhbGxlZCBvbiBpbmNvbXBhdGlibGUgJyArIHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gMy4gTGV0IEEgYmUgYSBuZXcgKHBvc3NpYmx5IGVtcHR5KSBpbnRlcm5hbCBsaXN0IG9mIGFsbCBvZiB0aGVcbiAgICAgICAgLy8gICBhcmd1bWVudCB2YWx1ZXMgcHJvdmlkZWQgYWZ0ZXIgdGhpc0FyZyAoYXJnMSwgYXJnMiBldGMpLCBpbiBvcmRlci5cbiAgICAgICAgLy8gWFhYIHNsaWNlZEFyZ3Mgd2lsbCBzdGFuZCBpbiBmb3IgXCJBXCIgaWYgdXNlZFxuICAgICAgICB2YXIgYXJncyA9IGFycmF5X3NsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTsgLy8gZm9yIG5vcm1hbCBjYWxsXG4gICAgICAgIC8vIDQuIExldCBGIGJlIGEgbmV3IG5hdGl2ZSBFQ01BU2NyaXB0IG9iamVjdC5cbiAgICAgICAgLy8gMTEuIFNldCB0aGUgW1tQcm90b3R5cGVdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBGIHRvIHRoZSBzdGFuZGFyZFxuICAgICAgICAvLyAgIGJ1aWx0LWluIEZ1bmN0aW9uIHByb3RvdHlwZSBvYmplY3QgYXMgc3BlY2lmaWVkIGluIDE1LjMuMy4xLlxuICAgICAgICAvLyAxMi4gU2V0IHRoZSBbW0NhbGxdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBGIGFzIGRlc2NyaWJlZCBpblxuICAgICAgICAvLyAgIDE1LjMuNC41LjEuXG4gICAgICAgIC8vIDEzLiBTZXQgdGhlIFtbQ29uc3RydWN0XV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgRiBhcyBkZXNjcmliZWQgaW5cbiAgICAgICAgLy8gICAxNS4zLjQuNS4yLlxuICAgICAgICAvLyAxNC4gU2V0IHRoZSBbW0hhc0luc3RhbmNlXV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgRiBhcyBkZXNjcmliZWQgaW5cbiAgICAgICAgLy8gICAxNS4zLjQuNS4zLlxuICAgICAgICB2YXIgYm91bmQ7XG4gICAgICAgIHZhciBiaW5kZXIgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgYm91bmQpIHtcbiAgICAgICAgICAgICAgICAvLyAxNS4zLjQuNS4yIFtbQ29uc3RydWN0XV1cbiAgICAgICAgICAgICAgICAvLyBXaGVuIHRoZSBbW0NvbnN0cnVjdF1dIGludGVybmFsIG1ldGhvZCBvZiBhIGZ1bmN0aW9uIG9iamVjdCxcbiAgICAgICAgICAgICAgICAvLyBGIHRoYXQgd2FzIGNyZWF0ZWQgdXNpbmcgdGhlIGJpbmQgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggYVxuICAgICAgICAgICAgICAgIC8vIGxpc3Qgb2YgYXJndW1lbnRzIEV4dHJhQXJncywgdGhlIGZvbGxvd2luZyBzdGVwcyBhcmUgdGFrZW46XG4gICAgICAgICAgICAgICAgLy8gMS4gTGV0IHRhcmdldCBiZSB0aGUgdmFsdWUgb2YgRidzIFtbVGFyZ2V0RnVuY3Rpb25dXVxuICAgICAgICAgICAgICAgIC8vICAgaW50ZXJuYWwgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgLy8gMi4gSWYgdGFyZ2V0IGhhcyBubyBbW0NvbnN0cnVjdF1dIGludGVybmFsIG1ldGhvZCwgYVxuICAgICAgICAgICAgICAgIC8vICAgVHlwZUVycm9yIGV4Y2VwdGlvbiBpcyB0aHJvd24uXG4gICAgICAgICAgICAgICAgLy8gMy4gTGV0IGJvdW5kQXJncyBiZSB0aGUgdmFsdWUgb2YgRidzIFtbQm91bmRBcmdzXV0gaW50ZXJuYWxcbiAgICAgICAgICAgICAgICAvLyAgIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIC8vIDQuIExldCBhcmdzIGJlIGEgbmV3IGxpc3QgY29udGFpbmluZyB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhlXG4gICAgICAgICAgICAgICAgLy8gICBsaXN0IGJvdW5kQXJncyBpbiB0aGUgc2FtZSBvcmRlciBmb2xsb3dlZCBieSB0aGUgc2FtZVxuICAgICAgICAgICAgICAgIC8vICAgdmFsdWVzIGFzIHRoZSBsaXN0IEV4dHJhQXJncyBpbiB0aGUgc2FtZSBvcmRlci5cbiAgICAgICAgICAgICAgICAvLyA1LiBSZXR1cm4gdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBbW0NvbnN0cnVjdF1dIGludGVybmFsXG4gICAgICAgICAgICAgICAgLy8gICBtZXRob2Qgb2YgdGFyZ2V0IHByb3ZpZGluZyBhcmdzIGFzIHRoZSBhcmd1bWVudHMuXG5cbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGFyZ2V0LmFwcGx5KFxuICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBhcnJheV9jb25jYXQuY2FsbChhcmdzLCBhcnJheV9zbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoJE9iamVjdChyZXN1bHQpID09PSByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gMTUuMy40LjUuMSBbW0NhbGxdXVxuICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIFtbQ2FsbF1dIGludGVybmFsIG1ldGhvZCBvZiBhIGZ1bmN0aW9uIG9iamVjdCwgRixcbiAgICAgICAgICAgICAgICAvLyB3aGljaCB3YXMgY3JlYXRlZCB1c2luZyB0aGUgYmluZCBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCBhXG4gICAgICAgICAgICAgICAgLy8gdGhpcyB2YWx1ZSBhbmQgYSBsaXN0IG9mIGFyZ3VtZW50cyBFeHRyYUFyZ3MsIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICAgICAgICAvLyBzdGVwcyBhcmUgdGFrZW46XG4gICAgICAgICAgICAgICAgLy8gMS4gTGV0IGJvdW5kQXJncyBiZSB0aGUgdmFsdWUgb2YgRidzIFtbQm91bmRBcmdzXV0gaW50ZXJuYWxcbiAgICAgICAgICAgICAgICAvLyAgIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIC8vIDIuIExldCBib3VuZFRoaXMgYmUgdGhlIHZhbHVlIG9mIEYncyBbW0JvdW5kVGhpc11dIGludGVybmFsXG4gICAgICAgICAgICAgICAgLy8gICBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAvLyAzLiBMZXQgdGFyZ2V0IGJlIHRoZSB2YWx1ZSBvZiBGJ3MgW1tUYXJnZXRGdW5jdGlvbl1dIGludGVybmFsXG4gICAgICAgICAgICAgICAgLy8gICBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAvLyA0LiBMZXQgYXJncyBiZSBhIG5ldyBsaXN0IGNvbnRhaW5pbmcgdGhlIHNhbWUgdmFsdWVzIGFzIHRoZVxuICAgICAgICAgICAgICAgIC8vICAgbGlzdCBib3VuZEFyZ3MgaW4gdGhlIHNhbWUgb3JkZXIgZm9sbG93ZWQgYnkgdGhlIHNhbWVcbiAgICAgICAgICAgICAgICAvLyAgIHZhbHVlcyBhcyB0aGUgbGlzdCBFeHRyYUFyZ3MgaW4gdGhlIHNhbWUgb3JkZXIuXG4gICAgICAgICAgICAgICAgLy8gNS4gUmV0dXJuIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgW1tDYWxsXV0gaW50ZXJuYWwgbWV0aG9kXG4gICAgICAgICAgICAgICAgLy8gICBvZiB0YXJnZXQgcHJvdmlkaW5nIGJvdW5kVGhpcyBhcyB0aGUgdGhpcyB2YWx1ZSBhbmRcbiAgICAgICAgICAgICAgICAvLyAgIHByb3ZpZGluZyBhcmdzIGFzIHRoZSBhcmd1bWVudHMuXG5cbiAgICAgICAgICAgICAgICAvLyBlcXVpdjogdGFyZ2V0LmNhbGwodGhpcywgLi4uYm91bmRBcmdzLCAuLi5hcmdzKVxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkoXG4gICAgICAgICAgICAgICAgICAgIHRoYXQsXG4gICAgICAgICAgICAgICAgICAgIGFycmF5X2NvbmNhdC5jYWxsKGFyZ3MsIGFycmF5X3NsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfTtcblxuICAgICAgICAvLyAxNS4gSWYgdGhlIFtbQ2xhc3NdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBUYXJnZXQgaXMgXCJGdW5jdGlvblwiLCB0aGVuXG4gICAgICAgIC8vICAgICBhLiBMZXQgTCBiZSB0aGUgbGVuZ3RoIHByb3BlcnR5IG9mIFRhcmdldCBtaW51cyB0aGUgbGVuZ3RoIG9mIEEuXG4gICAgICAgIC8vICAgICBiLiBTZXQgdGhlIGxlbmd0aCBvd24gcHJvcGVydHkgb2YgRiB0byBlaXRoZXIgMCBvciBMLCB3aGljaGV2ZXIgaXNcbiAgICAgICAgLy8gICAgICAgbGFyZ2VyLlxuICAgICAgICAvLyAxNi4gRWxzZSBzZXQgdGhlIGxlbmd0aCBvd24gcHJvcGVydHkgb2YgRiB0byAwLlxuXG4gICAgICAgIHZhciBib3VuZExlbmd0aCA9IG1heCgwLCB0YXJnZXQubGVuZ3RoIC0gYXJncy5sZW5ndGgpO1xuXG4gICAgICAgIC8vIDE3LiBTZXQgdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIGxlbmd0aCBvd24gcHJvcGVydHkgb2YgRiB0byB0aGUgdmFsdWVzXG4gICAgICAgIC8vICAgc3BlY2lmaWVkIGluIDE1LjMuNS4xLlxuICAgICAgICB2YXIgYm91bmRBcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm91bmRMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJyYXlfcHVzaC5jYWxsKGJvdW5kQXJncywgJyQnICsgaSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBYWFggQnVpbGQgYSBkeW5hbWljIGZ1bmN0aW9uIHdpdGggZGVzaXJlZCBhbW91bnQgb2YgYXJndW1lbnRzIGlzIHRoZSBvbmx5XG4gICAgICAgIC8vIHdheSB0byBzZXQgdGhlIGxlbmd0aCBwcm9wZXJ0eSBvZiBhIGZ1bmN0aW9uLlxuICAgICAgICAvLyBJbiBlbnZpcm9ubWVudHMgd2hlcmUgQ29udGVudCBTZWN1cml0eSBQb2xpY2llcyBlbmFibGVkIChDaHJvbWUgZXh0ZW5zaW9ucyxcbiAgICAgICAgLy8gZm9yIGV4LikgYWxsIHVzZSBvZiBldmFsIG9yIEZ1bmN0aW9uIGNvc3RydWN0b3IgdGhyb3dzIGFuIGV4Y2VwdGlvbi5cbiAgICAgICAgLy8gSG93ZXZlciBpbiBhbGwgb2YgdGhlc2UgZW52aXJvbm1lbnRzIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIGV4aXN0c1xuICAgICAgICAvLyBhbmQgc28gdGhpcyBjb2RlIHdpbGwgbmV2ZXIgYmUgZXhlY3V0ZWQuXG4gICAgICAgIGJvdW5kID0gRnVuY3Rpb24oJ2JpbmRlcicsICdyZXR1cm4gZnVuY3Rpb24gKCcgKyBib3VuZEFyZ3Muam9pbignLCcpICsgJyl7IHJldHVybiBiaW5kZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfScpKGJpbmRlcik7XG5cbiAgICAgICAgaWYgKHRhcmdldC5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IHRhcmdldC5wcm90b3R5cGU7XG4gICAgICAgICAgICBib3VuZC5wcm90b3R5cGUgPSBuZXcgRW1wdHkoKTtcbiAgICAgICAgICAgIC8vIENsZWFuIHVwIGRhbmdsaW5nIHJlZmVyZW5jZXMuXG4gICAgICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ET1xuICAgICAgICAvLyAxOC4gU2V0IHRoZSBbW0V4dGVuc2libGVdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBGIHRvIHRydWUuXG5cbiAgICAgICAgLy8gVE9ET1xuICAgICAgICAvLyAxOS4gTGV0IHRocm93ZXIgYmUgdGhlIFtbVGhyb3dUeXBlRXJyb3JdXSBmdW5jdGlvbiBPYmplY3QgKDEzLjIuMykuXG4gICAgICAgIC8vIDIwLiBDYWxsIHRoZSBbW0RlZmluZU93blByb3BlcnR5XV0gaW50ZXJuYWwgbWV0aG9kIG9mIEYgd2l0aFxuICAgICAgICAvLyAgIGFyZ3VtZW50cyBcImNhbGxlclwiLCBQcm9wZXJ0eURlc2NyaXB0b3Ige1tbR2V0XV06IHRocm93ZXIsIFtbU2V0XV06XG4gICAgICAgIC8vICAgdGhyb3dlciwgW1tFbnVtZXJhYmxlXV06IGZhbHNlLCBbW0NvbmZpZ3VyYWJsZV1dOiBmYWxzZX0sIGFuZFxuICAgICAgICAvLyAgIGZhbHNlLlxuICAgICAgICAvLyAyMS4gQ2FsbCB0aGUgW1tEZWZpbmVPd25Qcm9wZXJ0eV1dIGludGVybmFsIG1ldGhvZCBvZiBGIHdpdGhcbiAgICAgICAgLy8gICBhcmd1bWVudHMgXCJhcmd1bWVudHNcIiwgUHJvcGVydHlEZXNjcmlwdG9yIHtbW0dldF1dOiB0aHJvd2VyLFxuICAgICAgICAvLyAgIFtbU2V0XV06IHRocm93ZXIsIFtbRW51bWVyYWJsZV1dOiBmYWxzZSwgW1tDb25maWd1cmFibGVdXTogZmFsc2V9LFxuICAgICAgICAvLyAgIGFuZCBmYWxzZS5cblxuICAgICAgICAvLyBUT0RPXG4gICAgICAgIC8vIE5PVEUgRnVuY3Rpb24gb2JqZWN0cyBjcmVhdGVkIHVzaW5nIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIGRvIG5vdFxuICAgICAgICAvLyBoYXZlIGEgcHJvdG90eXBlIHByb3BlcnR5IG9yIHRoZSBbW0NvZGVdXSwgW1tGb3JtYWxQYXJhbWV0ZXJzXV0sIGFuZFxuICAgICAgICAvLyBbW1Njb3BlXV0gaW50ZXJuYWwgcHJvcGVydGllcy5cbiAgICAgICAgLy8gWFhYIGNhbid0IGRlbGV0ZSBwcm90b3R5cGUgaW4gcHVyZS1qcy5cblxuICAgICAgICAvLyAyMi4gUmV0dXJuIEYuXG4gICAgICAgIHJldHVybiBib3VuZDtcbiAgICB9XG59KTtcblxuLy8gX1BsZWFzZSBub3RlOiBTaG9ydGN1dHMgYXJlIGRlZmluZWQgYWZ0ZXIgYEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kYCBhcyB3ZVxuLy8gdXNlIGl0IGluIGRlZmluaW5nIHNob3J0Y3V0cy5cbnZhciBvd25zID0gY2FsbC5iaW5kKE9iamVjdFByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG52YXIgdG9TdHIgPSBjYWxsLmJpbmQoT2JqZWN0UHJvdG90eXBlLnRvU3RyaW5nKTtcbnZhciBhcnJheVNsaWNlID0gY2FsbC5iaW5kKGFycmF5X3NsaWNlKTtcbnZhciBhcnJheVNsaWNlQXBwbHkgPSBhcHBseS5iaW5kKGFycmF5X3NsaWNlKTtcbnZhciBzdHJTbGljZSA9IGNhbGwuYmluZChTdHJpbmdQcm90b3R5cGUuc2xpY2UpO1xudmFyIHN0clNwbGl0ID0gY2FsbC5iaW5kKFN0cmluZ1Byb3RvdHlwZS5zcGxpdCk7XG52YXIgc3RySW5kZXhPZiA9IGNhbGwuYmluZChTdHJpbmdQcm90b3R5cGUuaW5kZXhPZik7XG52YXIgcHVzaCA9IGNhbGwuYmluZChhcnJheV9wdXNoKTtcbnZhciBpc0VudW0gPSBjYWxsLmJpbmQoT2JqZWN0UHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlKTtcbnZhciBhcnJheVNvcnQgPSBjYWxsLmJpbmQoQXJyYXlQcm90b3R5cGUuc29ydCk7XG5cbi8vXG4vLyBBcnJheVxuLy8gPT09PT1cbi8vXG5cbnZhciBpc0FycmF5ID0gJEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShvYmopIHtcbiAgICByZXR1cm4gdG9TdHIob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbi8vIEVTNSAxNS40LjQuMTJcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjQuNC4xM1xuLy8gUmV0dXJuIGxlbithcmdDb3VudC5cbi8vIFtidWdmaXgsIGllbHQ4XVxuLy8gSUUgPCA4IGJ1ZzogW10udW5zaGlmdCgwKSA9PT0gdW5kZWZpbmVkIGJ1dCBzaG91bGQgYmUgXCIxXCJcbnZhciBoYXNVbnNoaWZ0UmV0dXJuVmFsdWVCdWcgPSBbXS51bnNoaWZ0KDApICE9PSAxO1xuZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgIHVuc2hpZnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYXJyYXlfdW5zaGlmdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGg7XG4gICAgfVxufSwgaGFzVW5zaGlmdFJldHVyblZhbHVlQnVnKTtcblxuLy8gRVM1IDE1LjQuMy4yXG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjMuMlxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvaXNBcnJheVxuZGVmaW5lUHJvcGVydGllcygkQXJyYXksIHsgaXNBcnJheTogaXNBcnJheSB9KTtcblxuLy8gVGhlIElzQ2FsbGFibGUoKSBjaGVjayBpbiB0aGUgQXJyYXkgZnVuY3Rpb25zXG4vLyBoYXMgYmVlbiByZXBsYWNlZCB3aXRoIGEgc3RyaWN0IGNoZWNrIG9uIHRoZVxuLy8gaW50ZXJuYWwgY2xhc3Mgb2YgdGhlIG9iamVjdCB0byB0cmFwIGNhc2VzIHdoZXJlXG4vLyB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gd2FzIGFjdHVhbGx5IGEgcmVndWxhclxuLy8gZXhwcmVzc2lvbiBsaXRlcmFsLCB3aGljaCBpbiBWOCBhbmRcbi8vIEphdmFTY3JpcHRDb3JlIGlzIGEgdHlwZW9mIFwiZnVuY3Rpb25cIi4gIE9ubHkgaW5cbi8vIFY4IGFyZSByZWd1bGFyIGV4cHJlc3Npb24gbGl0ZXJhbHMgcGVybWl0dGVkIGFzXG4vLyByZWR1Y2UgcGFyYW1ldGVycywgc28gaXQgaXMgZGVzaXJhYmxlIGluIHRoZVxuLy8gZ2VuZXJhbCBjYXNlIGZvciB0aGUgc2hpbSB0byBtYXRjaCB0aGUgbW9yZVxuLy8gc3RyaWN0IGFuZCBjb21tb24gYmVoYXZpb3Igb2YgcmVqZWN0aW5nIHJlZ3VsYXJcbi8vIGV4cHJlc3Npb25zLlxuXG4vLyBFUzUgMTUuNC40LjE4XG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjQuMThcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL2FycmF5L2ZvckVhY2hcblxuLy8gQ2hlY2sgZmFpbHVyZSBvZiBieS1pbmRleCBhY2Nlc3Mgb2Ygc3RyaW5nIGNoYXJhY3RlcnMgKElFIDwgOSlcbi8vIGFuZCBmYWlsdXJlIG9mIGAwIGluIGJveGVkU3RyaW5nYCAoUmhpbm8pXG52YXIgYm94ZWRTdHJpbmcgPSAkT2JqZWN0KCdhJyk7XG52YXIgc3BsaXRTdHJpbmcgPSBib3hlZFN0cmluZ1swXSAhPT0gJ2EnIHx8ICEoMCBpbiBib3hlZFN0cmluZyk7XG5cbnZhciBwcm9wZXJseUJveGVzQ29udGV4dCA9IGZ1bmN0aW9uIHByb3Blcmx5Qm94ZWQobWV0aG9kKSB7XG4gICAgLy8gQ2hlY2sgbm9kZSAwLjYuMjEgYnVnIHdoZXJlIHRoaXJkIHBhcmFtZXRlciBpcyBub3QgYm94ZWRcbiAgICB2YXIgcHJvcGVybHlCb3hlc05vblN0cmljdCA9IHRydWU7XG4gICAgdmFyIHByb3Blcmx5Qm94ZXNTdHJpY3QgPSB0cnVlO1xuICAgIGlmIChtZXRob2QpIHtcbiAgICAgICAgbWV0aG9kLmNhbGwoJ2ZvbycsIGZ1bmN0aW9uIChfLCBfXywgY29udGV4dCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZXh0ICE9PSAnb2JqZWN0JykgeyBwcm9wZXJseUJveGVzTm9uU3RyaWN0ID0gZmFsc2U7IH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWV0aG9kLmNhbGwoWzFdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgICAgIHByb3Blcmx5Qm94ZXNTdHJpY3QgPSB0eXBlb2YgdGhpcyA9PT0gJ3N0cmluZyc7XG4gICAgICAgIH0sICd4Jyk7XG4gICAgfVxuICAgIHJldHVybiAhIW1ldGhvZCAmJiBwcm9wZXJseUJveGVzTm9uU3RyaWN0ICYmIHByb3Blcmx5Qm94ZXNTdHJpY3Q7XG59O1xuXG5kZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja2ZuLyosIHRoaXNBcmcqLykge1xuICAgICAgICB2YXIgb2JqZWN0ID0gRVMuVG9PYmplY3QodGhpcyk7XG4gICAgICAgIHZhciBzZWxmID0gc3BsaXRTdHJpbmcgJiYgaXNTdHJpbmcodGhpcykgPyBzdHJTcGxpdCh0aGlzLCAnJykgOiBvYmplY3Q7XG4gICAgICAgIHZhciBpID0gLTE7XG4gICAgICAgIHZhciBsZW5ndGggPSBFUy5Ub1VpbnQzMihzZWxmLmxlbmd0aCk7XG4gICAgICAgIHZhciBUO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBUID0gYXJndW1lbnRzWzFdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgbm8gY2FsbGJhY2sgZnVuY3Rpb24gb3IgaWYgY2FsbGJhY2sgaXMgbm90IGEgY2FsbGFibGUgZnVuY3Rpb25cbiAgICAgICAgaWYgKCFpc0NhbGxhYmxlKGNhbGxiYWNrZm4pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheS5wcm90b3R5cGUuZm9yRWFjaCBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlICgrK2kgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChpIGluIHNlbGYpIHtcbiAgICAgICAgICAgICAgICAvLyBJbnZva2UgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdpdGggY2FsbCwgcGFzc2luZyBhcmd1bWVudHM6XG4gICAgICAgICAgICAgICAgLy8gY29udGV4dCwgcHJvcGVydHkgdmFsdWUsIHByb3BlcnR5IGtleSwgdGhpc0FyZyBvYmplY3RcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIFQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrZm4oc2VsZltpXSwgaSwgb2JqZWN0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja2ZuLmNhbGwoVCwgc2VsZltpXSwgaSwgb2JqZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59LCAhcHJvcGVybHlCb3hlc0NvbnRleHQoQXJyYXlQcm90b3R5cGUuZm9yRWFjaCkpO1xuXG4vLyBFUzUgMTUuNC40LjE5XG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjQuMTlcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0NvcmVfSmF2YVNjcmlwdF8xLjVfUmVmZXJlbmNlL09iamVjdHMvQXJyYXkvbWFwXG5kZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgbWFwOiBmdW5jdGlvbiBtYXAoY2FsbGJhY2tmbi8qLCB0aGlzQXJnKi8pIHtcbiAgICAgICAgdmFyIG9iamVjdCA9IEVTLlRvT2JqZWN0KHRoaXMpO1xuICAgICAgICB2YXIgc2VsZiA9IHNwbGl0U3RyaW5nICYmIGlzU3RyaW5nKHRoaXMpID8gc3RyU3BsaXQodGhpcywgJycpIDogb2JqZWN0O1xuICAgICAgICB2YXIgbGVuZ3RoID0gRVMuVG9VaW50MzIoc2VsZi5sZW5ndGgpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gJEFycmF5KGxlbmd0aCk7XG4gICAgICAgIHZhciBUO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIFQgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBubyBjYWxsYmFjayBmdW5jdGlvbiBvciBpZiBjYWxsYmFjayBpcyBub3QgYSBjYWxsYWJsZSBmdW5jdGlvblxuICAgICAgICBpZiAoIWlzQ2FsbGFibGUoY2FsbGJhY2tmbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5LnByb3RvdHlwZS5tYXAgY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSBpbiBzZWxmKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBUID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSBjYWxsYmFja2ZuKHNlbGZbaV0sIGksIG9iamVjdCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gY2FsbGJhY2tmbi5jYWxsKFQsIHNlbGZbaV0sIGksIG9iamVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufSwgIXByb3Blcmx5Qm94ZXNDb250ZXh0KEFycmF5UHJvdG90eXBlLm1hcCkpO1xuXG4vLyBFUzUgMTUuNC40LjIwXG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjQuMjBcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0NvcmVfSmF2YVNjcmlwdF8xLjVfUmVmZXJlbmNlL09iamVjdHMvQXJyYXkvZmlsdGVyXG5kZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIoY2FsbGJhY2tmbi8qLCB0aGlzQXJnKi8pIHtcbiAgICAgICAgdmFyIG9iamVjdCA9IEVTLlRvT2JqZWN0KHRoaXMpO1xuICAgICAgICB2YXIgc2VsZiA9IHNwbGl0U3RyaW5nICYmIGlzU3RyaW5nKHRoaXMpID8gc3RyU3BsaXQodGhpcywgJycpIDogb2JqZWN0O1xuICAgICAgICB2YXIgbGVuZ3RoID0gRVMuVG9VaW50MzIoc2VsZi5sZW5ndGgpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgdmFyIFQ7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgVCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIG5vIGNhbGxiYWNrIGZ1bmN0aW9uIG9yIGlmIGNhbGxiYWNrIGlzIG5vdCBhIGNhbGxhYmxlIGZ1bmN0aW9uXG4gICAgICAgIGlmICghaXNDYWxsYWJsZShjYWxsYmFja2ZuKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkucHJvdG90eXBlLmZpbHRlciBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpIGluIHNlbGYpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHNlbGZbaV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBUID09PSAndW5kZWZpbmVkJyA/IGNhbGxiYWNrZm4odmFsdWUsIGksIG9iamVjdCkgOiBjYWxsYmFja2ZuLmNhbGwoVCwgdmFsdWUsIGksIG9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcHVzaChyZXN1bHQsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59LCAhcHJvcGVybHlCb3hlc0NvbnRleHQoQXJyYXlQcm90b3R5cGUuZmlsdGVyKSk7XG5cbi8vIEVTNSAxNS40LjQuMTZcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjQuNC4xNlxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvZXZlcnlcbmRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICBldmVyeTogZnVuY3Rpb24gZXZlcnkoY2FsbGJhY2tmbi8qLCB0aGlzQXJnKi8pIHtcbiAgICAgICAgdmFyIG9iamVjdCA9IEVTLlRvT2JqZWN0KHRoaXMpO1xuICAgICAgICB2YXIgc2VsZiA9IHNwbGl0U3RyaW5nICYmIGlzU3RyaW5nKHRoaXMpID8gc3RyU3BsaXQodGhpcywgJycpIDogb2JqZWN0O1xuICAgICAgICB2YXIgbGVuZ3RoID0gRVMuVG9VaW50MzIoc2VsZi5sZW5ndGgpO1xuICAgICAgICB2YXIgVDtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBUID0gYXJndW1lbnRzWzFdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgbm8gY2FsbGJhY2sgZnVuY3Rpb24gb3IgaWYgY2FsbGJhY2sgaXMgbm90IGEgY2FsbGFibGUgZnVuY3Rpb25cbiAgICAgICAgaWYgKCFpc0NhbGxhYmxlKGNhbGxiYWNrZm4pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheS5wcm90b3R5cGUuZXZlcnkgY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSBpbiBzZWxmICYmICEodHlwZW9mIFQgPT09ICd1bmRlZmluZWQnID8gY2FsbGJhY2tmbihzZWxmW2ldLCBpLCBvYmplY3QpIDogY2FsbGJhY2tmbi5jYWxsKFQsIHNlbGZbaV0sIGksIG9iamVjdCkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn0sICFwcm9wZXJseUJveGVzQ29udGV4dChBcnJheVByb3RvdHlwZS5ldmVyeSkpO1xuXG4vLyBFUzUgMTUuNC40LjE3XG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjQuMTdcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NvbWVcbmRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICBzb21lOiBmdW5jdGlvbiBzb21lKGNhbGxiYWNrZm4vKiwgdGhpc0FyZyAqLykge1xuICAgICAgICB2YXIgb2JqZWN0ID0gRVMuVG9PYmplY3QodGhpcyk7XG4gICAgICAgIHZhciBzZWxmID0gc3BsaXRTdHJpbmcgJiYgaXNTdHJpbmcodGhpcykgPyBzdHJTcGxpdCh0aGlzLCAnJykgOiBvYmplY3Q7XG4gICAgICAgIHZhciBsZW5ndGggPSBFUy5Ub1VpbnQzMihzZWxmLmxlbmd0aCk7XG4gICAgICAgIHZhciBUO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIFQgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBubyBjYWxsYmFjayBmdW5jdGlvbiBvciBpZiBjYWxsYmFjayBpcyBub3QgYSBjYWxsYWJsZSBmdW5jdGlvblxuICAgICAgICBpZiAoIWlzQ2FsbGFibGUoY2FsbGJhY2tmbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5LnByb3RvdHlwZS5zb21lIGNhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgaW4gc2VsZiAmJiAodHlwZW9mIFQgPT09ICd1bmRlZmluZWQnID8gY2FsbGJhY2tmbihzZWxmW2ldLCBpLCBvYmplY3QpIDogY2FsbGJhY2tmbi5jYWxsKFQsIHNlbGZbaV0sIGksIG9iamVjdCkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn0sICFwcm9wZXJseUJveGVzQ29udGV4dChBcnJheVByb3RvdHlwZS5zb21lKSk7XG5cbi8vIEVTNSAxNS40LjQuMjFcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjQuNC4yMVxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vQ29yZV9KYXZhU2NyaXB0XzEuNV9SZWZlcmVuY2UvT2JqZWN0cy9BcnJheS9yZWR1Y2VcbnZhciByZWR1Y2VDb2VyY2VzVG9PYmplY3QgPSBmYWxzZTtcbmlmIChBcnJheVByb3RvdHlwZS5yZWR1Y2UpIHtcbiAgICByZWR1Y2VDb2VyY2VzVG9PYmplY3QgPSB0eXBlb2YgQXJyYXlQcm90b3R5cGUucmVkdWNlLmNhbGwoJ2VzNScsIGZ1bmN0aW9uIChfLCBfXywgX19fLCBsaXN0KSB7IHJldHVybiBsaXN0OyB9KSA9PT0gJ29iamVjdCc7XG59XG5kZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgcmVkdWNlOiBmdW5jdGlvbiByZWR1Y2UoY2FsbGJhY2tmbi8qLCBpbml0aWFsVmFsdWUqLykge1xuICAgICAgICB2YXIgb2JqZWN0ID0gRVMuVG9PYmplY3QodGhpcyk7XG4gICAgICAgIHZhciBzZWxmID0gc3BsaXRTdHJpbmcgJiYgaXNTdHJpbmcodGhpcykgPyBzdHJTcGxpdCh0aGlzLCAnJykgOiBvYmplY3Q7XG4gICAgICAgIHZhciBsZW5ndGggPSBFUy5Ub1VpbnQzMihzZWxmLmxlbmd0aCk7XG5cbiAgICAgICAgLy8gSWYgbm8gY2FsbGJhY2sgZnVuY3Rpb24gb3IgaWYgY2FsbGJhY2sgaXMgbm90IGEgY2FsbGFibGUgZnVuY3Rpb25cbiAgICAgICAgaWYgKCFpc0NhbGxhYmxlKGNhbGxiYWNrZm4pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheS5wcm90b3R5cGUucmVkdWNlIGNhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm8gdmFsdWUgdG8gcmV0dXJuIGlmIG5vIGluaXRpYWwgdmFsdWUgYW5kIGFuIGVtcHR5IGFycmF5XG4gICAgICAgIGlmIChsZW5ndGggPT09IDAgJiYgYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncmVkdWNlIG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgaWYgKGkgaW4gc2VsZikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBzZWxmW2krK107XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGlmIGFycmF5IGNvbnRhaW5zIG5vIHZhbHVlcywgbm8gaW5pdGlhbCB2YWx1ZSB0byByZXR1cm5cbiAgICAgICAgICAgICAgICBpZiAoKytpID49IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdyZWR1Y2Ugb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAodHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSBpbiBzZWxmKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gY2FsbGJhY2tmbihyZXN1bHQsIHNlbGZbaV0sIGksIG9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn0sICFyZWR1Y2VDb2VyY2VzVG9PYmplY3QpO1xuXG4vLyBFUzUgMTUuNC40LjIyXG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjQuMjJcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0NvcmVfSmF2YVNjcmlwdF8xLjVfUmVmZXJlbmNlL09iamVjdHMvQXJyYXkvcmVkdWNlUmlnaHRcbnZhciByZWR1Y2VSaWdodENvZXJjZXNUb09iamVjdCA9IGZhbHNlO1xuaWYgKEFycmF5UHJvdG90eXBlLnJlZHVjZVJpZ2h0KSB7XG4gICAgcmVkdWNlUmlnaHRDb2VyY2VzVG9PYmplY3QgPSB0eXBlb2YgQXJyYXlQcm90b3R5cGUucmVkdWNlUmlnaHQuY2FsbCgnZXM1JywgZnVuY3Rpb24gKF8sIF9fLCBfX18sIGxpc3QpIHsgcmV0dXJuIGxpc3Q7IH0pID09PSAnb2JqZWN0Jztcbn1cbmRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICByZWR1Y2VSaWdodDogZnVuY3Rpb24gcmVkdWNlUmlnaHQoY2FsbGJhY2tmbi8qLCBpbml0aWFsKi8pIHtcbiAgICAgICAgdmFyIG9iamVjdCA9IEVTLlRvT2JqZWN0KHRoaXMpO1xuICAgICAgICB2YXIgc2VsZiA9IHNwbGl0U3RyaW5nICYmIGlzU3RyaW5nKHRoaXMpID8gc3RyU3BsaXQodGhpcywgJycpIDogb2JqZWN0O1xuICAgICAgICB2YXIgbGVuZ3RoID0gRVMuVG9VaW50MzIoc2VsZi5sZW5ndGgpO1xuXG4gICAgICAgIC8vIElmIG5vIGNhbGxiYWNrIGZ1bmN0aW9uIG9yIGlmIGNhbGxiYWNrIGlzIG5vdCBhIGNhbGxhYmxlIGZ1bmN0aW9uXG4gICAgICAgIGlmICghaXNDYWxsYWJsZShjYWxsYmFja2ZuKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkucHJvdG90eXBlLnJlZHVjZVJpZ2h0IGNhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm8gdmFsdWUgdG8gcmV0dXJuIGlmIG5vIGluaXRpYWwgdmFsdWUsIGVtcHR5IGFycmF5XG4gICAgICAgIGlmIChsZW5ndGggPT09IDAgJiYgYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncmVkdWNlUmlnaHQgb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB2YXIgaSA9IGxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBpZiAoaSBpbiBzZWxmKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHNlbGZbaS0tXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gaWYgYXJyYXkgY29udGFpbnMgbm8gdmFsdWVzLCBubyBpbml0aWFsIHZhbHVlIHRvIHJldHVyblxuICAgICAgICAgICAgICAgIGlmICgtLWkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3JlZHVjZVJpZ2h0IG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGkgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKGkgaW4gc2VsZikge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGNhbGxiYWNrZm4ocmVzdWx0LCBzZWxmW2ldLCBpLCBvYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChpLS0pO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufSwgIXJlZHVjZVJpZ2h0Q29lcmNlc1RvT2JqZWN0KTtcblxuLy8gRVM1IDE1LjQuNC4xNFxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNC40LjE0XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9pbmRleE9mXG52YXIgaGFzRmlyZWZveDJJbmRleE9mQnVnID0gQXJyYXlQcm90b3R5cGUuaW5kZXhPZiAmJiBbMCwgMV0uaW5kZXhPZigxLCAyKSAhPT0gLTE7XG5kZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgaW5kZXhPZjogZnVuY3Rpb24gaW5kZXhPZihzZWFyY2hFbGVtZW50LyosIGZyb21JbmRleCAqLykge1xuICAgICAgICB2YXIgc2VsZiA9IHNwbGl0U3RyaW5nICYmIGlzU3RyaW5nKHRoaXMpID8gc3RyU3BsaXQodGhpcywgJycpIDogRVMuVG9PYmplY3QodGhpcyk7XG4gICAgICAgIHZhciBsZW5ndGggPSBFUy5Ub1VpbnQzMihzZWxmLmxlbmd0aCk7XG5cbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGkgPSBFUy5Ub0ludGVnZXIoYXJndW1lbnRzWzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGhhbmRsZSBuZWdhdGl2ZSBpbmRpY2VzXG4gICAgICAgIGkgPSBpID49IDAgPyBpIDogbWF4KDAsIGxlbmd0aCArIGkpO1xuICAgICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSBpbiBzZWxmICYmIHNlbGZbaV0gPT09IHNlYXJjaEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxufSwgaGFzRmlyZWZveDJJbmRleE9mQnVnKTtcblxuLy8gRVM1IDE1LjQuNC4xNVxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNC40LjE1XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9sYXN0SW5kZXhPZlxudmFyIGhhc0ZpcmVmb3gyTGFzdEluZGV4T2ZCdWcgPSBBcnJheVByb3RvdHlwZS5sYXN0SW5kZXhPZiAmJiBbMCwgMV0ubGFzdEluZGV4T2YoMCwgLTMpICE9PSAtMTtcbmRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICBsYXN0SW5kZXhPZjogZnVuY3Rpb24gbGFzdEluZGV4T2Yoc2VhcmNoRWxlbWVudC8qLCBmcm9tSW5kZXggKi8pIHtcbiAgICAgICAgdmFyIHNlbGYgPSBzcGxpdFN0cmluZyAmJiBpc1N0cmluZyh0aGlzKSA/IHN0clNwbGl0KHRoaXMsICcnKSA6IEVTLlRvT2JqZWN0KHRoaXMpO1xuICAgICAgICB2YXIgbGVuZ3RoID0gRVMuVG9VaW50MzIoc2VsZi5sZW5ndGgpO1xuXG4gICAgICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaSA9IGxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgaSA9IG1pbihpLCBFUy5Ub0ludGVnZXIoYXJndW1lbnRzWzFdKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaGFuZGxlIG5lZ2F0aXZlIGluZGljZXNcbiAgICAgICAgaSA9IGkgPj0gMCA/IGkgOiBsZW5ndGggLSBNYXRoLmFicyhpKTtcbiAgICAgICAgZm9yICg7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAoaSBpbiBzZWxmICYmIHNlYXJjaEVsZW1lbnQgPT09IHNlbGZbaV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxufSwgaGFzRmlyZWZveDJMYXN0SW5kZXhPZkJ1Zyk7XG5cbi8vIEVTNSAxNS40LjQuMTJcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjQuNC4xMlxudmFyIHNwbGljZU5vb3BSZXR1cm5zRW1wdHlBcnJheSA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGEgPSBbMSwgMl07XG4gICAgdmFyIHJlc3VsdCA9IGEuc3BsaWNlKCk7XG4gICAgcmV0dXJuIGEubGVuZ3RoID09PSAyICYmIGlzQXJyYXkocmVzdWx0KSAmJiByZXN1bHQubGVuZ3RoID09PSAwO1xufSgpKTtcbmRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICAvLyBTYWZhcmkgNS4wIGJ1ZyB3aGVyZSAuc3BsaWNlKCkgcmV0dXJucyB1bmRlZmluZWRcbiAgICBzcGxpY2U6IGZ1bmN0aW9uIHNwbGljZShzdGFydCwgZGVsZXRlQ291bnQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBhcnJheV9zcGxpY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH1cbn0sICFzcGxpY2VOb29wUmV0dXJuc0VtcHR5QXJyYXkpO1xuXG52YXIgc3BsaWNlV29ya3NXaXRoRW1wdHlPYmplY3QgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYmogPSB7fTtcbiAgICBBcnJheVByb3RvdHlwZS5zcGxpY2UuY2FsbChvYmosIDAsIDAsIDEpO1xuICAgIHJldHVybiBvYmoubGVuZ3RoID09PSAxO1xufSgpKTtcbmRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICBzcGxpY2U6IGZ1bmN0aW9uIHNwbGljZShzdGFydCwgZGVsZXRlQ291bnQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHsgcmV0dXJuIFtdOyB9XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IG1heChFUy5Ub0ludGVnZXIodGhpcy5sZW5ndGgpLCAwKTtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIHR5cGVvZiBkZWxldGVDb3VudCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGFyZ3MgPSBhcnJheVNsaWNlKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgcHVzaChhcmdzLCB0aGlzLmxlbmd0aCAtIHN0YXJ0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXJnc1sxXSA9IEVTLlRvSW50ZWdlcihkZWxldGVDb3VudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5X3NwbGljZS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG59LCAhc3BsaWNlV29ya3NXaXRoRW1wdHlPYmplY3QpO1xudmFyIHNwbGljZVdvcmtzV2l0aExhcmdlU3BhcnNlQXJyYXlzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBQZXIgaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltL2lzc3Vlcy8yOTVcbiAgICAvLyBTYWZhcmkgNy84IGJyZWFrcyB3aXRoIHNwYXJzZSBhcnJheXMgb2Ygc2l6ZSAxZTUgb3IgZ3JlYXRlclxuICAgIHZhciBhcnIgPSBuZXcgJEFycmF5KDFlNSk7XG4gICAgLy8gbm90ZTogdGhlIGluZGV4IE1VU1QgYmUgOCBvciBsYXJnZXIgb3IgdGhlIHRlc3Qgd2lsbCBmYWxzZSBwYXNzXG4gICAgYXJyWzhdID0gJ3gnO1xuICAgIGFyci5zcGxpY2UoMSwgMSk7XG4gICAgLy8gbm90ZTogdGhpcyB0ZXN0IG11c3QgYmUgZGVmaW5lZCAqYWZ0ZXIqIHRoZSBpbmRleE9mIHNoaW1cbiAgICAvLyBwZXIgaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltL2lzc3Vlcy8zMTNcbiAgICByZXR1cm4gYXJyLmluZGV4T2YoJ3gnKSA9PT0gNztcbn0oKSk7XG52YXIgc3BsaWNlV29ya3NXaXRoU21hbGxTcGFyc2VBcnJheXMgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8vIFBlciBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0vaXNzdWVzLzI5NVxuICAgIC8vIE9wZXJhIDEyLjE1IGJyZWFrcyBvbiB0aGlzLCBubyBpZGVhIHdoeS5cbiAgICB2YXIgbiA9IDI1NjtcbiAgICB2YXIgYXJyID0gW107XG4gICAgYXJyW25dID0gJ2EnO1xuICAgIGFyci5zcGxpY2UobiArIDEsIDAsICdiJyk7XG4gICAgcmV0dXJuIGFycltuXSA9PT0gJ2EnO1xufSgpKTtcbmRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICBzcGxpY2U6IGZ1bmN0aW9uIHNwbGljZShzdGFydCwgZGVsZXRlQ291bnQpIHtcbiAgICAgICAgdmFyIE8gPSBFUy5Ub09iamVjdCh0aGlzKTtcbiAgICAgICAgdmFyIEEgPSBbXTtcbiAgICAgICAgdmFyIGxlbiA9IEVTLlRvVWludDMyKE8ubGVuZ3RoKTtcbiAgICAgICAgdmFyIHJlbGF0aXZlU3RhcnQgPSBFUy5Ub0ludGVnZXIoc3RhcnQpO1xuICAgICAgICB2YXIgYWN0dWFsU3RhcnQgPSByZWxhdGl2ZVN0YXJ0IDwgMCA/IG1heCgobGVuICsgcmVsYXRpdmVTdGFydCksIDApIDogbWluKHJlbGF0aXZlU3RhcnQsIGxlbik7XG4gICAgICAgIHZhciBhY3R1YWxEZWxldGVDb3VudCA9IG1pbihtYXgoRVMuVG9JbnRlZ2VyKGRlbGV0ZUNvdW50KSwgMCksIGxlbiAtIGFjdHVhbFN0YXJ0KTtcblxuICAgICAgICB2YXIgayA9IDA7XG4gICAgICAgIHZhciBmcm9tO1xuICAgICAgICB3aGlsZSAoayA8IGFjdHVhbERlbGV0ZUNvdW50KSB7XG4gICAgICAgICAgICBmcm9tID0gJFN0cmluZyhhY3R1YWxTdGFydCArIGspO1xuICAgICAgICAgICAgaWYgKG93bnMoTywgZnJvbSkpIHtcbiAgICAgICAgICAgICAgICBBW2tdID0gT1tmcm9tXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGsgKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpdGVtcyA9IGFycmF5U2xpY2UoYXJndW1lbnRzLCAyKTtcbiAgICAgICAgdmFyIGl0ZW1Db3VudCA9IGl0ZW1zLmxlbmd0aDtcbiAgICAgICAgdmFyIHRvO1xuICAgICAgICBpZiAoaXRlbUNvdW50IDwgYWN0dWFsRGVsZXRlQ291bnQpIHtcbiAgICAgICAgICAgIGsgPSBhY3R1YWxTdGFydDtcbiAgICAgICAgICAgIHdoaWxlIChrIDwgKGxlbiAtIGFjdHVhbERlbGV0ZUNvdW50KSkge1xuICAgICAgICAgICAgICAgIGZyb20gPSAkU3RyaW5nKGsgKyBhY3R1YWxEZWxldGVDb3VudCk7XG4gICAgICAgICAgICAgICAgdG8gPSAkU3RyaW5nKGsgKyBpdGVtQ291bnQpO1xuICAgICAgICAgICAgICAgIGlmIChvd25zKE8sIGZyb20pKSB7XG4gICAgICAgICAgICAgICAgICAgIE9bdG9dID0gT1tmcm9tXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgT1t0b107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGsgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGsgPSBsZW47XG4gICAgICAgICAgICB3aGlsZSAoayA+IChsZW4gLSBhY3R1YWxEZWxldGVDb3VudCArIGl0ZW1Db3VudCkpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgT1trIC0gMV07XG4gICAgICAgICAgICAgICAgayAtPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGl0ZW1Db3VudCA+IGFjdHVhbERlbGV0ZUNvdW50KSB7XG4gICAgICAgICAgICBrID0gbGVuIC0gYWN0dWFsRGVsZXRlQ291bnQ7XG4gICAgICAgICAgICB3aGlsZSAoayA+IGFjdHVhbFN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgZnJvbSA9ICRTdHJpbmcoayArIGFjdHVhbERlbGV0ZUNvdW50IC0gMSk7XG4gICAgICAgICAgICAgICAgdG8gPSAkU3RyaW5nKGsgKyBpdGVtQ291bnQgLSAxKTtcbiAgICAgICAgICAgICAgICBpZiAob3ducyhPLCBmcm9tKSkge1xuICAgICAgICAgICAgICAgICAgICBPW3RvXSA9IE9bZnJvbV07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIE9bdG9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBrIC09IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgayA9IGFjdHVhbFN0YXJ0O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBPW2tdID0gaXRlbXNbaV07XG4gICAgICAgICAgICBrICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgTy5sZW5ndGggPSBsZW4gLSBhY3R1YWxEZWxldGVDb3VudCArIGl0ZW1Db3VudDtcblxuICAgICAgICByZXR1cm4gQTtcbiAgICB9XG59LCAhc3BsaWNlV29ya3NXaXRoTGFyZ2VTcGFyc2VBcnJheXMgfHwgIXNwbGljZVdvcmtzV2l0aFNtYWxsU3BhcnNlQXJyYXlzKTtcblxudmFyIG9yaWdpbmFsSm9pbiA9IEFycmF5UHJvdG90eXBlLmpvaW47XG52YXIgaGFzU3RyaW5nSm9pbkJ1ZztcbnRyeSB7XG4gICAgaGFzU3RyaW5nSm9pbkJ1ZyA9IEFycmF5LnByb3RvdHlwZS5qb2luLmNhbGwoJzEyMycsICcsJykgIT09ICcxLDIsMyc7XG59IGNhdGNoIChlKSB7XG4gICAgaGFzU3RyaW5nSm9pbkJ1ZyA9IHRydWU7XG59XG5pZiAoaGFzU3RyaW5nSm9pbkJ1Zykge1xuICAgIGRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICAgICAgam9pbjogZnVuY3Rpb24gam9pbihzZXBhcmF0b3IpIHtcbiAgICAgICAgICAgIHZhciBzZXAgPSB0eXBlb2Ygc2VwYXJhdG9yID09PSAndW5kZWZpbmVkJyA/ICcsJyA6IHNlcGFyYXRvcjtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbEpvaW4uY2FsbChpc1N0cmluZyh0aGlzKSA/IHN0clNwbGl0KHRoaXMsICcnKSA6IHRoaXMsIHNlcCk7XG4gICAgICAgIH1cbiAgICB9LCBoYXNTdHJpbmdKb2luQnVnKTtcbn1cblxudmFyIGhhc0pvaW5VbmRlZmluZWRCdWcgPSBbMSwgMl0uam9pbih1bmRlZmluZWQpICE9PSAnMSwyJztcbmlmIChoYXNKb2luVW5kZWZpbmVkQnVnKSB7XG4gICAgZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgICAgICBqb2luOiBmdW5jdGlvbiBqb2luKHNlcGFyYXRvcikge1xuICAgICAgICAgICAgdmFyIHNlcCA9IHR5cGVvZiBzZXBhcmF0b3IgPT09ICd1bmRlZmluZWQnID8gJywnIDogc2VwYXJhdG9yO1xuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsSm9pbi5jYWxsKHRoaXMsIHNlcCk7XG4gICAgICAgIH1cbiAgICB9LCBoYXNKb2luVW5kZWZpbmVkQnVnKTtcbn1cblxudmFyIHB1c2hTaGltID0gZnVuY3Rpb24gcHVzaChpdGVtKSB7XG4gICAgdmFyIE8gPSBFUy5Ub09iamVjdCh0aGlzKTtcbiAgICB2YXIgbiA9IEVTLlRvVWludDMyKE8ubGVuZ3RoKTtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIE9bbiArIGldID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBpICs9IDE7XG4gICAgfVxuICAgIE8ubGVuZ3RoID0gbiArIGk7XG4gICAgcmV0dXJuIG4gKyBpO1xufTtcblxudmFyIHB1c2hJc05vdEdlbmVyaWMgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYmogPSB7fTtcbiAgICB2YXIgcmVzdWx0ID0gQXJyYXkucHJvdG90eXBlLnB1c2guY2FsbChvYmosIHVuZGVmaW5lZCk7XG4gICAgcmV0dXJuIHJlc3VsdCAhPT0gMSB8fCBvYmoubGVuZ3RoICE9PSAxIHx8IHR5cGVvZiBvYmpbMF0gIT09ICd1bmRlZmluZWQnIHx8ICFvd25zKG9iaiwgMCk7XG59KCkpO1xuZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgIHB1c2g6IGZ1bmN0aW9uIHB1c2goaXRlbSkge1xuICAgICAgICBpZiAoaXNBcnJheSh0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGFycmF5X3B1c2guYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHVzaFNoaW0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG59LCBwdXNoSXNOb3RHZW5lcmljKTtcblxuLy8gVGhpcyBmaXhlcyBhIHZlcnkgd2VpcmQgYnVnIGluIE9wZXJhIDEwLjYgd2hlbiBwdXNoaW5nIGB1bmRlZmluZWRcbnZhciBwdXNoVW5kZWZpbmVkSXNXZWlyZCA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyciA9IFtdO1xuICAgIHZhciByZXN1bHQgPSBhcnIucHVzaCh1bmRlZmluZWQpO1xuICAgIHJldHVybiByZXN1bHQgIT09IDEgfHwgYXJyLmxlbmd0aCAhPT0gMSB8fCB0eXBlb2YgYXJyWzBdICE9PSAndW5kZWZpbmVkJyB8fCAhb3ducyhhcnIsIDApO1xufSgpKTtcbmRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHsgcHVzaDogcHVzaFNoaW0gfSwgcHVzaFVuZGVmaW5lZElzV2VpcmQpO1xuXG4vLyBFUzUgMTUuMi4zLjE0XG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjQuNC4xMFxuLy8gRml4IGJveGVkIHN0cmluZyBidWdcbmRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICBzbGljZTogZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdmFyIGFyciA9IGlzU3RyaW5nKHRoaXMpID8gc3RyU3BsaXQodGhpcywgJycpIDogdGhpcztcbiAgICAgICAgcmV0dXJuIGFycmF5U2xpY2VBcHBseShhcnIsIGFyZ3VtZW50cyk7XG4gICAgfVxufSwgc3BsaXRTdHJpbmcpO1xuXG52YXIgc29ydElnbm9yZXNOb25GdW5jdGlvbnMgPSAoZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIFsxLCAyXS5zb3J0KG51bGwpO1xuICAgICAgICBbMSwgMl0uc29ydCh7fSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHsgLyoqLyB9XG4gICAgcmV0dXJuIGZhbHNlO1xufSgpKTtcbnZhciBzb3J0VGhyb3dzT25SZWdleCA9IChmdW5jdGlvbiAoKSB7XG4gICAgLy8gdGhpcyBpcyBhIHByb2JsZW0gaW4gRmlyZWZveCA0LCBpbiB3aGljaCBgdHlwZW9mIC9hLyA9PT0gJ2Z1bmN0aW9uJ2BcbiAgICB0cnkge1xuICAgICAgICBbMSwgMl0uc29ydCgvYS8pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZSkgeyAvKiovIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn0oKSk7XG52YXIgc29ydElnbm9yZXNVbmRlZmluZWQgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8vIGFwcGxpZXMgaW4gSUUgOCwgZm9yIG9uZS5cbiAgICB0cnkge1xuICAgICAgICBbMSwgMl0uc29ydCh1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7IC8qKi8gfVxuICAgIHJldHVybiBmYWxzZTtcbn0oKSk7XG5kZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgc29ydDogZnVuY3Rpb24gc29ydChjb21wYXJlRm4pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjb21wYXJlRm4gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyYXlTb3J0KHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNDYWxsYWJsZShjb21wYXJlRm4pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheS5wcm90b3R5cGUuc29ydCBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXlTb3J0KHRoaXMsIGNvbXBhcmVGbik7XG4gICAgfVxufSwgc29ydElnbm9yZXNOb25GdW5jdGlvbnMgfHwgIXNvcnRJZ25vcmVzVW5kZWZpbmVkIHx8ICFzb3J0VGhyb3dzT25SZWdleCk7XG5cbi8vXG4vLyBPYmplY3Rcbi8vID09PT09PVxuLy9cblxuLy8gRVM1IDE1LjIuMy4xNFxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuMi4zLjE0XG5cbi8vIGh0dHA6Ly93aGF0dGhlaGVhZHNhaWQuY29tLzIwMTAvMTAvYS1zYWZlci1vYmplY3Qta2V5cy1jb21wYXRpYmlsaXR5LWltcGxlbWVudGF0aW9uXG52YXIgaGFzRG9udEVudW1CdWcgPSAhKHsgJ3RvU3RyaW5nJzogbnVsbCB9KS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgndG9TdHJpbmcnKTtcbnZhciBoYXNQcm90b0VudW1CdWcgPSBmdW5jdGlvbiAoKSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgncHJvdG90eXBlJyk7XG52YXIgaGFzU3RyaW5nRW51bUJ1ZyA9ICFvd25zKCd4JywgJzAnKTtcbnZhciBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgdmFyIGN0b3IgPSBvLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yICYmIGN0b3IucHJvdG90eXBlID09PSBvO1xufTtcbnZhciBibGFja2xpc3RlZEtleXMgPSB7XG4gICAgJHdpbmRvdzogdHJ1ZSxcbiAgICAkY29uc29sZTogdHJ1ZSxcbiAgICAkcGFyZW50OiB0cnVlLFxuICAgICRzZWxmOiB0cnVlLFxuICAgICRmcmFtZTogdHJ1ZSxcbiAgICAkZnJhbWVzOiB0cnVlLFxuICAgICRmcmFtZUVsZW1lbnQ6IHRydWUsXG4gICAgJHdlYmtpdEluZGV4ZWREQjogdHJ1ZSxcbiAgICAkd2Via2l0U3RvcmFnZUluZm86IHRydWUsXG4gICAgJGV4dGVybmFsOiB0cnVlXG59O1xudmFyIGhhc0F1dG9tYXRpb25FcXVhbGl0eUJ1ZyA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyogZ2xvYmFscyB3aW5kb3cgKi9cbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZm9yICh2YXIgayBpbiB3aW5kb3cpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghYmxhY2tsaXN0ZWRLZXlzWyckJyArIGtdICYmIG93bnMod2luZG93LCBrKSAmJiB3aW5kb3dba10gIT09IG51bGwgJiYgdHlwZW9mIHdpbmRvd1trXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZSh3aW5kb3dba10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59KCkpO1xudmFyIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlSWZOb3RCdWdneSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgIWhhc0F1dG9tYXRpb25FcXVhbGl0eUJ1ZykgeyByZXR1cm4gZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUob2JqZWN0KTsgfVxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZShvYmplY3QpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn07XG52YXIgZG9udEVudW1zID0gW1xuICAgICd0b1N0cmluZycsXG4gICAgJ3RvTG9jYWxlU3RyaW5nJyxcbiAgICAndmFsdWVPZicsXG4gICAgJ2hhc093blByb3BlcnR5JyxcbiAgICAnaXNQcm90b3R5cGVPZicsXG4gICAgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJyxcbiAgICAnY29uc3RydWN0b3InXG5dO1xudmFyIGRvbnRFbnVtc0xlbmd0aCA9IGRvbnRFbnVtcy5sZW5ndGg7XG5cbi8vIHRha2VuIGRpcmVjdGx5IGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2xqaGFyYi9pcy1hcmd1bWVudHMvYmxvYi9tYXN0ZXIvaW5kZXguanNcbi8vIGNhbiBiZSByZXBsYWNlZCB3aXRoIHJlcXVpcmUoJ2lzLWFyZ3VtZW50cycpIGlmIHdlIGV2ZXIgdXNlIGEgYnVpbGQgcHJvY2VzcyBpbnN0ZWFkXG52YXIgaXNTdGFuZGFyZEFyZ3VtZW50cyA9IGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRvU3RyKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG59O1xudmFyIGlzTGVnYWN5QXJndW1lbnRzID0gZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICB0eXBlb2YgdmFsdWUubGVuZ3RoID09PSAnbnVtYmVyJyAmJlxuICAgICAgICB2YWx1ZS5sZW5ndGggPj0gMCAmJlxuICAgICAgICAhaXNBcnJheSh2YWx1ZSkgJiZcbiAgICAgICAgaXNDYWxsYWJsZSh2YWx1ZS5jYWxsZWUpO1xufTtcbnZhciBpc0FyZ3VtZW50cyA9IGlzU3RhbmRhcmRBcmd1bWVudHMoYXJndW1lbnRzKSA/IGlzU3RhbmRhcmRBcmd1bWVudHMgOiBpc0xlZ2FjeUFyZ3VtZW50cztcblxuZGVmaW5lUHJvcGVydGllcygkT2JqZWN0LCB7XG4gICAga2V5czogZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgICAgICAgdmFyIGlzRm4gPSBpc0NhbGxhYmxlKG9iamVjdCk7XG4gICAgICAgIHZhciBpc0FyZ3MgPSBpc0FyZ3VtZW50cyhvYmplY3QpO1xuICAgICAgICB2YXIgaXNPYmplY3QgPSBvYmplY3QgIT09IG51bGwgJiYgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCc7XG4gICAgICAgIHZhciBpc1N0ciA9IGlzT2JqZWN0ICYmIGlzU3RyaW5nKG9iamVjdCk7XG5cbiAgICAgICAgaWYgKCFpc09iamVjdCAmJiAhaXNGbiAmJiAhaXNBcmdzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3Qua2V5cyBjYWxsZWQgb24gYSBub24tb2JqZWN0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGhlS2V5cyA9IFtdO1xuICAgICAgICB2YXIgc2tpcFByb3RvID0gaGFzUHJvdG9FbnVtQnVnICYmIGlzRm47XG4gICAgICAgIGlmICgoaXNTdHIgJiYgaGFzU3RyaW5nRW51bUJ1ZykgfHwgaXNBcmdzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHB1c2godGhlS2V5cywgJFN0cmluZyhpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzQXJncykge1xuICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShza2lwUHJvdG8gJiYgbmFtZSA9PT0gJ3Byb3RvdHlwZScpICYmIG93bnMob2JqZWN0LCBuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBwdXNoKHRoZUtleXMsICRTdHJpbmcobmFtZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNEb250RW51bUJ1Zykge1xuICAgICAgICAgICAgdmFyIHNraXBDb25zdHJ1Y3RvciA9IGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlSWZOb3RCdWdneShvYmplY3QpO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkb250RW51bXNMZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHZhciBkb250RW51bSA9IGRvbnRFbnVtc1tqXTtcbiAgICAgICAgICAgICAgICBpZiAoIShza2lwQ29uc3RydWN0b3IgJiYgZG9udEVudW0gPT09ICdjb25zdHJ1Y3RvcicpICYmIG93bnMob2JqZWN0LCBkb250RW51bSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcHVzaCh0aGVLZXlzLCBkb250RW51bSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGVLZXlzO1xuICAgIH1cbn0pO1xuXG52YXIga2V5c1dvcmtzV2l0aEFyZ3VtZW50cyA9ICRPYmplY3Qua2V5cyAmJiAoZnVuY3Rpb24gKCkge1xuICAgIC8vIFNhZmFyaSA1LjAgYnVnXG4gICAgcmV0dXJuICRPYmplY3Qua2V5cyhhcmd1bWVudHMpLmxlbmd0aCA9PT0gMjtcbn0oMSwgMikpO1xudmFyIGtleXNIYXNBcmd1bWVudHNMZW5ndGhCdWcgPSAkT2JqZWN0LmtleXMgJiYgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJnS2V5cyA9ICRPYmplY3Qua2V5cyhhcmd1bWVudHMpO1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoICE9PSAxIHx8IGFyZ0tleXMubGVuZ3RoICE9PSAxIHx8IGFyZ0tleXNbMF0gIT09IDE7XG59KDEpKTtcbnZhciBvcmlnaW5hbEtleXMgPSAkT2JqZWN0LmtleXM7XG5kZWZpbmVQcm9wZXJ0aWVzKCRPYmplY3QsIHtcbiAgICBrZXlzOiBmdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICAgICAgICBpZiAoaXNBcmd1bWVudHMob2JqZWN0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsS2V5cyhhcnJheVNsaWNlKG9iamVjdCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsS2V5cyhvYmplY3QpO1xuICAgICAgICB9XG4gICAgfVxufSwgIWtleXNXb3Jrc1dpdGhBcmd1bWVudHMgfHwga2V5c0hhc0FyZ3VtZW50c0xlbmd0aEJ1Zyk7XG5cbi8vXG4vLyBEYXRlXG4vLyA9PT09XG4vL1xuXG4vLyBFUzUgMTUuOS41LjQzXG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS45LjUuNDNcbi8vIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIFN0cmluZyB2YWx1ZSByZXByZXNlbnQgdGhlIGluc3RhbmNlIGluIHRpbWVcbi8vIHJlcHJlc2VudGVkIGJ5IHRoaXMgRGF0ZSBvYmplY3QuIFRoZSBmb3JtYXQgb2YgdGhlIFN0cmluZyBpcyB0aGUgRGF0ZSBUaW1lXG4vLyBzdHJpbmcgZm9ybWF0IGRlZmluZWQgaW4gMTUuOS4xLjE1LiBBbGwgZmllbGRzIGFyZSBwcmVzZW50IGluIHRoZSBTdHJpbmcuXG4vLyBUaGUgdGltZSB6b25lIGlzIGFsd2F5cyBVVEMsIGRlbm90ZWQgYnkgdGhlIHN1ZmZpeCBaLiBJZiB0aGUgdGltZSB2YWx1ZSBvZlxuLy8gdGhpcyBvYmplY3QgaXMgbm90IGEgZmluaXRlIE51bWJlciBhIFJhbmdlRXJyb3IgZXhjZXB0aW9uIGlzIHRocm93bi5cbnZhciBuZWdhdGl2ZURhdGUgPSAtNjIxOTg3NTUyMDAwMDA7XG52YXIgbmVnYXRpdmVZZWFyU3RyaW5nID0gJy0wMDAwMDEnO1xudmFyIGhhc05lZ2F0aXZlRGF0ZUJ1ZyA9IERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nICYmIG5ldyBEYXRlKG5lZ2F0aXZlRGF0ZSkudG9JU09TdHJpbmcoKS5pbmRleE9mKG5lZ2F0aXZlWWVhclN0cmluZykgPT09IC0xO1xudmFyIGhhc1NhZmFyaTUxRGF0ZUJ1ZyA9IERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nICYmIG5ldyBEYXRlKC0xKS50b0lTT1N0cmluZygpICE9PSAnMTk2OS0xMi0zMVQyMzo1OTo1OS45OTlaJztcblxuZGVmaW5lUHJvcGVydGllcyhEYXRlLnByb3RvdHlwZSwge1xuICAgIHRvSVNPU3RyaW5nOiBmdW5jdGlvbiB0b0lTT1N0cmluZygpIHtcbiAgICAgICAgdmFyIHJlc3VsdCwgbGVuZ3RoLCB2YWx1ZSwgeWVhciwgbW9udGg7XG4gICAgICAgIGlmICghaXNGaW5pdGUodGhpcykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZyBjYWxsZWQgb24gbm9uLWZpbml0ZSB2YWx1ZS4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHllYXIgPSB0aGlzLmdldFVUQ0Z1bGxZZWFyKCk7XG5cbiAgICAgICAgbW9udGggPSB0aGlzLmdldFVUQ01vbnRoKCk7XG4gICAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0vaXNzdWVzLzExMVxuICAgICAgICB5ZWFyICs9IE1hdGguZmxvb3IobW9udGggLyAxMik7XG4gICAgICAgIG1vbnRoID0gKG1vbnRoICUgMTIgKyAxMikgJSAxMjtcblxuICAgICAgICAvLyB0aGUgZGF0ZSB0aW1lIHN0cmluZyBmb3JtYXQgaXMgc3BlY2lmaWVkIGluIDE1LjkuMS4xNS5cbiAgICAgICAgcmVzdWx0ID0gW21vbnRoICsgMSwgdGhpcy5nZXRVVENEYXRlKCksIHRoaXMuZ2V0VVRDSG91cnMoKSwgdGhpcy5nZXRVVENNaW51dGVzKCksIHRoaXMuZ2V0VVRDU2Vjb25kcygpXTtcbiAgICAgICAgeWVhciA9IChcbiAgICAgICAgICAgICh5ZWFyIDwgMCA/ICctJyA6ICh5ZWFyID4gOTk5OSA/ICcrJyA6ICcnKSkgK1xuICAgICAgICAgICAgc3RyU2xpY2UoJzAwMDAwJyArIE1hdGguYWJzKHllYXIpLCAoMCA8PSB5ZWFyICYmIHllYXIgPD0gOTk5OSkgPyAtNCA6IC02KVxuICAgICAgICApO1xuXG4gICAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAgICAgdmFsdWUgPSByZXN1bHRbbGVuZ3RoXTtcbiAgICAgICAgICAgIC8vIHBhZCBtb250aHMsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBhbmQgc2Vjb25kcyB0byBoYXZlIHR3b1xuICAgICAgICAgICAgLy8gZGlnaXRzLlxuICAgICAgICAgICAgaWYgKHZhbHVlIDwgMTApIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbbGVuZ3RoXSA9ICcwJyArIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHBhZCBtaWxsaXNlY29uZHMgdG8gaGF2ZSB0aHJlZSBkaWdpdHMuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB5ZWFyICsgJy0nICsgYXJyYXlTbGljZShyZXN1bHQsIDAsIDIpLmpvaW4oJy0nKSArXG4gICAgICAgICAgICAnVCcgKyBhcnJheVNsaWNlKHJlc3VsdCwgMikuam9pbignOicpICsgJy4nICtcbiAgICAgICAgICAgIHN0clNsaWNlKCcwMDAnICsgdGhpcy5nZXRVVENNaWxsaXNlY29uZHMoKSwgLTMpICsgJ1onXG4gICAgICAgICk7XG4gICAgfVxufSwgaGFzTmVnYXRpdmVEYXRlQnVnIHx8IGhhc1NhZmFyaTUxRGF0ZUJ1Zyk7XG5cbi8vIEVTNSAxNS45LjUuNDRcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjkuNS40NFxuLy8gVGhpcyBmdW5jdGlvbiBwcm92aWRlcyBhIFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIERhdGUgb2JqZWN0IGZvciB1c2UgYnlcbi8vIEpTT04uc3RyaW5naWZ5ICgxNS4xMi4zKS5cbnZhciBkYXRlVG9KU09OSXNTdXBwb3J0ZWQgPSAoZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBEYXRlLnByb3RvdHlwZS50b0pTT04gJiZcbiAgICAgICAgICAgIG5ldyBEYXRlKE5hTikudG9KU09OKCkgPT09IG51bGwgJiZcbiAgICAgICAgICAgIG5ldyBEYXRlKG5lZ2F0aXZlRGF0ZSkudG9KU09OKCkuaW5kZXhPZihuZWdhdGl2ZVllYXJTdHJpbmcpICE9PSAtMSAmJlxuICAgICAgICAgICAgRGF0ZS5wcm90b3R5cGUudG9KU09OLmNhbGwoeyAvLyBnZW5lcmljXG4gICAgICAgICAgICAgICAgdG9JU09TdHJpbmc6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH1cbiAgICAgICAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn0oKSk7XG5pZiAoIWRhdGVUb0pTT05Jc1N1cHBvcnRlZCkge1xuICAgIERhdGUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTihrZXkpIHtcbiAgICAgICAgLy8gV2hlbiB0aGUgdG9KU09OIG1ldGhvZCBpcyBjYWxsZWQgd2l0aCBhcmd1bWVudCBrZXksIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgLy8gc3RlcHMgYXJlIHRha2VuOlxuXG4gICAgICAgIC8vIDEuICBMZXQgTyBiZSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgVG9PYmplY3QsIGdpdmluZyBpdCB0aGUgdGhpc1xuICAgICAgICAvLyB2YWx1ZSBhcyBpdHMgYXJndW1lbnQuXG4gICAgICAgIC8vIDIuIExldCB0diBiZSBFUy5Ub1ByaW1pdGl2ZShPLCBoaW50IE51bWJlcikuXG4gICAgICAgIHZhciBPID0gJE9iamVjdCh0aGlzKTtcbiAgICAgICAgdmFyIHR2ID0gRVMuVG9QcmltaXRpdmUoTyk7XG4gICAgICAgIC8vIDMuIElmIHR2IGlzIGEgTnVtYmVyIGFuZCBpcyBub3QgZmluaXRlLCByZXR1cm4gbnVsbC5cbiAgICAgICAgaWYgKHR5cGVvZiB0diA9PT0gJ251bWJlcicgJiYgIWlzRmluaXRlKHR2KSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gNC4gTGV0IHRvSVNPIGJlIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgW1tHZXRdXSBpbnRlcm5hbCBtZXRob2Qgb2ZcbiAgICAgICAgLy8gTyB3aXRoIGFyZ3VtZW50IFwidG9JU09TdHJpbmdcIi5cbiAgICAgICAgdmFyIHRvSVNPID0gTy50b0lTT1N0cmluZztcbiAgICAgICAgLy8gNS4gSWYgSXNDYWxsYWJsZSh0b0lTTykgaXMgZmFsc2UsIHRocm93IGEgVHlwZUVycm9yIGV4Y2VwdGlvbi5cbiAgICAgICAgaWYgKCFpc0NhbGxhYmxlKHRvSVNPKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndG9JU09TdHJpbmcgcHJvcGVydHkgaXMgbm90IGNhbGxhYmxlJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gNi4gUmV0dXJuIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgW1tDYWxsXV0gaW50ZXJuYWwgbWV0aG9kIG9mXG4gICAgICAgIC8vICB0b0lTTyB3aXRoIE8gYXMgdGhlIHRoaXMgdmFsdWUgYW5kIGFuIGVtcHR5IGFyZ3VtZW50IGxpc3QuXG4gICAgICAgIHJldHVybiB0b0lTTy5jYWxsKE8pO1xuXG4gICAgICAgIC8vIE5PVEUgMSBUaGUgYXJndW1lbnQgaXMgaWdub3JlZC5cblxuICAgICAgICAvLyBOT1RFIDIgVGhlIHRvSlNPTiBmdW5jdGlvbiBpcyBpbnRlbnRpb25hbGx5IGdlbmVyaWM7IGl0IGRvZXMgbm90XG4gICAgICAgIC8vIHJlcXVpcmUgdGhhdCBpdHMgdGhpcyB2YWx1ZSBiZSBhIERhdGUgb2JqZWN0LiBUaGVyZWZvcmUsIGl0IGNhbiBiZVxuICAgICAgICAvLyB0cmFuc2ZlcnJlZCB0byBvdGhlciBraW5kcyBvZiBvYmplY3RzIGZvciB1c2UgYXMgYSBtZXRob2QuIEhvd2V2ZXIsXG4gICAgICAgIC8vIGl0IGRvZXMgcmVxdWlyZSB0aGF0IGFueSBzdWNoIG9iamVjdCBoYXZlIGEgdG9JU09TdHJpbmcgbWV0aG9kLiBBblxuICAgICAgICAvLyBvYmplY3QgaXMgZnJlZSB0byB1c2UgdGhlIGFyZ3VtZW50IGtleSB0byBmaWx0ZXIgaXRzXG4gICAgICAgIC8vIHN0cmluZ2lmaWNhdGlvbi5cbiAgICB9O1xufVxuXG4vLyBFUzUgMTUuOS40LjJcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjkuNC4yXG4vLyBiYXNlZCBvbiB3b3JrIHNoYXJlZCBieSBEYW5pZWwgRnJpZXNlbiAoZGFudG1hbilcbi8vIGh0dHA6Ly9naXN0LmdpdGh1Yi5jb20vMzAzMjQ5XG52YXIgc3VwcG9ydHNFeHRlbmRlZFllYXJzID0gRGF0ZS5wYXJzZSgnKzAzMzY1OC0wOS0yN1QwMTo0Njo0MC4wMDBaJykgPT09IDFlMTU7XG52YXIgYWNjZXB0c0ludmFsaWREYXRlcyA9ICFpc05hTihEYXRlLnBhcnNlKCcyMDEyLTA0LTA0VDI0OjAwOjAwLjUwMFonKSkgfHwgIWlzTmFOKERhdGUucGFyc2UoJzIwMTItMTEtMzFUMjM6NTk6NTkuMDAwWicpKSB8fCAhaXNOYU4oRGF0ZS5wYXJzZSgnMjAxMi0xMi0zMVQyMzo1OTo2MC4wMDBaJykpO1xudmFyIGRvZXNOb3RQYXJzZVkyS05ld1llYXIgPSBpc05hTihEYXRlLnBhcnNlKCcyMDAwLTAxLTAxVDAwOjAwOjAwLjAwMFonKSk7XG5pZiAoZG9lc05vdFBhcnNlWTJLTmV3WWVhciB8fCBhY2NlcHRzSW52YWxpZERhdGVzIHx8ICFzdXBwb3J0c0V4dGVuZGVkWWVhcnMpIHtcbiAgICAvLyBYWFggZ2xvYmFsIGFzc2lnbm1lbnQgd29uJ3Qgd29yayBpbiBlbWJlZGRpbmdzIHRoYXQgdXNlXG4gICAgLy8gYW4gYWx0ZXJuYXRlIG9iamVjdCBmb3IgdGhlIGNvbnRleHQuXG4gICAgLyogZ2xvYmFsIERhdGU6IHRydWUgKi9cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlZiAqL1xuICAgIHZhciBtYXhTYWZlVW5zaWduZWQzMkJpdCA9IE1hdGgucG93KDIsIDMxKSAtIDE7XG4gICAgdmFyIGhhc1NhZmFyaVNpZ25lZEludEJ1ZyA9IGlzQWN0dWFsTmFOKG5ldyBEYXRlKDE5NzAsIDAsIDEsIDAsIDAsIDAsIG1heFNhZmVVbnNpZ25lZDMyQml0ICsgMSkuZ2V0VGltZSgpKTtcbiAgICBEYXRlID0gKGZ1bmN0aW9uIChOYXRpdmVEYXRlKSB7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby11bmRlZiAqL1xuICAgICAgICAvLyBEYXRlLmxlbmd0aCA9PT0gN1xuICAgICAgICB2YXIgRGF0ZVNoaW0gPSBmdW5jdGlvbiBEYXRlKFksIE0sIEQsIGgsIG0sIHMsIG1zKSB7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBkYXRlO1xuICAgICAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBOYXRpdmVEYXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlY29uZHMgPSBzO1xuICAgICAgICAgICAgICAgIHZhciBtaWxsaXMgPSBtcztcbiAgICAgICAgICAgICAgICBpZiAoaGFzU2FmYXJpU2lnbmVkSW50QnVnICYmIGxlbmd0aCA+PSA3ICYmIG1zID4gbWF4U2FmZVVuc2lnbmVkMzJCaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd29yayBhcm91bmQgYSBTYWZhcmkgOC85IGJ1ZyB3aGVyZSBpdCB0cmVhdHMgdGhlIHNlY29uZHMgYXMgc2lnbmVkXG4gICAgICAgICAgICAgICAgICAgIHZhciBtc1RvU2hpZnQgPSBNYXRoLmZsb29yKG1zIC8gbWF4U2FmZVVuc2lnbmVkMzJCaXQpICogbWF4U2FmZVVuc2lnbmVkMzJCaXQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzVG9TaGlmdCA9IE1hdGguZmxvb3IobXNUb1NoaWZ0IC8gMWUzKTtcbiAgICAgICAgICAgICAgICAgICAgc2Vjb25kcyArPSBzVG9TaGlmdDtcbiAgICAgICAgICAgICAgICAgICAgbWlsbGlzIC09IHNUb1NoaWZ0ICogMWUzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkYXRlID0gbGVuZ3RoID09PSAxICYmICRTdHJpbmcoWSkgPT09IFkgPyAvLyBpc1N0cmluZyhZKVxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBleHBsaWNpdGx5IHBhc3MgaXQgdGhyb3VnaCBwYXJzZTpcbiAgICAgICAgICAgICAgICAgICAgbmV3IE5hdGl2ZURhdGUoRGF0ZVNoaW0ucGFyc2UoWSkpIDpcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSB0byBtYW51YWxseSBtYWtlIGNhbGxzIGRlcGVuZGluZyBvbiBhcmd1bWVudFxuICAgICAgICAgICAgICAgICAgICAvLyBsZW5ndGggaGVyZVxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPj0gNyA/IG5ldyBOYXRpdmVEYXRlKFksIE0sIEQsIGgsIG0sIHNlY29uZHMsIG1pbGxpcykgOlxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPj0gNiA/IG5ldyBOYXRpdmVEYXRlKFksIE0sIEQsIGgsIG0sIHNlY29uZHMpIDpcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID49IDUgPyBuZXcgTmF0aXZlRGF0ZShZLCBNLCBELCBoLCBtKSA6XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA+PSA0ID8gbmV3IE5hdGl2ZURhdGUoWSwgTSwgRCwgaCkgOlxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPj0gMyA/IG5ldyBOYXRpdmVEYXRlKFksIE0sIEQpIDpcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID49IDIgPyBuZXcgTmF0aXZlRGF0ZShZLCBNKSA6XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA+PSAxID8gbmV3IE5hdGl2ZURhdGUoWSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBOYXRpdmVEYXRlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGUgPSBOYXRpdmVEYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzUHJpbWl0aXZlKGRhdGUpKSB7XG4gICAgICAgICAgICAgIC8vIFByZXZlbnQgbWl4dXBzIHdpdGggdW5maXhlZCBEYXRlIG9iamVjdFxuICAgICAgICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKGRhdGUsIHsgY29uc3RydWN0b3I6IERhdGVTaGltIH0sIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gMTUuOS4xLjE1IERhdGUgVGltZSBTdHJpbmcgRm9ybWF0LlxuICAgICAgICB2YXIgaXNvRGF0ZUV4cHJlc3Npb24gPSBuZXcgUmVnRXhwKCdeJyArXG4gICAgICAgICAgICAnKFxcXFxkezR9fFsrLV1cXFxcZHs2fSknICsgLy8gZm91ci1kaWdpdCB5ZWFyIGNhcHR1cmUgb3Igc2lnbiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDYtZGlnaXQgZXh0ZW5kZWQgeWVhclxuICAgICAgICAgICAgJyg/Oi0oXFxcXGR7Mn0pJyArIC8vIG9wdGlvbmFsIG1vbnRoIGNhcHR1cmVcbiAgICAgICAgICAgICcoPzotKFxcXFxkezJ9KScgKyAvLyBvcHRpb25hbCBkYXkgY2FwdHVyZVxuICAgICAgICAgICAgJyg/OicgKyAvLyBjYXB0dXJlIGhvdXJzOm1pbnV0ZXM6c2Vjb25kcy5taWxsaXNlY29uZHNcbiAgICAgICAgICAgICAgICAnVChcXFxcZHsyfSknICsgLy8gaG91cnMgY2FwdHVyZVxuICAgICAgICAgICAgICAgICc6KFxcXFxkezJ9KScgKyAvLyBtaW51dGVzIGNhcHR1cmVcbiAgICAgICAgICAgICAgICAnKD86JyArIC8vIG9wdGlvbmFsIDpzZWNvbmRzLm1pbGxpc2Vjb25kc1xuICAgICAgICAgICAgICAgICAgICAnOihcXFxcZHsyfSknICsgLy8gc2Vjb25kcyBjYXB0dXJlXG4gICAgICAgICAgICAgICAgICAgICcoPzooXFxcXC5cXFxcZHsxLH0pKT8nICsgLy8gbWlsbGlzZWNvbmRzIGNhcHR1cmVcbiAgICAgICAgICAgICAgICAnKT8nICtcbiAgICAgICAgICAgICcoJyArIC8vIGNhcHR1cmUgVVRDIG9mZnNldCBjb21wb25lbnRcbiAgICAgICAgICAgICAgICAnWnwnICsgLy8gVVRDIGNhcHR1cmVcbiAgICAgICAgICAgICAgICAnKD86JyArIC8vIG9mZnNldCBzcGVjaWZpZXIgKy8taG91cnM6bWludXRlc1xuICAgICAgICAgICAgICAgICAgICAnKFstK10pJyArIC8vIHNpZ24gY2FwdHVyZVxuICAgICAgICAgICAgICAgICAgICAnKFxcXFxkezJ9KScgKyAvLyBob3VycyBvZmZzZXQgY2FwdHVyZVxuICAgICAgICAgICAgICAgICAgICAnOihcXFxcZHsyfSknICsgLy8gbWludXRlcyBvZmZzZXQgY2FwdHVyZVxuICAgICAgICAgICAgICAgICcpJyArXG4gICAgICAgICAgICAnKT8pPyk/KT8nICtcbiAgICAgICAgJyQnKTtcblxuICAgICAgICB2YXIgbW9udGhzID0gWzAsIDMxLCA1OSwgOTAsIDEyMCwgMTUxLCAxODEsIDIxMiwgMjQzLCAyNzMsIDMwNCwgMzM0LCAzNjVdO1xuXG4gICAgICAgIHZhciBkYXlGcm9tTW9udGggPSBmdW5jdGlvbiBkYXlGcm9tTW9udGgoeWVhciwgbW9udGgpIHtcbiAgICAgICAgICAgIHZhciB0ID0gbW9udGggPiAxID8gMSA6IDA7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIG1vbnRoc1ttb250aF0gK1xuICAgICAgICAgICAgICAgIE1hdGguZmxvb3IoKHllYXIgLSAxOTY5ICsgdCkgLyA0KSAtXG4gICAgICAgICAgICAgICAgTWF0aC5mbG9vcigoeWVhciAtIDE5MDEgKyB0KSAvIDEwMCkgK1xuICAgICAgICAgICAgICAgIE1hdGguZmxvb3IoKHllYXIgLSAxNjAxICsgdCkgLyA0MDApICtcbiAgICAgICAgICAgICAgICAzNjUgKiAoeWVhciAtIDE5NzApXG4gICAgICAgICAgICApO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciB0b1VUQyA9IGZ1bmN0aW9uIHRvVVRDKHQpIHtcbiAgICAgICAgICAgIHZhciBzID0gMDtcbiAgICAgICAgICAgIHZhciBtcyA9IHQ7XG4gICAgICAgICAgICBpZiAoaGFzU2FmYXJpU2lnbmVkSW50QnVnICYmIG1zID4gbWF4U2FmZVVuc2lnbmVkMzJCaXQpIHtcbiAgICAgICAgICAgICAgICAvLyB3b3JrIGFyb3VuZCBhIFNhZmFyaSA4LzkgYnVnIHdoZXJlIGl0IHRyZWF0cyB0aGUgc2Vjb25kcyBhcyBzaWduZWRcbiAgICAgICAgICAgICAgICB2YXIgbXNUb1NoaWZ0ID0gTWF0aC5mbG9vcihtcyAvIG1heFNhZmVVbnNpZ25lZDMyQml0KSAqIG1heFNhZmVVbnNpZ25lZDMyQml0O1xuICAgICAgICAgICAgICAgIHZhciBzVG9TaGlmdCA9IE1hdGguZmxvb3IobXNUb1NoaWZ0IC8gMWUzKTtcbiAgICAgICAgICAgICAgICBzICs9IHNUb1NoaWZ0O1xuICAgICAgICAgICAgICAgIG1zIC09IHNUb1NoaWZ0ICogMWUzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICROdW1iZXIobmV3IE5hdGl2ZURhdGUoMTk3MCwgMCwgMSwgMCwgMCwgcywgbXMpKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBDb3B5IGFueSBjdXN0b20gbWV0aG9kcyBhIDNyZCBwYXJ0eSBsaWJyYXJ5IG1heSBoYXZlIGFkZGVkXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBOYXRpdmVEYXRlKSB7XG4gICAgICAgICAgICBpZiAob3ducyhOYXRpdmVEYXRlLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgRGF0ZVNoaW1ba2V5XSA9IE5hdGl2ZURhdGVba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvcHkgXCJuYXRpdmVcIiBtZXRob2RzIGV4cGxpY2l0bHk7IHRoZXkgbWF5IGJlIG5vbi1lbnVtZXJhYmxlXG4gICAgICAgIGRlZmluZVByb3BlcnRpZXMoRGF0ZVNoaW0sIHtcbiAgICAgICAgICAgIG5vdzogTmF0aXZlRGF0ZS5ub3csXG4gICAgICAgICAgICBVVEM6IE5hdGl2ZURhdGUuVVRDXG4gICAgICAgIH0sIHRydWUpO1xuICAgICAgICBEYXRlU2hpbS5wcm90b3R5cGUgPSBOYXRpdmVEYXRlLnByb3RvdHlwZTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyhEYXRlU2hpbS5wcm90b3R5cGUsIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yOiBEYXRlU2hpbVxuICAgICAgICB9LCB0cnVlKTtcblxuICAgICAgICAvLyBVcGdyYWRlIERhdGUucGFyc2UgdG8gaGFuZGxlIHNpbXBsaWZpZWQgSVNPIDg2MDEgc3RyaW5nc1xuICAgICAgICB2YXIgcGFyc2VTaGltID0gZnVuY3Rpb24gcGFyc2Uoc3RyaW5nKSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSBpc29EYXRlRXhwcmVzc2lvbi5leGVjKHN0cmluZyk7XG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAvLyBwYXJzZSBtb250aHMsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBhbmQgbWlsbGlzZWNvbmRzXG4gICAgICAgICAgICAgICAgLy8gcHJvdmlkZSBkZWZhdWx0IHZhbHVlcyBpZiBuZWNlc3NhcnlcbiAgICAgICAgICAgICAgICAvLyBwYXJzZSB0aGUgVVRDIG9mZnNldCBjb21wb25lbnRcbiAgICAgICAgICAgICAgICB2YXIgeWVhciA9ICROdW1iZXIobWF0Y2hbMV0pLFxuICAgICAgICAgICAgICAgICAgICBtb250aCA9ICROdW1iZXIobWF0Y2hbMl0gfHwgMSkgLSAxLFxuICAgICAgICAgICAgICAgICAgICBkYXkgPSAkTnVtYmVyKG1hdGNoWzNdIHx8IDEpIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgaG91ciA9ICROdW1iZXIobWF0Y2hbNF0gfHwgMCksXG4gICAgICAgICAgICAgICAgICAgIG1pbnV0ZSA9ICROdW1iZXIobWF0Y2hbNV0gfHwgMCksXG4gICAgICAgICAgICAgICAgICAgIHNlY29uZCA9ICROdW1iZXIobWF0Y2hbNl0gfHwgMCksXG4gICAgICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kID0gTWF0aC5mbG9vcigkTnVtYmVyKG1hdGNoWzddIHx8IDApICogMTAwMCksXG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gdGltZSB6b25lIGlzIG1pc3NlZCwgbG9jYWwgb2Zmc2V0IHNob3VsZCBiZSB1c2VkXG4gICAgICAgICAgICAgICAgICAgIC8vIChFUyA1LjEgYnVnKVxuICAgICAgICAgICAgICAgICAgICAvLyBzZWUgaHR0cHM6Ly9idWdzLmVjbWFzY3JpcHQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMTJcbiAgICAgICAgICAgICAgICAgICAgaXNMb2NhbFRpbWUgPSBCb29sZWFuKG1hdGNoWzRdICYmICFtYXRjaFs4XSksXG4gICAgICAgICAgICAgICAgICAgIHNpZ25PZmZzZXQgPSBtYXRjaFs5XSA9PT0gJy0nID8gMSA6IC0xLFxuICAgICAgICAgICAgICAgICAgICBob3VyT2Zmc2V0ID0gJE51bWJlcihtYXRjaFsxMF0gfHwgMCksXG4gICAgICAgICAgICAgICAgICAgIG1pbnV0ZU9mZnNldCA9ICROdW1iZXIobWF0Y2hbMTFdIHx8IDApLFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQ7XG4gICAgICAgICAgICAgICAgdmFyIGhhc01pbnV0ZXNPclNlY29uZHNPck1pbGxpc2Vjb25kcyA9IG1pbnV0ZSA+IDAgfHwgc2Vjb25kID4gMCB8fCBtaWxsaXNlY29uZCA+IDA7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBob3VyIDwgKGhhc01pbnV0ZXNPclNlY29uZHNPck1pbGxpc2Vjb25kcyA/IDI0IDogMjUpICYmXG4gICAgICAgICAgICAgICAgICAgIG1pbnV0ZSA8IDYwICYmIHNlY29uZCA8IDYwICYmIG1pbGxpc2Vjb25kIDwgMTAwMCAmJlxuICAgICAgICAgICAgICAgICAgICBtb250aCA+IC0xICYmIG1vbnRoIDwgMTIgJiYgaG91ck9mZnNldCA8IDI0ICYmXG4gICAgICAgICAgICAgICAgICAgIG1pbnV0ZU9mZnNldCA8IDYwICYmIC8vIGRldGVjdCBpbnZhbGlkIG9mZnNldHNcbiAgICAgICAgICAgICAgICAgICAgZGF5ID4gLTEgJiZcbiAgICAgICAgICAgICAgICAgICAgZGF5IDwgKGRheUZyb21Nb250aCh5ZWFyLCBtb250aCArIDEpIC0gZGF5RnJvbU1vbnRoKHllYXIsIG1vbnRoKSlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gKFxuICAgICAgICAgICAgICAgICAgICAgICAgKGRheUZyb21Nb250aCh5ZWFyLCBtb250aCkgKyBkYXkpICogMjQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgaG91ciArXG4gICAgICAgICAgICAgICAgICAgICAgICBob3VyT2Zmc2V0ICogc2lnbk9mZnNldFxuICAgICAgICAgICAgICAgICAgICApICogNjA7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IChcbiAgICAgICAgICAgICAgICAgICAgICAgIChyZXN1bHQgKyBtaW51dGUgKyBtaW51dGVPZmZzZXQgKiBzaWduT2Zmc2V0KSAqIDYwICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlY29uZFxuICAgICAgICAgICAgICAgICAgICApICogMTAwMCArIG1pbGxpc2Vjb25kO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNMb2NhbFRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRvVVRDKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKC04LjY0ZTE1IDw9IHJlc3VsdCAmJiByZXN1bHQgPD0gOC42NGUxNSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE5hdGl2ZURhdGUucGFyc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgICAgZGVmaW5lUHJvcGVydGllcyhEYXRlU2hpbSwgeyBwYXJzZTogcGFyc2VTaGltIH0pO1xuXG4gICAgICAgIHJldHVybiBEYXRlU2hpbTtcbiAgICB9KERhdGUpKTtcbiAgICAvKiBnbG9iYWwgRGF0ZTogZmFsc2UgKi9cbn1cblxuLy8gRVM1IDE1LjkuNC40XG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS45LjQuNFxuaWYgKCFEYXRlLm5vdykge1xuICAgIERhdGUubm93ID0gZnVuY3Rpb24gbm93KCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgfTtcbn1cblxuLy9cbi8vIE51bWJlclxuLy8gPT09PT09XG4vL1xuXG4vLyBFUzUuMSAxNS43LjQuNVxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNy40LjVcbnZhciBoYXNUb0ZpeGVkQnVncyA9IE51bWJlclByb3RvdHlwZS50b0ZpeGVkICYmIChcbiAgKDAuMDAwMDgpLnRvRml4ZWQoMykgIT09ICcwLjAwMCcgfHxcbiAgKDAuOSkudG9GaXhlZCgwKSAhPT0gJzEnIHx8XG4gICgxLjI1NSkudG9GaXhlZCgyKSAhPT0gJzEuMjUnIHx8XG4gICgxMDAwMDAwMDAwMDAwMDAwMTI4KS50b0ZpeGVkKDApICE9PSAnMTAwMDAwMDAwMDAwMDAwMDEyOCdcbik7XG5cbnZhciB0b0ZpeGVkSGVscGVycyA9IHtcbiAgYmFzZTogMWU3LFxuICBzaXplOiA2LFxuICBkYXRhOiBbMCwgMCwgMCwgMCwgMCwgMF0sXG4gIG11bHRpcGx5OiBmdW5jdGlvbiBtdWx0aXBseShuLCBjKSB7XG4gICAgICB2YXIgaSA9IC0xO1xuICAgICAgdmFyIGMyID0gYztcbiAgICAgIHdoaWxlICgrK2kgPCB0b0ZpeGVkSGVscGVycy5zaXplKSB7XG4gICAgICAgICAgYzIgKz0gbiAqIHRvRml4ZWRIZWxwZXJzLmRhdGFbaV07XG4gICAgICAgICAgdG9GaXhlZEhlbHBlcnMuZGF0YVtpXSA9IGMyICUgdG9GaXhlZEhlbHBlcnMuYmFzZTtcbiAgICAgICAgICBjMiA9IE1hdGguZmxvb3IoYzIgLyB0b0ZpeGVkSGVscGVycy5iYXNlKTtcbiAgICAgIH1cbiAgfSxcbiAgZGl2aWRlOiBmdW5jdGlvbiBkaXZpZGUobikge1xuICAgICAgdmFyIGkgPSB0b0ZpeGVkSGVscGVycy5zaXplLCBjID0gMDtcbiAgICAgIHdoaWxlICgtLWkgPj0gMCkge1xuICAgICAgICAgIGMgKz0gdG9GaXhlZEhlbHBlcnMuZGF0YVtpXTtcbiAgICAgICAgICB0b0ZpeGVkSGVscGVycy5kYXRhW2ldID0gTWF0aC5mbG9vcihjIC8gbik7XG4gICAgICAgICAgYyA9IChjICUgbikgKiB0b0ZpeGVkSGVscGVycy5iYXNlO1xuICAgICAgfVxuICB9LFxuICBudW1Ub1N0cmluZzogZnVuY3Rpb24gbnVtVG9TdHJpbmcoKSB7XG4gICAgICB2YXIgaSA9IHRvRml4ZWRIZWxwZXJzLnNpemU7XG4gICAgICB2YXIgcyA9ICcnO1xuICAgICAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgICAgICAgaWYgKHMgIT09ICcnIHx8IGkgPT09IDAgfHwgdG9GaXhlZEhlbHBlcnMuZGF0YVtpXSAhPT0gMCkge1xuICAgICAgICAgICAgICB2YXIgdCA9ICRTdHJpbmcodG9GaXhlZEhlbHBlcnMuZGF0YVtpXSk7XG4gICAgICAgICAgICAgIGlmIChzID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgcyA9IHQ7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBzICs9IHN0clNsaWNlKCcwMDAwMDAwJywgMCwgNyAtIHQubGVuZ3RoKSArIHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcztcbiAgfSxcbiAgcG93OiBmdW5jdGlvbiBwb3coeCwgbiwgYWNjKSB7XG4gICAgICByZXR1cm4gKG4gPT09IDAgPyBhY2MgOiAobiAlIDIgPT09IDEgPyBwb3coeCwgbiAtIDEsIGFjYyAqIHgpIDogcG93KHggKiB4LCBuIC8gMiwgYWNjKSkpO1xuICB9LFxuICBsb2c6IGZ1bmN0aW9uIGxvZyh4KSB7XG4gICAgICB2YXIgbiA9IDA7XG4gICAgICB2YXIgeDIgPSB4O1xuICAgICAgd2hpbGUgKHgyID49IDQwOTYpIHtcbiAgICAgICAgICBuICs9IDEyO1xuICAgICAgICAgIHgyIC89IDQwOTY7XG4gICAgICB9XG4gICAgICB3aGlsZSAoeDIgPj0gMikge1xuICAgICAgICAgIG4gKz0gMTtcbiAgICAgICAgICB4MiAvPSAyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG47XG4gIH1cbn07XG5cbnZhciB0b0ZpeGVkU2hpbSA9IGZ1bmN0aW9uIHRvRml4ZWQoZnJhY3Rpb25EaWdpdHMpIHtcbiAgICB2YXIgZiwgeCwgcywgbSwgZSwgeiwgaiwgaztcblxuICAgIC8vIFRlc3QgZm9yIE5hTiBhbmQgcm91bmQgZnJhY3Rpb25EaWdpdHMgZG93blxuICAgIGYgPSAkTnVtYmVyKGZyYWN0aW9uRGlnaXRzKTtcbiAgICBmID0gaXNBY3R1YWxOYU4oZikgPyAwIDogTWF0aC5mbG9vcihmKTtcblxuICAgIGlmIChmIDwgMCB8fCBmID4gMjApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ051bWJlci50b0ZpeGVkIGNhbGxlZCB3aXRoIGludmFsaWQgbnVtYmVyIG9mIGRlY2ltYWxzJyk7XG4gICAgfVxuXG4gICAgeCA9ICROdW1iZXIodGhpcyk7XG5cbiAgICBpZiAoaXNBY3R1YWxOYU4oeCkpIHtcbiAgICAgICAgcmV0dXJuICdOYU4nO1xuICAgIH1cblxuICAgIC8vIElmIGl0IGlzIHRvbyBiaWcgb3Igc21hbGwsIHJldHVybiB0aGUgc3RyaW5nIHZhbHVlIG9mIHRoZSBudW1iZXJcbiAgICBpZiAoeCA8PSAtMWUyMSB8fCB4ID49IDFlMjEpIHtcbiAgICAgICAgcmV0dXJuICRTdHJpbmcoeCk7XG4gICAgfVxuXG4gICAgcyA9ICcnO1xuXG4gICAgaWYgKHggPCAwKSB7XG4gICAgICAgIHMgPSAnLSc7XG4gICAgICAgIHggPSAteDtcbiAgICB9XG5cbiAgICBtID0gJzAnO1xuXG4gICAgaWYgKHggPiAxZS0yMSkge1xuICAgICAgICAvLyAxZS0yMSA8IHggPCAxZTIxXG4gICAgICAgIC8vIC03MCA8IGxvZzIoeCkgPCA3MFxuICAgICAgICBlID0gdG9GaXhlZEhlbHBlcnMubG9nKHggKiB0b0ZpeGVkSGVscGVycy5wb3coMiwgNjksIDEpKSAtIDY5O1xuICAgICAgICB6ID0gKGUgPCAwID8geCAqIHRvRml4ZWRIZWxwZXJzLnBvdygyLCAtZSwgMSkgOiB4IC8gdG9GaXhlZEhlbHBlcnMucG93KDIsIGUsIDEpKTtcbiAgICAgICAgeiAqPSAweDEwMDAwMDAwMDAwMDAwOyAvLyBNYXRoLnBvdygyLCA1Mik7XG4gICAgICAgIGUgPSA1MiAtIGU7XG5cbiAgICAgICAgLy8gLTE4IDwgZSA8IDEyMlxuICAgICAgICAvLyB4ID0geiAvIDIgXiBlXG4gICAgICAgIGlmIChlID4gMCkge1xuICAgICAgICAgICAgdG9GaXhlZEhlbHBlcnMubXVsdGlwbHkoMCwgeik7XG4gICAgICAgICAgICBqID0gZjtcblxuICAgICAgICAgICAgd2hpbGUgKGogPj0gNykge1xuICAgICAgICAgICAgICAgIHRvRml4ZWRIZWxwZXJzLm11bHRpcGx5KDFlNywgMCk7XG4gICAgICAgICAgICAgICAgaiAtPSA3O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0b0ZpeGVkSGVscGVycy5tdWx0aXBseSh0b0ZpeGVkSGVscGVycy5wb3coMTAsIGosIDEpLCAwKTtcbiAgICAgICAgICAgIGogPSBlIC0gMTtcblxuICAgICAgICAgICAgd2hpbGUgKGogPj0gMjMpIHtcbiAgICAgICAgICAgICAgICB0b0ZpeGVkSGVscGVycy5kaXZpZGUoMSA8PCAyMyk7XG4gICAgICAgICAgICAgICAgaiAtPSAyMztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdG9GaXhlZEhlbHBlcnMuZGl2aWRlKDEgPDwgaik7XG4gICAgICAgICAgICB0b0ZpeGVkSGVscGVycy5tdWx0aXBseSgxLCAxKTtcbiAgICAgICAgICAgIHRvRml4ZWRIZWxwZXJzLmRpdmlkZSgyKTtcbiAgICAgICAgICAgIG0gPSB0b0ZpeGVkSGVscGVycy5udW1Ub1N0cmluZygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG9GaXhlZEhlbHBlcnMubXVsdGlwbHkoMCwgeik7XG4gICAgICAgICAgICB0b0ZpeGVkSGVscGVycy5tdWx0aXBseSgxIDw8ICgtZSksIDApO1xuICAgICAgICAgICAgbSA9IHRvRml4ZWRIZWxwZXJzLm51bVRvU3RyaW5nKCkgKyBzdHJTbGljZSgnMC4wMDAwMDAwMDAwMDAwMDAwMDAwMCcsIDIsIDIgKyBmKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmID4gMCkge1xuICAgICAgICBrID0gbS5sZW5ndGg7XG5cbiAgICAgICAgaWYgKGsgPD0gZikge1xuICAgICAgICAgICAgbSA9IHMgKyBzdHJTbGljZSgnMC4wMDAwMDAwMDAwMDAwMDAwMDAwJywgMCwgZiAtIGsgKyAyKSArIG07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtID0gcyArIHN0clNsaWNlKG0sIDAsIGsgLSBmKSArICcuJyArIHN0clNsaWNlKG0sIGsgLSBmKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIG0gPSBzICsgbTtcbiAgICB9XG5cbiAgICByZXR1cm4gbTtcbn07XG5kZWZpbmVQcm9wZXJ0aWVzKE51bWJlclByb3RvdHlwZSwgeyB0b0ZpeGVkOiB0b0ZpeGVkU2hpbSB9LCBoYXNUb0ZpeGVkQnVncyk7XG5cbnZhciBoYXNUb1ByZWNpc2lvblVuZGVmaW5lZEJ1ZyA9IChmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIDEuMC50b1ByZWNpc2lvbih1bmRlZmluZWQpID09PSAnMSc7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59KCkpO1xudmFyIG9yaWdpbmFsVG9QcmVjaXNpb24gPSBOdW1iZXJQcm90b3R5cGUudG9QcmVjaXNpb247XG5kZWZpbmVQcm9wZXJ0aWVzKE51bWJlclByb3RvdHlwZSwge1xuICAgIHRvUHJlY2lzaW9uOiBmdW5jdGlvbiB0b1ByZWNpc2lvbihwcmVjaXNpb24pIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBwcmVjaXNpb24gPT09ICd1bmRlZmluZWQnID8gb3JpZ2luYWxUb1ByZWNpc2lvbi5jYWxsKHRoaXMpIDogb3JpZ2luYWxUb1ByZWNpc2lvbi5jYWxsKHRoaXMsIHByZWNpc2lvbik7XG4gICAgfVxufSwgaGFzVG9QcmVjaXNpb25VbmRlZmluZWRCdWcpO1xuXG4vL1xuLy8gU3RyaW5nXG4vLyA9PT09PT1cbi8vXG5cbi8vIEVTNSAxNS41LjQuMTRcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjUuNC4xNFxuXG4vLyBbYnVnZml4LCBJRSBsdCA5LCBmaXJlZm94IDQsIEtvbnF1ZXJvciwgT3BlcmEsIG9ic2N1cmUgYnJvd3NlcnNdXG4vLyBNYW55IGJyb3dzZXJzIGRvIG5vdCBzcGxpdCBwcm9wZXJseSB3aXRoIHJlZ3VsYXIgZXhwcmVzc2lvbnMgb3IgdGhleVxuLy8gZG8gbm90IHBlcmZvcm0gdGhlIHNwbGl0IGNvcnJlY3RseSB1bmRlciBvYnNjdXJlIGNvbmRpdGlvbnMuXG4vLyBTZWUgaHR0cDovL2Jsb2cuc3RldmVubGV2aXRoYW4uY29tL2FyY2hpdmVzL2Nyb3NzLWJyb3dzZXItc3BsaXRcbi8vIEkndmUgdGVzdGVkIGluIG1hbnkgYnJvd3NlcnMgYW5kIHRoaXMgc2VlbXMgdG8gY292ZXIgdGhlIGRldmlhbnQgb25lczpcbi8vICAgICdhYicuc3BsaXQoLyg/OmFiKSovKSBzaG91bGQgYmUgW1wiXCIsIFwiXCJdLCBub3QgW1wiXCJdXG4vLyAgICAnLicuc3BsaXQoLyguPykoLj8pLykgc2hvdWxkIGJlIFtcIlwiLCBcIi5cIiwgXCJcIiwgXCJcIl0sIG5vdCBbXCJcIiwgXCJcIl1cbi8vICAgICd0ZXNzdCcuc3BsaXQoLyhzKSovKSBzaG91bGQgYmUgW1widFwiLCB1bmRlZmluZWQsIFwiZVwiLCBcInNcIiwgXCJ0XCJdLCBub3Rcbi8vICAgICAgIFt1bmRlZmluZWQsIFwidFwiLCB1bmRlZmluZWQsIFwiZVwiLCAuLi5dXG4vLyAgICAnJy5zcGxpdCgvLj8vKSBzaG91bGQgYmUgW10sIG5vdCBbXCJcIl1cbi8vICAgICcuJy5zcGxpdCgvKCkoKS8pIHNob3VsZCBiZSBbXCIuXCJdLCBub3QgW1wiXCIsIFwiXCIsIFwiLlwiXVxuXG5pZiAoXG4gICAgJ2FiJy5zcGxpdCgvKD86YWIpKi8pLmxlbmd0aCAhPT0gMiB8fFxuICAgICcuJy5zcGxpdCgvKC4/KSguPykvKS5sZW5ndGggIT09IDQgfHxcbiAgICAndGVzc3QnLnNwbGl0KC8ocykqLylbMV0gPT09ICd0JyB8fFxuICAgICd0ZXN0Jy5zcGxpdCgvKD86KS8sIC0xKS5sZW5ndGggIT09IDQgfHxcbiAgICAnJy5zcGxpdCgvLj8vKS5sZW5ndGggfHxcbiAgICAnLicuc3BsaXQoLygpKCkvKS5sZW5ndGggPiAxXG4pIHtcbiAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29tcGxpYW50RXhlY05wY2cgPSB0eXBlb2YgKC8oKT8/LykuZXhlYygnJylbMV0gPT09ICd1bmRlZmluZWQnOyAvLyBOUENHOiBub25wYXJ0aWNpcGF0aW5nIGNhcHR1cmluZyBncm91cFxuICAgICAgICB2YXIgbWF4U2FmZTMyQml0SW50ID0gTWF0aC5wb3coMiwgMzIpIC0gMTtcblxuICAgICAgICBTdHJpbmdQcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiAoc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgICAgICAgdmFyIHN0cmluZyA9IFN0cmluZyh0aGlzKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VwYXJhdG9yID09PSAndW5kZWZpbmVkJyAmJiBsaW1pdCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgYHNlcGFyYXRvcmAgaXMgbm90IGEgcmVnZXgsIHVzZSBuYXRpdmUgc3BsaXRcbiAgICAgICAgICAgIGlmICghaXNSZWdleChzZXBhcmF0b3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0clNwbGl0KHRoaXMsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgICAgICAgICB2YXIgZmxhZ3MgPSAoc2VwYXJhdG9yLmlnbm9yZUNhc2UgPyAnaScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5tdWx0aWxpbmUgPyAnbScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci51bmljb2RlID8gJ3UnIDogJycpICsgLy8gaW4gRVM2XG4gICAgICAgICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLnN0aWNreSA/ICd5JyA6ICcnKSwgLy8gRmlyZWZveCAzKyBhbmQgRVM2XG4gICAgICAgICAgICAgICAgbGFzdExhc3RJbmRleCA9IDAsXG4gICAgICAgICAgICAgICAgLy8gTWFrZSBgZ2xvYmFsYCBhbmQgYXZvaWQgYGxhc3RJbmRleGAgaXNzdWVzIGJ5IHdvcmtpbmcgd2l0aCBhIGNvcHlcbiAgICAgICAgICAgICAgICBzZXBhcmF0b3IyLCBtYXRjaCwgbGFzdEluZGV4LCBsYXN0TGVuZ3RoO1xuICAgICAgICAgICAgdmFyIHNlcGFyYXRvckNvcHkgPSBuZXcgUmVnRXhwKHNlcGFyYXRvci5zb3VyY2UsIGZsYWdzICsgJ2cnKTtcbiAgICAgICAgICAgIGlmICghY29tcGxpYW50RXhlY05wY2cpIHtcbiAgICAgICAgICAgICAgICAvLyBEb2Vzbid0IG5lZWQgZmxhZ3MgZ3ksIGJ1dCB0aGV5IGRvbid0IGh1cnRcbiAgICAgICAgICAgICAgICBzZXBhcmF0b3IyID0gbmV3IFJlZ0V4cCgnXicgKyBzZXBhcmF0b3JDb3B5LnNvdXJjZSArICckKD8hXFxcXHMpJywgZmxhZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogVmFsdWVzIGZvciBgbGltaXRgLCBwZXIgdGhlIHNwZWM6XG4gICAgICAgICAgICAgKiBJZiB1bmRlZmluZWQ6IDQyOTQ5NjcyOTUgLy8gbWF4U2FmZTMyQml0SW50XG4gICAgICAgICAgICAgKiBJZiAwLCBJbmZpbml0eSwgb3IgTmFOOiAwXG4gICAgICAgICAgICAgKiBJZiBwb3NpdGl2ZSBudW1iZXI6IGxpbWl0ID0gTWF0aC5mbG9vcihsaW1pdCk7IGlmIChsaW1pdCA+IDQyOTQ5NjcyOTUpIGxpbWl0IC09IDQyOTQ5NjcyOTY7XG4gICAgICAgICAgICAgKiBJZiBuZWdhdGl2ZSBudW1iZXI6IDQyOTQ5NjcyOTYgLSBNYXRoLmZsb29yKE1hdGguYWJzKGxpbWl0KSlcbiAgICAgICAgICAgICAqIElmIG90aGVyOiBUeXBlLWNvbnZlcnQsIHRoZW4gdXNlIHRoZSBhYm92ZSBydWxlc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgc3BsaXRMaW1pdCA9IHR5cGVvZiBsaW1pdCA9PT0gJ3VuZGVmaW5lZCcgPyBtYXhTYWZlMzJCaXRJbnQgOiBFUy5Ub1VpbnQzMihsaW1pdCk7XG4gICAgICAgICAgICBtYXRjaCA9IHNlcGFyYXRvckNvcHkuZXhlYyhzdHJpbmcpO1xuICAgICAgICAgICAgd2hpbGUgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgLy8gYHNlcGFyYXRvckNvcHkubGFzdEluZGV4YCBpcyBub3QgcmVsaWFibGUgY3Jvc3MtYnJvd3NlclxuICAgICAgICAgICAgICAgIGxhc3RJbmRleCA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0SW5kZXggPiBsYXN0TGFzdEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHB1c2gob3V0cHV0LCBzdHJTbGljZShzdHJpbmcsIGxhc3RMYXN0SW5kZXgsIG1hdGNoLmluZGV4KSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpeCBicm93c2VycyB3aG9zZSBgZXhlY2AgbWV0aG9kcyBkb24ndCBjb25zaXN0ZW50bHkgcmV0dXJuIGB1bmRlZmluZWRgIGZvclxuICAgICAgICAgICAgICAgICAgICAvLyBub25wYXJ0aWNpcGF0aW5nIGNhcHR1cmluZyBncm91cHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb21wbGlhbnRFeGVjTnBjZyAmJiBtYXRjaC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1sb29wLWZ1bmMgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoWzBdLnJlcGxhY2Uoc2VwYXJhdG9yMiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aCAtIDI7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1tpXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoW2ldID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWxvb3AtZnVuYyAqL1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaC5sZW5ndGggPiAxICYmIG1hdGNoLmluZGV4IDwgc3RyaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlfcHVzaC5hcHBseShvdXRwdXQsIGFycmF5U2xpY2UobWF0Y2gsIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsYXN0TGVuZ3RoID0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBsYXN0TGFzdEluZGV4ID0gbGFzdEluZGV4O1xuICAgICAgICAgICAgICAgICAgICBpZiAob3V0cHV0Lmxlbmd0aCA+PSBzcGxpdExpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VwYXJhdG9yQ29weS5sYXN0SW5kZXggPT09IG1hdGNoLmluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlcGFyYXRvckNvcHkubGFzdEluZGV4Kys7IC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3BcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWF0Y2ggPSBzZXBhcmF0b3JDb3B5LmV4ZWMoc3RyaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYXN0TGFzdEluZGV4ID09PSBzdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RMZW5ndGggfHwgIXNlcGFyYXRvckNvcHkudGVzdCgnJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcHVzaChvdXRwdXQsICcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHB1c2gob3V0cHV0LCBzdHJTbGljZShzdHJpbmcsIGxhc3RMYXN0SW5kZXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQubGVuZ3RoID4gc3BsaXRMaW1pdCA/IHN0clNsaWNlKG91dHB1dCwgMCwgc3BsaXRMaW1pdCkgOiBvdXRwdXQ7XG4gICAgICAgIH07XG4gICAgfSgpKTtcblxuLy8gW2J1Z2ZpeCwgY2hyb21lXVxuLy8gSWYgc2VwYXJhdG9yIGlzIHVuZGVmaW5lZCwgdGhlbiB0aGUgcmVzdWx0IGFycmF5IGNvbnRhaW5zIGp1c3Qgb25lIFN0cmluZyxcbi8vIHdoaWNoIGlzIHRoZSB0aGlzIHZhbHVlIChjb252ZXJ0ZWQgdG8gYSBTdHJpbmcpLiBJZiBsaW1pdCBpcyBub3QgdW5kZWZpbmVkLFxuLy8gdGhlbiB0aGUgb3V0cHV0IGFycmF5IGlzIHRydW5jYXRlZCBzbyB0aGF0IGl0IGNvbnRhaW5zIG5vIG1vcmUgdGhhbiBsaW1pdFxuLy8gZWxlbWVudHMuXG4vLyBcIjBcIi5zcGxpdCh1bmRlZmluZWQsIDApIC0+IFtdXG59IGVsc2UgaWYgKCcwJy5zcGxpdCh2b2lkIDAsIDApLmxlbmd0aCkge1xuICAgIFN0cmluZ1Byb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIHNwbGl0KHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXBhcmF0b3IgPT09ICd1bmRlZmluZWQnICYmIGxpbWl0ID09PSAwKSB7IHJldHVybiBbXTsgfVxuICAgICAgICByZXR1cm4gc3RyU3BsaXQodGhpcywgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgfTtcbn1cblxudmFyIHN0cl9yZXBsYWNlID0gU3RyaW5nUHJvdG90eXBlLnJlcGxhY2U7XG52YXIgcmVwbGFjZVJlcG9ydHNHcm91cHNDb3JyZWN0bHkgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBncm91cHMgPSBbXTtcbiAgICAneCcucmVwbGFjZSgveCguKT8vZywgZnVuY3Rpb24gKG1hdGNoLCBncm91cCkge1xuICAgICAgICBwdXNoKGdyb3VwcywgZ3JvdXApO1xuICAgIH0pO1xuICAgIHJldHVybiBncm91cHMubGVuZ3RoID09PSAxICYmIHR5cGVvZiBncm91cHNbMF0gPT09ICd1bmRlZmluZWQnO1xufSgpKTtcblxuaWYgKCFyZXBsYWNlUmVwb3J0c0dyb3Vwc0NvcnJlY3RseSkge1xuICAgIFN0cmluZ1Byb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZShzZWFyY2hWYWx1ZSwgcmVwbGFjZVZhbHVlKSB7XG4gICAgICAgIHZhciBpc0ZuID0gaXNDYWxsYWJsZShyZXBsYWNlVmFsdWUpO1xuICAgICAgICB2YXIgaGFzQ2FwdHVyaW5nR3JvdXBzID0gaXNSZWdleChzZWFyY2hWYWx1ZSkgJiYgKC9cXClbKj9dLykudGVzdChzZWFyY2hWYWx1ZS5zb3VyY2UpO1xuICAgICAgICBpZiAoIWlzRm4gfHwgIWhhc0NhcHR1cmluZ0dyb3Vwcykge1xuICAgICAgICAgICAgcmV0dXJuIHN0cl9yZXBsYWNlLmNhbGwodGhpcywgc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgd3JhcHBlZFJlcGxhY2VWYWx1ZSA9IGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHZhciBvcmlnaW5hbExhc3RJbmRleCA9IHNlYXJjaFZhbHVlLmxhc3RJbmRleDtcbiAgICAgICAgICAgICAgICBzZWFyY2hWYWx1ZS5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gc2VhcmNoVmFsdWUuZXhlYyhtYXRjaCkgfHwgW107XG4gICAgICAgICAgICAgICAgc2VhcmNoVmFsdWUubGFzdEluZGV4ID0gb3JpZ2luYWxMYXN0SW5kZXg7XG4gICAgICAgICAgICAgICAgcHVzaChhcmdzLCBhcmd1bWVudHNbbGVuZ3RoIC0gMl0sIGFyZ3VtZW50c1tsZW5ndGggLSAxXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2VWYWx1ZS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gc3RyX3JlcGxhY2UuY2FsbCh0aGlzLCBzZWFyY2hWYWx1ZSwgd3JhcHBlZFJlcGxhY2VWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG4vLyBFQ01BLTI2MiwgM3JkIEIuMi4zXG4vLyBOb3QgYW4gRUNNQVNjcmlwdCBzdGFuZGFyZCwgYWx0aG91Z2ggRUNNQVNjcmlwdCAzcmQgRWRpdGlvbiBoYXMgYVxuLy8gbm9uLW5vcm1hdGl2ZSBzZWN0aW9uIHN1Z2dlc3RpbmcgdW5pZm9ybSBzZW1hbnRpY3MgYW5kIGl0IHNob3VsZCBiZVxuLy8gbm9ybWFsaXplZCBhY3Jvc3MgYWxsIGJyb3dzZXJzXG4vLyBbYnVnZml4LCBJRSBsdCA5XSBJRSA8IDkgc3Vic3RyKCkgd2l0aCBuZWdhdGl2ZSB2YWx1ZSBub3Qgd29ya2luZyBpbiBJRVxudmFyIHN0cmluZ19zdWJzdHIgPSBTdHJpbmdQcm90b3R5cGUuc3Vic3RyO1xudmFyIGhhc05lZ2F0aXZlU3Vic3RyQnVnID0gJycuc3Vic3RyICYmICcwYicuc3Vic3RyKC0xKSAhPT0gJ2InO1xuZGVmaW5lUHJvcGVydGllcyhTdHJpbmdQcm90b3R5cGUsIHtcbiAgICBzdWJzdHI6IGZ1bmN0aW9uIHN1YnN0cihzdGFydCwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBub3JtYWxpemVkU3RhcnQgPSBzdGFydDtcbiAgICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICAgICAgbm9ybWFsaXplZFN0YXJ0ID0gbWF4KHRoaXMubGVuZ3RoICsgc3RhcnQsIDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJpbmdfc3Vic3RyLmNhbGwodGhpcywgbm9ybWFsaXplZFN0YXJ0LCBsZW5ndGgpO1xuICAgIH1cbn0sIGhhc05lZ2F0aXZlU3Vic3RyQnVnKTtcblxuLy8gRVM1IDE1LjUuNC4yMFxuLy8gd2hpdGVzcGFjZSBmcm9tOiBodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjUuNC4yMFxudmFyIHdzID0gJ1xceDA5XFx4MEFcXHgwQlxceDBDXFx4MERcXHgyMFxceEEwXFx1MTY4MFxcdTE4MEVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzJyArXG4gICAgJ1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMEFcXHUyMDJGXFx1MjA1RlxcdTMwMDBcXHUyMDI4JyArXG4gICAgJ1xcdTIwMjlcXHVGRUZGJztcbnZhciB6ZXJvV2lkdGggPSAnXFx1MjAwYic7XG52YXIgd3NSZWdleENoYXJzID0gJ1snICsgd3MgKyAnXSc7XG52YXIgdHJpbUJlZ2luUmVnZXhwID0gbmV3IFJlZ0V4cCgnXicgKyB3c1JlZ2V4Q2hhcnMgKyB3c1JlZ2V4Q2hhcnMgKyAnKicpO1xudmFyIHRyaW1FbmRSZWdleHAgPSBuZXcgUmVnRXhwKHdzUmVnZXhDaGFycyArIHdzUmVnZXhDaGFycyArICcqJCcpO1xudmFyIGhhc1RyaW1XaGl0ZXNwYWNlQnVnID0gU3RyaW5nUHJvdG90eXBlLnRyaW0gJiYgKHdzLnRyaW0oKSB8fCAhemVyb1dpZHRoLnRyaW0oKSk7XG5kZWZpbmVQcm9wZXJ0aWVzKFN0cmluZ1Byb3RvdHlwZSwge1xuICAgIC8vIGh0dHA6Ly9ibG9nLnN0ZXZlbmxldml0aGFuLmNvbS9hcmNoaXZlcy9mYXN0ZXItdHJpbS1qYXZhc2NyaXB0XG4gICAgLy8gaHR0cDovL3BlcmZlY3Rpb25raWxscy5jb20vd2hpdGVzcGFjZS1kZXZpYXRpb25zL1xuICAgIHRyaW06IGZ1bmN0aW9uIHRyaW0oKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcyA9PT0gJ3VuZGVmaW5lZCcgfHwgdGhpcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbid0IGNvbnZlcnQgXCIgKyB0aGlzICsgJyB0byBvYmplY3QnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJFN0cmluZyh0aGlzKS5yZXBsYWNlKHRyaW1CZWdpblJlZ2V4cCwgJycpLnJlcGxhY2UodHJpbUVuZFJlZ2V4cCwgJycpO1xuICAgIH1cbn0sIGhhc1RyaW1XaGl0ZXNwYWNlQnVnKTtcblxudmFyIGhhc0xhc3RJbmRleEJ1ZyA9IFN0cmluZ1Byb3RvdHlwZS5sYXN0SW5kZXhPZiAmJiAnYWJj44GC44GEJy5sYXN0SW5kZXhPZign44GC44GEJywgMikgIT09IC0xO1xuZGVmaW5lUHJvcGVydGllcyhTdHJpbmdQcm90b3R5cGUsIHtcbiAgICBsYXN0SW5kZXhPZjogZnVuY3Rpb24gbGFzdEluZGV4T2Yoc2VhcmNoU3RyaW5nKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcyA9PT0gJ3VuZGVmaW5lZCcgfHwgdGhpcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbid0IGNvbnZlcnQgXCIgKyB0aGlzICsgJyB0byBvYmplY3QnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgUyA9ICRTdHJpbmcodGhpcyk7XG4gICAgICAgIHZhciBzZWFyY2hTdHIgPSAkU3RyaW5nKHNlYXJjaFN0cmluZyk7XG4gICAgICAgIHZhciBudW1Qb3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/ICROdW1iZXIoYXJndW1lbnRzWzFdKSA6IE5hTjtcbiAgICAgICAgdmFyIHBvcyA9IGlzQWN0dWFsTmFOKG51bVBvcykgPyBJbmZpbml0eSA6IEVTLlRvSW50ZWdlcihudW1Qb3MpO1xuICAgICAgICB2YXIgc3RhcnQgPSBtaW4obWF4KHBvcywgMCksIFMubGVuZ3RoKTtcbiAgICAgICAgdmFyIHNlYXJjaExlbiA9IHNlYXJjaFN0ci5sZW5ndGg7XG4gICAgICAgIHZhciBrID0gc3RhcnQgKyBzZWFyY2hMZW47XG4gICAgICAgIHdoaWxlIChrID4gMCkge1xuICAgICAgICAgICAgayA9IG1heCgwLCBrIC0gc2VhcmNoTGVuKTtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHN0ckluZGV4T2Yoc3RyU2xpY2UoUywgaywgc3RhcnQgKyBzZWFyY2hMZW4pLCBzZWFyY2hTdHIpO1xuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBrICsgaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbn0sIGhhc0xhc3RJbmRleEJ1Zyk7XG5cbnZhciBvcmlnaW5hbExhc3RJbmRleE9mID0gU3RyaW5nUHJvdG90eXBlLmxhc3RJbmRleE9mO1xuZGVmaW5lUHJvcGVydGllcyhTdHJpbmdQcm90b3R5cGUsIHtcbiAgICBsYXN0SW5kZXhPZjogZnVuY3Rpb24gbGFzdEluZGV4T2Yoc2VhcmNoU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBvcmlnaW5hbExhc3RJbmRleE9mLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxufSwgU3RyaW5nUHJvdG90eXBlLmxhc3RJbmRleE9mLmxlbmd0aCAhPT0gMSk7XG5cbi8vIEVTLTUgMTUuMS4yLjJcbi8qIGVzbGludC1kaXNhYmxlIHJhZGl4ICovXG5pZiAocGFyc2VJbnQod3MgKyAnMDgnKSAhPT0gOCB8fCBwYXJzZUludCh3cyArICcweDE2JykgIT09IDIyKSB7XG4vKiBlc2xpbnQtZW5hYmxlIHJhZGl4ICovXG4gICAgLyogZ2xvYmFsIHBhcnNlSW50OiB0cnVlICovXG4gICAgcGFyc2VJbnQgPSAoZnVuY3Rpb24gKG9yaWdQYXJzZUludCkge1xuICAgICAgICB2YXIgaGV4UmVnZXggPSAvXltcXC0rXT8wW3hYXS87XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBwYXJzZUludChzdHIsIHJhZGl4KSB7XG4gICAgICAgICAgICB2YXIgc3RyaW5nID0gJFN0cmluZyhzdHIpLnRyaW0oKTtcbiAgICAgICAgICAgIHZhciBkZWZhdWx0ZWRSYWRpeCA9ICROdW1iZXIocmFkaXgpIHx8IChoZXhSZWdleC50ZXN0KHN0cmluZykgPyAxNiA6IDEwKTtcbiAgICAgICAgICAgIHJldHVybiBvcmlnUGFyc2VJbnQoc3RyaW5nLCBkZWZhdWx0ZWRSYWRpeCk7XG4gICAgICAgIH07XG4gICAgfShwYXJzZUludCkpO1xufVxuXG5pZiAoU3RyaW5nKG5ldyBSYW5nZUVycm9yKCd0ZXN0JykpICE9PSAnUmFuZ2VFcnJvcjogdGVzdCcpIHtcbiAgICB2YXIgZXJyb3JUb1N0cmluZ1NoaW0gPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzID09PSAndW5kZWZpbmVkJyB8fCB0aGlzID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2FuJ3QgY29udmVydCBcIiArIHRoaXMgKyAnIHRvIG9iamVjdCcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuYW1lID0gdGhpcy5uYW1lO1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBuYW1lID0gJ0Vycm9yJztcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG5hbWUgPSAkU3RyaW5nKG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtc2cgPSB0aGlzLm1lc3NhZ2U7XG4gICAgICAgIGlmICh0eXBlb2YgbXNnID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgbXNnID0gJyc7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG1zZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG1zZyA9ICRTdHJpbmcobXNnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBtc2c7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtc2cpIHtcbiAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuYW1lICsgJzogJyArIG1zZztcbiAgICB9O1xuICAgIC8vIGNhbid0IHVzZSBkZWZpbmVQcm9wZXJ0aWVzIGhlcmUgYmVjYXVzZSBvZiB0b1N0cmluZyBlbnVtZXJhdGlvbiBpc3N1ZSBpbiBJRSA8PSA4XG4gICAgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZXJyb3JUb1N0cmluZ1NoaW07XG59XG5cbmlmIChzdXBwb3J0c0Rlc2NyaXB0b3JzKSB7XG4gICAgdmFyIGVuc3VyZU5vbkVudW1lcmFibGUgPSBmdW5jdGlvbiAob2JqLCBwcm9wKSB7XG4gICAgICAgIGlmIChpc0VudW0ob2JqLCBwcm9wKSkge1xuICAgICAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgcHJvcCk7XG4gICAgICAgICAgICBkZXNjLmVudW1lcmFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIHByb3AsIGRlc2MpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBlbnN1cmVOb25FbnVtZXJhYmxlKEVycm9yLnByb3RvdHlwZSwgJ21lc3NhZ2UnKTtcbiAgICBpZiAoRXJyb3IucHJvdG90eXBlLm1lc3NhZ2UgIT09ICcnKSB7XG4gICAgICBFcnJvci5wcm90b3R5cGUubWVzc2FnZSA9ICcnO1xuICAgIH1cbiAgICBlbnN1cmVOb25FbnVtZXJhYmxlKEVycm9yLnByb3RvdHlwZSwgJ25hbWUnKTtcbn1cblxuaWYgKFN0cmluZygvYS9taWcpICE9PSAnL2EvZ2ltJykge1xuICAgIHZhciByZWdleFRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgIHZhciBzdHIgPSAnLycgKyB0aGlzLnNvdXJjZSArICcvJztcbiAgICAgICAgaWYgKHRoaXMuZ2xvYmFsKSB7XG4gICAgICAgICAgICBzdHIgKz0gJ2cnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlnbm9yZUNhc2UpIHtcbiAgICAgICAgICAgIHN0ciArPSAnaSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubXVsdGlsaW5lKSB7XG4gICAgICAgICAgICBzdHIgKz0gJ20nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfTtcbiAgICAvLyBjYW4ndCB1c2UgZGVmaW5lUHJvcGVydGllcyBoZXJlIGJlY2F1c2Ugb2YgdG9TdHJpbmcgZW51bWVyYXRpb24gaXNzdWUgaW4gSUUgPD0gOFxuICAgIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcgPSByZWdleFRvU3RyaW5nO1xufVxuXG59KSk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9lczUtc2hpbS9lczUtc2hpbS5qc1xuICoqIG1vZHVsZSBpZCA9IDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCIvKlxcbiAqIFN1cHBvcnQgZm9yIHNvdXJjZSBtYXBzIGluIFY4IHN0YWNrIHRyYWNlc1xcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ldmFudy9ub2RlLXNvdXJjZS1tYXAtc3VwcG9ydFxcbiAqL1xcbih0aGlzLmRlZmluZXx8ZnVuY3Rpb24oSyxOKXt0aGlzLnNvdXJjZU1hcFN1cHBvcnQ9TigpfSkoXFxcImJyb3dzZXItc291cmNlLW1hcC1zdXBwb3J0XFxcIixmdW5jdGlvbihLKXsoZnVuY3Rpb24gbih3LHQsZSl7ZnVuY3Rpb24gcihnLGIpe2lmKCF0W2ddKXtpZighd1tnXSl7dmFyIGY9XFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWImJmYpcmV0dXJuIGYoZywhMCk7aWYobClyZXR1cm4gbChnLCEwKTt0aHJvdyBFcnJvcihcXFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcXFwiK2crXFxcIidcXFwiKTt9Zj10W2ddPXtleHBvcnRzOnt9fTt3W2ddWzBdLmNhbGwoZi5leHBvcnRzLGZ1bmN0aW9uKGIpe3ZhciBhPXdbZ11bMV1bYl07cmV0dXJuIHIoYT9hOmIpfSxmLGYuZXhwb3J0cyxuLHcsdCxlKX1yZXR1cm4gdFtnXS5leHBvcnRzfWZvcih2YXIgbD1cXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxtPTA7bTxlLmxlbmd0aDttKyspcihlW21dKTtyZXR1cm4gcn0pKHsxOltmdW5jdGlvbihuLFxcbncsdCl7Sz1uKFxcXCIuL3NvdXJjZS1tYXAtc3VwcG9ydFxcXCIpfSx7XFxcIi4vc291cmNlLW1hcC1zdXBwb3J0XFxcIjoxOH1dLDI6W2Z1bmN0aW9uKG4sdyx0KXsoZnVuY3Rpb24oZSxyKXt3LmV4cG9ydHM9ZnVuY3Rpb24obCxtKXtmdW5jdGlvbiBnKGMsZCl7dmFyIGE7aWYoYyYmXFxcIi5cXFwiPT09Yy5jaGFyQXQoMCkmJmQpe2E9ZC5zcGxpdChcXFwiL1xcXCIpO2E9YS5zbGljZSgwLGEubGVuZ3RoLTEpO3ZhciBiPWE9YS5jb25jYXQoYy5zcGxpdChcXFwiL1xcXCIpKSxmLGs7Zm9yKGY9MDtiW2ZdO2YrPTEpaWYoaz1iW2ZdLFxcXCIuXFxcIj09PWspYi5zcGxpY2UoZiwxKSwtLWY7ZWxzZSBpZihcXFwiLi5cXFwiPT09aylpZigxIT09Znx8XFxcIi4uXFxcIiE9PWJbMl0mJlxcXCIuLlxcXCIhPT1iWzBdKTA8ZiYmKGIuc3BsaWNlKGYtMSwyKSxmLT0yKTtlbHNlIGJyZWFrO2M9YS5qb2luKFxcXCIvXFxcIil9cmV0dXJuIGN9ZnVuY3Rpb24gYihjKXtyZXR1cm4gZnVuY3Rpb24oYSl7cmV0dXJuIGcoYSxjKX19ZnVuY3Rpb24gZihjKXtmdW5jdGlvbiBhKGIpe2RbY109Yn1hLmZyb21UZXh0PVxcbmZ1bmN0aW9uKGMsYSl7dGhyb3cgRXJyb3IoXFxcImFtZGVmaW5lIGRvZXMgbm90IGltcGxlbWVudCBsb2FkLmZyb21UZXh0XFxcIik7fTtyZXR1cm4gYX1mdW5jdGlvbiBrKGMsYSxiKXt2YXIgZixrLGc7aWYoYylrPWRbY109e30sZz17aWQ6Yyx1cmk6cixleHBvcnRzOmt9LGY9QShtLGssZyxjKTtlbHNle2lmKHkpdGhyb3cgRXJyb3IoXFxcImFtZGVmaW5lIHdpdGggbm8gbW9kdWxlIElEIGNhbm5vdCBiZSBjYWxsZWQgbW9yZSB0aGFuIG9uY2UgcGVyIGZpbGUuXFxcIik7eT0hMDtrPWwuZXhwb3J0cztnPWw7Zj1BKG0sayxnLGwuaWQpfWEmJihhPWEubWFwKGZ1bmN0aW9uKGMpe3JldHVybiBmKGMpfSkpO2E9XFxcImZ1bmN0aW9uXFxcIj09PXR5cGVvZiBiP2IuYXBwbHkoZy5leHBvcnRzLGEpOmI7dm9pZCAwIT09YSYmKGcuZXhwb3J0cz1hLGMmJihkW2NdPWcuZXhwb3J0cykpfWZ1bmN0aW9uIGEoYSxkLGIpe0FycmF5LmlzQXJyYXkoYSk/KGI9ZCxkPWEsYT12b2lkIDApOlxcXCJzdHJpbmdcXFwiIT09dHlwZW9mIGEmJlxcbihiPWEsYT1kPXZvaWQgMCk7ZCYmIUFycmF5LmlzQXJyYXkoZCkmJihiPWQsZD12b2lkIDApO2R8fChkPVtcXFwicmVxdWlyZVxcXCIsXFxcImV4cG9ydHNcXFwiLFxcXCJtb2R1bGVcXFwiXSk7YT9jW2FdPVthLGQsYl06ayhhLGQsYil9dmFyIGM9e30sZD17fSx5PSExLHg9bihcXFwicGF0aFxcXCIpLEEsQjtBPWZ1bmN0aW9uKGMsYSxkLGIpe2Z1bmN0aW9uIGYoayxnKXtpZihcXFwic3RyaW5nXFxcIj09PXR5cGVvZiBrKXJldHVybiBCKGMsYSxkLGssYik7az1rLm1hcChmdW5jdGlvbihmKXtyZXR1cm4gQihjLGEsZCxmLGIpfSk7ZyYmZS5uZXh0VGljayhmdW5jdGlvbigpe2cuYXBwbHkobnVsbCxrKX0pfWYudG9Vcmw9ZnVuY3Rpb24oYyl7cmV0dXJuIDA9PT1jLmluZGV4T2YoXFxcIi5cXFwiKT9nKGMseC5kaXJuYW1lKGQuZmlsZW5hbWUpKTpjfTtyZXR1cm4gZn07bT1tfHxmdW5jdGlvbigpe3JldHVybiBsLnJlcXVpcmUuYXBwbHkobCxhcmd1bWVudHMpfTtCPWZ1bmN0aW9uKGEsZSx5LG0seCl7dmFyIGw9bS5pbmRleE9mKFxcXCIhXFxcIikscj1tO1xcbmlmKC0xPT09bCl7bT1nKG0seCk7aWYoXFxcInJlcXVpcmVcXFwiPT09bSlyZXR1cm4gQShhLGUseSx4KTtpZihcXFwiZXhwb3J0c1xcXCI9PT1tKXJldHVybiBlO2lmKFxcXCJtb2R1bGVcXFwiPT09bSlyZXR1cm4geTtpZihkLmhhc093blByb3BlcnR5KG0pKXJldHVybiBkW21dO2lmKGNbbV0pcmV0dXJuIGsuYXBwbHkobnVsbCxjW21dKSxkW21dO2lmKGEpcmV0dXJuIGEocik7dGhyb3cgRXJyb3IoXFxcIk5vIG1vZHVsZSB3aXRoIElEOiBcXFwiK20pO31yPW0uc3Vic3RyaW5nKDAsbCk7bT1tLnN1YnN0cmluZyhsKzEsbS5sZW5ndGgpO2w9QihhLGUseSxyLHgpO209bC5ub3JtYWxpemU/bC5ub3JtYWxpemUobSxiKHgpKTpnKG0seCk7ZFttXXx8bC5sb2FkKG0sQShhLGUseSx4KSxmKG0pLHt9KTtyZXR1cm4gZFttXX07YS5yZXF1aXJlPWZ1bmN0aW9uKGEpe2lmKGRbYV0pcmV0dXJuIGRbYV07aWYoY1thXSlyZXR1cm4gay5hcHBseShudWxsLGNbYV0pLGRbYV19O2EuYW1kPXt9O3JldHVybiBhfX0pLmNhbGwodGhpcyxuKFxcXCJub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzXFxcIiksXFxuXFxcIi9ub2RlX21vZHVsZXMvYW1kZWZpbmUvYW1kZWZpbmUuanNcXFwiKX0se1xcXCJub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzXFxcIjo4LHBhdGg6N31dLDM6W2Z1bmN0aW9uKG4sdyx0KXsoZnVuY3Rpb24oZSl7ZnVuY3Rpb24gcihlKXtlPWUuY2hhckNvZGVBdCgwKTtpZig0Mz09PWV8fDQ1PT09ZSlyZXR1cm4gNjI7aWYoNDc9PT1lfHw5NT09PWUpcmV0dXJuIDYzO2lmKDQ4PmUpcmV0dXJuLTE7aWYoNTg+ZSlyZXR1cm4gZS00OCs1MjtpZig5MT5lKXJldHVybiBlLTY1O2lmKDEyMz5lKXJldHVybiBlLTk3KzI2fXZhciBsPVxcXCJ1bmRlZmluZWRcXFwiIT09dHlwZW9mIFVpbnQ4QXJyYXk/VWludDhBcnJheTpBcnJheTtlLnRvQnl0ZUFycmF5PWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIGcoYSl7Y1tkKytdPWF9dmFyIGIsZixrLGEsYztpZigwPGUubGVuZ3RoJTQpdGhyb3cgRXJyb3IoXFxcIkludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDRcXFwiKTtiPWUubGVuZ3RoO2E9XFxcIj1cXFwiPT09XFxuZS5jaGFyQXQoYi0yKT8yOlxcXCI9XFxcIj09PWUuY2hhckF0KGItMSk/MTowO2M9bmV3IGwoMyplLmxlbmd0aC80LWEpO2Y9MDxhP2UubGVuZ3RoLTQ6ZS5sZW5ndGg7dmFyIGQ9MDtmb3IoYj0wO2I8ZjtiKz00KWs9cihlLmNoYXJBdChiKSk8PDE4fHIoZS5jaGFyQXQoYisxKSk8PDEyfHIoZS5jaGFyQXQoYisyKSk8PDZ8cihlLmNoYXJBdChiKzMpKSxnKChrJjE2NzExNjgwKT4+MTYpLGcoKGsmNjUyODApPj44KSxnKGsmMjU1KTsyPT09YT8oaz1yKGUuY2hhckF0KGIpKTw8MnxyKGUuY2hhckF0KGIrMSkpPj40LGcoayYyNTUpKToxPT09YSYmKGs9cihlLmNoYXJBdChiKSk8PDEwfHIoZS5jaGFyQXQoYisxKSk8PDR8cihlLmNoYXJBdChiKzIpKT4+MixnKGs+PjgmMjU1KSxnKGsmMjU1KSk7cmV0dXJuIGN9O2UuZnJvbUJ5dGVBcnJheT1mdW5jdGlvbihlKXt2YXIgZyxiPWUubGVuZ3RoJTMsZj1cXFwiXFxcIixrLGE7Zz0wO2ZvcihhPWUubGVuZ3RoLWI7ZzxhO2crPTMpaz0oZVtnXTw8MTYpKyhlW2crXFxuMV08PDgpK2VbZysyXSxrPVxcXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXFxcIi5jaGFyQXQoaz4+MTgmNjMpK1xcXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXFxcIi5jaGFyQXQoaz4+MTImNjMpK1xcXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXFxcIi5jaGFyQXQoaz4+NiY2MykrXFxcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cXFwiLmNoYXJBdChrJjYzKSxmKz1rO3N3aXRjaChiKXtjYXNlIDE6az1lW2UubGVuZ3RoLTFdO2YrPVxcXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXFxcIi5jaGFyQXQoaz4+Mik7Zis9XFxcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cXFwiLmNoYXJBdChrPDxcXG40JjYzKTtmKz1cXFwiPT1cXFwiO2JyZWFrO2Nhc2UgMjprPShlW2UubGVuZ3RoLTJdPDw4KStlW2UubGVuZ3RoLTFdLGYrPVxcXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXFxcIi5jaGFyQXQoaz4+MTApLGYrPVxcXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXFxcIi5jaGFyQXQoaz4+NCY2MyksZis9XFxcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cXFwiLmNoYXJBdChrPDwyJjYzKSxmKz1cXFwiPVxcXCJ9cmV0dXJuIGZ9fSkoXFxcInVuZGVmaW5lZFxcXCI9PT10eXBlb2YgdD90aGlzLmJhc2U2NGpzPXt9OnQpfSx7fV0sNDpbZnVuY3Rpb24obix3LHQpe30se31dLDU6W2Z1bmN0aW9uKG4sdyx0KXtmdW5jdGlvbiBlKGgscSxjKXtpZighKHRoaXMgaW5zdGFuY2VvZiBlKSlyZXR1cm4gbmV3IGUoaCxxLGMpO3ZhciBhPXR5cGVvZiBoO1xcbmlmKFxcXCJiYXNlNjRcXFwiPT09cSYmXFxcInN0cmluZ1xcXCI9PT1hKWZvcihoPWgudHJpbT9oLnRyaW0oKTpoLnJlcGxhY2UoL15cXFxccyt8XFxcXHMrJC9nLFxcXCJcXFwiKTswIT09aC5sZW5ndGglNDspaCs9XFxcIj1cXFwiO3ZhciBkO2lmKFxcXCJudW1iZXJcXFwiPT09YSlkPUYoaCk7ZWxzZSBpZihcXFwic3RyaW5nXFxcIj09PWEpZD1lLmJ5dGVMZW5ndGgoaCxxKTtlbHNlIGlmKFxcXCJvYmplY3RcXFwiPT09YSlkPUYoaC5sZW5ndGgpO2Vsc2UgdGhyb3cgRXJyb3IoXFxcIkZpcnN0IGFyZ3VtZW50IG5lZWRzIHRvIGJlIGEgbnVtYmVyLCBhcnJheSBvciBzdHJpbmcuXFxcIik7dmFyIGI7ZS5fdXNlVHlwZWRBcnJheXM/Yj1lLl9hdWdtZW50KG5ldyBVaW50OEFycmF5KGQpKTooYj10aGlzLGIubGVuZ3RoPWQsYi5faXNCdWZmZXI9ITApO2lmKGUuX3VzZVR5cGVkQXJyYXlzJiZcXFwibnVtYmVyXFxcIj09PXR5cGVvZiBoLmJ5dGVMZW5ndGgpYi5fc2V0KGgpO2Vsc2V7dmFyIGY9aDtpZihFKGYpfHxlLmlzQnVmZmVyKGYpfHxmJiZcXFwib2JqZWN0XFxcIj09PXR5cGVvZiBmJiZcXFwibnVtYmVyXFxcIj09PVxcbnR5cGVvZiBmLmxlbmd0aClmb3IocT0wO3E8ZDtxKyspZS5pc0J1ZmZlcihoKT9iW3FdPWgucmVhZFVJbnQ4KHEpOmJbcV09aFtxXTtlbHNlIGlmKFxcXCJzdHJpbmdcXFwiPT09YSliLndyaXRlKGgsMCxxKTtlbHNlIGlmKFxcXCJudW1iZXJcXFwiPT09YSYmIWUuX3VzZVR5cGVkQXJyYXlzJiYhYylmb3IocT0wO3E8ZDtxKyspYltxXT0wfXJldHVybiBifWZ1bmN0aW9uIHIoaCxxLGMpe3ZhciBhPVxcXCJcXFwiO2ZvcihjPU1hdGgubWluKGgubGVuZ3RoLGMpO3E8YztxKyspYSs9U3RyaW5nLmZyb21DaGFyQ29kZShoW3FdKTtyZXR1cm4gYX1mdW5jdGlvbiBsKGgscSxjLGEpe2F8fChwKFxcXCJib29sZWFuXFxcIj09PXR5cGVvZiBjLFxcXCJtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuXFxcIikscCh2b2lkIDAhPT1xJiZudWxsIT09cSxcXFwibWlzc2luZyBvZmZzZXRcXFwiKSxwKHErMTxoLmxlbmd0aCxcXFwiVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGhcXFwiKSk7YT1oLmxlbmd0aDtpZighKHE+PWEpKXJldHVybiBjPyhjPWhbcV0scStcXG4xPGEmJihjfD1oW3ErMV08PDgpKTooYz1oW3FdPDw4LHErMTxhJiYoY3w9aFtxKzFdKSksY31mdW5jdGlvbiBtKGgscSxjLGEpe2F8fChwKFxcXCJib29sZWFuXFxcIj09PXR5cGVvZiBjLFxcXCJtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuXFxcIikscCh2b2lkIDAhPT1xJiZudWxsIT09cSxcXFwibWlzc2luZyBvZmZzZXRcXFwiKSxwKHErMzxoLmxlbmd0aCxcXFwiVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGhcXFwiKSk7YT1oLmxlbmd0aDtpZighKHE+PWEpKXt2YXIgZDtjPyhxKzI8YSYmKGQ9aFtxKzJdPDwxNikscSsxPGEmJihkfD1oW3ErMV08PDgpLGR8PWhbcV0scSszPGEmJihkKz1oW3ErM108PDI0Pj4+MCkpOihxKzE8YSYmKGQ9aFtxKzFdPDwxNikscSsyPGEmJihkfD1oW3ErMl08PDgpLHErMzxhJiYoZHw9aFtxKzNdKSxkKz1oW3FdPDwyND4+PjApO3JldHVybiBkfX1mdW5jdGlvbiBnKGgscSxhLGMpe2N8fChwKFxcXCJib29sZWFuXFxcIj09PXR5cGVvZiBhLFxcXCJtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuXFxcIiksXFxucCh2b2lkIDAhPT1xJiZudWxsIT09cSxcXFwibWlzc2luZyBvZmZzZXRcXFwiKSxwKHErMTxoLmxlbmd0aCxcXFwiVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGhcXFwiKSk7aWYoIShxPj1oLmxlbmd0aCkpcmV0dXJuIGg9bChoLHEsYSwhMCksaCYzMjc2OD8tMSooNjU1MzUtaCsxKTpofWZ1bmN0aW9uIGIoaCxxLGEsYyl7Y3x8KHAoXFxcImJvb2xlYW5cXFwiPT09dHlwZW9mIGEsXFxcIm1pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW5cXFwiKSxwKHZvaWQgMCE9PXEmJm51bGwhPT1xLFxcXCJtaXNzaW5nIG9mZnNldFxcXCIpLHAocSszPGgubGVuZ3RoLFxcXCJUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aFxcXCIpKTtpZighKHE+PWgubGVuZ3RoKSlyZXR1cm4gaD1tKGgscSxhLCEwKSxoJjIxNDc0ODM2NDg/LTEqKDQyOTQ5NjcyOTUtaCsxKTpofWZ1bmN0aW9uIGYoaCxxLGEsYyl7Y3x8KHAoXFxcImJvb2xlYW5cXFwiPT09dHlwZW9mIGEsXFxcIm1pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW5cXFwiKSxwKHErMzxoLmxlbmd0aCxcXFwiVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGhcXFwiKSk7XFxucmV0dXJuIEkucmVhZChoLHEsYSwyMyw0KX1mdW5jdGlvbiBrKGgscSxhLGMpe2N8fChwKFxcXCJib29sZWFuXFxcIj09PXR5cGVvZiBhLFxcXCJtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuXFxcIikscChxKzc8aC5sZW5ndGgsXFxcIlRyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoXFxcIikpO3JldHVybiBJLnJlYWQoaCxxLGEsNTIsOCl9ZnVuY3Rpb24gYShoLGEsYyxkLGIpe2J8fChwKHZvaWQgMCE9PWEmJm51bGwhPT1hLFxcXCJtaXNzaW5nIHZhbHVlXFxcIikscChcXFwiYm9vbGVhblxcXCI9PT10eXBlb2YgZCxcXFwibWlzc2luZyBvciBpbnZhbGlkIGVuZGlhblxcXCIpLHAodm9pZCAwIT09YyYmbnVsbCE9PWMsXFxcIm1pc3Npbmcgb2Zmc2V0XFxcIikscChjKzE8aC5sZW5ndGgsXFxcInRyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aFxcXCIpLEgoYSw2NTUzNSkpO3ZhciBmPWgubGVuZ3RoO2lmKCEoYz49ZikpZm9yKGI9MCxmPU1hdGgubWluKGYtYywyKTtiPGY7YisrKWhbYytiXT0oYSYyNTU8PDgqKGQ/YjoxLWIpKT4+PjgqXFxuKGQ/YjoxLWIpfWZ1bmN0aW9uIGMoaCxhLGMsZCxiKXtifHwocCh2b2lkIDAhPT1hJiZudWxsIT09YSxcXFwibWlzc2luZyB2YWx1ZVxcXCIpLHAoXFxcImJvb2xlYW5cXFwiPT09dHlwZW9mIGQsXFxcIm1pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW5cXFwiKSxwKHZvaWQgMCE9PWMmJm51bGwhPT1jLFxcXCJtaXNzaW5nIG9mZnNldFxcXCIpLHAoYyszPGgubGVuZ3RoLFxcXCJ0cnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGhcXFwiKSxIKGEsNDI5NDk2NzI5NSkpO3ZhciBmPWgubGVuZ3RoO2lmKCEoYz49ZikpZm9yKGI9MCxmPU1hdGgubWluKGYtYyw0KTtiPGY7YisrKWhbYytiXT1hPj4+OCooZD9iOjMtYikmMjU1fWZ1bmN0aW9uIGQoaCxjLGQsYixmKXtmfHwocCh2b2lkIDAhPT1jJiZudWxsIT09YyxcXFwibWlzc2luZyB2YWx1ZVxcXCIpLHAoXFxcImJvb2xlYW5cXFwiPT09dHlwZW9mIGIsXFxcIm1pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW5cXFwiKSxwKHZvaWQgMCE9PWQmJm51bGwhPT1kLFxcXCJtaXNzaW5nIG9mZnNldFxcXCIpLHAoZCsxPGgubGVuZ3RoLFxcblxcXCJUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGhcXFwiKSxMKGMsMzI3NjcsLTMyNzY4KSk7ZD49aC5sZW5ndGh8fCgwPD1jP2EoaCxjLGQsYixmKTphKGgsNjU1MzUrYysxLGQsYixmKSl9ZnVuY3Rpb24geShoLGEsZCxiLGYpe2Z8fChwKHZvaWQgMCE9PWEmJm51bGwhPT1hLFxcXCJtaXNzaW5nIHZhbHVlXFxcIikscChcXFwiYm9vbGVhblxcXCI9PT10eXBlb2YgYixcXFwibWlzc2luZyBvciBpbnZhbGlkIGVuZGlhblxcXCIpLHAodm9pZCAwIT09ZCYmbnVsbCE9PWQsXFxcIm1pc3Npbmcgb2Zmc2V0XFxcIikscChkKzM8aC5sZW5ndGgsXFxcIlRyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aFxcXCIpLEwoYSwyMTQ3NDgzNjQ3LC0yMTQ3NDgzNjQ4KSk7ZD49aC5sZW5ndGh8fCgwPD1hP2MoaCxhLGQsYixmKTpjKGgsNDI5NDk2NzI5NSthKzEsZCxiLGYpKX1mdW5jdGlvbiB4KGgsYSxjLGQsYil7Ynx8KHAodm9pZCAwIT09YSYmbnVsbCE9PWEsXFxcIm1pc3NpbmcgdmFsdWVcXFwiKSxwKFxcXCJib29sZWFuXFxcIj09PXR5cGVvZiBkLFxcblxcXCJtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuXFxcIikscCh2b2lkIDAhPT1jJiZudWxsIT09YyxcXFwibWlzc2luZyBvZmZzZXRcXFwiKSxwKGMrMzxoLmxlbmd0aCxcXFwiVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoXFxcIiksTShhLDMuNDAyODIzNDY2Mzg1Mjg4NkUzOCwtMy40MDI4MjM0NjYzODUyODg2RTM4KSk7Yz49aC5sZW5ndGh8fEkud3JpdGUoaCxhLGMsZCwyMyw0KX1mdW5jdGlvbiBBKGgsYyxhLGQsYil7Ynx8KHAodm9pZCAwIT09YyYmbnVsbCE9PWMsXFxcIm1pc3NpbmcgdmFsdWVcXFwiKSxwKFxcXCJib29sZWFuXFxcIj09PXR5cGVvZiBkLFxcXCJtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuXFxcIikscCh2b2lkIDAhPT1hJiZudWxsIT09YSxcXFwibWlzc2luZyBvZmZzZXRcXFwiKSxwKGErNzxoLmxlbmd0aCxcXFwiVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoXFxcIiksTShjLDEuNzk3NjkzMTM0ODYyMzE1N0UzMDgsLTEuNzk3NjkzMTM0ODYyMzE1N0UzMDgpKTthPj1oLmxlbmd0aHx8SS53cml0ZShoLFxcbmMsYSxkLDUyLDgpfWZ1bmN0aW9uIEIoaCxhLGMpe2lmKFxcXCJudW1iZXJcXFwiIT09dHlwZW9mIGgpcmV0dXJuIGM7aD1+fmg7aWYoaD49YSlyZXR1cm4gYTtpZigwPD1oKXJldHVybiBoO2grPWE7cmV0dXJuIDA8PWg/aDowfWZ1bmN0aW9uIEYoaCl7aD1+fk1hdGguY2VpbCgraCk7cmV0dXJuIDA+aD8wOmh9ZnVuY3Rpb24gRShoKXtyZXR1cm4oQXJyYXkuaXNBcnJheXx8ZnVuY3Rpb24oaCl7cmV0dXJuXFxcIltvYmplY3QgQXJyYXldXFxcIj09PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChoKX0pKGgpfWZ1bmN0aW9uIEcoaCl7cmV0dXJuIDE2Pmg/XFxcIjBcXFwiK2gudG9TdHJpbmcoMTYpOmgudG9TdHJpbmcoMTYpfWZ1bmN0aW9uIHUoaCl7Zm9yKHZhciBhPVtdLGM9MDtjPGgubGVuZ3RoO2MrKyl7dmFyIGQ9aC5jaGFyQ29kZUF0KGMpO2lmKDEyNz49ZClhLnB1c2goaC5jaGFyQ29kZUF0KGMpKTtlbHNle3ZhciBiPWM7NTUyOTY8PWQmJjU3MzQzPj1kJiZjKys7ZD1lbmNvZGVVUklDb21wb25lbnQoaC5zbGljZShiLFxcbmMrMSkpLnN1YnN0cigxKS5zcGxpdChcXFwiJVxcXCIpO2ZvcihiPTA7YjxkLmxlbmd0aDtiKyspYS5wdXNoKHBhcnNlSW50KGRbYl0sMTYpKX19cmV0dXJuIGF9ZnVuY3Rpb24gQyhoKXtmb3IodmFyIGM9W10sYT0wO2E8aC5sZW5ndGg7YSsrKWMucHVzaChoLmNoYXJDb2RlQXQoYSkmMjU1KTtyZXR1cm4gY31mdW5jdGlvbiB6KGgsYyxhLGQpe2Zvcih2YXIgYj0wO2I8ZCYmIShiK2E+PWMubGVuZ3RofHxiPj1oLmxlbmd0aCk7YisrKWNbYithXT1oW2JdO3JldHVybiBifWZ1bmN0aW9uIEQoaCl7dHJ5e3JldHVybiBkZWNvZGVVUklDb21wb25lbnQoaCl9Y2F0Y2goYyl7cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoNjU1MzMpfX1mdW5jdGlvbiBIKGgsYyl7cChcXFwibnVtYmVyXFxcIj09PXR5cGVvZiBoLFxcXCJjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyXFxcIik7cCgwPD1oLFxcXCJzcGVjaWZpZWQgYSBuZWdhdGl2ZSB2YWx1ZSBmb3Igd3JpdGluZyBhbiB1bnNpZ25lZCB2YWx1ZVxcXCIpO3AoaDw9XFxuYyxcXFwidmFsdWUgaXMgbGFyZ2VyIHRoYW4gbWF4aW11bSB2YWx1ZSBmb3IgdHlwZVxcXCIpO3AoTWF0aC5mbG9vcihoKT09PWgsXFxcInZhbHVlIGhhcyBhIGZyYWN0aW9uYWwgY29tcG9uZW50XFxcIil9ZnVuY3Rpb24gTChoLGMsYSl7cChcXFwibnVtYmVyXFxcIj09PXR5cGVvZiBoLFxcXCJjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyXFxcIik7cChoPD1jLFxcXCJ2YWx1ZSBsYXJnZXIgdGhhbiBtYXhpbXVtIGFsbG93ZWQgdmFsdWVcXFwiKTtwKGg+PWEsXFxcInZhbHVlIHNtYWxsZXIgdGhhbiBtaW5pbXVtIGFsbG93ZWQgdmFsdWVcXFwiKTtwKE1hdGguZmxvb3IoaCk9PT1oLFxcXCJ2YWx1ZSBoYXMgYSBmcmFjdGlvbmFsIGNvbXBvbmVudFxcXCIpfWZ1bmN0aW9uIE0oaCxjLGEpe3AoXFxcIm51bWJlclxcXCI9PT10eXBlb2YgaCxcXFwiY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlclxcXCIpO3AoaDw9YyxcXFwidmFsdWUgbGFyZ2VyIHRoYW4gbWF4aW11bSBhbGxvd2VkIHZhbHVlXFxcIik7cChoPj1hLFxcXCJ2YWx1ZSBzbWFsbGVyIHRoYW4gbWluaW11bSBhbGxvd2VkIHZhbHVlXFxcIil9XFxuZnVuY3Rpb24gcChoLGMpe2lmKCFoKXRocm93IEVycm9yKGN8fFxcXCJGYWlsZWQgYXNzZXJ0aW9uXFxcIik7fXZhciBKPW4oXFxcImJhc2U2NC1qc1xcXCIpLEk9bihcXFwiaWVlZTc1NFxcXCIpO3QuQnVmZmVyPWU7dC5TbG93QnVmZmVyPWU7dC5JTlNQRUNUX01BWF9CWVRFUz01MDtlLnBvb2xTaXplPTgxOTI7ZS5fdXNlVHlwZWRBcnJheXM9ZnVuY3Rpb24oKXt0cnl7dmFyIGg9bmV3IEFycmF5QnVmZmVyKDApLGM9bmV3IFVpbnQ4QXJyYXkoaCk7Yy5mb289ZnVuY3Rpb24oKXtyZXR1cm4gNDJ9O3JldHVybiA0Mj09PWMuZm9vKCkmJlxcXCJmdW5jdGlvblxcXCI9PT10eXBlb2YgYy5zdWJhcnJheX1jYXRjaChhKXtyZXR1cm4hMX19KCk7ZS5pc0VuY29kaW5nPWZ1bmN0aW9uKGgpe3N3aXRjaChTdHJpbmcoaCkudG9Mb3dlckNhc2UoKSl7Y2FzZSBcXFwiaGV4XFxcIjpjYXNlIFxcXCJ1dGY4XFxcIjpjYXNlIFxcXCJ1dGYtOFxcXCI6Y2FzZSBcXFwiYXNjaWlcXFwiOmNhc2UgXFxcImJpbmFyeVxcXCI6Y2FzZSBcXFwiYmFzZTY0XFxcIjpjYXNlIFxcXCJyYXdcXFwiOmNhc2UgXFxcInVjczJcXFwiOmNhc2UgXFxcInVjcy0yXFxcIjpjYXNlIFxcXCJ1dGYxNmxlXFxcIjpjYXNlIFxcXCJ1dGYtMTZsZVxcXCI6cmV0dXJuITA7XFxuZGVmYXVsdDpyZXR1cm4hMX19O2UuaXNCdWZmZXI9ZnVuY3Rpb24oaCl7cmV0dXJuIShudWxsPT09aHx8dm9pZCAwPT09aHx8IWguX2lzQnVmZmVyKX07ZS5ieXRlTGVuZ3RoPWZ1bmN0aW9uKGgsYyl7dmFyIGE7aCs9XFxcIlxcXCI7c3dpdGNoKGN8fFxcXCJ1dGY4XFxcIil7Y2FzZSBcXFwiaGV4XFxcIjphPWgubGVuZ3RoLzI7YnJlYWs7Y2FzZSBcXFwidXRmOFxcXCI6Y2FzZSBcXFwidXRmLThcXFwiOmE9dShoKS5sZW5ndGg7YnJlYWs7Y2FzZSBcXFwiYXNjaWlcXFwiOmNhc2UgXFxcImJpbmFyeVxcXCI6Y2FzZSBcXFwicmF3XFxcIjphPWgubGVuZ3RoO2JyZWFrO2Nhc2UgXFxcImJhc2U2NFxcXCI6YT1KLnRvQnl0ZUFycmF5KGgpLmxlbmd0aDticmVhaztjYXNlIFxcXCJ1Y3MyXFxcIjpjYXNlIFxcXCJ1Y3MtMlxcXCI6Y2FzZSBcXFwidXRmMTZsZVxcXCI6Y2FzZSBcXFwidXRmLTE2bGVcXFwiOmE9MipoLmxlbmd0aDticmVhaztkZWZhdWx0OnRocm93IEVycm9yKFxcXCJVbmtub3duIGVuY29kaW5nXFxcIik7fXJldHVybiBhfTtlLmNvbmNhdD1mdW5jdGlvbihoLGMpe3AoRShoKSxcXFwiVXNhZ2U6IEJ1ZmZlci5jb25jYXQobGlzdCwgW3RvdGFsTGVuZ3RoXSlcXFxcbmxpc3Qgc2hvdWxkIGJlIGFuIEFycmF5LlxcXCIpO1xcbmlmKDA9PT1oLmxlbmd0aClyZXR1cm4gbmV3IGUoMCk7aWYoMT09PWgubGVuZ3RoKXJldHVybiBoWzBdO3ZhciBhO2lmKFxcXCJudW1iZXJcXFwiIT09dHlwZW9mIGMpZm9yKGE9Yz0wO2E8aC5sZW5ndGg7YSsrKWMrPWhbYV0ubGVuZ3RoO3ZhciBkPW5ldyBlKGMpLGI9MDtmb3IoYT0wO2E8aC5sZW5ndGg7YSsrKXt2YXIgZj1oW2FdO2YuY29weShkLGIpO2IrPWYubGVuZ3RofXJldHVybiBkfTtlLnByb3RvdHlwZS53cml0ZT1mdW5jdGlvbihoLGMsYSxkKXtpZihpc0Zpbml0ZShjKSlpc0Zpbml0ZShhKXx8KGQ9YSxhPXZvaWQgMCk7ZWxzZXt2YXIgYj1kO2Q9YztjPWE7YT1ifWM9TnVtYmVyKGMpfHwwO2I9dGhpcy5sZW5ndGgtYzthPyhhPU51bWJlcihhKSxhPmImJihhPWIpKTphPWI7ZD1TdHJpbmcoZHx8XFxcInV0ZjhcXFwiKS50b0xvd2VyQ2FzZSgpO3N3aXRjaChkKXtjYXNlIFxcXCJoZXhcXFwiOmM9TnVtYmVyKGMpfHwwO2Q9dGhpcy5sZW5ndGgtYzthPyhhPU51bWJlcihhKSxhPmQmJihhPWQpKTphPWQ7ZD1cXG5oLmxlbmd0aDtwKDA9PT1kJTIsXFxcIkludmFsaWQgaGV4IHN0cmluZ1xcXCIpO2E+ZC8yJiYoYT1kLzIpO2ZvcihkPTA7ZDxhO2QrKyliPXBhcnNlSW50KGguc3Vic3RyKDIqZCwyKSwxNikscCghaXNOYU4oYiksXFxcIkludmFsaWQgaGV4IHN0cmluZ1xcXCIpLHRoaXNbYytkXT1iO2UuX2NoYXJzV3JpdHRlbj0yKmQ7aD1kO2JyZWFrO2Nhc2UgXFxcInV0ZjhcXFwiOmNhc2UgXFxcInV0Zi04XFxcIjpoPWUuX2NoYXJzV3JpdHRlbj16KHUoaCksdGhpcyxjLGEpO2JyZWFrO2Nhc2UgXFxcImFzY2lpXFxcIjpoPWUuX2NoYXJzV3JpdHRlbj16KEMoaCksdGhpcyxjLGEpO2JyZWFrO2Nhc2UgXFxcImJpbmFyeVxcXCI6aD1lLl9jaGFyc1dyaXR0ZW49eihDKGgpLHRoaXMsYyxhKTticmVhaztjYXNlIFxcXCJiYXNlNjRcXFwiOmg9ZS5fY2hhcnNXcml0dGVuPXooSi50b0J5dGVBcnJheShoKSx0aGlzLGMsYSk7YnJlYWs7Y2FzZSBcXFwidWNzMlxcXCI6Y2FzZSBcXFwidWNzLTJcXFwiOmNhc2UgXFxcInV0ZjE2bGVcXFwiOmNhc2UgXFxcInV0Zi0xNmxlXFxcIjpmb3IodmFyIGYsYj1bXSxrPTA7azxoLmxlbmd0aDtrKyspZj1cXG5oLmNoYXJDb2RlQXQoayksZD1mPj44LGYlPTI1NixiLnB1c2goZiksYi5wdXNoKGQpO2g9ZS5fY2hhcnNXcml0dGVuPXooYix0aGlzLGMsYSk7YnJlYWs7ZGVmYXVsdDp0aHJvdyBFcnJvcihcXFwiVW5rbm93biBlbmNvZGluZ1xcXCIpO31yZXR1cm4gaH07ZS5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oYSxjLGQpe2E9U3RyaW5nKGF8fFxcXCJ1dGY4XFxcIikudG9Mb3dlckNhc2UoKTtjPU51bWJlcihjKXx8MDtkPXZvaWQgMCE9PWQ/TnVtYmVyKGQpOmQ9dGhpcy5sZW5ndGg7aWYoZD09PWMpcmV0dXJuXFxcIlxcXCI7c3dpdGNoKGEpe2Nhc2UgXFxcImhleFxcXCI6YT10aGlzLmxlbmd0aDtpZighY3x8MD5jKWM9MDtpZighZHx8MD5kfHxkPmEpZD1hO2ZvcihhPVxcXCJcXFwiO2M8ZDtjKyspYSs9Ryh0aGlzW2NdKTtkPWE7YnJlYWs7Y2FzZSBcXFwidXRmOFxcXCI6Y2FzZSBcXFwidXRmLThcXFwiOnZhciBiPWE9XFxcIlxcXCI7Zm9yKGQ9TWF0aC5taW4odGhpcy5sZW5ndGgsZCk7YzxkO2MrKykxMjc+PXRoaXNbY10/KGErPUQoYikrU3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzW2NdKSxcXG5iPVxcXCJcXFwiKTpiKz1cXFwiJVxcXCIrdGhpc1tjXS50b1N0cmluZygxNik7ZD1hK0QoYik7YnJlYWs7Y2FzZSBcXFwiYXNjaWlcXFwiOmQ9cih0aGlzLGMsZCk7YnJlYWs7Y2FzZSBcXFwiYmluYXJ5XFxcIjpkPXIodGhpcyxjLGQpO2JyZWFrO2Nhc2UgXFxcImJhc2U2NFxcXCI6ZD0wPT09YyYmZD09PXRoaXMubGVuZ3RoP0ouZnJvbUJ5dGVBcnJheSh0aGlzKTpKLmZyb21CeXRlQXJyYXkodGhpcy5zbGljZShjLGQpKTticmVhaztjYXNlIFxcXCJ1Y3MyXFxcIjpjYXNlIFxcXCJ1Y3MtMlxcXCI6Y2FzZSBcXFwidXRmMTZsZVxcXCI6Y2FzZSBcXFwidXRmLTE2bGVcXFwiOmQ9dGhpcy5zbGljZShjLGQpO2M9XFxcIlxcXCI7Zm9yKGE9MDthPGQubGVuZ3RoO2ErPTIpYys9U3RyaW5nLmZyb21DaGFyQ29kZShkW2FdKzI1NipkW2ErMV0pO2Q9YzticmVhaztkZWZhdWx0OnRocm93IEVycm9yKFxcXCJVbmtub3duIGVuY29kaW5nXFxcIik7fXJldHVybiBkfTtlLnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpcXFwiQnVmZmVyXFxcIixkYXRhOkFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2Fycnx8XFxudGhpcywwKX19O2UucHJvdG90eXBlLmNvcHk9ZnVuY3Rpb24oYSxjLGQsYil7ZHx8KGQ9MCk7Ynx8MD09PWJ8fChiPXRoaXMubGVuZ3RoKTtjfHwoYz0wKTtpZihiIT09ZCYmMCE9PWEubGVuZ3RoJiYwIT09dGhpcy5sZW5ndGgpaWYocChiPj1kLFxcXCJzb3VyY2VFbmQgPCBzb3VyY2VTdGFydFxcXCIpLHAoMDw9YyYmYzxhLmxlbmd0aCxcXFwidGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kc1xcXCIpLHAoMDw9ZCYmZDx0aGlzLmxlbmd0aCxcXFwic291cmNlU3RhcnQgb3V0IG9mIGJvdW5kc1xcXCIpLHAoMDw9YiYmYjw9dGhpcy5sZW5ndGgsXFxcInNvdXJjZUVuZCBvdXQgb2YgYm91bmRzXFxcIiksYj50aGlzLmxlbmd0aCYmKGI9dGhpcy5sZW5ndGgpLGEubGVuZ3RoLWM8Yi1kJiYoYj1hLmxlbmd0aC1jK2QpLGItPWQsMTAwPmJ8fCFlLl91c2VUeXBlZEFycmF5cylmb3IodmFyIGY9MDtmPGI7ZisrKWFbZitjXT10aGlzW2YrZF07ZWxzZSBhLl9zZXQodGhpcy5zdWJhcnJheShkLGQrYiksYyl9O2UucHJvdG90eXBlLnNsaWNlPVxcbmZ1bmN0aW9uKGEsYyl7dmFyIGQ9dGhpcy5sZW5ndGg7YT1CKGEsZCwwKTtjPUIoYyxkLGQpO2lmKGUuX3VzZVR5cGVkQXJyYXlzKXJldHVybiBlLl9hdWdtZW50KHRoaXMuc3ViYXJyYXkoYSxjKSk7Zm9yKHZhciBkPWMtYSxiPW5ldyBlKGQsdm9pZCAwLCEwKSxmPTA7ZjxkO2YrKyliW2ZdPXRoaXNbZithXTtyZXR1cm4gYn07ZS5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKGEpe2NvbnNvbGUubG9nKFxcXCIuZ2V0KCkgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHVzaW5nIGFycmF5IGluZGV4ZXMgaW5zdGVhZC5cXFwiKTtyZXR1cm4gdGhpcy5yZWFkVUludDgoYSl9O2UucHJvdG90eXBlLnNldD1mdW5jdGlvbihhLGMpe2NvbnNvbGUubG9nKFxcXCIuc2V0KCkgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHVzaW5nIGFycmF5IGluZGV4ZXMgaW5zdGVhZC5cXFwiKTtyZXR1cm4gdGhpcy53cml0ZVVJbnQ4KGEsYyl9O2UucHJvdG90eXBlLnJlYWRVSW50OD1mdW5jdGlvbihhLGMpe2N8fChwKHZvaWQgMCE9PWEmJm51bGwhPT1cXG5hLFxcXCJtaXNzaW5nIG9mZnNldFxcXCIpLHAoYTx0aGlzLmxlbmd0aCxcXFwiVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGhcXFwiKSk7aWYoIShhPj10aGlzLmxlbmd0aCkpcmV0dXJuIHRoaXNbYV19O2UucHJvdG90eXBlLnJlYWRVSW50MTZMRT1mdW5jdGlvbihhLGMpe3JldHVybiBsKHRoaXMsYSwhMCxjKX07ZS5wcm90b3R5cGUucmVhZFVJbnQxNkJFPWZ1bmN0aW9uKGEsYyl7cmV0dXJuIGwodGhpcyxhLCExLGMpfTtlLnByb3RvdHlwZS5yZWFkVUludDMyTEU9ZnVuY3Rpb24oYSxjKXtyZXR1cm4gbSh0aGlzLGEsITAsYyl9O2UucHJvdG90eXBlLnJlYWRVSW50MzJCRT1mdW5jdGlvbihhLGMpe3JldHVybiBtKHRoaXMsYSwhMSxjKX07ZS5wcm90b3R5cGUucmVhZEludDg9ZnVuY3Rpb24oYSxjKXtjfHwocCh2b2lkIDAhPT1hJiZudWxsIT09YSxcXFwibWlzc2luZyBvZmZzZXRcXFwiKSxwKGE8dGhpcy5sZW5ndGgsXFxcIlRyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoXFxcIikpO2lmKCEoYT49XFxudGhpcy5sZW5ndGgpKXJldHVybiB0aGlzW2FdJjEyOD8tMSooMjU1LXRoaXNbYV0rMSk6dGhpc1thXX07ZS5wcm90b3R5cGUucmVhZEludDE2TEU9ZnVuY3Rpb24oYSxjKXtyZXR1cm4gZyh0aGlzLGEsITAsYyl9O2UucHJvdG90eXBlLnJlYWRJbnQxNkJFPWZ1bmN0aW9uKGEsYyl7cmV0dXJuIGcodGhpcyxhLCExLGMpfTtlLnByb3RvdHlwZS5yZWFkSW50MzJMRT1mdW5jdGlvbihhLGMpe3JldHVybiBiKHRoaXMsYSwhMCxjKX07ZS5wcm90b3R5cGUucmVhZEludDMyQkU9ZnVuY3Rpb24oYSxjKXtyZXR1cm4gYih0aGlzLGEsITEsYyl9O2UucHJvdG90eXBlLnJlYWRGbG9hdExFPWZ1bmN0aW9uKGEsYyl7cmV0dXJuIGYodGhpcyxhLCEwLGMpfTtlLnByb3RvdHlwZS5yZWFkRmxvYXRCRT1mdW5jdGlvbihhLGMpe3JldHVybiBmKHRoaXMsYSwhMSxjKX07ZS5wcm90b3R5cGUucmVhZERvdWJsZUxFPWZ1bmN0aW9uKGEsYyl7cmV0dXJuIGsodGhpcyxhLCEwLGMpfTtlLnByb3RvdHlwZS5yZWFkRG91YmxlQkU9XFxuZnVuY3Rpb24oYSxjKXtyZXR1cm4gayh0aGlzLGEsITEsYyl9O2UucHJvdG90eXBlLndyaXRlVUludDg9ZnVuY3Rpb24oYSxjLGQpe2R8fChwKHZvaWQgMCE9PWEmJm51bGwhPT1hLFxcXCJtaXNzaW5nIHZhbHVlXFxcIikscCh2b2lkIDAhPT1jJiZudWxsIT09YyxcXFwibWlzc2luZyBvZmZzZXRcXFwiKSxwKGM8dGhpcy5sZW5ndGgsXFxcInRyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aFxcXCIpLEgoYSwyNTUpKTtjPj10aGlzLmxlbmd0aHx8KHRoaXNbY109YSl9O2UucHJvdG90eXBlLndyaXRlVUludDE2TEU9ZnVuY3Rpb24oYyxkLGIpe2EodGhpcyxjLGQsITAsYil9O2UucHJvdG90eXBlLndyaXRlVUludDE2QkU9ZnVuY3Rpb24oYyxkLGIpe2EodGhpcyxjLGQsITEsYil9O2UucHJvdG90eXBlLndyaXRlVUludDMyTEU9ZnVuY3Rpb24oYSxkLGIpe2ModGhpcyxhLGQsITAsYil9O2UucHJvdG90eXBlLndyaXRlVUludDMyQkU9ZnVuY3Rpb24oYSxkLGIpe2ModGhpcyxhLGQsITEsYil9O2UucHJvdG90eXBlLndyaXRlSW50OD1cXG5mdW5jdGlvbihhLGMsZCl7ZHx8KHAodm9pZCAwIT09YSYmbnVsbCE9PWEsXFxcIm1pc3NpbmcgdmFsdWVcXFwiKSxwKHZvaWQgMCE9PWMmJm51bGwhPT1jLFxcXCJtaXNzaW5nIG9mZnNldFxcXCIpLHAoYzx0aGlzLmxlbmd0aCxcXFwiVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoXFxcIiksTChhLDEyNywtMTI4KSk7Yz49dGhpcy5sZW5ndGh8fCgwPD1hP3RoaXMud3JpdGVVSW50OChhLGMsZCk6dGhpcy53cml0ZVVJbnQ4KDI1NSthKzEsYyxkKSl9O2UucHJvdG90eXBlLndyaXRlSW50MTZMRT1mdW5jdGlvbihhLGMsYil7ZCh0aGlzLGEsYywhMCxiKX07ZS5wcm90b3R5cGUud3JpdGVJbnQxNkJFPWZ1bmN0aW9uKGEsYyxiKXtkKHRoaXMsYSxjLCExLGIpfTtlLnByb3RvdHlwZS53cml0ZUludDMyTEU9ZnVuY3Rpb24oYSxjLGQpe3kodGhpcyxhLGMsITAsZCl9O2UucHJvdG90eXBlLndyaXRlSW50MzJCRT1mdW5jdGlvbihhLGMsZCl7eSh0aGlzLGEsYywhMSxkKX07ZS5wcm90b3R5cGUud3JpdGVGbG9hdExFPVxcbmZ1bmN0aW9uKGEsYyxkKXt4KHRoaXMsYSxjLCEwLGQpfTtlLnByb3RvdHlwZS53cml0ZUZsb2F0QkU9ZnVuY3Rpb24oYSxjLGQpe3godGhpcyxhLGMsITEsZCl9O2UucHJvdG90eXBlLndyaXRlRG91YmxlTEU9ZnVuY3Rpb24oYSxjLGQpe0EodGhpcyxhLGMsITAsZCl9O2UucHJvdG90eXBlLndyaXRlRG91YmxlQkU9ZnVuY3Rpb24oYSxjLGQpe0EodGhpcyxhLGMsITEsZCl9O2UucHJvdG90eXBlLmZpbGw9ZnVuY3Rpb24oYSxjLGQpe2F8fChhPTApO2N8fChjPTApO2R8fChkPXRoaXMubGVuZ3RoKTtcXFwic3RyaW5nXFxcIj09PXR5cGVvZiBhJiYoYT1hLmNoYXJDb2RlQXQoMCkpO3AoXFxcIm51bWJlclxcXCI9PT10eXBlb2YgYSYmIWlzTmFOKGEpLFxcXCJ2YWx1ZSBpcyBub3QgYSBudW1iZXJcXFwiKTtwKGQ+PWMsXFxcImVuZCA8IHN0YXJ0XFxcIik7aWYoZCE9PWMmJjAhPT10aGlzLmxlbmd0aClmb3IocCgwPD1jJiZjPHRoaXMubGVuZ3RoLFxcXCJzdGFydCBvdXQgb2YgYm91bmRzXFxcIikscCgwPD1kJiZkPD10aGlzLmxlbmd0aCxcXG5cXFwiZW5kIG91dCBvZiBib3VuZHNcXFwiKTtjPGQ7YysrKXRoaXNbY109YX07ZS5wcm90b3R5cGUuaW5zcGVjdD1mdW5jdGlvbigpe2Zvcih2YXIgYT1bXSxjPXRoaXMubGVuZ3RoLGQ9MDtkPGM7ZCsrKWlmKGFbZF09Ryh0aGlzW2RdKSxkPT09dC5JTlNQRUNUX01BWF9CWVRFUyl7YVtkKzFdPVxcXCIuLi5cXFwiO2JyZWFrfXJldHVyblxcXCI8QnVmZmVyIFxcXCIrYS5qb2luKFxcXCIgXFxcIikrXFxcIj5cXFwifTtlLnByb3RvdHlwZS50b0FycmF5QnVmZmVyPWZ1bmN0aW9uKCl7aWYoXFxcInVuZGVmaW5lZFxcXCIhPT10eXBlb2YgVWludDhBcnJheSl7aWYoZS5fdXNlVHlwZWRBcnJheXMpcmV0dXJuKG5ldyBlKHRoaXMpKS5idWZmZXI7Zm9yKHZhciBhPW5ldyBVaW50OEFycmF5KHRoaXMubGVuZ3RoKSxjPTAsZD1hLmxlbmd0aDtjPGQ7Yys9MSlhW2NdPXRoaXNbY107cmV0dXJuIGEuYnVmZmVyfXRocm93IEVycm9yKFxcXCJCdWZmZXIudG9BcnJheUJ1ZmZlciBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlclxcXCIpO307dmFyIHY9ZS5wcm90b3R5cGU7XFxuZS5fYXVnbWVudD1mdW5jdGlvbihhKXthLl9pc0J1ZmZlcj0hMDthLl9nZXQ9YS5nZXQ7YS5fc2V0PWEuc2V0O2EuZ2V0PXYuZ2V0O2Euc2V0PXYuc2V0O2Eud3JpdGU9di53cml0ZTthLnRvU3RyaW5nPXYudG9TdHJpbmc7YS50b0xvY2FsZVN0cmluZz12LnRvU3RyaW5nO2EudG9KU09OPXYudG9KU09OO2EuY29weT12LmNvcHk7YS5zbGljZT12LnNsaWNlO2EucmVhZFVJbnQ4PXYucmVhZFVJbnQ4O2EucmVhZFVJbnQxNkxFPXYucmVhZFVJbnQxNkxFO2EucmVhZFVJbnQxNkJFPXYucmVhZFVJbnQxNkJFO2EucmVhZFVJbnQzMkxFPXYucmVhZFVJbnQzMkxFO2EucmVhZFVJbnQzMkJFPXYucmVhZFVJbnQzMkJFO2EucmVhZEludDg9di5yZWFkSW50ODthLnJlYWRJbnQxNkxFPXYucmVhZEludDE2TEU7YS5yZWFkSW50MTZCRT12LnJlYWRJbnQxNkJFO2EucmVhZEludDMyTEU9di5yZWFkSW50MzJMRTthLnJlYWRJbnQzMkJFPXYucmVhZEludDMyQkU7YS5yZWFkRmxvYXRMRT12LnJlYWRGbG9hdExFO1xcbmEucmVhZEZsb2F0QkU9di5yZWFkRmxvYXRCRTthLnJlYWREb3VibGVMRT12LnJlYWREb3VibGVMRTthLnJlYWREb3VibGVCRT12LnJlYWREb3VibGVCRTthLndyaXRlVUludDg9di53cml0ZVVJbnQ4O2Eud3JpdGVVSW50MTZMRT12LndyaXRlVUludDE2TEU7YS53cml0ZVVJbnQxNkJFPXYud3JpdGVVSW50MTZCRTthLndyaXRlVUludDMyTEU9di53cml0ZVVJbnQzMkxFO2Eud3JpdGVVSW50MzJCRT12LndyaXRlVUludDMyQkU7YS53cml0ZUludDg9di53cml0ZUludDg7YS53cml0ZUludDE2TEU9di53cml0ZUludDE2TEU7YS53cml0ZUludDE2QkU9di53cml0ZUludDE2QkU7YS53cml0ZUludDMyTEU9di53cml0ZUludDMyTEU7YS53cml0ZUludDMyQkU9di53cml0ZUludDMyQkU7YS53cml0ZUZsb2F0TEU9di53cml0ZUZsb2F0TEU7YS53cml0ZUZsb2F0QkU9di53cml0ZUZsb2F0QkU7YS53cml0ZURvdWJsZUxFPXYud3JpdGVEb3VibGVMRTthLndyaXRlRG91YmxlQkU9di53cml0ZURvdWJsZUJFO1xcbmEuZmlsbD12LmZpbGw7YS5pbnNwZWN0PXYuaW5zcGVjdDthLnRvQXJyYXlCdWZmZXI9di50b0FycmF5QnVmZmVyO3JldHVybiBhfX0se1xcXCJiYXNlNjQtanNcXFwiOjMsaWVlZTc1NDo2fV0sNjpbZnVuY3Rpb24obix3LHQpe3QucmVhZD1mdW5jdGlvbihlLHIsbCxtLGcpe3ZhciBiO2I9OCpnLW0tMTt2YXIgZj0oMTw8YiktMSxrPWY+PjEsYT0tNztnPWw/Zy0xOjA7dmFyIGM9bD8tMToxLGQ9ZVtyK2ddO2crPWM7bD1kJigxPDwtYSktMTtkPj49LWE7Zm9yKGErPWI7MDxhO2w9MjU2KmwrZVtyK2ddLGcrPWMsYS09OCk7Yj1sJigxPDwtYSktMTtsPj49LWE7Zm9yKGErPW07MDxhO2I9MjU2KmIrZVtyK2ddLGcrPWMsYS09OCk7aWYoMD09PWwpbD0xLWs7ZWxzZXtpZihsPT09ZilyZXR1cm4gYj9OYU46SW5maW5pdHkqKGQ/LTE6MSk7Yis9TWF0aC5wb3coMixtKTtsLT1rfXJldHVybihkPy0xOjEpKmIqTWF0aC5wb3coMixsLW0pfTt0LndyaXRlPWZ1bmN0aW9uKGUscixsLG0sZyxiKXt2YXIgZixcXG5rPTgqYi1nLTEsYT0oMTw8ayktMSxjPWE+PjEsZD0yMz09PWc/TWF0aC5wb3coMiwtMjQpLU1hdGgucG93KDIsLTc3KTowO2I9bT8wOmItMTt2YXIgeT1tPzE6LTEseD0wPnJ8fDA9PT1yJiYwPjEvcj8xOjA7cj1NYXRoLmFicyhyKTtpc05hTihyKXx8SW5maW5pdHk9PT1yPyhyPWlzTmFOKHIpPzE6MCxtPWEpOihtPU1hdGguZmxvb3IoTWF0aC5sb2cocikvTWF0aC5MTjIpLDE+ciooZj1NYXRoLnBvdygyLC1tKSkmJihtLS0sZio9Mikscj0xPD1tK2M/citkL2Y6citkKk1hdGgucG93KDIsMS1jKSwyPD1yKmYmJihtKyssZi89MiksbStjPj1hPyhyPTAsbT1hKToxPD1tK2M/KHI9KHIqZi0xKSpNYXRoLnBvdygyLGcpLG0rPWMpOihyPXIqTWF0aC5wb3coMixjLTEpKk1hdGgucG93KDIsZyksbT0wKSk7Zm9yKDs4PD1nO2VbbCtiXT1yJjI1NSxiKz15LHIvPTI1NixnLT04KTttPW08PGd8cjtmb3Ioays9ZzswPGs7ZVtsK2JdPW0mMjU1LGIrPXksbS89MjU2LGstPTgpO2VbbCtiLXldfD1cXG4xMjgqeH19LHt9XSw3OltmdW5jdGlvbihuLHcsdCl7KGZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHIoYixmKXtmb3IodmFyIGU9MCxhPWIubGVuZ3RoLTE7MDw9YTthLS0pe3ZhciBjPWJbYV07XFxcIi5cXFwiPT09Yz9iLnNwbGljZShhLDEpOlxcXCIuLlxcXCI9PT1jPyhiLnNwbGljZShhLDEpLGUrKyk6ZSYmKGIuc3BsaWNlKGEsMSksZS0tKX1pZihmKWZvcig7ZS0tO2UpYi51bnNoaWZ0KFxcXCIuLlxcXCIpO3JldHVybiBifWZ1bmN0aW9uIGwoYixmKXtpZihiLmZpbHRlcilyZXR1cm4gYi5maWx0ZXIoZik7Zm9yKHZhciBlPVtdLGE9MDthPGIubGVuZ3RoO2ErKylmKGJbYV0sYSxiKSYmZS5wdXNoKGJbYV0pO3JldHVybiBlfXZhciBtPS9eKFxcXFwvP3wpKFtcXFxcc1xcXFxTXSo/KSgoPzpcXFxcLnsxLDJ9fFteXFxcXC9dKz98KShcXFxcLlteLlxcXFwvXSp8KSkoPzpbXFxcXC9dKikkLzt0LnJlc29sdmU9ZnVuY3Rpb24oKXtmb3IodmFyIGI9XFxcIlxcXCIsZj0hMSxrPWFyZ3VtZW50cy5sZW5ndGgtMTstMTw9ayYmIWY7ay0tKXt2YXIgYT0wPD1rP2FyZ3VtZW50c1trXTpcXG5lLmN3ZCgpO2lmKFxcXCJzdHJpbmdcXFwiIT09dHlwZW9mIGEpdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3NcXFwiKTthJiYoYj1hK1xcXCIvXFxcIitiLGY9XFxcIi9cXFwiPT09YS5jaGFyQXQoMCkpfWI9cihsKGIuc3BsaXQoXFxcIi9cXFwiKSxmdW5jdGlvbihhKXtyZXR1cm4hIWF9KSwhZikuam9pbihcXFwiL1xcXCIpO3JldHVybihmP1xcXCIvXFxcIjpcXFwiXFxcIikrYnx8XFxcIi5cXFwifTt0Lm5vcm1hbGl6ZT1mdW5jdGlvbihiKXt2YXIgZj10LmlzQWJzb2x1dGUoYiksZT1cXFwiL1xcXCI9PT1nKGIsLTEpOyhiPXIobChiLnNwbGl0KFxcXCIvXFxcIiksZnVuY3Rpb24oYSl7cmV0dXJuISFhfSksIWYpLmpvaW4oXFxcIi9cXFwiKSl8fGZ8fChiPVxcXCIuXFxcIik7YiYmZSYmKGIrPVxcXCIvXFxcIik7cmV0dXJuKGY/XFxcIi9cXFwiOlxcXCJcXFwiKStifTt0LmlzQWJzb2x1dGU9ZnVuY3Rpb24oYil7cmV0dXJuXFxcIi9cXFwiPT09Yi5jaGFyQXQoMCl9O3Quam9pbj1mdW5jdGlvbigpe3ZhciBiPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywwKTtyZXR1cm4gdC5ub3JtYWxpemUobChiLFxcbmZ1bmN0aW9uKGIsZSl7aWYoXFxcInN0cmluZ1xcXCIhPT10eXBlb2YgYil0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJBcmd1bWVudHMgdG8gcGF0aC5qb2luIG11c3QgYmUgc3RyaW5nc1xcXCIpO3JldHVybiBifSkuam9pbihcXFwiL1xcXCIpKX07dC5yZWxhdGl2ZT1mdW5jdGlvbihiLGYpe2Z1bmN0aW9uIGUoYSl7Zm9yKHZhciBjPTA7YzxhLmxlbmd0aCYmXFxcIlxcXCI9PT1hW2NdO2MrKyk7Zm9yKHZhciBkPWEubGVuZ3RoLTE7MDw9ZCYmXFxcIlxcXCI9PT1hW2RdO2QtLSk7cmV0dXJuIGM+ZD9bXTphLnNsaWNlKGMsZC1jKzEpfWI9dC5yZXNvbHZlKGIpLnN1YnN0cigxKTtmPXQucmVzb2x2ZShmKS5zdWJzdHIoMSk7Zm9yKHZhciBhPWUoYi5zcGxpdChcXFwiL1xcXCIpKSxjPWUoZi5zcGxpdChcXFwiL1xcXCIpKSxkPU1hdGgubWluKGEubGVuZ3RoLGMubGVuZ3RoKSxnPWQseD0wO3g8ZDt4KyspaWYoYVt4XSE9PWNbeF0pe2c9eDticmVha31kPVtdO2Zvcih4PWc7eDxhLmxlbmd0aDt4KyspZC5wdXNoKFxcXCIuLlxcXCIpO2Q9ZC5jb25jYXQoYy5zbGljZShnKSk7XFxucmV0dXJuIGQuam9pbihcXFwiL1xcXCIpfTt0LnNlcD1cXFwiL1xcXCI7dC5kZWxpbWl0ZXI9XFxcIjpcXFwiO3QuZGlybmFtZT1mdW5jdGlvbihiKXt2YXIgZj1tLmV4ZWMoYikuc2xpY2UoMSk7Yj1mWzBdO2Y9ZlsxXTtpZighYiYmIWYpcmV0dXJuXFxcIi5cXFwiO2YmJihmPWYuc3Vic3RyKDAsZi5sZW5ndGgtMSkpO3JldHVybiBiK2Z9O3QuYmFzZW5hbWU9ZnVuY3Rpb24oYixmKXt2YXIgZT1tLmV4ZWMoYikuc2xpY2UoMSlbMl07ZiYmZS5zdWJzdHIoLTEqZi5sZW5ndGgpPT09ZiYmKGU9ZS5zdWJzdHIoMCxlLmxlbmd0aC1mLmxlbmd0aCkpO3JldHVybiBlfTt0LmV4dG5hbWU9ZnVuY3Rpb24oYil7cmV0dXJuIG0uZXhlYyhiKS5zbGljZSgxKVszXX07dmFyIGc9XFxcImJcXFwiPT09XFxcImFiXFxcIi5zdWJzdHIoLTEpP2Z1bmN0aW9uKGIsZixlKXtyZXR1cm4gYi5zdWJzdHIoZixlKX06ZnVuY3Rpb24oYixmLGUpezA+ZiYmKGY9Yi5sZW5ndGgrZik7cmV0dXJuIGIuc3Vic3RyKGYsZSl9fSkuY2FsbCh0aGlzLG4oXFxcIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanNcXFwiKSl9LFxcbntcXFwibm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1xcXCI6OH1dLDg6W2Z1bmN0aW9uKG4sdyx0KXtmdW5jdGlvbiBlKCl7fW49dy5leHBvcnRzPXt9O24ubmV4dFRpY2s9ZnVuY3Rpb24oKXtpZihcXFwidW5kZWZpbmVkXFxcIiE9PXR5cGVvZiB3aW5kb3cmJndpbmRvdy5zZXRJbW1lZGlhdGUpcmV0dXJuIGZ1bmN0aW9uKGUpe3JldHVybiB3aW5kb3cuc2V0SW1tZWRpYXRlKGUpfTtpZihcXFwidW5kZWZpbmVkXFxcIiE9PXR5cGVvZiB3aW5kb3cmJndpbmRvdy5wb3N0TWVzc2FnZSYmd2luZG93LmFkZEV2ZW50TGlzdGVuZXIpe3ZhciBlPVtdO3dpbmRvdy5hZGRFdmVudExpc3RlbmVyKFxcXCJtZXNzYWdlXFxcIixmdW5jdGlvbihsKXt2YXIgbT1sLnNvdXJjZTttIT09d2luZG93JiZudWxsIT09bXx8XFxcInByb2Nlc3MtdGlja1xcXCIhPT1sLmRhdGF8fChsLnN0b3BQcm9wYWdhdGlvbigpLDA8ZS5sZW5ndGgmJmUuc2hpZnQoKSgpKX0sITApO3JldHVybiBmdW5jdGlvbihsKXtlLnB1c2gobCk7d2luZG93LnBvc3RNZXNzYWdlKFxcXCJwcm9jZXNzLXRpY2tcXFwiLFxcblxcXCIqXFxcIil9fXJldHVybiBmdW5jdGlvbihlKXtzZXRUaW1lb3V0KGUsMCl9fSgpO24udGl0bGU9XFxcImJyb3dzZXJcXFwiO24uYnJvd3Nlcj0hMDtuLmVudj17fTtuLmFyZ3Y9W107bi5vbj1lO24ub25jZT1lO24ub2ZmPWU7bi5lbWl0PWU7bi5iaW5kaW5nPWZ1bmN0aW9uKGUpe3Rocm93IEVycm9yKFxcXCJwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZFxcXCIpO307bi5jd2Q9ZnVuY3Rpb24oKXtyZXR1cm5cXFwiL1xcXCJ9O24uY2hkaXI9ZnVuY3Rpb24oZSl7dGhyb3cgRXJyb3IoXFxcInByb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZFxcXCIpO319LHt9XSw5OltmdW5jdGlvbihuLHcsdCl7dC5Tb3VyY2VNYXBHZW5lcmF0b3I9bihcXFwiLi9zb3VyY2UtbWFwL3NvdXJjZS1tYXAtZ2VuZXJhdG9yXFxcIikuU291cmNlTWFwR2VuZXJhdG9yO3QuU291cmNlTWFwQ29uc3VtZXI9bihcXFwiLi9zb3VyY2UtbWFwL3NvdXJjZS1tYXAtY29uc3VtZXJcXFwiKS5Tb3VyY2VNYXBDb25zdW1lcjt0LlNvdXJjZU5vZGU9bihcXFwiLi9zb3VyY2UtbWFwL3NvdXJjZS1ub2RlXFxcIikuU291cmNlTm9kZX0sXFxue1xcXCIuL3NvdXJjZS1tYXAvc291cmNlLW1hcC1jb25zdW1lclxcXCI6MTQsXFxcIi4vc291cmNlLW1hcC9zb3VyY2UtbWFwLWdlbmVyYXRvclxcXCI6MTUsXFxcIi4vc291cmNlLW1hcC9zb3VyY2Utbm9kZVxcXCI6MTZ9XSwxMDpbZnVuY3Rpb24obix3LHQpe2lmKFxcXCJmdW5jdGlvblxcXCIhPT10eXBlb2YgZSl2YXIgZT1uKFxcXCJhbWRlZmluZVxcXCIpKHcsbik7ZShmdW5jdGlvbihlLGwsbSl7ZnVuY3Rpb24gZygpe3RoaXMuX2FycmF5PVtdO3RoaXMuX3NldD17fX12YXIgYj1lKFxcXCIuL3V0aWxcXFwiKTtnLmZyb21BcnJheT1mdW5jdGlvbihiLGUpe2Zvcih2YXIgYT1uZXcgZyxjPTAsZD1iLmxlbmd0aDtjPGQ7YysrKWEuYWRkKGJbY10sZSk7cmV0dXJuIGF9O2cucHJvdG90eXBlLmFkZD1mdW5jdGlvbihmLGUpe3ZhciBhPXRoaXMuaGFzKGYpLGM9dGhpcy5fYXJyYXkubGVuZ3RoO2EmJiFlfHx0aGlzLl9hcnJheS5wdXNoKGYpO2F8fCh0aGlzLl9zZXRbYi50b1NldFN0cmluZyhmKV09Yyl9O2cucHJvdG90eXBlLmhhcz1mdW5jdGlvbihmKXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuX3NldCxcXG5iLnRvU2V0U3RyaW5nKGYpKX07Zy5wcm90b3R5cGUuaW5kZXhPZj1mdW5jdGlvbihmKXtpZih0aGlzLmhhcyhmKSlyZXR1cm4gdGhpcy5fc2V0W2IudG9TZXRTdHJpbmcoZildO3Rocm93IEVycm9yKCdcXFwiJytmKydcXFwiIGlzIG5vdCBpbiB0aGUgc2V0LicpO307Zy5wcm90b3R5cGUuYXQ9ZnVuY3Rpb24oYil7aWYoMDw9YiYmYjx0aGlzLl9hcnJheS5sZW5ndGgpcmV0dXJuIHRoaXMuX2FycmF5W2JdO3Rocm93IEVycm9yKFxcXCJObyBlbGVtZW50IGluZGV4ZWQgYnkgXFxcIitiKTt9O2cucHJvdG90eXBlLnRvQXJyYXk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fYXJyYXkuc2xpY2UoKX07bC5BcnJheVNldD1nfSl9LHtcXFwiLi91dGlsXFxcIjoxNyxhbWRlZmluZToyfV0sMTE6W2Z1bmN0aW9uKG4sdyx0KXtpZihcXFwiZnVuY3Rpb25cXFwiIT09dHlwZW9mIGUpdmFyIGU9bihcXFwiYW1kZWZpbmVcXFwiKSh3LG4pO2UoZnVuY3Rpb24oZSxsLG0pe3ZhciBnPWUoXFxcIi4vYmFzZTY0XFxcIik7bC5lbmNvZGU9ZnVuY3Rpb24oYil7dmFyIGU9XFxuXFxcIlxcXCIsaz0wPmI/KC1iPDwxKSsxOihiPDwxKSswO2RvIGI9ayYzMSxrPj4+PTUsMDxrJiYoYnw9MzIpLGUrPWcuZW5jb2RlKGIpO3doaWxlKDA8ayk7cmV0dXJuIGV9O2wuZGVjb2RlPWZ1bmN0aW9uKGIpe3ZhciBlPTAsaz1iLmxlbmd0aCxhPTAsYz0wLGQseTtkb3tpZihlPj1rKXRocm93IEVycm9yKFxcXCJFeHBlY3RlZCBtb3JlIGRpZ2l0cyBpbiBiYXNlIDY0IFZMUSB2YWx1ZS5cXFwiKTt5PWcuZGVjb2RlKGIuY2hhckF0KGUrKykpO2Q9ISEoeSYzMik7eSY9MzE7YSs9eTw8YztjKz01fXdoaWxlKGQpO2s9YT4+MTtyZXR1cm57dmFsdWU6MT09PShhJjEpPy1rOmsscmVzdDpiLnNsaWNlKGUpfX19KX0se1xcXCIuL2Jhc2U2NFxcXCI6MTIsYW1kZWZpbmU6Mn1dLDEyOltmdW5jdGlvbihuLHcsdCl7aWYoXFxcImZ1bmN0aW9uXFxcIiE9PXR5cGVvZiBlKXZhciBlPW4oXFxcImFtZGVmaW5lXFxcIikodyxuKTtlKGZ1bmN0aW9uKGUsbCxtKXt2YXIgZz17fSxiPXt9O1xcXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXFxcIi5zcGxpdChcXFwiXFxcIikuZm9yRWFjaChmdW5jdGlvbihlLFxcbmspe2dbZV09aztiW2tdPWV9KTtsLmVuY29kZT1mdW5jdGlvbihlKXtpZihlIGluIGIpcmV0dXJuIGJbZV07dGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiTXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDYzOiBcXFwiK2UpO307bC5kZWNvZGU9ZnVuY3Rpb24oYil7aWYoYiBpbiBnKXJldHVybiBnW2JdO3Rocm93IG5ldyBUeXBlRXJyb3IoXFxcIk5vdCBhIHZhbGlkIGJhc2UgNjQgZGlnaXQ6IFxcXCIrYik7fX0pfSx7YW1kZWZpbmU6Mn1dLDEzOltmdW5jdGlvbihuLHcsdCl7aWYoXFxcImZ1bmN0aW9uXFxcIiE9PXR5cGVvZiBlKXZhciBlPW4oXFxcImFtZGVmaW5lXFxcIikodyxuKTtlKGZ1bmN0aW9uKGUsbCxtKXtmdW5jdGlvbiBnKGIsZSxrLGEsYyl7dmFyIGQ9TWF0aC5mbG9vcigoZS1iKS8yKStiLHk9YyhrLGFbZF0sITApO3JldHVybiAwPT09eT9hW2RdOjA8eT8xPGUtZD9nKGQsZSxrLGEsYyk6YVtkXToxPGQtYj9nKGIsZCxrLGEsYyk6MD5iP251bGw6YVtiXX1sLnNlYXJjaD1mdW5jdGlvbihiLGUsayl7cmV0dXJuIDA8ZS5sZW5ndGg/XFxuZygtMSxlLmxlbmd0aCxiLGUsayk6bnVsbH19KX0se2FtZGVmaW5lOjJ9XSwxNDpbZnVuY3Rpb24obix3LHQpe2lmKFxcXCJmdW5jdGlvblxcXCIhPT10eXBlb2YgZSl2YXIgZT1uKFxcXCJhbWRlZmluZVxcXCIpKHcsbik7ZShmdW5jdGlvbihlLGwsbSl7ZnVuY3Rpb24gZyhhKXt2YXIgZD1hO1xcXCJzdHJpbmdcXFwiPT09dHlwZW9mIGEmJihkPUpTT04ucGFyc2UoYS5yZXBsYWNlKC9eXFxcXClcXFxcXVxcXFx9Jy8sXFxcIlxcXCIpKSk7YT1iLmdldEFyZyhkLFxcXCJ2ZXJzaW9uXFxcIik7dmFyIGU9Yi5nZXRBcmcoZCxcXFwic291cmNlc1xcXCIpLGY9Yi5nZXRBcmcoZCxcXFwibmFtZXNcXFwiLFtdKSxnPWIuZ2V0QXJnKGQsXFxcInNvdXJjZVJvb3RcXFwiLG51bGwpLGw9Yi5nZXRBcmcoZCxcXFwic291cmNlc0NvbnRlbnRcXFwiLG51bGwpLG09Yi5nZXRBcmcoZCxcXFwibWFwcGluZ3NcXFwiKSxkPWIuZ2V0QXJnKGQsXFxcImZpbGVcXFwiLG51bGwpO2lmKGEhPXRoaXMuX3ZlcnNpb24pdGhyb3cgRXJyb3IoXFxcIlVuc3VwcG9ydGVkIHZlcnNpb246IFxcXCIrYSk7dGhpcy5fbmFtZXM9ay5mcm9tQXJyYXkoZiwhMCk7XFxudGhpcy5fc291cmNlcz1rLmZyb21BcnJheShlLCEwKTt0aGlzLnNvdXJjZVJvb3Q9Zzt0aGlzLnNvdXJjZXNDb250ZW50PWw7dGhpcy5fbWFwcGluZ3M9bTt0aGlzLmZpbGU9ZH12YXIgYj1lKFxcXCIuL3V0aWxcXFwiKSxmPWUoXFxcIi4vYmluYXJ5LXNlYXJjaFxcXCIpLGs9ZShcXFwiLi9hcnJheS1zZXRcXFwiKS5BcnJheVNldCxhPWUoXFxcIi4vYmFzZTY0LXZscVxcXCIpO2cuZnJvbVNvdXJjZU1hcD1mdW5jdGlvbihhKXt2YXIgZD1PYmplY3QuY3JlYXRlKGcucHJvdG90eXBlKTtkLl9uYW1lcz1rLmZyb21BcnJheShhLl9uYW1lcy50b0FycmF5KCksITApO2QuX3NvdXJjZXM9ay5mcm9tQXJyYXkoYS5fc291cmNlcy50b0FycmF5KCksITApO2Quc291cmNlUm9vdD1hLl9zb3VyY2VSb290O2Quc291cmNlc0NvbnRlbnQ9YS5fZ2VuZXJhdGVTb3VyY2VzQ29udGVudChkLl9zb3VyY2VzLnRvQXJyYXkoKSxkLnNvdXJjZVJvb3QpO2QuZmlsZT1hLl9maWxlO2QuX19nZW5lcmF0ZWRNYXBwaW5ncz1hLl9tYXBwaW5ncy5zbGljZSgpLnNvcnQoYi5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnMpO1xcbmQuX19vcmlnaW5hbE1hcHBpbmdzPWEuX21hcHBpbmdzLnNsaWNlKCkuc29ydChiLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKTtyZXR1cm4gZH07Zy5wcm90b3R5cGUuX3ZlcnNpb249MztPYmplY3QuZGVmaW5lUHJvcGVydHkoZy5wcm90b3R5cGUsXFxcInNvdXJjZXNcXFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc291cmNlcy50b0FycmF5KCkubWFwKGZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLnNvdXJjZVJvb3Q/Yi5qb2luKHRoaXMuc291cmNlUm9vdCxhKTphfSx0aGlzKX19KTtnLnByb3RvdHlwZS5fX2dlbmVyYXRlZE1hcHBpbmdzPW51bGw7T2JqZWN0LmRlZmluZVByb3BlcnR5KGcucHJvdG90eXBlLFxcXCJfZ2VuZXJhdGVkTWFwcGluZ3NcXFwiLHtnZXQ6ZnVuY3Rpb24oKXt0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3N8fCh0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3M9W10sdGhpcy5fX29yaWdpbmFsTWFwcGluZ3M9W10sdGhpcy5fcGFyc2VNYXBwaW5ncyh0aGlzLl9tYXBwaW5ncyxcXG50aGlzLnNvdXJjZVJvb3QpKTtyZXR1cm4gdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzfX0pO2cucHJvdG90eXBlLl9fb3JpZ2luYWxNYXBwaW5ncz1udWxsO09iamVjdC5kZWZpbmVQcm9wZXJ0eShnLnByb3RvdHlwZSxcXFwiX29yaWdpbmFsTWFwcGluZ3NcXFwiLHtnZXQ6ZnVuY3Rpb24oKXt0aGlzLl9fb3JpZ2luYWxNYXBwaW5nc3x8KHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncz1bXSx0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncz1bXSx0aGlzLl9wYXJzZU1hcHBpbmdzKHRoaXMuX21hcHBpbmdzLHRoaXMuc291cmNlUm9vdCkpO3JldHVybiB0aGlzLl9fb3JpZ2luYWxNYXBwaW5nc319KTtnLnByb3RvdHlwZS5fcGFyc2VNYXBwaW5ncz1mdW5jdGlvbihjLGQpe2Zvcih2YXIgZT0xLGY9MCxnPTAsaz0wLGw9MCxtPTAscj0vXlssO10vLHU9YyxuOzA8dS5sZW5ndGg7KWlmKFxcXCI7XFxcIj09PXUuY2hhckF0KDApKWUrKyx1PXUuc2xpY2UoMSksZj0wO2Vsc2UgaWYoXFxcIixcXFwiPT09dS5jaGFyQXQoMCkpdT11LnNsaWNlKDEpO1xcbmVsc2V7bj17fTtuLmdlbmVyYXRlZExpbmU9ZTt1PWEuZGVjb2RlKHUpO24uZ2VuZXJhdGVkQ29sdW1uPWYrdS52YWx1ZTtmPW4uZ2VuZXJhdGVkQ29sdW1uO3U9dS5yZXN0O2lmKDA8dS5sZW5ndGgmJiFyLnRlc3QodS5jaGFyQXQoMCkpKXt1PWEuZGVjb2RlKHUpO24uc291cmNlPXRoaXMuX3NvdXJjZXMuYXQobCt1LnZhbHVlKTtsKz11LnZhbHVlO3U9dS5yZXN0O2lmKDA9PT11Lmxlbmd0aHx8ci50ZXN0KHUuY2hhckF0KDApKSl0aHJvdyBFcnJvcihcXFwiRm91bmQgYSBzb3VyY2UsIGJ1dCBubyBsaW5lIGFuZCBjb2x1bW5cXFwiKTt1PWEuZGVjb2RlKHUpO24ub3JpZ2luYWxMaW5lPWcrdS52YWx1ZTtnPW4ub3JpZ2luYWxMaW5lO24ub3JpZ2luYWxMaW5lKz0xO3U9dS5yZXN0O2lmKDA9PT11Lmxlbmd0aHx8ci50ZXN0KHUuY2hhckF0KDApKSl0aHJvdyBFcnJvcihcXFwiRm91bmQgYSBzb3VyY2UgYW5kIGxpbmUsIGJ1dCBubyBjb2x1bW5cXFwiKTt1PWEuZGVjb2RlKHUpO24ub3JpZ2luYWxDb2x1bW49XFxuayt1LnZhbHVlO2s9bi5vcmlnaW5hbENvbHVtbjt1PXUucmVzdDswPHUubGVuZ3RoJiYhci50ZXN0KHUuY2hhckF0KDApKSYmKHU9YS5kZWNvZGUodSksbi5uYW1lPXRoaXMuX25hbWVzLmF0KG0rdS52YWx1ZSksbSs9dS52YWx1ZSx1PXUucmVzdCl9dGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzLnB1c2gobik7XFxcIm51bWJlclxcXCI9PT10eXBlb2Ygbi5vcmlnaW5hbExpbmUmJnRoaXMuX19vcmlnaW5hbE1hcHBpbmdzLnB1c2gobil9dGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzLnNvcnQoYi5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnMpO3RoaXMuX19vcmlnaW5hbE1hcHBpbmdzLnNvcnQoYi5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyl9O2cucHJvdG90eXBlLl9maW5kTWFwcGluZz1mdW5jdGlvbihhLGQsYixlLGcpe2lmKDA+PWFbYl0pdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiTGluZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxLCBnb3QgXFxcIithW2JdKTtpZigwPmFbZV0pdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ29sdW1uIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDAsIGdvdCBcXFwiK1xcbmFbZV0pO3JldHVybiBmLnNlYXJjaChhLGQsZyl9O2cucHJvdG90eXBlLm9yaWdpbmFsUG9zaXRpb25Gb3I9ZnVuY3Rpb24oYSl7YT17Z2VuZXJhdGVkTGluZTpiLmdldEFyZyhhLFxcXCJsaW5lXFxcIiksZ2VuZXJhdGVkQ29sdW1uOmIuZ2V0QXJnKGEsXFxcImNvbHVtblxcXCIpfTtpZihhPXRoaXMuX2ZpbmRNYXBwaW5nKGEsdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3MsXFxcImdlbmVyYXRlZExpbmVcXFwiLFxcXCJnZW5lcmF0ZWRDb2x1bW5cXFwiLGIuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zKSl7dmFyIGQ9Yi5nZXRBcmcoYSxcXFwic291cmNlXFxcIixudWxsKTtkJiZ0aGlzLnNvdXJjZVJvb3QmJihkPWIuam9pbih0aGlzLnNvdXJjZVJvb3QsZCkpO3JldHVybntzb3VyY2U6ZCxsaW5lOmIuZ2V0QXJnKGEsXFxcIm9yaWdpbmFsTGluZVxcXCIsbnVsbCksY29sdW1uOmIuZ2V0QXJnKGEsXFxcIm9yaWdpbmFsQ29sdW1uXFxcIixudWxsKSxuYW1lOmIuZ2V0QXJnKGEsXFxcIm5hbWVcXFwiLG51bGwpfX1yZXR1cm57c291cmNlOm51bGwsbGluZTpudWxsLGNvbHVtbjpudWxsLFxcbm5hbWU6bnVsbH19O2cucHJvdG90eXBlLnNvdXJjZUNvbnRlbnRGb3I9ZnVuY3Rpb24oYSl7aWYoIXRoaXMuc291cmNlc0NvbnRlbnQpcmV0dXJuIG51bGw7dGhpcy5zb3VyY2VSb290JiYoYT1iLnJlbGF0aXZlKHRoaXMuc291cmNlUm9vdCxhKSk7aWYodGhpcy5fc291cmNlcy5oYXMoYSkpcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbdGhpcy5fc291cmNlcy5pbmRleE9mKGEpXTt2YXIgZDtpZih0aGlzLnNvdXJjZVJvb3QmJihkPWIudXJsUGFyc2UodGhpcy5zb3VyY2VSb290KSkpe3ZhciBlPWEucmVwbGFjZSgvXmZpbGU6XFxcXC9cXFxcLy8sXFxcIlxcXCIpO2lmKFxcXCJmaWxlXFxcIj09ZC5zY2hlbWUmJnRoaXMuX3NvdXJjZXMuaGFzKGUpKXJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50W3RoaXMuX3NvdXJjZXMuaW5kZXhPZihlKV07aWYoKCFkLnBhdGh8fFxcXCIvXFxcIj09ZC5wYXRoKSYmdGhpcy5fc291cmNlcy5oYXMoXFxcIi9cXFwiK2EpKXJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50W3RoaXMuX3NvdXJjZXMuaW5kZXhPZihcXFwiL1xcXCIrXFxuYSldfXRocm93IEVycm9yKCdcXFwiJythKydcXFwiIGlzIG5vdCBpbiB0aGUgU291cmNlTWFwLicpO307Zy5wcm90b3R5cGUuZ2VuZXJhdGVkUG9zaXRpb25Gb3I9ZnVuY3Rpb24oYSl7YT17c291cmNlOmIuZ2V0QXJnKGEsXFxcInNvdXJjZVxcXCIpLG9yaWdpbmFsTGluZTpiLmdldEFyZyhhLFxcXCJsaW5lXFxcIiksb3JpZ2luYWxDb2x1bW46Yi5nZXRBcmcoYSxcXFwiY29sdW1uXFxcIil9O3RoaXMuc291cmNlUm9vdCYmKGEuc291cmNlPWIucmVsYXRpdmUodGhpcy5zb3VyY2VSb290LGEuc291cmNlKSk7cmV0dXJuKGE9dGhpcy5fZmluZE1hcHBpbmcoYSx0aGlzLl9vcmlnaW5hbE1hcHBpbmdzLFxcXCJvcmlnaW5hbExpbmVcXFwiLFxcXCJvcmlnaW5hbENvbHVtblxcXCIsYi5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucykpP3tsaW5lOmIuZ2V0QXJnKGEsXFxcImdlbmVyYXRlZExpbmVcXFwiLG51bGwpLGNvbHVtbjpiLmdldEFyZyhhLFxcXCJnZW5lcmF0ZWRDb2x1bW5cXFwiLG51bGwpfTp7bGluZTpudWxsLGNvbHVtbjpudWxsfX07Zy5HRU5FUkFURURfT1JERVI9XFxuMTtnLk9SSUdJTkFMX09SREVSPTI7Zy5wcm90b3R5cGUuZWFjaE1hcHBpbmc9ZnVuY3Rpb24oYSxkLGUpe2Q9ZHx8bnVsbDtzd2l0Y2goZXx8Zy5HRU5FUkFURURfT1JERVIpe2Nhc2UgZy5HRU5FUkFURURfT1JERVI6ZT10aGlzLl9nZW5lcmF0ZWRNYXBwaW5nczticmVhaztjYXNlIGcuT1JJR0lOQUxfT1JERVI6ZT10aGlzLl9vcmlnaW5hbE1hcHBpbmdzO2JyZWFrO2RlZmF1bHQ6dGhyb3cgRXJyb3IoXFxcIlVua25vd24gb3JkZXIgb2YgaXRlcmF0aW9uLlxcXCIpO312YXIgZj10aGlzLnNvdXJjZVJvb3Q7ZS5tYXAoZnVuY3Rpb24oYSl7dmFyIGM9YS5zb3VyY2U7YyYmZiYmKGM9Yi5qb2luKGYsYykpO3JldHVybntzb3VyY2U6YyxnZW5lcmF0ZWRMaW5lOmEuZ2VuZXJhdGVkTGluZSxnZW5lcmF0ZWRDb2x1bW46YS5nZW5lcmF0ZWRDb2x1bW4sb3JpZ2luYWxMaW5lOmEub3JpZ2luYWxMaW5lLG9yaWdpbmFsQ29sdW1uOmEub3JpZ2luYWxDb2x1bW4sbmFtZTphLm5hbWV9fSkuZm9yRWFjaChhLFxcbmQpfTtsLlNvdXJjZU1hcENvbnN1bWVyPWd9KX0se1xcXCIuL2FycmF5LXNldFxcXCI6MTAsXFxcIi4vYmFzZTY0LXZscVxcXCI6MTEsXFxcIi4vYmluYXJ5LXNlYXJjaFxcXCI6MTMsXFxcIi4vdXRpbFxcXCI6MTcsYW1kZWZpbmU6Mn1dLDE1OltmdW5jdGlvbihuLHcsdCl7aWYoXFxcImZ1bmN0aW9uXFxcIiE9PXR5cGVvZiBlKXZhciBlPW4oXFxcImFtZGVmaW5lXFxcIikodyxuKTtlKGZ1bmN0aW9uKGUsbCxtKXtmdW5jdGlvbiBnKGEpe3RoaXMuX2ZpbGU9Zi5nZXRBcmcoYSxcXFwiZmlsZVxcXCIpO3RoaXMuX3NvdXJjZVJvb3Q9Zi5nZXRBcmcoYSxcXFwic291cmNlUm9vdFxcXCIsbnVsbCk7dGhpcy5fc291cmNlcz1uZXcgazt0aGlzLl9uYW1lcz1uZXcgazt0aGlzLl9tYXBwaW5ncz1bXTt0aGlzLl9zb3VyY2VzQ29udGVudHM9bnVsbH12YXIgYj1lKFxcXCIuL2Jhc2U2NC12bHFcXFwiKSxmPWUoXFxcIi4vdXRpbFxcXCIpLGs9ZShcXFwiLi9hcnJheS1zZXRcXFwiKS5BcnJheVNldDtnLnByb3RvdHlwZS5fdmVyc2lvbj0zO2cuZnJvbVNvdXJjZU1hcD1mdW5jdGlvbihhKXt2YXIgYz1hLnNvdXJjZVJvb3QsXFxuZD1uZXcgZyh7ZmlsZTphLmZpbGUsc291cmNlUm9vdDpjfSk7YS5lYWNoTWFwcGluZyhmdW5jdGlvbihhKXt2YXIgYj17Z2VuZXJhdGVkOntsaW5lOmEuZ2VuZXJhdGVkTGluZSxjb2x1bW46YS5nZW5lcmF0ZWRDb2x1bW59fTthLnNvdXJjZSYmKGIuc291cmNlPWEuc291cmNlLGMmJihiLnNvdXJjZT1mLnJlbGF0aXZlKGMsYi5zb3VyY2UpKSxiLm9yaWdpbmFsPXtsaW5lOmEub3JpZ2luYWxMaW5lLGNvbHVtbjphLm9yaWdpbmFsQ29sdW1ufSxhLm5hbWUmJihiLm5hbWU9YS5uYW1lKSk7ZC5hZGRNYXBwaW5nKGIpfSk7YS5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24oYyl7dmFyIGI9YS5zb3VyY2VDb250ZW50Rm9yKGMpO2ImJmQuc2V0U291cmNlQ29udGVudChjLGIpfSk7cmV0dXJuIGR9O2cucHJvdG90eXBlLmFkZE1hcHBpbmc9ZnVuY3Rpb24oYSl7dmFyIGM9Zi5nZXRBcmcoYSxcXFwiZ2VuZXJhdGVkXFxcIiksZD1mLmdldEFyZyhhLFxcXCJvcmlnaW5hbFxcXCIsbnVsbCksYj1mLmdldEFyZyhhLFxcXCJzb3VyY2VcXFwiLFxcbm51bGwpO2E9Zi5nZXRBcmcoYSxcXFwibmFtZVxcXCIsbnVsbCk7dGhpcy5fdmFsaWRhdGVNYXBwaW5nKGMsZCxiLGEpO2ImJiF0aGlzLl9zb3VyY2VzLmhhcyhiKSYmdGhpcy5fc291cmNlcy5hZGQoYik7YSYmIXRoaXMuX25hbWVzLmhhcyhhKSYmdGhpcy5fbmFtZXMuYWRkKGEpO3RoaXMuX21hcHBpbmdzLnB1c2goe2dlbmVyYXRlZExpbmU6Yy5saW5lLGdlbmVyYXRlZENvbHVtbjpjLmNvbHVtbixvcmlnaW5hbExpbmU6bnVsbCE9ZCYmZC5saW5lLG9yaWdpbmFsQ29sdW1uOm51bGwhPWQmJmQuY29sdW1uLHNvdXJjZTpiLG5hbWU6YX0pfTtnLnByb3RvdHlwZS5zZXRTb3VyY2VDb250ZW50PWZ1bmN0aW9uKGEsYyl7dmFyIGQ9YTt0aGlzLl9zb3VyY2VSb290JiYoZD1mLnJlbGF0aXZlKHRoaXMuX3NvdXJjZVJvb3QsZCkpO251bGwhPT1jPyh0aGlzLl9zb3VyY2VzQ29udGVudHN8fCh0aGlzLl9zb3VyY2VzQ29udGVudHM9e30pLHRoaXMuX3NvdXJjZXNDb250ZW50c1tmLnRvU2V0U3RyaW5nKGQpXT1cXG5jKTooZGVsZXRlIHRoaXMuX3NvdXJjZXNDb250ZW50c1tmLnRvU2V0U3RyaW5nKGQpXSwwPT09T2JqZWN0LmtleXModGhpcy5fc291cmNlc0NvbnRlbnRzKS5sZW5ndGgmJih0aGlzLl9zb3VyY2VzQ29udGVudHM9bnVsbCkpfTtnLnByb3RvdHlwZS5hcHBseVNvdXJjZU1hcD1mdW5jdGlvbihhLGMpe2N8fChjPWEuZmlsZSk7dmFyIGQ9dGhpcy5fc291cmNlUm9vdDtkJiYoYz1mLnJlbGF0aXZlKGQsYykpO3ZhciBiPW5ldyBrLGU9bmV3IGs7dGhpcy5fbWFwcGluZ3MuZm9yRWFjaChmdW5jdGlvbihnKXtpZihnLnNvdXJjZT09PWMmJmcub3JpZ2luYWxMaW5lKXt2YXIgaz1hLm9yaWdpbmFsUG9zaXRpb25Gb3Ioe2xpbmU6Zy5vcmlnaW5hbExpbmUsY29sdW1uOmcub3JpZ2luYWxDb2x1bW59KTtudWxsIT09ay5zb3VyY2UmJihnLnNvdXJjZT1kP2YucmVsYXRpdmUoZCxrLnNvdXJjZSk6ay5zb3VyY2UsZy5vcmlnaW5hbExpbmU9ay5saW5lLGcub3JpZ2luYWxDb2x1bW49ay5jb2x1bW4sXFxubnVsbCE9PWsubmFtZSYmbnVsbCE9PWcubmFtZSYmKGcubmFtZT1rLm5hbWUpKX0oaz1nLnNvdXJjZSkmJiFiLmhhcyhrKSYmYi5hZGQoayk7KGc9Zy5uYW1lKSYmIWUuaGFzKGcpJiZlLmFkZChnKX0sdGhpcyk7dGhpcy5fc291cmNlcz1iO3RoaXMuX25hbWVzPWU7YS5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24oYyl7dmFyIGI9YS5zb3VyY2VDb250ZW50Rm9yKGMpO2ImJihkJiYoYz1mLnJlbGF0aXZlKGQsYykpLHRoaXMuc2V0U291cmNlQ29udGVudChjLGIpKX0sdGhpcyl9O2cucHJvdG90eXBlLl92YWxpZGF0ZU1hcHBpbmc9ZnVuY3Rpb24oYSxjLGQsYil7aWYoIShhJiZcXFwibGluZVxcXCJpbiBhJiZcXFwiY29sdW1uXFxcImluIGEmJjA8YS5saW5lJiYwPD1hLmNvbHVtbiYmIWMmJiFkJiYhYnx8YSYmXFxcImxpbmVcXFwiaW4gYSYmXFxcImNvbHVtblxcXCJpbiBhJiZjJiZcXFwibGluZVxcXCJpbiBjJiZcXFwiY29sdW1uXFxcImluIGMmJjA8YS5saW5lJiYwPD1hLmNvbHVtbiYmMDxjLmxpbmUmJjA8PWMuY29sdW1uJiZkKSl0aHJvdyBFcnJvcihcXFwiSW52YWxpZCBtYXBwaW5nOiBcXFwiK1xcbkpTT04uc3RyaW5naWZ5KHtnZW5lcmF0ZWQ6YSxzb3VyY2U6ZCxvcmlnaW5hbDpjLG5hbWU6Yn0pKTt9O2cucHJvdG90eXBlLl9zZXJpYWxpemVNYXBwaW5ncz1mdW5jdGlvbigpe3ZhciBhPTAsYz0xLGQ9MCxlPTAsZz0wLGs9MCxsPVxcXCJcXFwiLG07dGhpcy5fbWFwcGluZ3Muc29ydChmLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9ucyk7Zm9yKHZhciBuPTAscj10aGlzLl9tYXBwaW5ncy5sZW5ndGg7bjxyO24rKyl7bT10aGlzLl9tYXBwaW5nc1tuXTtpZihtLmdlbmVyYXRlZExpbmUhPT1jKWZvcihhPTA7bS5nZW5lcmF0ZWRMaW5lIT09YzspbCs9XFxcIjtcXFwiLGMrKztlbHNlIGlmKDA8bil7aWYoIWYuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zKG0sdGhpcy5fbWFwcGluZ3Nbbi0xXSkpY29udGludWU7bCs9XFxcIixcXFwifWwrPWIuZW5jb2RlKG0uZ2VuZXJhdGVkQ29sdW1uLWEpO2E9bS5nZW5lcmF0ZWRDb2x1bW47bS5zb3VyY2UmJihsKz1iLmVuY29kZSh0aGlzLl9zb3VyY2VzLmluZGV4T2YobS5zb3VyY2UpLVxcbmspLGs9dGhpcy5fc291cmNlcy5pbmRleE9mKG0uc291cmNlKSxsKz1iLmVuY29kZShtLm9yaWdpbmFsTGluZS0xLWUpLGU9bS5vcmlnaW5hbExpbmUtMSxsKz1iLmVuY29kZShtLm9yaWdpbmFsQ29sdW1uLWQpLGQ9bS5vcmlnaW5hbENvbHVtbixtLm5hbWUmJihsKz1iLmVuY29kZSh0aGlzLl9uYW1lcy5pbmRleE9mKG0ubmFtZSktZyksZz10aGlzLl9uYW1lcy5pbmRleE9mKG0ubmFtZSkpKX1yZXR1cm4gbH07Zy5wcm90b3R5cGUuX2dlbmVyYXRlU291cmNlc0NvbnRlbnQ9ZnVuY3Rpb24oYSxjKXtyZXR1cm4gYS5tYXAoZnVuY3Rpb24oYSl7aWYoIXRoaXMuX3NvdXJjZXNDb250ZW50cylyZXR1cm4gbnVsbDtjJiYoYT1mLnJlbGF0aXZlKGMsYSkpO2E9Zi50b1NldFN0cmluZyhhKTtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuX3NvdXJjZXNDb250ZW50cyxhKT90aGlzLl9zb3VyY2VzQ29udGVudHNbYV06bnVsbH0sdGhpcyl9O2cucHJvdG90eXBlLnRvSlNPTj1cXG5mdW5jdGlvbigpe3ZhciBhPXt2ZXJzaW9uOnRoaXMuX3ZlcnNpb24sZmlsZTp0aGlzLl9maWxlLHNvdXJjZXM6dGhpcy5fc291cmNlcy50b0FycmF5KCksbmFtZXM6dGhpcy5fbmFtZXMudG9BcnJheSgpLG1hcHBpbmdzOnRoaXMuX3NlcmlhbGl6ZU1hcHBpbmdzKCl9O3RoaXMuX3NvdXJjZVJvb3QmJihhLnNvdXJjZVJvb3Q9dGhpcy5fc291cmNlUm9vdCk7dGhpcy5fc291cmNlc0NvbnRlbnRzJiYoYS5zb3VyY2VzQ29udGVudD10aGlzLl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50KGEuc291cmNlcyxhLnNvdXJjZVJvb3QpKTtyZXR1cm4gYX07Zy5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcyl9O2wuU291cmNlTWFwR2VuZXJhdG9yPWd9KX0se1xcXCIuL2FycmF5LXNldFxcXCI6MTAsXFxcIi4vYmFzZTY0LXZscVxcXCI6MTEsXFxcIi4vdXRpbFxcXCI6MTcsYW1kZWZpbmU6Mn1dLDE2OltmdW5jdGlvbihuLHcsdCl7aWYoXFxcImZ1bmN0aW9uXFxcIiE9PXR5cGVvZiBlKXZhciBlPVxcbm4oXFxcImFtZGVmaW5lXFxcIikodyxuKTtlKGZ1bmN0aW9uKGUsbCxtKXtmdW5jdGlvbiBnKGIsYSxjLGQsZSl7dGhpcy5jaGlsZHJlbj1bXTt0aGlzLnNvdXJjZUNvbnRlbnRzPXt9O3RoaXMubGluZT12b2lkIDA9PT1iP251bGw6Yjt0aGlzLmNvbHVtbj12b2lkIDA9PT1hP251bGw6YTt0aGlzLnNvdXJjZT12b2lkIDA9PT1jP251bGw6Yzt0aGlzLm5hbWU9dm9pZCAwPT09ZT9udWxsOmU7bnVsbCE9ZCYmdGhpcy5hZGQoZCl9dmFyIGI9ZShcXFwiLi9zb3VyY2UtbWFwLWdlbmVyYXRvclxcXCIpLlNvdXJjZU1hcEdlbmVyYXRvcixmPWUoXFxcIi4vdXRpbFxcXCIpO2cuZnJvbVN0cmluZ1dpdGhTb3VyY2VNYXA9ZnVuY3Rpb24oYixhKXtmdW5jdGlvbiBjKGEsYyl7bnVsbD09PWF8fHZvaWQgMD09PWEuc291cmNlP2QuYWRkKGMpOmQuYWRkKG5ldyBnKGEub3JpZ2luYWxMaW5lLGEub3JpZ2luYWxDb2x1bW4sYS5zb3VyY2UsYyxhLm5hbWUpKX12YXIgZD1uZXcgZyxlPWIuc3BsaXQoXFxcIlxcXFxuXFxcIiksZj0xLGw9MCxtPW51bGw7XFxuYS5lYWNoTWFwcGluZyhmdW5jdGlvbihhKXtpZihudWxsPT09bSl7Zm9yKDtmPGEuZ2VuZXJhdGVkTGluZTspZC5hZGQoZS5zaGlmdCgpK1xcXCJcXFxcblxcXCIpLGYrKztpZihsPGEuZ2VuZXJhdGVkQ29sdW1uKXt2YXIgYj1lWzBdO2QuYWRkKGIuc3Vic3RyKDAsYS5nZW5lcmF0ZWRDb2x1bW4pKTtlWzBdPWIuc3Vic3RyKGEuZ2VuZXJhdGVkQ29sdW1uKTtsPWEuZ2VuZXJhdGVkQ29sdW1ufX1lbHNle2lmKGY8YS5nZW5lcmF0ZWRMaW5lKXt2YXIgZz1cXFwiXFxcIjtkbyBnKz1lLnNoaWZ0KCkrXFxcIlxcXFxuXFxcIixmKyssbD0wO3doaWxlKGY8YS5nZW5lcmF0ZWRMaW5lKTtsPGEuZ2VuZXJhdGVkQ29sdW1uJiYoYj1lWzBdLGcrPWIuc3Vic3RyKDAsYS5nZW5lcmF0ZWRDb2x1bW4pLGVbMF09Yi5zdWJzdHIoYS5nZW5lcmF0ZWRDb2x1bW4pLGw9YS5nZW5lcmF0ZWRDb2x1bW4pfWVsc2UgYj1lWzBdLGc9Yi5zdWJzdHIoMCxhLmdlbmVyYXRlZENvbHVtbi1sKSxlWzBdPWIuc3Vic3RyKGEuZ2VuZXJhdGVkQ29sdW1uLWwpLFxcbmw9YS5nZW5lcmF0ZWRDb2x1bW47YyhtLGcpfW09YX0sdGhpcyk7YyhtLGUuam9pbihcXFwiXFxcXG5cXFwiKSk7YS5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24oYyl7dmFyIGI9YS5zb3VyY2VDb250ZW50Rm9yKGMpO2ImJmQuc2V0U291cmNlQ29udGVudChjLGIpfSk7cmV0dXJuIGR9O2cucHJvdG90eXBlLmFkZD1mdW5jdGlvbihiKXtpZihBcnJheS5pc0FycmF5KGIpKWIuZm9yRWFjaChmdW5jdGlvbihhKXt0aGlzLmFkZChhKX0sdGhpcyk7ZWxzZSBpZihiIGluc3RhbmNlb2YgZ3x8XFxcInN0cmluZ1xcXCI9PT10eXBlb2YgYiliJiZ0aGlzLmNoaWxkcmVuLnB1c2goYik7ZWxzZSB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJFeHBlY3RlZCBhIFNvdXJjZU5vZGUsIHN0cmluZywgb3IgYW4gYXJyYXkgb2YgU291cmNlTm9kZXMgYW5kIHN0cmluZ3MuIEdvdCBcXFwiK2IpO3JldHVybiB0aGlzfTtnLnByb3RvdHlwZS5wcmVwZW5kPWZ1bmN0aW9uKGIpe2lmKEFycmF5LmlzQXJyYXkoYikpZm9yKHZhciBhPWIubGVuZ3RoLVxcbjE7MDw9YTthLS0pdGhpcy5wcmVwZW5kKGJbYV0pO2Vsc2UgaWYoYiBpbnN0YW5jZW9mIGd8fFxcXCJzdHJpbmdcXFwiPT09dHlwZW9mIGIpdGhpcy5jaGlsZHJlbi51bnNoaWZ0KGIpO2Vsc2UgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiRXhwZWN0ZWQgYSBTb3VyY2VOb2RlLCBzdHJpbmcsIG9yIGFuIGFycmF5IG9mIFNvdXJjZU5vZGVzIGFuZCBzdHJpbmdzLiBHb3QgXFxcIitiKTtyZXR1cm4gdGhpc307Zy5wcm90b3R5cGUud2Fsaz1mdW5jdGlvbihiKXtmb3IodmFyIGEsYz0wLGQ9dGhpcy5jaGlsZHJlbi5sZW5ndGg7YzxkO2MrKylhPXRoaXMuY2hpbGRyZW5bY10sYSBpbnN0YW5jZW9mIGc/YS53YWxrKGIpOlxcXCJcXFwiIT09YSYmYihhLHtzb3VyY2U6dGhpcy5zb3VyY2UsbGluZTp0aGlzLmxpbmUsY29sdW1uOnRoaXMuY29sdW1uLG5hbWU6dGhpcy5uYW1lfSl9O2cucHJvdG90eXBlLmpvaW49ZnVuY3Rpb24oYil7dmFyIGEsYyxkPXRoaXMuY2hpbGRyZW4ubGVuZ3RoO2lmKDA8ZCl7YT1bXTtmb3IoYz0wO2M8XFxuZC0xO2MrKylhLnB1c2godGhpcy5jaGlsZHJlbltjXSksYS5wdXNoKGIpO2EucHVzaCh0aGlzLmNoaWxkcmVuW2NdKTt0aGlzLmNoaWxkcmVuPWF9cmV0dXJuIHRoaXN9O2cucHJvdG90eXBlLnJlcGxhY2VSaWdodD1mdW5jdGlvbihiLGEpe3ZhciBjPXRoaXMuY2hpbGRyZW5bdGhpcy5jaGlsZHJlbi5sZW5ndGgtMV07YyBpbnN0YW5jZW9mIGc/Yy5yZXBsYWNlUmlnaHQoYixhKTpcXFwic3RyaW5nXFxcIj09PXR5cGVvZiBjP3RoaXMuY2hpbGRyZW5bdGhpcy5jaGlsZHJlbi5sZW5ndGgtMV09Yy5yZXBsYWNlKGIsYSk6dGhpcy5jaGlsZHJlbi5wdXNoKFxcXCJcXFwiLnJlcGxhY2UoYixhKSk7cmV0dXJuIHRoaXN9O2cucHJvdG90eXBlLnNldFNvdXJjZUNvbnRlbnQ9ZnVuY3Rpb24oYixhKXt0aGlzLnNvdXJjZUNvbnRlbnRzW2YudG9TZXRTdHJpbmcoYildPWF9O2cucHJvdG90eXBlLndhbGtTb3VyY2VDb250ZW50cz1mdW5jdGlvbihiKXtmb3IodmFyIGE9MCxjPXRoaXMuY2hpbGRyZW4ubGVuZ3RoO2E8XFxuYzthKyspdGhpcy5jaGlsZHJlblthXWluc3RhbmNlb2YgZyYmdGhpcy5jaGlsZHJlblthXS53YWxrU291cmNlQ29udGVudHMoYik7Zm9yKHZhciBkPU9iamVjdC5rZXlzKHRoaXMuc291cmNlQ29udGVudHMpLGE9MCxjPWQubGVuZ3RoO2E8YzthKyspYihmLmZyb21TZXRTdHJpbmcoZFthXSksdGhpcy5zb3VyY2VDb250ZW50c1tkW2FdXSl9O2cucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7dmFyIGI9XFxcIlxcXCI7dGhpcy53YWxrKGZ1bmN0aW9uKGEpe2IrPWF9KTtyZXR1cm4gYn07Zy5wcm90b3R5cGUudG9TdHJpbmdXaXRoU291cmNlTWFwPWZ1bmN0aW9uKGUpe3ZhciBhPVxcXCJcXFwiLGM9MSxkPTAsZj1uZXcgYihlKSxnPSExLGw9bnVsbCxtPW51bGwsbj1udWxsLHI9bnVsbDt0aGlzLndhbGsoZnVuY3Rpb24oYixlKXthKz1iO251bGwhPT1lLnNvdXJjZSYmbnVsbCE9PWUubGluZSYmbnVsbCE9PWUuY29sdW1uPyhsPT09ZS5zb3VyY2UmJm09PT1lLmxpbmUmJm49PT1lLmNvbHVtbiYmcj09PVxcbmUubmFtZXx8Zi5hZGRNYXBwaW5nKHtzb3VyY2U6ZS5zb3VyY2Usb3JpZ2luYWw6e2xpbmU6ZS5saW5lLGNvbHVtbjplLmNvbHVtbn0sZ2VuZXJhdGVkOntsaW5lOmMsY29sdW1uOmR9LG5hbWU6ZS5uYW1lfSksbD1lLnNvdXJjZSxtPWUubGluZSxuPWUuY29sdW1uLHI9ZS5uYW1lLGc9ITApOmcmJihmLmFkZE1hcHBpbmcoe2dlbmVyYXRlZDp7bGluZTpjLGNvbHVtbjpkfX0pLGw9bnVsbCxnPSExKTtiLnNwbGl0KFxcXCJcXFwiKS5mb3JFYWNoKGZ1bmN0aW9uKGEpe1xcXCJcXFxcblxcXCI9PT1hPyhjKyssZD0wKTpkKyt9KX0pO3RoaXMud2Fsa1NvdXJjZUNvbnRlbnRzKGZ1bmN0aW9uKGEsYyl7Zi5zZXRTb3VyY2VDb250ZW50KGEsYyl9KTtyZXR1cm57Y29kZTphLG1hcDpmfX07bC5Tb3VyY2VOb2RlPWd9KX0se1xcXCIuL3NvdXJjZS1tYXAtZ2VuZXJhdG9yXFxcIjoxNSxcXFwiLi91dGlsXFxcIjoxNyxhbWRlZmluZToyfV0sMTc6W2Z1bmN0aW9uKG4sdyx0KXtpZihcXFwiZnVuY3Rpb25cXFwiIT09dHlwZW9mIGUpdmFyIGU9bihcXFwiYW1kZWZpbmVcXFwiKSh3LFxcbm4pO2UoZnVuY3Rpb24oZSxsLG0pe2Z1bmN0aW9uIGcoYSl7cmV0dXJuKGE9YS5tYXRjaChrKSk/e3NjaGVtZTphWzFdLGF1dGg6YVszXSxob3N0OmFbNF0scG9ydDphWzZdLHBhdGg6YVs3XX06bnVsbH1mdW5jdGlvbiBiKGEpe3ZhciBiPWEuc2NoZW1lK1xcXCI6Ly9cXFwiO2EuYXV0aCYmKGIrPWEuYXV0aCtcXFwiQFxcXCIpO2EuaG9zdCYmKGIrPWEuaG9zdCk7YS5wb3J0JiYoYis9XFxcIjpcXFwiK2EucG9ydCk7YS5wYXRoJiYoYis9YS5wYXRoKTtyZXR1cm4gYn1mdW5jdGlvbiBmKGEsYil7dmFyIGU9YXx8XFxcIlxcXCIsZj1ifHxcXFwiXFxcIjtyZXR1cm4oZT5mKS0oZTxmKX1sLmdldEFyZz1mdW5jdGlvbihhLGIsZSl7aWYoYiBpbiBhKXJldHVybiBhW2JdO2lmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiBlO3Rocm93IEVycm9yKCdcXFwiJytiKydcXFwiIGlzIGEgcmVxdWlyZWQgYXJndW1lbnQuJyk7fTt2YXIgaz0vKFtcXFxcdytcXFxcLS5dKyk6XFxcXC9cXFxcLygoXFxcXHcrOlxcXFx3KylAKT8oW1xcXFx3Ll0rKT8oOihcXFxcZCspKT8oXFxcXFMrKT8vLGE9L15kYXRhOi4rXFxcXCwuKy87XFxubC51cmxQYXJzZT1nO2wudXJsR2VuZXJhdGU9YjtsLmpvaW49ZnVuY3Rpb24oYyxkKXt2YXIgZTtyZXR1cm4gZC5tYXRjaChrKXx8ZC5tYXRjaChhKT9kOlxcXCIvXFxcIj09PWQuY2hhckF0KDApJiYoZT1nKGMpKT8oZS5wYXRoPWQsYihlKSk6Yy5yZXBsYWNlKC9cXFxcLyQvLFxcXCJcXFwiKStcXFwiL1xcXCIrZH07bC50b1NldFN0cmluZz1mdW5jdGlvbihhKXtyZXR1cm5cXFwiJFxcXCIrYX07bC5mcm9tU2V0U3RyaW5nPWZ1bmN0aW9uKGEpe3JldHVybiBhLnN1YnN0cigxKX07bC5yZWxhdGl2ZT1mdW5jdGlvbihhLGIpe2E9YS5yZXBsYWNlKC9cXFxcLyQvLFxcXCJcXFwiKTt2YXIgZT1nKGEpO3JldHVyblxcXCIvXFxcIj09Yi5jaGFyQXQoMCkmJmUmJlxcXCIvXFxcIj09ZS5wYXRoP2Iuc2xpY2UoMSk6MD09PWIuaW5kZXhPZihhK1xcXCIvXFxcIik/Yi5zdWJzdHIoYS5sZW5ndGgrMSk6Yn07bC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucz1mdW5jdGlvbihhLGIsZSl7dmFyIGc7cmV0dXJuKGc9ZihhLnNvdXJjZSxiLnNvdXJjZSkpfHwoZz1hLm9yaWdpbmFsTGluZS1iLm9yaWdpbmFsTGluZSl8fFxcbihnPWEub3JpZ2luYWxDb2x1bW4tYi5vcmlnaW5hbENvbHVtbil8fGV8fChnPWYoYS5uYW1lLGIubmFtZSkpP2c6KGc9YS5nZW5lcmF0ZWRMaW5lLWIuZ2VuZXJhdGVkTGluZSk/ZzphLmdlbmVyYXRlZENvbHVtbi1iLmdlbmVyYXRlZENvbHVtbn07bC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnM9ZnVuY3Rpb24oYSxiLGUpe3ZhciBnO3JldHVybihnPWEuZ2VuZXJhdGVkTGluZS1iLmdlbmVyYXRlZExpbmUpfHwoZz1hLmdlbmVyYXRlZENvbHVtbi1iLmdlbmVyYXRlZENvbHVtbil8fGV8fChnPWYoYS5zb3VyY2UsYi5zb3VyY2UpKXx8KGc9YS5vcmlnaW5hbExpbmUtYi5vcmlnaW5hbExpbmUpP2c6KGc9YS5vcmlnaW5hbENvbHVtbi1iLm9yaWdpbmFsQ29sdW1uKT9nOmYoYS5uYW1lLGIubmFtZSl9fSl9LHthbWRlZmluZToyfV0sMTg6W2Z1bmN0aW9uKG4sdyx0KXsoZnVuY3Rpb24oZSxyKXtmdW5jdGlvbiBsKCl7cmV0dXJuXFxcImJyb3dzZXJcXFwiPT09Qz8hMDpcXFwibm9kZVxcXCI9PT1DPyExOlxcblxcXCJ1bmRlZmluZWRcXFwiIT09dHlwZW9mIHdpbmRvdyYmXFxcImZ1bmN0aW9uXFxcIj09PXR5cGVvZiBYTUxIdHRwUmVxdWVzdH1mdW5jdGlvbiBtKGEpe2E9YS50cmltKCk7aWYoYSBpbiB6KXJldHVybiB6W2FdO3RyeXtpZihsKCkpe3ZhciBiPW5ldyBYTUxIdHRwUmVxdWVzdDtiLm9wZW4oXFxcIkdFVFxcXCIsYSwhMSk7Yi5zZW5kKG51bGwpO3ZhciBjPW51bGw7ND09PWIucmVhZHlTdGF0ZSYmMjAwPT09Yi5zdGF0dXMmJihjPWIucmVzcG9uc2VUZXh0KX1lbHNlIGM9RS5yZWFkRmlsZVN5bmMoYSxcXFwidXRmOFxcXCIpfWNhdGNoKGQpe2M9bnVsbH1yZXR1cm4gelthXT1jfWZ1bmN0aW9uIGcoYSxiKXtpZighYSlyZXR1cm4gYjt2YXIgYz1GLmRpcm5hbWUoYSksZD0vXlxcXFx3KzpcXFxcL1xcXFwvW15cXFxcL10qLy5leGVjKGMpLGQ9ZD9kWzBdOlxcXCJcXFwiO3JldHVybiBkK0YucmVzb2x2ZShjLnNsaWNlKGQubGVuZ3RoKSxiKX1mdW5jdGlvbiBiKGEpe3ZhciBiO2E6e3ZhciBjO2lmKGwoKSYmKGM9bmV3IFhNTEh0dHBSZXF1ZXN0LGMub3BlbihcXFwiR0VUXFxcIixcXG5hLCExKSxjLnNlbmQobnVsbCksYz1jLmdldFJlc3BvbnNlSGVhZGVyKFxcXCJTb3VyY2VNYXBcXFwiKXx8Yy5nZXRSZXNwb25zZUhlYWRlcihcXFwiWC1Tb3VyY2VNYXBcXFwiKSkpe2I9YzticmVhayBhfWM9bShhKTtmb3IodmFyIGQ9Lyg/OlxcXFwvXFxcXC9bQCNdWyBcXFxcdF0rc291cmNlTWFwcGluZ1VSTD0oW15cXFxccydcXFwiXSs/KVsgXFxcXHRdKiQpfCg/OlxcXFwvXFxcXCpbQCNdWyBcXFxcdF0rc291cmNlTWFwcGluZ1VSTD0oW15cXFxcKl0rPylbIFxcXFx0XSooPzpcXFxcKlxcXFwvKVsgXFxcXHRdKiQpL21nLGU7ZT1kLmV4ZWMoYyk7KWI9ZTtiPWI/YlsxXTpudWxsfWlmKCFiKXJldHVybiBudWxsO0gudGVzdChiKT8oYT1iLnNsaWNlKGIuaW5kZXhPZihcXFwiLFxcXCIpKzEpLGE9KG5ldyByKGEsXFxcImJhc2U2NFxcXCIpKS50b1N0cmluZygpLGI9bnVsbCk6KGI9ZyhhLGIpLGE9bShiKSk7cmV0dXJuIGE/e3VybDpiLG1hcDphfTpudWxsfWZ1bmN0aW9uIGYoYSl7dmFyIGM9RFthLnNvdXJjZV07aWYoIWMpe3ZhciBkPWIoYS5zb3VyY2UpO2Q/KGM9RFthLnNvdXJjZV09e3VybDpkLnVybCxcXG5tYXA6bmV3IEIoZC5tYXApfSxjLm1hcC5zb3VyY2VzQ29udGVudCYmYy5tYXAuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uKGEsYil7dmFyIGQ9Yy5tYXAuc291cmNlc0NvbnRlbnRbYl07aWYoZCl7dmFyIGU9ZyhjLnVybCxhKTt6W2VdPWR9fSkpOmM9RFthLnNvdXJjZV09e3VybDpudWxsLG1hcDpudWxsfX1yZXR1cm4gYyYmYy5tYXAmJihkPWMubWFwLm9yaWdpbmFsUG9zaXRpb25Gb3IoYSksbnVsbCE9PWQuc291cmNlKT8oZC5zb3VyY2U9ZyhjLnVybCxkLnNvdXJjZSksZCk6YX1mdW5jdGlvbiBrKGEpe3ZhciBiPS9eZXZhbCBhdCAoW14oXSspIFxcXFwoKC4rKTooXFxcXGQrKTooXFxcXGQrKVxcXFwpJC8uZXhlYyhhKTtyZXR1cm4gYj8oYT1mKHtzb3VyY2U6YlsyXSxsaW5lOmJbM10sY29sdW1uOmJbNF0tMX0pLFxcXCJldmFsIGF0IFxcXCIrYlsxXStcXFwiIChcXFwiK2Euc291cmNlK1xcXCI6XFxcIithLmxpbmUrXFxcIjpcXFwiKyhhLmNvbHVtbisxKStcXFwiKVxcXCIpOihiPS9eZXZhbCBhdCAoW14oXSspIFxcXFwoKC4rKVxcXFwpJC8uZXhlYyhhKSk/XFxcImV2YWwgYXQgXFxcIitcXG5iWzFdK1xcXCIgKFxcXCIrayhiWzJdKStcXFwiKVxcXCI6YX1mdW5jdGlvbiBhKCl7dmFyIGEsYj1cXFwiXFxcIjt0aGlzLmlzTmF0aXZlKCk/Yj1cXFwibmF0aXZlXFxcIjooYT10aGlzLmdldFNjcmlwdE5hbWVPclNvdXJjZVVSTCgpLCFhJiZ0aGlzLmlzRXZhbCgpJiYoYj10aGlzLmdldEV2YWxPcmlnaW4oKSxiKz1cXFwiLCBcXFwiKSxiPWE/YithOmIrXFxcIjxhbm9ueW1vdXM+XFxcIixhPXRoaXMuZ2V0TGluZU51bWJlcigpLG51bGwhPWEmJihiKz1cXFwiOlxcXCIrYSwoYT10aGlzLmdldENvbHVtbk51bWJlcigpKSYmKGIrPVxcXCI6XFxcIithKSkpO2E9XFxcIlxcXCI7dmFyIGM9dGhpcy5nZXRGdW5jdGlvbk5hbWUoKSxkPSEwLGU9dGhpcy5pc0NvbnN0cnVjdG9yKCk7aWYodGhpcy5pc1RvcGxldmVsKCl8fGUpZT9hKz1cXFwibmV3IFxcXCIrKGN8fFxcXCI8YW5vbnltb3VzPlxcXCIpOmM/YSs9YzooYSs9YixkPSExKTtlbHNle3ZhciBlPXRoaXMuZ2V0VHlwZU5hbWUoKSxmPXRoaXMuZ2V0TWV0aG9kTmFtZSgpO2M/KGUmJjAhPWMuaW5kZXhPZihlKSYmKGErPWUrXFxcIi5cXFwiKSxhKz1jLGYmJmMuaW5kZXhPZihcXFwiLlxcXCIrXFxuZikhPWMubGVuZ3RoLWYubGVuZ3RoLTEmJihhKz1cXFwiIFthcyBcXFwiK2YrXFxcIl1cXFwiKSk6YSs9ZStcXFwiLlxcXCIrKGZ8fFxcXCI8YW5vbnltb3VzPlxcXCIpfWQmJihhKz1cXFwiIChcXFwiK2IrXFxcIilcXFwiKTtyZXR1cm4gYX1mdW5jdGlvbiBjKGIpe3ZhciBjPXt9O09iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE9iamVjdC5nZXRQcm90b3R5cGVPZihiKSkuZm9yRWFjaChmdW5jdGlvbihhKXtjW2FdPS9eKD86aXN8Z2V0KS8udGVzdChhKT9mdW5jdGlvbigpe3JldHVybiBiW2FdLmNhbGwoYil9OmJbYV19KTtjLnRvU3RyaW5nPWE7cmV0dXJuIGN9ZnVuY3Rpb24gZChhKXt2YXIgYj1hLmdldEZpbGVOYW1lKCl8fGEuZ2V0U2NyaXB0TmFtZU9yU291cmNlVVJMKCk7aWYoYil7dmFyIGQ9YS5nZXRMaW5lTnVtYmVyKCksZT1hLmdldENvbHVtbk51bWJlcigpLTE7MSE9PWR8fGwoKXx8YS5pc0V2YWwoKXx8KGUtPTYyKTt2YXIgZz1mKHtzb3VyY2U6YixsaW5lOmQsY29sdW1uOmV9KTthPWMoYSk7YS5nZXRGaWxlTmFtZT1mdW5jdGlvbigpe3JldHVybiBnLnNvdXJjZX07XFxuYS5nZXRMaW5lTnVtYmVyPWZ1bmN0aW9uKCl7cmV0dXJuIGcubGluZX07YS5nZXRDb2x1bW5OdW1iZXI9ZnVuY3Rpb24oKXtyZXR1cm4gZy5jb2x1bW4rMX07YS5nZXRTY3JpcHROYW1lT3JTb3VyY2VVUkw9ZnVuY3Rpb24oKXtyZXR1cm4gZy5zb3VyY2V9O3JldHVybiBhfXZhciBtPWEuaXNFdmFsKCkmJmEuZ2V0RXZhbE9yaWdpbigpO20mJihtPWsobSksYT1jKGEpLGEuZ2V0RXZhbE9yaWdpbj1mdW5jdGlvbigpe3JldHVybiBtfSk7cmV0dXJuIGF9ZnVuY3Rpb24gdyhhLGIpe3UmJih6PXt9LEQ9e30pO3JldHVybiBhK2IubWFwKGZ1bmN0aW9uKGEpe3JldHVyblxcXCJcXFxcbiAgICBhdCBcXFwiK2QoYSl9KS5qb2luKFxcXCJcXFwiKX1mdW5jdGlvbiB4KGEpe3ZhciBiPS9cXFxcbiAgICBhdCBbXihdKyBcXFxcKCguKik6KFxcXFxkKyk6KFxcXFxkKylcXFxcKS8uZXhlYyhhLnN0YWNrKTtpZihiKXthPWJbMV07dmFyIGM9K2JbMl0sYj0rYlszXSxkPXpbYV07IWQmJkUuZXhpc3RzU3luYyhhKSYmKGQ9RS5yZWFkRmlsZVN5bmMoYSxcXFwidXRmOFxcXCIpKTtcXG5pZihkJiYoZD1kLnNwbGl0KC8oPzpcXFxcclxcXFxufFxcXFxyfFxcXFxuKS8pW2MtMV0pKXJldHVybiBhK1xcXCI6XFxcIitjK1xcXCJcXFxcblxcXCIrZCtcXFwiXFxcXG5cXFwiK0FycmF5KGIpLmpvaW4oXFxcIiBcXFwiKStcXFwiXlxcXCJ9cmV0dXJuIG51bGx9ZnVuY3Rpb24gQSgpe3ZhciBhPWUuZW1pdDtlLmVtaXQ9ZnVuY3Rpb24oYil7aWYoXFxcInVuY2F1Z2h0RXhjZXB0aW9uXFxcIj09PWIpe3ZhciBjPWFyZ3VtZW50c1sxXSYmYXJndW1lbnRzWzFdLnN0YWNrLGQ9MDx0aGlzLmxpc3RlbmVycyhiKS5sZW5ndGg7aWYoYyYmIWQpe2M9YXJndW1lbnRzWzFdO2lmKGQ9eChjKSljb25zb2xlLmVycm9yKCksY29uc29sZS5lcnJvcihkKTtjb25zb2xlLmVycm9yKGMuc3RhY2spO2UuZXhpdCgxKTtyZXR1cm59fXJldHVybiBhLmFwcGx5KHRoaXMsYXJndW1lbnRzKX19dmFyIEI9bihcXFwic291cmNlLW1hcFxcXCIpLlNvdXJjZU1hcENvbnN1bWVyLEY9bihcXFwicGF0aFxcXCIpLEU9bihcXFwiZnNcXFwiKSxHPSExLHU9ITEsQz1cXFwiYXV0b1xcXCIsej17fSxEPXt9LEg9L15kYXRhOmFwcGxpY2F0aW9uXFxcXC9qc29uW14sXStiYXNlNjQsLztcXG50LndyYXBDYWxsU2l0ZT1kO3QuZ2V0RXJyb3JTb3VyY2U9eDt0Lm1hcFNvdXJjZVBvc2l0aW9uPWY7dC5yZXRyaWV2ZVNvdXJjZU1hcD1iO3QuaW5zdGFsbD1mdW5jdGlvbihhKXtpZighRyl7Rz0hMDtFcnJvci5wcmVwYXJlU3RhY2tUcmFjZT13O2E9YXx8e307dmFyIGM9XFxcImhhbmRsZVVuY2F1Z2h0RXhjZXB0aW9uc1xcXCJpbiBhP2EuaGFuZGxlVW5jYXVnaHRFeGNlcHRpb25zOiEwO3U9XFxcImVtcHR5Q2FjaGVCZXR3ZWVuT3BlcmF0aW9uc1xcXCJpbiBhP2EuZW1wdHlDYWNoZUJldHdlZW5PcGVyYXRpb25zOiExO2lmKGEuZW52aXJvbm1lbnQmJihDPWEuZW52aXJvbm1lbnQsLTE9PT1bXFxcIm5vZGVcXFwiLFxcXCJicm93c2VyXFxcIixcXFwiYXV0b1xcXCJdLmluZGV4T2YoQykpKXRocm93IEVycm9yKFxcXCJlbnZpcm9ubWVudCBcXFwiK0MrXFxcIiB3YXMgdW5rbm93bi4gQXZhaWxhYmxlIG9wdGlvbnMgYXJlIHthdXRvLCBicm93c2VyLCBub2RlfVxcXCIpO2EucmV0cmlldmVGaWxlJiYobT1hLnJldHJpZXZlRmlsZSk7YS5yZXRyaWV2ZVNvdXJjZU1hcCYmXFxuKGI9YS5yZXRyaWV2ZVNvdXJjZU1hcCk7YyYmXFxcIm9iamVjdFxcXCI9PT10eXBlb2YgZSYmbnVsbCE9PWUmJlxcXCJmdW5jdGlvblxcXCI9PT10eXBlb2YgZS5vbiYmQSgpfX19KS5jYWxsKHRoaXMsbihcXFwibm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1xcXCIpLG4oXFxcImJ1ZmZlclxcXCIpLkJ1ZmZlcil9LHtcXFwibm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1xcXCI6OCxidWZmZXI6NSxmczo0LHBhdGg6NyxcXFwic291cmNlLW1hcFxcXCI6OX1dfSx7fSxbMV0pO3JldHVybiBLfSk7XFxuXCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zb3VyY2UtbWFwLXN1cHBvcnQvYnJvd3Nlci1zb3VyY2UtbWFwLXN1cHBvcnQuanNcbiAqKiBtb2R1bGUgaWQgPSA2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiLypcXG5Db3B5cmlnaHQgKGMpIDIwMDgtMjAxNSBQaXZvdGFsIExhYnNcXG5cXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmdcXG5hIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcXG5cXFwiU29mdHdhcmVcXFwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXFxud2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxcbmRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xcbnBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0b1xcbnRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcXG5cXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxcbmluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxcblxcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcXFwiQVMgSVNcXFwiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxcbkVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxcbk1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXFxuTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRVxcbkxJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT05cXG5PRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT05cXG5XSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cXG4qL1xcbnZhciBnZXRKYXNtaW5lUmVxdWlyZU9iaiA9IChmdW5jdGlvbiAoamFzbWluZUdsb2JhbCkge1xcbiAgdmFyIGphc21pbmVSZXF1aXJlO1xcblxcbiAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XFxuICAgIGphc21pbmVHbG9iYWwgPSBnbG9iYWw7XFxuICAgIGphc21pbmVSZXF1aXJlID0gZXhwb3J0cztcXG4gIH0gZWxzZSB7XFxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LnRvU3RyaW5nID09PSAnZnVuY3Rpb24nICYmIHdpbmRvdy50b1N0cmluZygpID09PSAnW29iamVjdCBHanNHbG9iYWxdJykge1xcbiAgICAgIGphc21pbmVHbG9iYWwgPSB3aW5kb3c7XFxuICAgIH1cXG4gICAgamFzbWluZVJlcXVpcmUgPSBqYXNtaW5lR2xvYmFsLmphc21pbmVSZXF1aXJlID0gamFzbWluZUdsb2JhbC5qYXNtaW5lUmVxdWlyZSB8fCB7fTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGdldEphc21pbmVSZXF1aXJlKCkge1xcbiAgICByZXR1cm4gamFzbWluZVJlcXVpcmU7XFxuICB9XFxuXFxuICBnZXRKYXNtaW5lUmVxdWlyZSgpLmNvcmUgPSBmdW5jdGlvbihqUmVxdWlyZSkge1xcbiAgICB2YXIgaiQgPSB7fTtcXG5cXG4gICAgalJlcXVpcmUuYmFzZShqJCwgamFzbWluZUdsb2JhbCk7XFxuICAgIGokLnV0aWwgPSBqUmVxdWlyZS51dGlsKCk7XFxuICAgIGokLmVycm9ycyA9IGpSZXF1aXJlLmVycm9ycygpO1xcbiAgICBqJC5BbnkgPSBqUmVxdWlyZS5BbnkoaiQpO1xcbiAgICBqJC5Bbnl0aGluZyA9IGpSZXF1aXJlLkFueXRoaW5nKGokKTtcXG4gICAgaiQuQ2FsbFRyYWNrZXIgPSBqUmVxdWlyZS5DYWxsVHJhY2tlcigpO1xcbiAgICBqJC5Nb2NrRGF0ZSA9IGpSZXF1aXJlLk1vY2tEYXRlKCk7XFxuICAgIGokLkNsb2NrID0galJlcXVpcmUuQ2xvY2soKTtcXG4gICAgaiQuRGVsYXllZEZ1bmN0aW9uU2NoZWR1bGVyID0galJlcXVpcmUuRGVsYXllZEZ1bmN0aW9uU2NoZWR1bGVyKCk7XFxuICAgIGokLkVudiA9IGpSZXF1aXJlLkVudihqJCk7XFxuICAgIGokLkV4Y2VwdGlvbkZvcm1hdHRlciA9IGpSZXF1aXJlLkV4Y2VwdGlvbkZvcm1hdHRlcigpO1xcbiAgICBqJC5FeHBlY3RhdGlvbiA9IGpSZXF1aXJlLkV4cGVjdGF0aW9uKCk7XFxuICAgIGokLmJ1aWxkRXhwZWN0YXRpb25SZXN1bHQgPSBqUmVxdWlyZS5idWlsZEV4cGVjdGF0aW9uUmVzdWx0KCk7XFxuICAgIGokLkpzQXBpUmVwb3J0ZXIgPSBqUmVxdWlyZS5Kc0FwaVJlcG9ydGVyKCk7XFxuICAgIGokLm1hdGNoZXJzVXRpbCA9IGpSZXF1aXJlLm1hdGNoZXJzVXRpbChqJCk7XFxuICAgIGokLk9iamVjdENvbnRhaW5pbmcgPSBqUmVxdWlyZS5PYmplY3RDb250YWluaW5nKGokKTtcXG4gICAgaiQuQXJyYXlDb250YWluaW5nID0galJlcXVpcmUuQXJyYXlDb250YWluaW5nKGokKTtcXG4gICAgaiQucHAgPSBqUmVxdWlyZS5wcChqJCk7XFxuICAgIGokLlF1ZXVlUnVubmVyID0galJlcXVpcmUuUXVldWVSdW5uZXIoaiQpO1xcbiAgICBqJC5SZXBvcnREaXNwYXRjaGVyID0galJlcXVpcmUuUmVwb3J0RGlzcGF0Y2hlcigpO1xcbiAgICBqJC5TcGVjID0galJlcXVpcmUuU3BlYyhqJCk7XFxuICAgIGokLlNweVJlZ2lzdHJ5ID0galJlcXVpcmUuU3B5UmVnaXN0cnkoaiQpO1xcbiAgICBqJC5TcHlTdHJhdGVneSA9IGpSZXF1aXJlLlNweVN0cmF0ZWd5KCk7XFxuICAgIGokLlN0cmluZ01hdGNoaW5nID0galJlcXVpcmUuU3RyaW5nTWF0Y2hpbmcoaiQpO1xcbiAgICBqJC5TdWl0ZSA9IGpSZXF1aXJlLlN1aXRlKGokKTtcXG4gICAgaiQuVGltZXIgPSBqUmVxdWlyZS5UaW1lcigpO1xcbiAgICBqJC5UcmVlUHJvY2Vzc29yID0galJlcXVpcmUuVHJlZVByb2Nlc3NvcigpO1xcbiAgICBqJC52ZXJzaW9uID0galJlcXVpcmUudmVyc2lvbigpO1xcblxcbiAgICBqJC5tYXRjaGVycyA9IGpSZXF1aXJlLnJlcXVpcmVNYXRjaGVycyhqUmVxdWlyZSwgaiQpO1xcblxcbiAgICByZXR1cm4gaiQ7XFxuICB9O1xcblxcbiAgcmV0dXJuIGdldEphc21pbmVSZXF1aXJlO1xcbn0pKHRoaXMpO1xcblxcbmdldEphc21pbmVSZXF1aXJlT2JqKCkucmVxdWlyZU1hdGNoZXJzID0gZnVuY3Rpb24oalJlcXVpcmUsIGokKSB7XFxuICB2YXIgYXZhaWxhYmxlTWF0Y2hlcnMgPSBbXFxuICAgICAgJ3RvQmUnLFxcbiAgICAgICd0b0JlQ2xvc2VUbycsXFxuICAgICAgJ3RvQmVEZWZpbmVkJyxcXG4gICAgICAndG9CZUZhbHN5JyxcXG4gICAgICAndG9CZUdyZWF0ZXJUaGFuJyxcXG4gICAgICAndG9CZUxlc3NUaGFuJyxcXG4gICAgICAndG9CZU5hTicsXFxuICAgICAgJ3RvQmVOdWxsJyxcXG4gICAgICAndG9CZVRydXRoeScsXFxuICAgICAgJ3RvQmVVbmRlZmluZWQnLFxcbiAgICAgICd0b0NvbnRhaW4nLFxcbiAgICAgICd0b0VxdWFsJyxcXG4gICAgICAndG9IYXZlQmVlbkNhbGxlZCcsXFxuICAgICAgJ3RvSGF2ZUJlZW5DYWxsZWRXaXRoJyxcXG4gICAgICAndG9NYXRjaCcsXFxuICAgICAgJ3RvVGhyb3cnLFxcbiAgICAgICd0b1Rocm93RXJyb3InXFxuICAgIF0sXFxuICAgIG1hdGNoZXJzID0ge307XFxuXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGF2YWlsYWJsZU1hdGNoZXJzLmxlbmd0aDsgaSsrKSB7XFxuICAgIHZhciBuYW1lID0gYXZhaWxhYmxlTWF0Y2hlcnNbaV07XFxuICAgIG1hdGNoZXJzW25hbWVdID0galJlcXVpcmVbbmFtZV0oaiQpO1xcbiAgfVxcblxcbiAgcmV0dXJuIG1hdGNoZXJzO1xcbn07XFxuXFxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5iYXNlID0gZnVuY3Rpb24oaiQsIGphc21pbmVHbG9iYWwpIHtcXG4gIGokLnVuaW1wbGVtZW50ZWRNZXRob2RfID0gZnVuY3Rpb24oKSB7XFxuICAgIHRocm93IG5ldyBFcnJvcigndW5pbXBsZW1lbnRlZCBtZXRob2QnKTtcXG4gIH07XFxuXFxuICBqJC5NQVhfUFJFVFRZX1BSSU5UX0RFUFRIID0gNDA7XFxuICBqJC5NQVhfUFJFVFRZX1BSSU5UX0FSUkFZX0xFTkdUSCA9IDEwMDtcXG4gIGokLkRFRkFVTFRfVElNRU9VVF9JTlRFUlZBTCA9IDUwMDA7XFxuXFxuICBqJC5nZXRHbG9iYWwgPSBmdW5jdGlvbigpIHtcXG4gICAgcmV0dXJuIGphc21pbmVHbG9iYWw7XFxuICB9O1xcblxcbiAgaiQuZ2V0RW52ID0gZnVuY3Rpb24ob3B0aW9ucykge1xcbiAgICB2YXIgZW52ID0gaiQuY3VycmVudEVudl8gPSBqJC5jdXJyZW50RW52XyB8fCBuZXcgaiQuRW52KG9wdGlvbnMpO1xcbiAgICAvL2phc21pbmUuIHNpbmdsZXRvbnMgaW4gaGVyZSAoc2V0VGltZW91dCBibGFoIGJsYWgpLlxcbiAgICByZXR1cm4gZW52O1xcbiAgfTtcXG5cXG4gIGokLmlzQXJyYXlfID0gZnVuY3Rpb24odmFsdWUpIHtcXG4gICAgcmV0dXJuIGokLmlzQV8oJ0FycmF5JywgdmFsdWUpO1xcbiAgfTtcXG5cXG4gIGokLmlzU3RyaW5nXyA9IGZ1bmN0aW9uKHZhbHVlKSB7XFxuICAgIHJldHVybiBqJC5pc0FfKCdTdHJpbmcnLCB2YWx1ZSk7XFxuICB9O1xcblxcbiAgaiQuaXNOdW1iZXJfID0gZnVuY3Rpb24odmFsdWUpIHtcXG4gICAgcmV0dXJuIGokLmlzQV8oJ051bWJlcicsIHZhbHVlKTtcXG4gIH07XFxuXFxuICBqJC5pc0FfID0gZnVuY3Rpb24odHlwZU5hbWUsIHZhbHVlKSB7XFxuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KHZhbHVlKSA9PT0gJ1tvYmplY3QgJyArIHR5cGVOYW1lICsgJ10nO1xcbiAgfTtcXG5cXG4gIGokLmlzRG9tTm9kZSA9IGZ1bmN0aW9uKG9iaikge1xcbiAgICByZXR1cm4gb2JqLm5vZGVUeXBlID4gMDtcXG4gIH07XFxuXFxuICBqJC5mbk5hbWVGb3IgPSBmdW5jdGlvbihmdW5jKSB7XFxuICAgIHJldHVybiBmdW5jLm5hbWUgfHwgZnVuYy50b1N0cmluZygpLm1hdGNoKC9eXFxcXHMqZnVuY3Rpb25cXFxccyooXFxcXHcqKVxcXFxzKlxcXFwoLylbMV07XFxuICB9O1xcblxcbiAgaiQuYW55ID0gZnVuY3Rpb24oY2xhenopIHtcXG4gICAgcmV0dXJuIG5ldyBqJC5BbnkoY2xhenopO1xcbiAgfTtcXG5cXG4gIGokLmFueXRoaW5nID0gZnVuY3Rpb24oKSB7XFxuICAgIHJldHVybiBuZXcgaiQuQW55dGhpbmcoKTtcXG4gIH07XFxuXFxuICBqJC5vYmplY3RDb250YWluaW5nID0gZnVuY3Rpb24oc2FtcGxlKSB7XFxuICAgIHJldHVybiBuZXcgaiQuT2JqZWN0Q29udGFpbmluZyhzYW1wbGUpO1xcbiAgfTtcXG5cXG4gIGokLnN0cmluZ01hdGNoaW5nID0gZnVuY3Rpb24oZXhwZWN0ZWQpIHtcXG4gICAgcmV0dXJuIG5ldyBqJC5TdHJpbmdNYXRjaGluZyhleHBlY3RlZCk7XFxuICB9O1xcblxcbiAgaiQuYXJyYXlDb250YWluaW5nID0gZnVuY3Rpb24oc2FtcGxlKSB7XFxuICAgIHJldHVybiBuZXcgaiQuQXJyYXlDb250YWluaW5nKHNhbXBsZSk7XFxuICB9O1xcblxcbiAgaiQuY3JlYXRlU3B5ID0gZnVuY3Rpb24obmFtZSwgb3JpZ2luYWxGbikge1xcblxcbiAgICB2YXIgc3B5U3RyYXRlZ3kgPSBuZXcgaiQuU3B5U3RyYXRlZ3koe1xcbiAgICAgICAgbmFtZTogbmFtZSxcXG4gICAgICAgIGZuOiBvcmlnaW5hbEZuLFxcbiAgICAgICAgZ2V0U3B5OiBmdW5jdGlvbigpIHsgcmV0dXJuIHNweTsgfVxcbiAgICAgIH0pLFxcbiAgICAgIGNhbGxUcmFja2VyID0gbmV3IGokLkNhbGxUcmFja2VyKCksXFxuICAgICAgc3B5ID0gZnVuY3Rpb24oKSB7XFxuICAgICAgICB2YXIgY2FsbERhdGEgPSB7XFxuICAgICAgICAgIG9iamVjdDogdGhpcyxcXG4gICAgICAgICAgYXJnczogQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGFyZ3VtZW50cylcXG4gICAgICAgIH07XFxuXFxuICAgICAgICBjYWxsVHJhY2tlci50cmFjayhjYWxsRGF0YSk7XFxuICAgICAgICB2YXIgcmV0dXJuVmFsdWUgPSBzcHlTdHJhdGVneS5leGVjLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICAgICAgICBjYWxsRGF0YS5yZXR1cm5WYWx1ZSA9IHJldHVyblZhbHVlO1xcblxcbiAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xcbiAgICAgIH07XFxuXFxuICAgIGZvciAodmFyIHByb3AgaW4gb3JpZ2luYWxGbikge1xcbiAgICAgIGlmIChwcm9wID09PSAnYW5kJyB8fCBwcm9wID09PSAnY2FsbHMnKSB7XFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0phc21pbmUgc3BpZXMgd291bGQgb3ZlcndyaXRlIHRoZSBcXFxcJ2FuZFxcXFwnIGFuZCBcXFxcJ2NhbGxzXFxcXCcgcHJvcGVydGllcyBvbiB0aGUgb2JqZWN0IGJlaW5nIHNwaWVkIHVwb24nKTtcXG4gICAgICB9XFxuXFxuICAgICAgc3B5W3Byb3BdID0gb3JpZ2luYWxGbltwcm9wXTtcXG4gICAgfVxcblxcbiAgICBzcHkuYW5kID0gc3B5U3RyYXRlZ3k7XFxuICAgIHNweS5jYWxscyA9IGNhbGxUcmFja2VyO1xcblxcbiAgICByZXR1cm4gc3B5O1xcbiAgfTtcXG5cXG4gIGokLmlzU3B5ID0gZnVuY3Rpb24ocHV0YXRpdmVTcHkpIHtcXG4gICAgaWYgKCFwdXRhdGl2ZVNweSkge1xcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcbiAgICByZXR1cm4gcHV0YXRpdmVTcHkuYW5kIGluc3RhbmNlb2YgaiQuU3B5U3RyYXRlZ3kgJiZcXG4gICAgICBwdXRhdGl2ZVNweS5jYWxscyBpbnN0YW5jZW9mIGokLkNhbGxUcmFja2VyO1xcbiAgfTtcXG5cXG4gIGokLmNyZWF0ZVNweU9iaiA9IGZ1bmN0aW9uKGJhc2VOYW1lLCBtZXRob2ROYW1lcykge1xcbiAgICBpZiAoaiQuaXNBcnJheV8oYmFzZU5hbWUpICYmIGokLnV0aWwuaXNVbmRlZmluZWQobWV0aG9kTmFtZXMpKSB7XFxuICAgICAgbWV0aG9kTmFtZXMgPSBiYXNlTmFtZTtcXG4gICAgICBiYXNlTmFtZSA9ICd1bmtub3duJztcXG4gICAgfVxcblxcbiAgICBpZiAoIWokLmlzQXJyYXlfKG1ldGhvZE5hbWVzKSB8fCBtZXRob2ROYW1lcy5sZW5ndGggPT09IDApIHtcXG4gICAgICB0aHJvdyAnY3JlYXRlU3B5T2JqIHJlcXVpcmVzIGEgbm9uLWVtcHR5IGFycmF5IG9mIG1ldGhvZCBuYW1lcyB0byBjcmVhdGUgc3BpZXMgZm9yJztcXG4gICAgfVxcbiAgICB2YXIgb2JqID0ge307XFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWV0aG9kTmFtZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgICBvYmpbbWV0aG9kTmFtZXNbaV1dID0gaiQuY3JlYXRlU3B5KGJhc2VOYW1lICsgJy4nICsgbWV0aG9kTmFtZXNbaV0pO1xcbiAgICB9XFxuICAgIHJldHVybiBvYmo7XFxuICB9O1xcbn07XFxuXFxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS51dGlsID0gZnVuY3Rpb24oKSB7XFxuXFxuICB2YXIgdXRpbCA9IHt9O1xcblxcbiAgdXRpbC5pbmhlcml0ID0gZnVuY3Rpb24oY2hpbGRDbGFzcywgcGFyZW50Q2xhc3MpIHtcXG4gICAgdmFyIFN1YmNsYXNzID0gZnVuY3Rpb24oKSB7XFxuICAgIH07XFxuICAgIFN1YmNsYXNzLnByb3RvdHlwZSA9IHBhcmVudENsYXNzLnByb3RvdHlwZTtcXG4gICAgY2hpbGRDbGFzcy5wcm90b3R5cGUgPSBuZXcgU3ViY2xhc3MoKTtcXG4gIH07XFxuXFxuICB1dGlsLmh0bWxFc2NhcGUgPSBmdW5jdGlvbihzdHIpIHtcXG4gICAgaWYgKCFzdHIpIHtcXG4gICAgICByZXR1cm4gc3RyO1xcbiAgICB9XFxuICAgIHJldHVybiBzdHIucmVwbGFjZSgvJi9nLCAnJmFtcDsnKVxcbiAgICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcXG4gICAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpO1xcbiAgfTtcXG5cXG4gIHV0aWwuYXJnc1RvQXJyYXkgPSBmdW5jdGlvbihhcmdzKSB7XFxuICAgIHZhciBhcnJheU9mQXJncyA9IFtdO1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcXG4gICAgICBhcnJheU9mQXJncy5wdXNoKGFyZ3NbaV0pO1xcbiAgICB9XFxuICAgIHJldHVybiBhcnJheU9mQXJncztcXG4gIH07XFxuXFxuICB1dGlsLmlzVW5kZWZpbmVkID0gZnVuY3Rpb24ob2JqKSB7XFxuICAgIHJldHVybiBvYmogPT09IHZvaWQgMDtcXG4gIH07XFxuXFxuICB1dGlsLmFycmF5Q29udGFpbnMgPSBmdW5jdGlvbihhcnJheSwgc2VhcmNoKSB7XFxuICAgIHZhciBpID0gYXJyYXkubGVuZ3RoO1xcbiAgICB3aGlsZSAoaS0tKSB7XFxuICAgICAgaWYgKGFycmF5W2ldID09PSBzZWFyY2gpIHtcXG4gICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICByZXR1cm4gZmFsc2U7XFxuICB9O1xcblxcbiAgdXRpbC5jbG9uZSA9IGZ1bmN0aW9uKG9iaikge1xcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5hcHBseShvYmopID09PSAnW29iamVjdCBBcnJheV0nKSB7XFxuICAgICAgcmV0dXJuIG9iai5zbGljZSgpO1xcbiAgICB9XFxuXFxuICAgIHZhciBjbG9uZWQgPSB7fTtcXG4gICAgZm9yICh2YXIgcHJvcCBpbiBvYmopIHtcXG4gICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHByb3ApKSB7XFxuICAgICAgICBjbG9uZWRbcHJvcF0gPSBvYmpbcHJvcF07XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHJldHVybiBjbG9uZWQ7XFxuICB9O1xcblxcbiAgcmV0dXJuIHV0aWw7XFxufTtcXG5cXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLlNwZWMgPSBmdW5jdGlvbihqJCkge1xcbiAgZnVuY3Rpb24gU3BlYyhhdHRycykge1xcbiAgICB0aGlzLmV4cGVjdGF0aW9uRmFjdG9yeSA9IGF0dHJzLmV4cGVjdGF0aW9uRmFjdG9yeTtcXG4gICAgdGhpcy5yZXN1bHRDYWxsYmFjayA9IGF0dHJzLnJlc3VsdENhbGxiYWNrIHx8IGZ1bmN0aW9uKCkge307XFxuICAgIHRoaXMuaWQgPSBhdHRycy5pZDtcXG4gICAgdGhpcy5kZXNjcmlwdGlvbiA9IGF0dHJzLmRlc2NyaXB0aW9uIHx8ICcnO1xcbiAgICB0aGlzLnF1ZXVlYWJsZUZuID0gYXR0cnMucXVldWVhYmxlRm47XFxuICAgIHRoaXMuYmVmb3JlQW5kQWZ0ZXJGbnMgPSBhdHRycy5iZWZvcmVBbmRBZnRlckZucyB8fCBmdW5jdGlvbigpIHsgcmV0dXJuIHtiZWZvcmVzOiBbXSwgYWZ0ZXJzOiBbXX07IH07XFxuICAgIHRoaXMudXNlckNvbnRleHQgPSBhdHRycy51c2VyQ29udGV4dCB8fCBmdW5jdGlvbigpIHsgcmV0dXJuIHt9OyB9O1xcbiAgICB0aGlzLm9uU3RhcnQgPSBhdHRycy5vblN0YXJ0IHx8IGZ1bmN0aW9uKCkge307XFxuICAgIHRoaXMuZ2V0U3BlY05hbWUgPSBhdHRycy5nZXRTcGVjTmFtZSB8fCBmdW5jdGlvbigpIHsgcmV0dXJuICcnOyB9O1xcbiAgICB0aGlzLmV4cGVjdGF0aW9uUmVzdWx0RmFjdG9yeSA9IGF0dHJzLmV4cGVjdGF0aW9uUmVzdWx0RmFjdG9yeSB8fCBmdW5jdGlvbigpIHsgfTtcXG4gICAgdGhpcy5xdWV1ZVJ1bm5lckZhY3RvcnkgPSBhdHRycy5xdWV1ZVJ1bm5lckZhY3RvcnkgfHwgZnVuY3Rpb24oKSB7fTtcXG4gICAgdGhpcy5jYXRjaGluZ0V4Y2VwdGlvbnMgPSBhdHRycy5jYXRjaGluZ0V4Y2VwdGlvbnMgfHwgZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9O1xcbiAgICB0aGlzLnRocm93T25FeHBlY3RhdGlvbkZhaWx1cmUgPSAhIWF0dHJzLnRocm93T25FeHBlY3RhdGlvbkZhaWx1cmU7XFxuXFxuICAgIGlmICghdGhpcy5xdWV1ZWFibGVGbi5mbikge1xcbiAgICAgIHRoaXMucGVuZCgpO1xcbiAgICB9XFxuXFxuICAgIHRoaXMucmVzdWx0ID0ge1xcbiAgICAgIGlkOiB0aGlzLmlkLFxcbiAgICAgIGRlc2NyaXB0aW9uOiB0aGlzLmRlc2NyaXB0aW9uLFxcbiAgICAgIGZ1bGxOYW1lOiB0aGlzLmdldEZ1bGxOYW1lKCksXFxuICAgICAgZmFpbGVkRXhwZWN0YXRpb25zOiBbXSxcXG4gICAgICBwYXNzZWRFeHBlY3RhdGlvbnM6IFtdLFxcbiAgICAgIHBlbmRpbmdSZWFzb246ICcnXFxuICAgIH07XFxuICB9XFxuXFxuICBTcGVjLnByb3RvdHlwZS5hZGRFeHBlY3RhdGlvblJlc3VsdCA9IGZ1bmN0aW9uKHBhc3NlZCwgZGF0YSwgaXNFcnJvcikge1xcbiAgICB2YXIgZXhwZWN0YXRpb25SZXN1bHQgPSB0aGlzLmV4cGVjdGF0aW9uUmVzdWx0RmFjdG9yeShkYXRhKTtcXG4gICAgaWYgKHBhc3NlZCkge1xcbiAgICAgIHRoaXMucmVzdWx0LnBhc3NlZEV4cGVjdGF0aW9ucy5wdXNoKGV4cGVjdGF0aW9uUmVzdWx0KTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICB0aGlzLnJlc3VsdC5mYWlsZWRFeHBlY3RhdGlvbnMucHVzaChleHBlY3RhdGlvblJlc3VsdCk7XFxuXFxuICAgICAgaWYgKHRoaXMudGhyb3dPbkV4cGVjdGF0aW9uRmFpbHVyZSAmJiAhaXNFcnJvcikge1xcbiAgICAgICAgdGhyb3cgbmV3IGokLmVycm9ycy5FeHBlY3RhdGlvbkZhaWxlZCgpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfTtcXG5cXG4gIFNwZWMucHJvdG90eXBlLmV4cGVjdCA9IGZ1bmN0aW9uKGFjdHVhbCkge1xcbiAgICByZXR1cm4gdGhpcy5leHBlY3RhdGlvbkZhY3RvcnkoYWN0dWFsLCB0aGlzKTtcXG4gIH07XFxuXFxuICBTcGVjLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24ob25Db21wbGV0ZSwgZW5hYmxlZCkge1xcbiAgICB2YXIgc2VsZiA9IHRoaXM7XFxuXFxuICAgIHRoaXMub25TdGFydCh0aGlzKTtcXG5cXG4gICAgaWYgKCF0aGlzLmlzRXhlY3V0YWJsZSgpIHx8IHRoaXMubWFya2VkUGVuZGluZyB8fCBlbmFibGVkID09PSBmYWxzZSkge1xcbiAgICAgIGNvbXBsZXRlKGVuYWJsZWQpO1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICB2YXIgZm5zID0gdGhpcy5iZWZvcmVBbmRBZnRlckZucygpO1xcbiAgICB2YXIgYWxsRm5zID0gZm5zLmJlZm9yZXMuY29uY2F0KHRoaXMucXVldWVhYmxlRm4pLmNvbmNhdChmbnMuYWZ0ZXJzKTtcXG5cXG4gICAgdGhpcy5xdWV1ZVJ1bm5lckZhY3Rvcnkoe1xcbiAgICAgIHF1ZXVlYWJsZUZuczogYWxsRm5zLFxcbiAgICAgIG9uRXhjZXB0aW9uOiBmdW5jdGlvbigpIHsgc2VsZi5vbkV4Y2VwdGlvbi5hcHBseShzZWxmLCBhcmd1bWVudHMpOyB9LFxcbiAgICAgIG9uQ29tcGxldGU6IGNvbXBsZXRlLFxcbiAgICAgIHVzZXJDb250ZXh0OiB0aGlzLnVzZXJDb250ZXh0KClcXG4gICAgfSk7XFxuXFxuICAgIGZ1bmN0aW9uIGNvbXBsZXRlKGVuYWJsZWRBZ2Fpbikge1xcbiAgICAgIHNlbGYucmVzdWx0LnN0YXR1cyA9IHNlbGYuc3RhdHVzKGVuYWJsZWRBZ2Fpbik7XFxuICAgICAgc2VsZi5yZXN1bHRDYWxsYmFjayhzZWxmLnJlc3VsdCk7XFxuXFxuICAgICAgaWYgKG9uQ29tcGxldGUpIHtcXG4gICAgICAgIG9uQ29tcGxldGUoKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH07XFxuXFxuICBTcGVjLnByb3RvdHlwZS5vbkV4Y2VwdGlvbiA9IGZ1bmN0aW9uIG9uRXhjZXB0aW9uKGUpIHtcXG4gICAgaWYgKFNwZWMuaXNQZW5kaW5nU3BlY0V4Y2VwdGlvbihlKSkge1xcbiAgICAgIHRoaXMucGVuZChleHRyYWN0Q3VzdG9tUGVuZGluZ01lc3NhZ2UoZSkpO1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBpZiAoZSBpbnN0YW5jZW9mIGokLmVycm9ycy5FeHBlY3RhdGlvbkZhaWxlZCkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICB0aGlzLmFkZEV4cGVjdGF0aW9uUmVzdWx0KGZhbHNlLCB7XFxuICAgICAgbWF0Y2hlck5hbWU6ICcnLFxcbiAgICAgIHBhc3NlZDogZmFsc2UsXFxuICAgICAgZXhwZWN0ZWQ6ICcnLFxcbiAgICAgIGFjdHVhbDogJycsXFxuICAgICAgZXJyb3I6IGVcXG4gICAgfSwgdHJ1ZSk7XFxuICB9O1xcblxcbiAgU3BlYy5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uKCkge1xcbiAgICB0aGlzLmRpc2FibGVkID0gdHJ1ZTtcXG4gIH07XFxuXFxuICBTcGVjLnByb3RvdHlwZS5wZW5kID0gZnVuY3Rpb24obWVzc2FnZSkge1xcbiAgICB0aGlzLm1hcmtlZFBlbmRpbmcgPSB0cnVlO1xcbiAgICBpZiAobWVzc2FnZSkge1xcbiAgICAgIHRoaXMucmVzdWx0LnBlbmRpbmdSZWFzb24gPSBtZXNzYWdlO1xcbiAgICB9XFxuICB9O1xcblxcbiAgU3BlYy5wcm90b3R5cGUuZ2V0UmVzdWx0ID0gZnVuY3Rpb24oKSB7XFxuICAgIHRoaXMucmVzdWx0LnN0YXR1cyA9IHRoaXMuc3RhdHVzKCk7XFxuICAgIHJldHVybiB0aGlzLnJlc3VsdDtcXG4gIH07XFxuXFxuICBTcGVjLnByb3RvdHlwZS5zdGF0dXMgPSBmdW5jdGlvbihlbmFibGVkKSB7XFxuICAgIGlmICh0aGlzLmRpc2FibGVkIHx8IGVuYWJsZWQgPT09IGZhbHNlKSB7XFxuICAgICAgcmV0dXJuICdkaXNhYmxlZCc7XFxuICAgIH1cXG5cXG4gICAgaWYgKHRoaXMubWFya2VkUGVuZGluZykge1xcbiAgICAgIHJldHVybiAncGVuZGluZyc7XFxuICAgIH1cXG5cXG4gICAgaWYgKHRoaXMucmVzdWx0LmZhaWxlZEV4cGVjdGF0aW9ucy5sZW5ndGggPiAwKSB7XFxuICAgICAgcmV0dXJuICdmYWlsZWQnO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHJldHVybiAncGFzc2VkJztcXG4gICAgfVxcbiAgfTtcXG5cXG4gIFNwZWMucHJvdG90eXBlLmlzRXhlY3V0YWJsZSA9IGZ1bmN0aW9uKCkge1xcbiAgICByZXR1cm4gIXRoaXMuZGlzYWJsZWQ7XFxuICB9O1xcblxcbiAgU3BlYy5wcm90b3R5cGUuZ2V0RnVsbE5hbWUgPSBmdW5jdGlvbigpIHtcXG4gICAgcmV0dXJuIHRoaXMuZ2V0U3BlY05hbWUodGhpcyk7XFxuICB9O1xcblxcbiAgdmFyIGV4dHJhY3RDdXN0b21QZW5kaW5nTWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcXG4gICAgdmFyIGZ1bGxNZXNzYWdlID0gZS50b1N0cmluZygpLFxcbiAgICAgICAgYm9pbGVycGxhdGVTdGFydCA9IGZ1bGxNZXNzYWdlLmluZGV4T2YoU3BlYy5wZW5kaW5nU3BlY0V4Y2VwdGlvbk1lc3NhZ2UpLFxcbiAgICAgICAgYm9pbGVycGxhdGVFbmQgPSBib2lsZXJwbGF0ZVN0YXJ0ICsgU3BlYy5wZW5kaW5nU3BlY0V4Y2VwdGlvbk1lc3NhZ2UubGVuZ3RoO1xcblxcbiAgICByZXR1cm4gZnVsbE1lc3NhZ2Uuc3Vic3RyKGJvaWxlcnBsYXRlRW5kKTtcXG4gIH07XFxuXFxuICBTcGVjLnBlbmRpbmdTcGVjRXhjZXB0aW9uTWVzc2FnZSA9ICc9PiBtYXJrZWQgUGVuZGluZyc7XFxuXFxuICBTcGVjLmlzUGVuZGluZ1NwZWNFeGNlcHRpb24gPSBmdW5jdGlvbihlKSB7XFxuICAgIHJldHVybiAhIShlICYmIGUudG9TdHJpbmcgJiYgZS50b1N0cmluZygpLmluZGV4T2YoU3BlYy5wZW5kaW5nU3BlY0V4Y2VwdGlvbk1lc3NhZ2UpICE9PSAtMSk7XFxuICB9O1xcblxcbiAgcmV0dXJuIFNwZWM7XFxufTtcXG5cXG5pZiAodHlwZW9mIHdpbmRvdyA9PSB2b2lkIDAgJiYgdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcpIHtcXG4gIGV4cG9ydHMuU3BlYyA9IGphc21pbmVSZXF1aXJlLlNwZWM7XFxufVxcblxcbmdldEphc21pbmVSZXF1aXJlT2JqKCkuRW52ID0gZnVuY3Rpb24oaiQpIHtcXG4gIGZ1bmN0aW9uIEVudihvcHRpb25zKSB7XFxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xcblxcbiAgICB2YXIgc2VsZiA9IHRoaXM7XFxuICAgIHZhciBnbG9iYWwgPSBvcHRpb25zLmdsb2JhbCB8fCBqJC5nZXRHbG9iYWwoKTtcXG5cXG4gICAgdmFyIHRvdGFsU3BlY3NEZWZpbmVkID0gMDtcXG5cXG4gICAgdmFyIGNhdGNoRXhjZXB0aW9ucyA9IHRydWU7XFxuXFxuICAgIHZhciByZWFsU2V0VGltZW91dCA9IGokLmdldEdsb2JhbCgpLnNldFRpbWVvdXQ7XFxuICAgIHZhciByZWFsQ2xlYXJUaW1lb3V0ID0gaiQuZ2V0R2xvYmFsKCkuY2xlYXJUaW1lb3V0O1xcbiAgICB0aGlzLmNsb2NrID0gbmV3IGokLkNsb2NrKGdsb2JhbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IGokLkRlbGF5ZWRGdW5jdGlvblNjaGVkdWxlcigpOyB9LCBuZXcgaiQuTW9ja0RhdGUoZ2xvYmFsKSk7XFxuXFxuICAgIHZhciBydW5uYWJsZUxvb2t1cFRhYmxlID0ge307XFxuICAgIHZhciBydW5uYWJsZVJlc291cmNlcyA9IHt9O1xcblxcbiAgICB2YXIgY3VycmVudFNwZWMgPSBudWxsO1xcbiAgICB2YXIgY3VycmVudGx5RXhlY3V0aW5nU3VpdGVzID0gW107XFxuICAgIHZhciBjdXJyZW50RGVjbGFyYXRpb25TdWl0ZSA9IG51bGw7XFxuICAgIHZhciB0aHJvd09uRXhwZWN0YXRpb25GYWlsdXJlID0gZmFsc2U7XFxuXFxuICAgIHZhciBjdXJyZW50U3VpdGUgPSBmdW5jdGlvbigpIHtcXG4gICAgICByZXR1cm4gY3VycmVudGx5RXhlY3V0aW5nU3VpdGVzW2N1cnJlbnRseUV4ZWN1dGluZ1N1aXRlcy5sZW5ndGggLSAxXTtcXG4gICAgfTtcXG5cXG4gICAgdmFyIGN1cnJlbnRSdW5uYWJsZSA9IGZ1bmN0aW9uKCkge1xcbiAgICAgIHJldHVybiBjdXJyZW50U3BlYyB8fCBjdXJyZW50U3VpdGUoKTtcXG4gICAgfTtcXG5cXG4gICAgdmFyIHJlcG9ydGVyID0gbmV3IGokLlJlcG9ydERpc3BhdGNoZXIoW1xcbiAgICAgICdqYXNtaW5lU3RhcnRlZCcsXFxuICAgICAgJ2phc21pbmVEb25lJyxcXG4gICAgICAnc3VpdGVTdGFydGVkJyxcXG4gICAgICAnc3VpdGVEb25lJyxcXG4gICAgICAnc3BlY1N0YXJ0ZWQnLFxcbiAgICAgICdzcGVjRG9uZSdcXG4gICAgXSk7XFxuXFxuICAgIHRoaXMuc3BlY0ZpbHRlciA9IGZ1bmN0aW9uKCkge1xcbiAgICAgIHJldHVybiB0cnVlO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLmFkZEN1c3RvbUVxdWFsaXR5VGVzdGVyID0gZnVuY3Rpb24odGVzdGVyKSB7XFxuICAgICAgaWYoIWN1cnJlbnRSdW5uYWJsZSgpKSB7XFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0N1c3RvbSBFcXVhbGl0aWVzIG11c3QgYmUgYWRkZWQgaW4gYSBiZWZvcmUgZnVuY3Rpb24gb3IgYSBzcGVjJyk7XFxuICAgICAgfVxcbiAgICAgIHJ1bm5hYmxlUmVzb3VyY2VzW2N1cnJlbnRSdW5uYWJsZSgpLmlkXS5jdXN0b21FcXVhbGl0eVRlc3RlcnMucHVzaCh0ZXN0ZXIpO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLmFkZE1hdGNoZXJzID0gZnVuY3Rpb24obWF0Y2hlcnNUb0FkZCkge1xcbiAgICAgIGlmKCFjdXJyZW50UnVubmFibGUoKSkge1xcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYXRjaGVycyBtdXN0IGJlIGFkZGVkIGluIGEgYmVmb3JlIGZ1bmN0aW9uIG9yIGEgc3BlYycpO1xcbiAgICAgIH1cXG4gICAgICB2YXIgY3VzdG9tTWF0Y2hlcnMgPSBydW5uYWJsZVJlc291cmNlc1tjdXJyZW50UnVubmFibGUoKS5pZF0uY3VzdG9tTWF0Y2hlcnM7XFxuICAgICAgZm9yICh2YXIgbWF0Y2hlck5hbWUgaW4gbWF0Y2hlcnNUb0FkZCkge1xcbiAgICAgICAgY3VzdG9tTWF0Y2hlcnNbbWF0Y2hlck5hbWVdID0gbWF0Y2hlcnNUb0FkZFttYXRjaGVyTmFtZV07XFxuICAgICAgfVxcbiAgICB9O1xcblxcbiAgICBqJC5FeHBlY3RhdGlvbi5hZGRDb3JlTWF0Y2hlcnMoaiQubWF0Y2hlcnMpO1xcblxcbiAgICB2YXIgbmV4dFNwZWNJZCA9IDA7XFxuICAgIHZhciBnZXROZXh0U3BlY0lkID0gZnVuY3Rpb24oKSB7XFxuICAgICAgcmV0dXJuICdzcGVjJyArIG5leHRTcGVjSWQrKztcXG4gICAgfTtcXG5cXG4gICAgdmFyIG5leHRTdWl0ZUlkID0gMDtcXG4gICAgdmFyIGdldE5leHRTdWl0ZUlkID0gZnVuY3Rpb24oKSB7XFxuICAgICAgcmV0dXJuICdzdWl0ZScgKyBuZXh0U3VpdGVJZCsrO1xcbiAgICB9O1xcblxcbiAgICB2YXIgZXhwZWN0YXRpb25GYWN0b3J5ID0gZnVuY3Rpb24oYWN0dWFsLCBzcGVjKSB7XFxuICAgICAgcmV0dXJuIGokLkV4cGVjdGF0aW9uLkZhY3Rvcnkoe1xcbiAgICAgICAgdXRpbDogaiQubWF0Y2hlcnNVdGlsLFxcbiAgICAgICAgY3VzdG9tRXF1YWxpdHlUZXN0ZXJzOiBydW5uYWJsZVJlc291cmNlc1tzcGVjLmlkXS5jdXN0b21FcXVhbGl0eVRlc3RlcnMsXFxuICAgICAgICBjdXN0b21NYXRjaGVyczogcnVubmFibGVSZXNvdXJjZXNbc3BlYy5pZF0uY3VzdG9tTWF0Y2hlcnMsXFxuICAgICAgICBhY3R1YWw6IGFjdHVhbCxcXG4gICAgICAgIGFkZEV4cGVjdGF0aW9uUmVzdWx0OiBhZGRFeHBlY3RhdGlvblJlc3VsdFxcbiAgICAgIH0pO1xcblxcbiAgICAgIGZ1bmN0aW9uIGFkZEV4cGVjdGF0aW9uUmVzdWx0KHBhc3NlZCwgcmVzdWx0KSB7XFxuICAgICAgICByZXR1cm4gc3BlYy5hZGRFeHBlY3RhdGlvblJlc3VsdChwYXNzZWQsIHJlc3VsdCk7XFxuICAgICAgfVxcbiAgICB9O1xcblxcbiAgICB2YXIgZGVmYXVsdFJlc291cmNlc0ZvclJ1bm5hYmxlID0gZnVuY3Rpb24oaWQsIHBhcmVudFJ1bm5hYmxlSWQpIHtcXG4gICAgICB2YXIgcmVzb3VyY2VzID0ge3NwaWVzOiBbXSwgY3VzdG9tRXF1YWxpdHlUZXN0ZXJzOiBbXSwgY3VzdG9tTWF0Y2hlcnM6IHt9fTtcXG5cXG4gICAgICBpZihydW5uYWJsZVJlc291cmNlc1twYXJlbnRSdW5uYWJsZUlkXSl7XFxuICAgICAgICByZXNvdXJjZXMuY3VzdG9tRXF1YWxpdHlUZXN0ZXJzID0gaiQudXRpbC5jbG9uZShydW5uYWJsZVJlc291cmNlc1twYXJlbnRSdW5uYWJsZUlkXS5jdXN0b21FcXVhbGl0eVRlc3RlcnMpO1xcbiAgICAgICAgcmVzb3VyY2VzLmN1c3RvbU1hdGNoZXJzID0gaiQudXRpbC5jbG9uZShydW5uYWJsZVJlc291cmNlc1twYXJlbnRSdW5uYWJsZUlkXS5jdXN0b21NYXRjaGVycyk7XFxuICAgICAgfVxcblxcbiAgICAgIHJ1bm5hYmxlUmVzb3VyY2VzW2lkXSA9IHJlc291cmNlcztcXG4gICAgfTtcXG5cXG4gICAgdmFyIGNsZWFyUmVzb3VyY2VzRm9yUnVubmFibGUgPSBmdW5jdGlvbihpZCkge1xcbiAgICAgICAgc3B5UmVnaXN0cnkuY2xlYXJTcGllcygpO1xcbiAgICAgICAgZGVsZXRlIHJ1bm5hYmxlUmVzb3VyY2VzW2lkXTtcXG4gICAgfTtcXG5cXG4gICAgdmFyIGJlZm9yZUFuZEFmdGVyRm5zID0gZnVuY3Rpb24oc3VpdGUpIHtcXG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XFxuICAgICAgICB2YXIgYmVmb3JlcyA9IFtdLFxcbiAgICAgICAgICBhZnRlcnMgPSBbXTtcXG5cXG4gICAgICAgIHdoaWxlKHN1aXRlKSB7XFxuICAgICAgICAgIGJlZm9yZXMgPSBiZWZvcmVzLmNvbmNhdChzdWl0ZS5iZWZvcmVGbnMpO1xcbiAgICAgICAgICBhZnRlcnMgPSBhZnRlcnMuY29uY2F0KHN1aXRlLmFmdGVyRm5zKTtcXG5cXG4gICAgICAgICAgc3VpdGUgPSBzdWl0ZS5wYXJlbnRTdWl0ZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgIGJlZm9yZXM6IGJlZm9yZXMucmV2ZXJzZSgpLFxcbiAgICAgICAgICBhZnRlcnM6IGFmdGVyc1xcbiAgICAgICAgfTtcXG4gICAgICB9O1xcbiAgICB9O1xcblxcbiAgICB2YXIgZ2V0U3BlY05hbWUgPSBmdW5jdGlvbihzcGVjLCBzdWl0ZSkge1xcbiAgICAgIHJldHVybiBzdWl0ZS5nZXRGdWxsTmFtZSgpICsgJyAnICsgc3BlYy5kZXNjcmlwdGlvbjtcXG4gICAgfTtcXG5cXG4gICAgLy8gVE9ETzogd2UgbWF5IGp1c3QgYmUgYWJsZSB0byBwYXNzIGluIHRoZSBmbiBpbnN0ZWFkIG9mIHdyYXBwaW5nIGhlcmVcXG4gICAgdmFyIGJ1aWxkRXhwZWN0YXRpb25SZXN1bHQgPSBqJC5idWlsZEV4cGVjdGF0aW9uUmVzdWx0LFxcbiAgICAgICAgZXhjZXB0aW9uRm9ybWF0dGVyID0gbmV3IGokLkV4Y2VwdGlvbkZvcm1hdHRlcigpLFxcbiAgICAgICAgZXhwZWN0YXRpb25SZXN1bHRGYWN0b3J5ID0gZnVuY3Rpb24oYXR0cnMpIHtcXG4gICAgICAgICAgYXR0cnMubWVzc2FnZUZvcm1hdHRlciA9IGV4Y2VwdGlvbkZvcm1hdHRlci5tZXNzYWdlO1xcbiAgICAgICAgICBhdHRycy5zdGFja0Zvcm1hdHRlciA9IGV4Y2VwdGlvbkZvcm1hdHRlci5zdGFjaztcXG5cXG4gICAgICAgICAgcmV0dXJuIGJ1aWxkRXhwZWN0YXRpb25SZXN1bHQoYXR0cnMpO1xcbiAgICAgICAgfTtcXG5cXG4gICAgLy8gVE9ETzogZml4IHRoaXMgbmFtaW5nLCBhbmQgaGVyZSdzIHdoZXJlIHRoZSB2YWx1ZSBjb21lcyBpblxcbiAgICB0aGlzLmNhdGNoRXhjZXB0aW9ucyA9IGZ1bmN0aW9uKHZhbHVlKSB7XFxuICAgICAgY2F0Y2hFeGNlcHRpb25zID0gISF2YWx1ZTtcXG4gICAgICByZXR1cm4gY2F0Y2hFeGNlcHRpb25zO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLmNhdGNoaW5nRXhjZXB0aW9ucyA9IGZ1bmN0aW9uKCkge1xcbiAgICAgIHJldHVybiBjYXRjaEV4Y2VwdGlvbnM7XFxuICAgIH07XFxuXFxuICAgIHZhciBtYXhpbXVtU3BlY0NhbGxiYWNrRGVwdGggPSAyMDtcXG4gICAgdmFyIGN1cnJlbnRTcGVjQ2FsbGJhY2tEZXB0aCA9IDA7XFxuXFxuICAgIGZ1bmN0aW9uIGNsZWFyU3RhY2soZm4pIHtcXG4gICAgICBjdXJyZW50U3BlY0NhbGxiYWNrRGVwdGgrKztcXG4gICAgICBpZiAoY3VycmVudFNwZWNDYWxsYmFja0RlcHRoID49IG1heGltdW1TcGVjQ2FsbGJhY2tEZXB0aCkge1xcbiAgICAgICAgY3VycmVudFNwZWNDYWxsYmFja0RlcHRoID0gMDtcXG4gICAgICAgIHJlYWxTZXRUaW1lb3V0KGZuLCAwKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgZm4oKTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgdmFyIGNhdGNoRXhjZXB0aW9uID0gZnVuY3Rpb24oZSkge1xcbiAgICAgIHJldHVybiBqJC5TcGVjLmlzUGVuZGluZ1NwZWNFeGNlcHRpb24oZSkgfHwgY2F0Y2hFeGNlcHRpb25zO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLnRocm93T25FeHBlY3RhdGlvbkZhaWx1cmUgPSBmdW5jdGlvbih2YWx1ZSkge1xcbiAgICAgIHRocm93T25FeHBlY3RhdGlvbkZhaWx1cmUgPSAhIXZhbHVlO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLnRocm93aW5nRXhwZWN0YXRpb25GYWlsdXJlcyA9IGZ1bmN0aW9uKCkge1xcbiAgICAgIHJldHVybiB0aHJvd09uRXhwZWN0YXRpb25GYWlsdXJlO1xcbiAgICB9O1xcblxcbiAgICB2YXIgcXVldWVSdW5uZXJGYWN0b3J5ID0gZnVuY3Rpb24ob3B0aW9ucykge1xcbiAgICAgIG9wdGlvbnMuY2F0Y2hFeGNlcHRpb24gPSBjYXRjaEV4Y2VwdGlvbjtcXG4gICAgICBvcHRpb25zLmNsZWFyU3RhY2sgPSBvcHRpb25zLmNsZWFyU3RhY2sgfHwgY2xlYXJTdGFjaztcXG4gICAgICBvcHRpb25zLnRpbWVvdXQgPSB7c2V0VGltZW91dDogcmVhbFNldFRpbWVvdXQsIGNsZWFyVGltZW91dDogcmVhbENsZWFyVGltZW91dH07XFxuICAgICAgb3B0aW9ucy5mYWlsID0gc2VsZi5mYWlsO1xcblxcbiAgICAgIG5ldyBqJC5RdWV1ZVJ1bm5lcihvcHRpb25zKS5leGVjdXRlKCk7XFxuICAgIH07XFxuXFxuICAgIHZhciB0b3BTdWl0ZSA9IG5ldyBqJC5TdWl0ZSh7XFxuICAgICAgZW52OiB0aGlzLFxcbiAgICAgIGlkOiBnZXROZXh0U3VpdGVJZCgpLFxcbiAgICAgIGRlc2NyaXB0aW9uOiAnSmFzbWluZV9fVG9wTGV2ZWxfX1N1aXRlJyxcXG4gICAgICBxdWV1ZVJ1bm5lcjogcXVldWVSdW5uZXJGYWN0b3J5XFxuICAgIH0pO1xcbiAgICBydW5uYWJsZUxvb2t1cFRhYmxlW3RvcFN1aXRlLmlkXSA9IHRvcFN1aXRlO1xcbiAgICBkZWZhdWx0UmVzb3VyY2VzRm9yUnVubmFibGUodG9wU3VpdGUuaWQpO1xcbiAgICBjdXJyZW50RGVjbGFyYXRpb25TdWl0ZSA9IHRvcFN1aXRlO1xcblxcbiAgICB0aGlzLnRvcFN1aXRlID0gZnVuY3Rpb24oKSB7XFxuICAgICAgcmV0dXJuIHRvcFN1aXRlO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLmV4ZWN1dGUgPSBmdW5jdGlvbihydW5uYWJsZXNUb1J1bikge1xcbiAgICAgIGlmKCFydW5uYWJsZXNUb1J1bikge1xcbiAgICAgICAgaWYgKGZvY3VzZWRSdW5uYWJsZXMubGVuZ3RoKSB7XFxuICAgICAgICAgIHJ1bm5hYmxlc1RvUnVuID0gZm9jdXNlZFJ1bm5hYmxlcztcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHJ1bm5hYmxlc1RvUnVuID0gW3RvcFN1aXRlLmlkXTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgdmFyIHByb2Nlc3NvciA9IG5ldyBqJC5UcmVlUHJvY2Vzc29yKHtcXG4gICAgICAgIHRyZWU6IHRvcFN1aXRlLFxcbiAgICAgICAgcnVubmFibGVJZHM6IHJ1bm5hYmxlc1RvUnVuLFxcbiAgICAgICAgcXVldWVSdW5uZXJGYWN0b3J5OiBxdWV1ZVJ1bm5lckZhY3RvcnksXFxuICAgICAgICBub2RlU3RhcnQ6IGZ1bmN0aW9uKHN1aXRlKSB7XFxuICAgICAgICAgIGN1cnJlbnRseUV4ZWN1dGluZ1N1aXRlcy5wdXNoKHN1aXRlKTtcXG4gICAgICAgICAgZGVmYXVsdFJlc291cmNlc0ZvclJ1bm5hYmxlKHN1aXRlLmlkLCBzdWl0ZS5wYXJlbnRTdWl0ZS5pZCk7XFxuICAgICAgICAgIHJlcG9ydGVyLnN1aXRlU3RhcnRlZChzdWl0ZS5yZXN1bHQpO1xcbiAgICAgICAgfSxcXG4gICAgICAgIG5vZGVDb21wbGV0ZTogZnVuY3Rpb24oc3VpdGUsIHJlc3VsdCkge1xcbiAgICAgICAgICBpZiAoIXN1aXRlLmRpc2FibGVkKSB7XFxuICAgICAgICAgICAgY2xlYXJSZXNvdXJjZXNGb3JSdW5uYWJsZShzdWl0ZS5pZCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgY3VycmVudGx5RXhlY3V0aW5nU3VpdGVzLnBvcCgpO1xcbiAgICAgICAgICByZXBvcnRlci5zdWl0ZURvbmUocmVzdWx0KTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG5cXG4gICAgICBpZighcHJvY2Vzc29yLnByb2Nlc3NUcmVlKCkudmFsaWQpIHtcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBvcmRlcjogd291bGQgY2F1c2UgYSBiZWZvcmVBbGwgb3IgYWZ0ZXJBbGwgdG8gYmUgcnVuIG11bHRpcGxlIHRpbWVzJyk7XFxuICAgICAgfVxcblxcbiAgICAgIHJlcG9ydGVyLmphc21pbmVTdGFydGVkKHtcXG4gICAgICAgIHRvdGFsU3BlY3NEZWZpbmVkOiB0b3RhbFNwZWNzRGVmaW5lZFxcbiAgICAgIH0pO1xcblxcbiAgICAgIHByb2Nlc3Nvci5leGVjdXRlKHJlcG9ydGVyLmphc21pbmVEb25lKTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5hZGRSZXBvcnRlciA9IGZ1bmN0aW9uKHJlcG9ydGVyVG9BZGQpIHtcXG4gICAgICByZXBvcnRlci5hZGRSZXBvcnRlcihyZXBvcnRlclRvQWRkKTtcXG4gICAgfTtcXG5cXG4gICAgdmFyIHNweVJlZ2lzdHJ5ID0gbmV3IGokLlNweVJlZ2lzdHJ5KHtjdXJyZW50U3BpZXM6IGZ1bmN0aW9uKCkge1xcbiAgICAgIGlmKCFjdXJyZW50UnVubmFibGUoKSkge1xcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTcGllcyBtdXN0IGJlIGNyZWF0ZWQgaW4gYSBiZWZvcmUgZnVuY3Rpb24gb3IgYSBzcGVjJyk7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBydW5uYWJsZVJlc291cmNlc1tjdXJyZW50UnVubmFibGUoKS5pZF0uc3BpZXM7XFxuICAgIH19KTtcXG5cXG4gICAgdGhpcy5zcHlPbiA9IGZ1bmN0aW9uKCkge1xcbiAgICAgIHJldHVybiBzcHlSZWdpc3RyeS5zcHlPbi5hcHBseShzcHlSZWdpc3RyeSwgYXJndW1lbnRzKTtcXG4gICAgfTtcXG5cXG4gICAgdmFyIHN1aXRlRmFjdG9yeSA9IGZ1bmN0aW9uKGRlc2NyaXB0aW9uKSB7XFxuICAgICAgdmFyIHN1aXRlID0gbmV3IGokLlN1aXRlKHtcXG4gICAgICAgIGVudjogc2VsZixcXG4gICAgICAgIGlkOiBnZXROZXh0U3VpdGVJZCgpLFxcbiAgICAgICAgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uLFxcbiAgICAgICAgcGFyZW50U3VpdGU6IGN1cnJlbnREZWNsYXJhdGlvblN1aXRlLFxcbiAgICAgICAgZXhwZWN0YXRpb25GYWN0b3J5OiBleHBlY3RhdGlvbkZhY3RvcnksXFxuICAgICAgICBleHBlY3RhdGlvblJlc3VsdEZhY3Rvcnk6IGV4cGVjdGF0aW9uUmVzdWx0RmFjdG9yeSxcXG4gICAgICAgIHRocm93T25FeHBlY3RhdGlvbkZhaWx1cmU6IHRocm93T25FeHBlY3RhdGlvbkZhaWx1cmVcXG4gICAgICB9KTtcXG5cXG4gICAgICBydW5uYWJsZUxvb2t1cFRhYmxlW3N1aXRlLmlkXSA9IHN1aXRlO1xcbiAgICAgIHJldHVybiBzdWl0ZTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5kZXNjcmliZSA9IGZ1bmN0aW9uKGRlc2NyaXB0aW9uLCBzcGVjRGVmaW5pdGlvbnMpIHtcXG4gICAgICB2YXIgc3VpdGUgPSBzdWl0ZUZhY3RvcnkoZGVzY3JpcHRpb24pO1xcbiAgICAgIGFkZFNwZWNzVG9TdWl0ZShzdWl0ZSwgc3BlY0RlZmluaXRpb25zKTtcXG4gICAgICByZXR1cm4gc3VpdGU7XFxuICAgIH07XFxuXFxuICAgIHRoaXMueGRlc2NyaWJlID0gZnVuY3Rpb24oZGVzY3JpcHRpb24sIHNwZWNEZWZpbml0aW9ucykge1xcbiAgICAgIHZhciBzdWl0ZSA9IHRoaXMuZGVzY3JpYmUoZGVzY3JpcHRpb24sIHNwZWNEZWZpbml0aW9ucyk7XFxuICAgICAgc3VpdGUuZGlzYWJsZSgpO1xcbiAgICAgIHJldHVybiBzdWl0ZTtcXG4gICAgfTtcXG5cXG4gICAgdmFyIGZvY3VzZWRSdW5uYWJsZXMgPSBbXTtcXG5cXG4gICAgdGhpcy5mZGVzY3JpYmUgPSBmdW5jdGlvbihkZXNjcmlwdGlvbiwgc3BlY0RlZmluaXRpb25zKSB7XFxuICAgICAgdmFyIHN1aXRlID0gc3VpdGVGYWN0b3J5KGRlc2NyaXB0aW9uKTtcXG4gICAgICBzdWl0ZS5pc0ZvY3VzZWQgPSB0cnVlO1xcblxcbiAgICAgIGZvY3VzZWRSdW5uYWJsZXMucHVzaChzdWl0ZS5pZCk7XFxuICAgICAgdW5mb2N1c0FuY2VzdG9yKCk7XFxuICAgICAgYWRkU3BlY3NUb1N1aXRlKHN1aXRlLCBzcGVjRGVmaW5pdGlvbnMpO1xcblxcbiAgICAgIHJldHVybiBzdWl0ZTtcXG4gICAgfTtcXG5cXG4gICAgZnVuY3Rpb24gYWRkU3BlY3NUb1N1aXRlKHN1aXRlLCBzcGVjRGVmaW5pdGlvbnMpIHtcXG4gICAgICB2YXIgcGFyZW50U3VpdGUgPSBjdXJyZW50RGVjbGFyYXRpb25TdWl0ZTtcXG4gICAgICBwYXJlbnRTdWl0ZS5hZGRDaGlsZChzdWl0ZSk7XFxuICAgICAgY3VycmVudERlY2xhcmF0aW9uU3VpdGUgPSBzdWl0ZTtcXG5cXG4gICAgICB2YXIgZGVjbGFyYXRpb25FcnJvciA9IG51bGw7XFxuICAgICAgdHJ5IHtcXG4gICAgICAgIHNwZWNEZWZpbml0aW9ucy5jYWxsKHN1aXRlKTtcXG4gICAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICBkZWNsYXJhdGlvbkVycm9yID0gZTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGRlY2xhcmF0aW9uRXJyb3IpIHtcXG4gICAgICAgIHNlbGYuaXQoJ2VuY291bnRlcmVkIGEgZGVjbGFyYXRpb24gZXhjZXB0aW9uJywgZnVuY3Rpb24oKSB7XFxuICAgICAgICAgIHRocm93IGRlY2xhcmF0aW9uRXJyb3I7XFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuXFxuICAgICAgY3VycmVudERlY2xhcmF0aW9uU3VpdGUgPSBwYXJlbnRTdWl0ZTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBmaW5kRm9jdXNlZEFuY2VzdG9yKHN1aXRlKSB7XFxuICAgICAgd2hpbGUgKHN1aXRlKSB7XFxuICAgICAgICBpZiAoc3VpdGUuaXNGb2N1c2VkKSB7XFxuICAgICAgICAgIHJldHVybiBzdWl0ZS5pZDtcXG4gICAgICAgIH1cXG4gICAgICAgIHN1aXRlID0gc3VpdGUucGFyZW50U3VpdGU7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBudWxsO1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIHVuZm9jdXNBbmNlc3RvcigpIHtcXG4gICAgICB2YXIgZm9jdXNlZEFuY2VzdG9yID0gZmluZEZvY3VzZWRBbmNlc3RvcihjdXJyZW50RGVjbGFyYXRpb25TdWl0ZSk7XFxuICAgICAgaWYgKGZvY3VzZWRBbmNlc3Rvcikge1xcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb2N1c2VkUnVubmFibGVzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgIGlmIChmb2N1c2VkUnVubmFibGVzW2ldID09PSBmb2N1c2VkQW5jZXN0b3IpIHtcXG4gICAgICAgICAgICBmb2N1c2VkUnVubmFibGVzLnNwbGljZShpLCAxKTtcXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICB2YXIgc3BlY0ZhY3RvcnkgPSBmdW5jdGlvbihkZXNjcmlwdGlvbiwgZm4sIHN1aXRlLCB0aW1lb3V0KSB7XFxuICAgICAgdG90YWxTcGVjc0RlZmluZWQrKztcXG4gICAgICB2YXIgc3BlYyA9IG5ldyBqJC5TcGVjKHtcXG4gICAgICAgIGlkOiBnZXROZXh0U3BlY0lkKCksXFxuICAgICAgICBiZWZvcmVBbmRBZnRlckZuczogYmVmb3JlQW5kQWZ0ZXJGbnMoc3VpdGUpLFxcbiAgICAgICAgZXhwZWN0YXRpb25GYWN0b3J5OiBleHBlY3RhdGlvbkZhY3RvcnksXFxuICAgICAgICByZXN1bHRDYWxsYmFjazogc3BlY1Jlc3VsdENhbGxiYWNrLFxcbiAgICAgICAgZ2V0U3BlY05hbWU6IGZ1bmN0aW9uKHNwZWMpIHtcXG4gICAgICAgICAgcmV0dXJuIGdldFNwZWNOYW1lKHNwZWMsIHN1aXRlKTtcXG4gICAgICAgIH0sXFxuICAgICAgICBvblN0YXJ0OiBzcGVjU3RhcnRlZCxcXG4gICAgICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbixcXG4gICAgICAgIGV4cGVjdGF0aW9uUmVzdWx0RmFjdG9yeTogZXhwZWN0YXRpb25SZXN1bHRGYWN0b3J5LFxcbiAgICAgICAgcXVldWVSdW5uZXJGYWN0b3J5OiBxdWV1ZVJ1bm5lckZhY3RvcnksXFxuICAgICAgICB1c2VyQ29udGV4dDogZnVuY3Rpb24oKSB7IHJldHVybiBzdWl0ZS5jbG9uZWRTaGFyZWRVc2VyQ29udGV4dCgpOyB9LFxcbiAgICAgICAgcXVldWVhYmxlRm46IHtcXG4gICAgICAgICAgZm46IGZuLFxcbiAgICAgICAgICB0aW1lb3V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRpbWVvdXQgfHwgaiQuREVGQVVMVF9USU1FT1VUX0lOVEVSVkFMOyB9XFxuICAgICAgICB9LFxcbiAgICAgICAgdGhyb3dPbkV4cGVjdGF0aW9uRmFpbHVyZTogdGhyb3dPbkV4cGVjdGF0aW9uRmFpbHVyZVxcbiAgICAgIH0pO1xcblxcbiAgICAgIHJ1bm5hYmxlTG9va3VwVGFibGVbc3BlYy5pZF0gPSBzcGVjO1xcblxcbiAgICAgIGlmICghc2VsZi5zcGVjRmlsdGVyKHNwZWMpKSB7XFxuICAgICAgICBzcGVjLmRpc2FibGUoKTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHNwZWM7XFxuXFxuICAgICAgZnVuY3Rpb24gc3BlY1Jlc3VsdENhbGxiYWNrKHJlc3VsdCkge1xcbiAgICAgICAgY2xlYXJSZXNvdXJjZXNGb3JSdW5uYWJsZShzcGVjLmlkKTtcXG4gICAgICAgIGN1cnJlbnRTcGVjID0gbnVsbDtcXG4gICAgICAgIHJlcG9ydGVyLnNwZWNEb25lKHJlc3VsdCk7XFxuICAgICAgfVxcblxcbiAgICAgIGZ1bmN0aW9uIHNwZWNTdGFydGVkKHNwZWMpIHtcXG4gICAgICAgIGN1cnJlbnRTcGVjID0gc3BlYztcXG4gICAgICAgIGRlZmF1bHRSZXNvdXJjZXNGb3JSdW5uYWJsZShzcGVjLmlkLCBzdWl0ZS5pZCk7XFxuICAgICAgICByZXBvcnRlci5zcGVjU3RhcnRlZChzcGVjLnJlc3VsdCk7XFxuICAgICAgfVxcbiAgICB9O1xcblxcbiAgICB0aGlzLml0ID0gZnVuY3Rpb24oZGVzY3JpcHRpb24sIGZuLCB0aW1lb3V0KSB7XFxuICAgICAgdmFyIHNwZWMgPSBzcGVjRmFjdG9yeShkZXNjcmlwdGlvbiwgZm4sIGN1cnJlbnREZWNsYXJhdGlvblN1aXRlLCB0aW1lb3V0KTtcXG4gICAgICBjdXJyZW50RGVjbGFyYXRpb25TdWl0ZS5hZGRDaGlsZChzcGVjKTtcXG4gICAgICByZXR1cm4gc3BlYztcXG4gICAgfTtcXG5cXG4gICAgdGhpcy54aXQgPSBmdW5jdGlvbigpIHtcXG4gICAgICB2YXIgc3BlYyA9IHRoaXMuaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gICAgICBzcGVjLnBlbmQoKTtcXG4gICAgICByZXR1cm4gc3BlYztcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5maXQgPSBmdW5jdGlvbigpe1xcbiAgICAgIHZhciBzcGVjID0gdGhpcy5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcblxcbiAgICAgIGZvY3VzZWRSdW5uYWJsZXMucHVzaChzcGVjLmlkKTtcXG4gICAgICB1bmZvY3VzQW5jZXN0b3IoKTtcXG4gICAgICByZXR1cm4gc3BlYztcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5leHBlY3QgPSBmdW5jdGlvbihhY3R1YWwpIHtcXG4gICAgICBpZiAoIWN1cnJlbnRSdW5uYWJsZSgpKSB7XFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1xcXFwnZXhwZWN0XFxcXCcgd2FzIHVzZWQgd2hlbiB0aGVyZSB3YXMgbm8gY3VycmVudCBzcGVjLCB0aGlzIGNvdWxkIGJlIGJlY2F1c2UgYW4gYXN5bmNocm9ub3VzIHRlc3QgdGltZWQgb3V0Jyk7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBjdXJyZW50UnVubmFibGUoKS5leHBlY3QoYWN0dWFsKTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5iZWZvcmVFYWNoID0gZnVuY3Rpb24oYmVmb3JlRWFjaEZ1bmN0aW9uLCB0aW1lb3V0KSB7XFxuICAgICAgY3VycmVudERlY2xhcmF0aW9uU3VpdGUuYmVmb3JlRWFjaCh7XFxuICAgICAgICBmbjogYmVmb3JlRWFjaEZ1bmN0aW9uLFxcbiAgICAgICAgdGltZW91dDogZnVuY3Rpb24oKSB7IHJldHVybiB0aW1lb3V0IHx8IGokLkRFRkFVTFRfVElNRU9VVF9JTlRFUlZBTDsgfVxcbiAgICAgIH0pO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLmJlZm9yZUFsbCA9IGZ1bmN0aW9uKGJlZm9yZUFsbEZ1bmN0aW9uLCB0aW1lb3V0KSB7XFxuICAgICAgY3VycmVudERlY2xhcmF0aW9uU3VpdGUuYmVmb3JlQWxsKHtcXG4gICAgICAgIGZuOiBiZWZvcmVBbGxGdW5jdGlvbixcXG4gICAgICAgIHRpbWVvdXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGltZW91dCB8fCBqJC5ERUZBVUxUX1RJTUVPVVRfSU5URVJWQUw7IH1cXG4gICAgICB9KTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5hZnRlckVhY2ggPSBmdW5jdGlvbihhZnRlckVhY2hGdW5jdGlvbiwgdGltZW91dCkge1xcbiAgICAgIGN1cnJlbnREZWNsYXJhdGlvblN1aXRlLmFmdGVyRWFjaCh7XFxuICAgICAgICBmbjogYWZ0ZXJFYWNoRnVuY3Rpb24sXFxuICAgICAgICB0aW1lb3V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRpbWVvdXQgfHwgaiQuREVGQVVMVF9USU1FT1VUX0lOVEVSVkFMOyB9XFxuICAgICAgfSk7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuYWZ0ZXJBbGwgPSBmdW5jdGlvbihhZnRlckFsbEZ1bmN0aW9uLCB0aW1lb3V0KSB7XFxuICAgICAgY3VycmVudERlY2xhcmF0aW9uU3VpdGUuYWZ0ZXJBbGwoe1xcbiAgICAgICAgZm46IGFmdGVyQWxsRnVuY3Rpb24sXFxuICAgICAgICB0aW1lb3V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRpbWVvdXQgfHwgaiQuREVGQVVMVF9USU1FT1VUX0lOVEVSVkFMOyB9XFxuICAgICAgfSk7XFxuICAgIH07XFxuXFxuICAgIHRoaXMucGVuZGluZyA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcXG4gICAgICB2YXIgZnVsbE1lc3NhZ2UgPSBqJC5TcGVjLnBlbmRpbmdTcGVjRXhjZXB0aW9uTWVzc2FnZTtcXG4gICAgICBpZihtZXNzYWdlKSB7XFxuICAgICAgICBmdWxsTWVzc2FnZSArPSBtZXNzYWdlO1xcbiAgICAgIH1cXG4gICAgICB0aHJvdyBmdWxsTWVzc2FnZTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5mYWlsID0gZnVuY3Rpb24oZXJyb3IpIHtcXG4gICAgICB2YXIgbWVzc2FnZSA9ICdGYWlsZWQnO1xcbiAgICAgIGlmIChlcnJvcikge1xcbiAgICAgICAgbWVzc2FnZSArPSAnOiAnO1xcbiAgICAgICAgbWVzc2FnZSArPSBlcnJvci5tZXNzYWdlIHx8IGVycm9yO1xcbiAgICAgIH1cXG5cXG4gICAgICBjdXJyZW50UnVubmFibGUoKS5hZGRFeHBlY3RhdGlvblJlc3VsdChmYWxzZSwge1xcbiAgICAgICAgbWF0Y2hlck5hbWU6ICcnLFxcbiAgICAgICAgcGFzc2VkOiBmYWxzZSxcXG4gICAgICAgIGV4cGVjdGVkOiAnJyxcXG4gICAgICAgIGFjdHVhbDogJycsXFxuICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxcbiAgICAgICAgZXJyb3I6IGVycm9yICYmIGVycm9yLm1lc3NhZ2UgPyBlcnJvciA6IG51bGxcXG4gICAgICB9KTtcXG4gICAgfTtcXG4gIH1cXG5cXG4gIHJldHVybiBFbnY7XFxufTtcXG5cXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLkpzQXBpUmVwb3J0ZXIgPSBmdW5jdGlvbigpIHtcXG5cXG4gIHZhciBub29wVGltZXIgPSB7XFxuICAgIHN0YXJ0OiBmdW5jdGlvbigpe30sXFxuICAgIGVsYXBzZWQ6IGZ1bmN0aW9uKCl7IHJldHVybiAwOyB9XFxuICB9O1xcblxcbiAgZnVuY3Rpb24gSnNBcGlSZXBvcnRlcihvcHRpb25zKSB7XFxuICAgIHZhciB0aW1lciA9IG9wdGlvbnMudGltZXIgfHwgbm9vcFRpbWVyLFxcbiAgICAgICAgc3RhdHVzID0gJ2xvYWRlZCc7XFxuXFxuICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xcbiAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XFxuXFxuICAgIHRoaXMuamFzbWluZVN0YXJ0ZWQgPSBmdW5jdGlvbigpIHtcXG4gICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xcbiAgICAgIHN0YXR1cyA9ICdzdGFydGVkJztcXG4gICAgICB0aW1lci5zdGFydCgpO1xcbiAgICB9O1xcblxcbiAgICB2YXIgZXhlY3V0aW9uVGltZTtcXG5cXG4gICAgdGhpcy5qYXNtaW5lRG9uZSA9IGZ1bmN0aW9uKCkge1xcbiAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xcbiAgICAgIGV4ZWN1dGlvblRpbWUgPSB0aW1lci5lbGFwc2VkKCk7XFxuICAgICAgc3RhdHVzID0gJ2RvbmUnO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLnN0YXR1cyA9IGZ1bmN0aW9uKCkge1xcbiAgICAgIHJldHVybiBzdGF0dXM7XFxuICAgIH07XFxuXFxuICAgIHZhciBzdWl0ZXMgPSBbXSxcXG4gICAgICBzdWl0ZXNfaGFzaCA9IHt9O1xcblxcbiAgICB0aGlzLnN1aXRlU3RhcnRlZCA9IGZ1bmN0aW9uKHJlc3VsdCkge1xcbiAgICAgIHN1aXRlc19oYXNoW3Jlc3VsdC5pZF0gPSByZXN1bHQ7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuc3VpdGVEb25lID0gZnVuY3Rpb24ocmVzdWx0KSB7XFxuICAgICAgc3RvcmVTdWl0ZShyZXN1bHQpO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLnN1aXRlUmVzdWx0cyA9IGZ1bmN0aW9uKGluZGV4LCBsZW5ndGgpIHtcXG4gICAgICByZXR1cm4gc3VpdGVzLnNsaWNlKGluZGV4LCBpbmRleCArIGxlbmd0aCk7XFxuICAgIH07XFxuXFxuICAgIGZ1bmN0aW9uIHN0b3JlU3VpdGUocmVzdWx0KSB7XFxuICAgICAgc3VpdGVzLnB1c2gocmVzdWx0KTtcXG4gICAgICBzdWl0ZXNfaGFzaFtyZXN1bHQuaWRdID0gcmVzdWx0O1xcbiAgICB9XFxuXFxuICAgIHRoaXMuc3VpdGVzID0gZnVuY3Rpb24oKSB7XFxuICAgICAgcmV0dXJuIHN1aXRlc19oYXNoO1xcbiAgICB9O1xcblxcbiAgICB2YXIgc3BlY3MgPSBbXTtcXG5cXG4gICAgdGhpcy5zcGVjRG9uZSA9IGZ1bmN0aW9uKHJlc3VsdCkge1xcbiAgICAgIHNwZWNzLnB1c2gocmVzdWx0KTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5zcGVjUmVzdWx0cyA9IGZ1bmN0aW9uKGluZGV4LCBsZW5ndGgpIHtcXG4gICAgICByZXR1cm4gc3BlY3Muc2xpY2UoaW5kZXgsIGluZGV4ICsgbGVuZ3RoKTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5zcGVjcyA9IGZ1bmN0aW9uKCkge1xcbiAgICAgIHJldHVybiBzcGVjcztcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5leGVjdXRpb25UaW1lID0gZnVuY3Rpb24oKSB7XFxuICAgICAgcmV0dXJuIGV4ZWN1dGlvblRpbWU7XFxuICAgIH07XFxuXFxuICB9XFxuXFxuICByZXR1cm4gSnNBcGlSZXBvcnRlcjtcXG59O1xcblxcbmdldEphc21pbmVSZXF1aXJlT2JqKCkuQ2FsbFRyYWNrZXIgPSBmdW5jdGlvbigpIHtcXG5cXG4gIGZ1bmN0aW9uIENhbGxUcmFja2VyKCkge1xcbiAgICB2YXIgY2FsbHMgPSBbXTtcXG5cXG4gICAgdGhpcy50cmFjayA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcXG4gICAgICBjYWxscy5wdXNoKGNvbnRleHQpO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLmFueSA9IGZ1bmN0aW9uKCkge1xcbiAgICAgIHJldHVybiAhIWNhbGxzLmxlbmd0aDtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5jb3VudCA9IGZ1bmN0aW9uKCkge1xcbiAgICAgIHJldHVybiBjYWxscy5sZW5ndGg7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuYXJnc0ZvciA9IGZ1bmN0aW9uKGluZGV4KSB7XFxuICAgICAgdmFyIGNhbGwgPSBjYWxsc1tpbmRleF07XFxuICAgICAgcmV0dXJuIGNhbGwgPyBjYWxsLmFyZ3MgOiBbXTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5hbGwgPSBmdW5jdGlvbigpIHtcXG4gICAgICByZXR1cm4gY2FsbHM7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuYWxsQXJncyA9IGZ1bmN0aW9uKCkge1xcbiAgICAgIHZhciBjYWxsQXJncyA9IFtdO1xcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBjYWxscy5sZW5ndGg7IGkrKyl7XFxuICAgICAgICBjYWxsQXJncy5wdXNoKGNhbGxzW2ldLmFyZ3MpO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gY2FsbEFyZ3M7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuZmlyc3QgPSBmdW5jdGlvbigpIHtcXG4gICAgICByZXR1cm4gY2FsbHNbMF07XFxuICAgIH07XFxuXFxuICAgIHRoaXMubW9zdFJlY2VudCA9IGZ1bmN0aW9uKCkge1xcbiAgICAgIHJldHVybiBjYWxsc1tjYWxscy5sZW5ndGggLSAxXTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5yZXNldCA9IGZ1bmN0aW9uKCkge1xcbiAgICAgIGNhbGxzID0gW107XFxuICAgIH07XFxuICB9XFxuXFxuICByZXR1cm4gQ2FsbFRyYWNrZXI7XFxufTtcXG5cXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLkNsb2NrID0gZnVuY3Rpb24oKSB7XFxuICBmdW5jdGlvbiBDbG9jayhnbG9iYWwsIGRlbGF5ZWRGdW5jdGlvblNjaGVkdWxlckZhY3RvcnksIG1vY2tEYXRlKSB7XFxuICAgIHZhciBzZWxmID0gdGhpcyxcXG4gICAgICByZWFsVGltaW5nRnVuY3Rpb25zID0ge1xcbiAgICAgICAgc2V0VGltZW91dDogZ2xvYmFsLnNldFRpbWVvdXQsXFxuICAgICAgICBjbGVhclRpbWVvdXQ6IGdsb2JhbC5jbGVhclRpbWVvdXQsXFxuICAgICAgICBzZXRJbnRlcnZhbDogZ2xvYmFsLnNldEludGVydmFsLFxcbiAgICAgICAgY2xlYXJJbnRlcnZhbDogZ2xvYmFsLmNsZWFySW50ZXJ2YWxcXG4gICAgICB9LFxcbiAgICAgIGZha2VUaW1pbmdGdW5jdGlvbnMgPSB7XFxuICAgICAgICBzZXRUaW1lb3V0OiBzZXRUaW1lb3V0LFxcbiAgICAgICAgY2xlYXJUaW1lb3V0OiBjbGVhclRpbWVvdXQsXFxuICAgICAgICBzZXRJbnRlcnZhbDogc2V0SW50ZXJ2YWwsXFxuICAgICAgICBjbGVhckludGVydmFsOiBjbGVhckludGVydmFsXFxuICAgICAgfSxcXG4gICAgICBpbnN0YWxsZWQgPSBmYWxzZSxcXG4gICAgICBkZWxheWVkRnVuY3Rpb25TY2hlZHVsZXIsXFxuICAgICAgdGltZXI7XFxuXFxuXFxuICAgIHNlbGYuaW5zdGFsbCA9IGZ1bmN0aW9uKCkge1xcbiAgICAgIGlmKCFvcmlnaW5hbFRpbWluZ0Z1bmN0aW9uc0ludGFjdCgpKSB7XFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0phc21pbmUgQ2xvY2sgd2FzIHVuYWJsZSB0byBpbnN0YWxsIG92ZXIgY3VzdG9tIGdsb2JhbCB0aW1lciBmdW5jdGlvbnMuIElzIHRoZSBjbG9jayBhbHJlYWR5IGluc3RhbGxlZD8nKTtcXG4gICAgICB9XFxuICAgICAgcmVwbGFjZShnbG9iYWwsIGZha2VUaW1pbmdGdW5jdGlvbnMpO1xcbiAgICAgIHRpbWVyID0gZmFrZVRpbWluZ0Z1bmN0aW9ucztcXG4gICAgICBkZWxheWVkRnVuY3Rpb25TY2hlZHVsZXIgPSBkZWxheWVkRnVuY3Rpb25TY2hlZHVsZXJGYWN0b3J5KCk7XFxuICAgICAgaW5zdGFsbGVkID0gdHJ1ZTtcXG5cXG4gICAgICByZXR1cm4gc2VsZjtcXG4gICAgfTtcXG5cXG4gICAgc2VsZi51bmluc3RhbGwgPSBmdW5jdGlvbigpIHtcXG4gICAgICBkZWxheWVkRnVuY3Rpb25TY2hlZHVsZXIgPSBudWxsO1xcbiAgICAgIG1vY2tEYXRlLnVuaW5zdGFsbCgpO1xcbiAgICAgIHJlcGxhY2UoZ2xvYmFsLCByZWFsVGltaW5nRnVuY3Rpb25zKTtcXG5cXG4gICAgICB0aW1lciA9IHJlYWxUaW1pbmdGdW5jdGlvbnM7XFxuICAgICAgaW5zdGFsbGVkID0gZmFsc2U7XFxuICAgIH07XFxuXFxuICAgIHNlbGYud2l0aE1vY2sgPSBmdW5jdGlvbihjbG9zdXJlKSB7XFxuICAgICAgdGhpcy5pbnN0YWxsKCk7XFxuICAgICAgdHJ5IHtcXG4gICAgICAgIGNsb3N1cmUoKTtcXG4gICAgICB9IGZpbmFsbHkge1xcbiAgICAgICAgdGhpcy51bmluc3RhbGwoKTtcXG4gICAgICB9XFxuICAgIH07XFxuXFxuICAgIHNlbGYubW9ja0RhdGUgPSBmdW5jdGlvbihpbml0aWFsRGF0ZSkge1xcbiAgICAgIG1vY2tEYXRlLmluc3RhbGwoaW5pdGlhbERhdGUpO1xcbiAgICB9O1xcblxcbiAgICBzZWxmLnNldFRpbWVvdXQgPSBmdW5jdGlvbihmbiwgZGVsYXksIHBhcmFtcykge1xcbiAgICAgIGlmIChsZWdhY3lJRSgpKSB7XFxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJRSA8IDkgY2Fubm90IHN1cHBvcnQgZXh0cmEgcGFyYW1zIHRvIHNldFRpbWVvdXQgd2l0aG91dCBhIHBvbHlmaWxsJyk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gdGltZXIuc2V0VGltZW91dChmbiwgZGVsYXkpO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmFwcGx5KHRpbWVyLnNldFRpbWVvdXQsIFtnbG9iYWwsIGFyZ3VtZW50c10pO1xcbiAgICB9O1xcblxcbiAgICBzZWxmLnNldEludGVydmFsID0gZnVuY3Rpb24oZm4sIGRlbGF5LCBwYXJhbXMpIHtcXG4gICAgICBpZiAobGVnYWN5SUUoKSkge1xcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XFxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSUUgPCA5IGNhbm5vdCBzdXBwb3J0IGV4dHJhIHBhcmFtcyB0byBzZXRJbnRlcnZhbCB3aXRob3V0IGEgcG9seWZpbGwnKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiB0aW1lci5zZXRJbnRlcnZhbChmbiwgZGVsYXkpO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmFwcGx5KHRpbWVyLnNldEludGVydmFsLCBbZ2xvYmFsLCBhcmd1bWVudHNdKTtcXG4gICAgfTtcXG5cXG4gICAgc2VsZi5jbGVhclRpbWVvdXQgPSBmdW5jdGlvbihpZCkge1xcbiAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbC5hcHBseSh0aW1lci5jbGVhclRpbWVvdXQsIFtnbG9iYWwsIGlkXSk7XFxuICAgIH07XFxuXFxuICAgIHNlbGYuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKGlkKSB7XFxuICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsLmFwcGx5KHRpbWVyLmNsZWFySW50ZXJ2YWwsIFtnbG9iYWwsIGlkXSk7XFxuICAgIH07XFxuXFxuICAgIHNlbGYudGljayA9IGZ1bmN0aW9uKG1pbGxpcykge1xcbiAgICAgIGlmIChpbnN0YWxsZWQpIHtcXG4gICAgICAgIG1vY2tEYXRlLnRpY2sobWlsbGlzKTtcXG4gICAgICAgIGRlbGF5ZWRGdW5jdGlvblNjaGVkdWxlci50aWNrKG1pbGxpcyk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTW9jayBjbG9jayBpcyBub3QgaW5zdGFsbGVkLCB1c2UgamFzbWluZS5jbG9jaygpLmluc3RhbGwoKScpO1xcbiAgICAgIH1cXG4gICAgfTtcXG5cXG4gICAgcmV0dXJuIHNlbGY7XFxuXFxuICAgIGZ1bmN0aW9uIG9yaWdpbmFsVGltaW5nRnVuY3Rpb25zSW50YWN0KCkge1xcbiAgICAgIHJldHVybiBnbG9iYWwuc2V0VGltZW91dCA9PT0gcmVhbFRpbWluZ0Z1bmN0aW9ucy5zZXRUaW1lb3V0ICYmXFxuICAgICAgICBnbG9iYWwuY2xlYXJUaW1lb3V0ID09PSByZWFsVGltaW5nRnVuY3Rpb25zLmNsZWFyVGltZW91dCAmJlxcbiAgICAgICAgZ2xvYmFsLnNldEludGVydmFsID09PSByZWFsVGltaW5nRnVuY3Rpb25zLnNldEludGVydmFsICYmXFxuICAgICAgICBnbG9iYWwuY2xlYXJJbnRlcnZhbCA9PT0gcmVhbFRpbWluZ0Z1bmN0aW9ucy5jbGVhckludGVydmFsO1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIGxlZ2FjeUlFKCkge1xcbiAgICAgIC8vaWYgdGhlc2UgbWV0aG9kcyBhcmUgcG9seWZpbGxlZCwgYXBwbHkgd2lsbCBiZSBwcmVzZW50XFxuICAgICAgcmV0dXJuICEocmVhbFRpbWluZ0Z1bmN0aW9ucy5zZXRUaW1lb3V0IHx8IHJlYWxUaW1pbmdGdW5jdGlvbnMuc2V0SW50ZXJ2YWwpLmFwcGx5O1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIHJlcGxhY2UoZGVzdCwgc291cmNlKSB7XFxuICAgICAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpIHtcXG4gICAgICAgIGRlc3RbcHJvcF0gPSBzb3VyY2VbcHJvcF07XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIHNldFRpbWVvdXQoZm4sIGRlbGF5KSB7XFxuICAgICAgcmV0dXJuIGRlbGF5ZWRGdW5jdGlvblNjaGVkdWxlci5zY2hlZHVsZUZ1bmN0aW9uKGZuLCBkZWxheSwgYXJnU2xpY2UoYXJndW1lbnRzLCAyKSk7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gY2xlYXJUaW1lb3V0KGlkKSB7XFxuICAgICAgcmV0dXJuIGRlbGF5ZWRGdW5jdGlvblNjaGVkdWxlci5yZW1vdmVGdW5jdGlvbldpdGhJZChpZCk7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gc2V0SW50ZXJ2YWwoZm4sIGludGVydmFsKSB7XFxuICAgICAgcmV0dXJuIGRlbGF5ZWRGdW5jdGlvblNjaGVkdWxlci5zY2hlZHVsZUZ1bmN0aW9uKGZuLCBpbnRlcnZhbCwgYXJnU2xpY2UoYXJndW1lbnRzLCAyKSwgdHJ1ZSk7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gY2xlYXJJbnRlcnZhbChpZCkge1xcbiAgICAgIHJldHVybiBkZWxheWVkRnVuY3Rpb25TY2hlZHVsZXIucmVtb3ZlRnVuY3Rpb25XaXRoSWQoaWQpO1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIGFyZ1NsaWNlKGFyZ3NPYmosIG4pIHtcXG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJnc09iaiwgbik7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiBDbG9jaztcXG59O1xcblxcbmdldEphc21pbmVSZXF1aXJlT2JqKCkuRGVsYXllZEZ1bmN0aW9uU2NoZWR1bGVyID0gZnVuY3Rpb24oKSB7XFxuICBmdW5jdGlvbiBEZWxheWVkRnVuY3Rpb25TY2hlZHVsZXIoKSB7XFxuICAgIHZhciBzZWxmID0gdGhpcztcXG4gICAgdmFyIHNjaGVkdWxlZExvb2t1cCA9IFtdO1xcbiAgICB2YXIgc2NoZWR1bGVkRnVuY3Rpb25zID0ge307XFxuICAgIHZhciBjdXJyZW50VGltZSA9IDA7XFxuICAgIHZhciBkZWxheWVkRm5Db3VudCA9IDA7XFxuXFxuICAgIHNlbGYudGljayA9IGZ1bmN0aW9uKG1pbGxpcykge1xcbiAgICAgIG1pbGxpcyA9IG1pbGxpcyB8fCAwO1xcbiAgICAgIHZhciBlbmRUaW1lID0gY3VycmVudFRpbWUgKyBtaWxsaXM7XFxuXFxuICAgICAgcnVuU2NoZWR1bGVkRnVuY3Rpb25zKGVuZFRpbWUpO1xcbiAgICAgIGN1cnJlbnRUaW1lID0gZW5kVGltZTtcXG4gICAgfTtcXG5cXG4gICAgc2VsZi5zY2hlZHVsZUZ1bmN0aW9uID0gZnVuY3Rpb24oZnVuY1RvQ2FsbCwgbWlsbGlzLCBwYXJhbXMsIHJlY3VycmluZywgdGltZW91dEtleSwgcnVuQXRNaWxsaXMpIHtcXG4gICAgICB2YXIgZjtcXG4gICAgICBpZiAodHlwZW9mKGZ1bmNUb0NhbGwpID09PSAnc3RyaW5nJykge1xcbiAgICAgICAgLyoganNoaW50IGV2aWw6IHRydWUgKi9cXG4gICAgICAgIGYgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGV2YWwoZnVuY1RvQ2FsbCk7IH07XFxuICAgICAgICAvKiBqc2hpbnQgZXZpbDogZmFsc2UgKi9cXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgZiA9IGZ1bmNUb0NhbGw7XFxuICAgICAgfVxcblxcbiAgICAgIG1pbGxpcyA9IG1pbGxpcyB8fCAwO1xcbiAgICAgIHRpbWVvdXRLZXkgPSB0aW1lb3V0S2V5IHx8ICsrZGVsYXllZEZuQ291bnQ7XFxuICAgICAgcnVuQXRNaWxsaXMgPSBydW5BdE1pbGxpcyB8fCAoY3VycmVudFRpbWUgKyBtaWxsaXMpO1xcblxcbiAgICAgIHZhciBmdW5jVG9TY2hlZHVsZSA9IHtcXG4gICAgICAgIHJ1bkF0TWlsbGlzOiBydW5BdE1pbGxpcyxcXG4gICAgICAgIGZ1bmNUb0NhbGw6IGYsXFxuICAgICAgICByZWN1cnJpbmc6IHJlY3VycmluZyxcXG4gICAgICAgIHBhcmFtczogcGFyYW1zLFxcbiAgICAgICAgdGltZW91dEtleTogdGltZW91dEtleSxcXG4gICAgICAgIG1pbGxpczogbWlsbGlzXFxuICAgICAgfTtcXG5cXG4gICAgICBpZiAocnVuQXRNaWxsaXMgaW4gc2NoZWR1bGVkRnVuY3Rpb25zKSB7XFxuICAgICAgICBzY2hlZHVsZWRGdW5jdGlvbnNbcnVuQXRNaWxsaXNdLnB1c2goZnVuY1RvU2NoZWR1bGUpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBzY2hlZHVsZWRGdW5jdGlvbnNbcnVuQXRNaWxsaXNdID0gW2Z1bmNUb1NjaGVkdWxlXTtcXG4gICAgICAgIHNjaGVkdWxlZExvb2t1cC5wdXNoKHJ1bkF0TWlsbGlzKTtcXG4gICAgICAgIHNjaGVkdWxlZExvb2t1cC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgICAgICAgIHJldHVybiBhIC0gYjtcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gdGltZW91dEtleTtcXG4gICAgfTtcXG5cXG4gICAgc2VsZi5yZW1vdmVGdW5jdGlvbldpdGhJZCA9IGZ1bmN0aW9uKHRpbWVvdXRLZXkpIHtcXG4gICAgICBmb3IgKHZhciBydW5BdE1pbGxpcyBpbiBzY2hlZHVsZWRGdW5jdGlvbnMpIHtcXG4gICAgICAgIHZhciBmdW5jcyA9IHNjaGVkdWxlZEZ1bmN0aW9uc1tydW5BdE1pbGxpc107XFxuICAgICAgICB2YXIgaSA9IGluZGV4T2ZGaXJzdFRvUGFzcyhmdW5jcywgZnVuY3Rpb24gKGZ1bmMpIHtcXG4gICAgICAgICAgcmV0dXJuIGZ1bmMudGltZW91dEtleSA9PT0gdGltZW91dEtleTtcXG4gICAgICAgIH0pO1xcblxcbiAgICAgICAgaWYgKGkgPiAtMSkge1xcbiAgICAgICAgICBpZiAoZnVuY3MubGVuZ3RoID09PSAxKSB7XFxuICAgICAgICAgICAgZGVsZXRlIHNjaGVkdWxlZEZ1bmN0aW9uc1tydW5BdE1pbGxpc107XFxuICAgICAgICAgICAgZGVsZXRlRnJvbUxvb2t1cChydW5BdE1pbGxpcyk7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgZnVuY3Muc3BsaWNlKGksIDEpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIC8vIGludGVydmFscyBnZXQgcmVzY2hlZHVsZWQgd2hlbiBleGVjdXRlZCwgc28gdGhlcmUncyBuZXZlciBtb3JlXFxuICAgICAgICAgIC8vIHRoYW4gYSBzaW5nbGUgc2NoZWR1bGVkIGZ1bmN0aW9uIHdpdGggYSBnaXZlbiB0aW1lb3V0S2V5XFxuICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfTtcXG5cXG4gICAgcmV0dXJuIHNlbGY7XFxuXFxuICAgIGZ1bmN0aW9uIGluZGV4T2ZGaXJzdFRvUGFzcyhhcnJheSwgdGVzdEZuKSB7XFxuICAgICAgdmFyIGluZGV4ID0gLTE7XFxuXFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7ICsraSkge1xcbiAgICAgICAgaWYgKHRlc3RGbihhcnJheVtpXSkpIHtcXG4gICAgICAgICAgaW5kZXggPSBpO1xcbiAgICAgICAgICBicmVhaztcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIGluZGV4O1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIGRlbGV0ZUZyb21Mb29rdXAoa2V5KSB7XFxuICAgICAgdmFyIHZhbHVlID0gTnVtYmVyKGtleSk7XFxuICAgICAgdmFyIGkgPSBpbmRleE9mRmlyc3RUb1Bhc3Moc2NoZWR1bGVkTG9va3VwLCBmdW5jdGlvbiAobWlsbGlzKSB7XFxuICAgICAgICByZXR1cm4gbWlsbGlzID09PSB2YWx1ZTtcXG4gICAgICB9KTtcXG5cXG4gICAgICBpZiAoaSA+IC0xKSB7XFxuICAgICAgICBzY2hlZHVsZWRMb29rdXAuc3BsaWNlKGksIDEpO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiByZXNjaGVkdWxlKHNjaGVkdWxlZEZuKSB7XFxuICAgICAgc2VsZi5zY2hlZHVsZUZ1bmN0aW9uKHNjaGVkdWxlZEZuLmZ1bmNUb0NhbGwsXFxuICAgICAgICBzY2hlZHVsZWRGbi5taWxsaXMsXFxuICAgICAgICBzY2hlZHVsZWRGbi5wYXJhbXMsXFxuICAgICAgICB0cnVlLFxcbiAgICAgICAgc2NoZWR1bGVkRm4udGltZW91dEtleSxcXG4gICAgICAgIHNjaGVkdWxlZEZuLnJ1bkF0TWlsbGlzICsgc2NoZWR1bGVkRm4ubWlsbGlzKTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBmb3JFYWNoRnVuY3Rpb24oZnVuY3NUb1J1biwgY2FsbGJhY2spIHtcXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZ1bmNzVG9SdW4ubGVuZ3RoOyArK2kpIHtcXG4gICAgICAgIGNhbGxiYWNrKGZ1bmNzVG9SdW5baV0pO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBydW5TY2hlZHVsZWRGdW5jdGlvbnMoZW5kVGltZSkge1xcbiAgICAgIGlmIChzY2hlZHVsZWRMb29rdXAubGVuZ3RoID09PSAwIHx8IHNjaGVkdWxlZExvb2t1cFswXSA+IGVuZFRpbWUpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgZG8ge1xcbiAgICAgICAgY3VycmVudFRpbWUgPSBzY2hlZHVsZWRMb29rdXAuc2hpZnQoKTtcXG5cXG4gICAgICAgIHZhciBmdW5jc1RvUnVuID0gc2NoZWR1bGVkRnVuY3Rpb25zW2N1cnJlbnRUaW1lXTtcXG4gICAgICAgIGRlbGV0ZSBzY2hlZHVsZWRGdW5jdGlvbnNbY3VycmVudFRpbWVdO1xcblxcbiAgICAgICAgZm9yRWFjaEZ1bmN0aW9uKGZ1bmNzVG9SdW4sIGZ1bmN0aW9uKGZ1bmNUb1J1bikge1xcbiAgICAgICAgICBpZiAoZnVuY1RvUnVuLnJlY3VycmluZykge1xcbiAgICAgICAgICAgIHJlc2NoZWR1bGUoZnVuY1RvUnVuKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuXFxuICAgICAgICBmb3JFYWNoRnVuY3Rpb24oZnVuY3NUb1J1biwgZnVuY3Rpb24oZnVuY1RvUnVuKSB7XFxuICAgICAgICAgIGZ1bmNUb1J1bi5mdW5jVG9DYWxsLmFwcGx5KG51bGwsIGZ1bmNUb1J1bi5wYXJhbXMgfHwgW10pO1xcbiAgICAgICAgfSk7XFxuICAgICAgfSB3aGlsZSAoc2NoZWR1bGVkTG9va3VwLmxlbmd0aCA+IDAgJiZcXG4gICAgICAgICAgICAgIC8vIGNoZWNraW5nIGZpcnN0IGlmIHdlJ3JlIG91dCBvZiB0aW1lIHByZXZlbnRzIHNldFRpbWVvdXQoMClcXG4gICAgICAgICAgICAgIC8vIHNjaGVkdWxlZCBpbiBhIGZ1bmNUb1J1biBmcm9tIGZvcmNpbmcgYW4gZXh0cmEgaXRlcmF0aW9uXFxuICAgICAgICAgICAgICAgICBjdXJyZW50VGltZSAhPT0gZW5kVGltZSAgJiZcXG4gICAgICAgICAgICAgICAgIHNjaGVkdWxlZExvb2t1cFswXSA8PSBlbmRUaW1lKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgcmV0dXJuIERlbGF5ZWRGdW5jdGlvblNjaGVkdWxlcjtcXG59O1xcblxcbmdldEphc21pbmVSZXF1aXJlT2JqKCkuRXhjZXB0aW9uRm9ybWF0dGVyID0gZnVuY3Rpb24oKSB7XFxuICBmdW5jdGlvbiBFeGNlcHRpb25Gb3JtYXR0ZXIoKSB7XFxuICAgIHRoaXMubWVzc2FnZSA9IGZ1bmN0aW9uKGVycm9yKSB7XFxuICAgICAgdmFyIG1lc3NhZ2UgPSAnJztcXG5cXG4gICAgICBpZiAoZXJyb3IubmFtZSAmJiBlcnJvci5tZXNzYWdlKSB7XFxuICAgICAgICBtZXNzYWdlICs9IGVycm9yLm5hbWUgKyAnOiAnICsgZXJyb3IubWVzc2FnZTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgbWVzc2FnZSArPSBlcnJvci50b1N0cmluZygpICsgJyB0aHJvd24nO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoZXJyb3IuZmlsZU5hbWUgfHwgZXJyb3Iuc291cmNlVVJMKSB7XFxuICAgICAgICBtZXNzYWdlICs9ICcgaW4gJyArIChlcnJvci5maWxlTmFtZSB8fCBlcnJvci5zb3VyY2VVUkwpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoZXJyb3IubGluZSB8fCBlcnJvci5saW5lTnVtYmVyKSB7XFxuICAgICAgICBtZXNzYWdlICs9ICcgKGxpbmUgJyArIChlcnJvci5saW5lIHx8IGVycm9yLmxpbmVOdW1iZXIpICsgJyknO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gbWVzc2FnZTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5zdGFjayA9IGZ1bmN0aW9uKGVycm9yKSB7XFxuICAgICAgcmV0dXJuIGVycm9yID8gZXJyb3Iuc3RhY2sgOiBudWxsO1xcbiAgICB9O1xcbiAgfVxcblxcbiAgcmV0dXJuIEV4Y2VwdGlvbkZvcm1hdHRlcjtcXG59O1xcblxcbmdldEphc21pbmVSZXF1aXJlT2JqKCkuRXhwZWN0YXRpb24gPSBmdW5jdGlvbigpIHtcXG5cXG4gIGZ1bmN0aW9uIEV4cGVjdGF0aW9uKG9wdGlvbnMpIHtcXG4gICAgdGhpcy51dGlsID0gb3B0aW9ucy51dGlsIHx8IHsgYnVpbGRGYWlsdXJlTWVzc2FnZTogZnVuY3Rpb24oKSB7fSB9O1xcbiAgICB0aGlzLmN1c3RvbUVxdWFsaXR5VGVzdGVycyA9IG9wdGlvbnMuY3VzdG9tRXF1YWxpdHlUZXN0ZXJzIHx8IFtdO1xcbiAgICB0aGlzLmFjdHVhbCA9IG9wdGlvbnMuYWN0dWFsO1xcbiAgICB0aGlzLmFkZEV4cGVjdGF0aW9uUmVzdWx0ID0gb3B0aW9ucy5hZGRFeHBlY3RhdGlvblJlc3VsdCB8fCBmdW5jdGlvbigpe307XFxuICAgIHRoaXMuaXNOb3QgPSBvcHRpb25zLmlzTm90O1xcblxcbiAgICB2YXIgY3VzdG9tTWF0Y2hlcnMgPSBvcHRpb25zLmN1c3RvbU1hdGNoZXJzIHx8IHt9O1xcbiAgICBmb3IgKHZhciBtYXRjaGVyTmFtZSBpbiBjdXN0b21NYXRjaGVycykge1xcbiAgICAgIHRoaXNbbWF0Y2hlck5hbWVdID0gRXhwZWN0YXRpb24ucHJvdG90eXBlLndyYXBDb21wYXJlKG1hdGNoZXJOYW1lLCBjdXN0b21NYXRjaGVyc1ttYXRjaGVyTmFtZV0pO1xcbiAgICB9XFxuICB9XFxuXFxuICBFeHBlY3RhdGlvbi5wcm90b3R5cGUud3JhcENvbXBhcmUgPSBmdW5jdGlvbihuYW1lLCBtYXRjaGVyRmFjdG9yeSkge1xcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XFxuICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApLFxcbiAgICAgICAgZXhwZWN0ZWQgPSBhcmdzLnNsaWNlKDApLFxcbiAgICAgICAgbWVzc2FnZSA9ICcnO1xcblxcbiAgICAgIGFyZ3MudW5zaGlmdCh0aGlzLmFjdHVhbCk7XFxuXFxuICAgICAgdmFyIG1hdGNoZXIgPSBtYXRjaGVyRmFjdG9yeSh0aGlzLnV0aWwsIHRoaXMuY3VzdG9tRXF1YWxpdHlUZXN0ZXJzKSxcXG4gICAgICAgICAgbWF0Y2hlckNvbXBhcmUgPSBtYXRjaGVyLmNvbXBhcmU7XFxuXFxuICAgICAgZnVuY3Rpb24gZGVmYXVsdE5lZ2F0aXZlQ29tcGFyZSgpIHtcXG4gICAgICAgIHZhciByZXN1bHQgPSBtYXRjaGVyLmNvbXBhcmUuYXBwbHkobnVsbCwgYXJncyk7XFxuICAgICAgICByZXN1bHQucGFzcyA9ICFyZXN1bHQucGFzcztcXG4gICAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLmlzTm90KSB7XFxuICAgICAgICBtYXRjaGVyQ29tcGFyZSA9IG1hdGNoZXIubmVnYXRpdmVDb21wYXJlIHx8IGRlZmF1bHROZWdhdGl2ZUNvbXBhcmU7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciByZXN1bHQgPSBtYXRjaGVyQ29tcGFyZS5hcHBseShudWxsLCBhcmdzKTtcXG5cXG4gICAgICBpZiAoIXJlc3VsdC5wYXNzKSB7XFxuICAgICAgICBpZiAoIXJlc3VsdC5tZXNzYWdlKSB7XFxuICAgICAgICAgIGFyZ3MudW5zaGlmdCh0aGlzLmlzTm90KTtcXG4gICAgICAgICAgYXJncy51bnNoaWZ0KG5hbWUpO1xcbiAgICAgICAgICBtZXNzYWdlID0gdGhpcy51dGlsLmJ1aWxkRmFpbHVyZU1lc3NhZ2UuYXBwbHkobnVsbCwgYXJncyk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5hcHBseShyZXN1bHQubWVzc2FnZSkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXScpIHtcXG4gICAgICAgICAgICBtZXNzYWdlID0gcmVzdWx0Lm1lc3NhZ2UoKTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBtZXNzYWdlID0gcmVzdWx0Lm1lc3NhZ2U7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGV4cGVjdGVkLmxlbmd0aCA9PSAxKSB7XFxuICAgICAgICBleHBlY3RlZCA9IGV4cGVjdGVkWzBdO1xcbiAgICAgIH1cXG5cXG4gICAgICAvLyBUT0RPOiBob3cgbWFueSBvZiB0aGVzZSBwYXJhbXMgYXJlIG5lZWRlZD9cXG4gICAgICB0aGlzLmFkZEV4cGVjdGF0aW9uUmVzdWx0KFxcbiAgICAgICAgcmVzdWx0LnBhc3MsXFxuICAgICAgICB7XFxuICAgICAgICAgIG1hdGNoZXJOYW1lOiBuYW1lLFxcbiAgICAgICAgICBwYXNzZWQ6IHJlc3VsdC5wYXNzLFxcbiAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxcbiAgICAgICAgICBhY3R1YWw6IHRoaXMuYWN0dWFsLFxcbiAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWQgLy8gVE9ETzogdGhpcyBtYXkgbmVlZCB0byBiZSBhcnJheWlmaWVkL3NsaWNlZFxcbiAgICAgICAgfVxcbiAgICAgICk7XFxuICAgIH07XFxuICB9O1xcblxcbiAgRXhwZWN0YXRpb24uYWRkQ29yZU1hdGNoZXJzID0gZnVuY3Rpb24obWF0Y2hlcnMpIHtcXG4gICAgdmFyIHByb3RvdHlwZSA9IEV4cGVjdGF0aW9uLnByb3RvdHlwZTtcXG4gICAgZm9yICh2YXIgbWF0Y2hlck5hbWUgaW4gbWF0Y2hlcnMpIHtcXG4gICAgICB2YXIgbWF0Y2hlciA9IG1hdGNoZXJzW21hdGNoZXJOYW1lXTtcXG4gICAgICBwcm90b3R5cGVbbWF0Y2hlck5hbWVdID0gcHJvdG90eXBlLndyYXBDb21wYXJlKG1hdGNoZXJOYW1lLCBtYXRjaGVyKTtcXG4gICAgfVxcbiAgfTtcXG5cXG4gIEV4cGVjdGF0aW9uLkZhY3RvcnkgPSBmdW5jdGlvbihvcHRpb25zKSB7XFxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xcblxcbiAgICB2YXIgZXhwZWN0ID0gbmV3IEV4cGVjdGF0aW9uKG9wdGlvbnMpO1xcblxcbiAgICAvLyBUT0RPOiB0aGlzIHdvdWxkIGJlIG5pY2UgYXMgaXRzIG93biBPYmplY3QgLSBOZWdhdGl2ZUV4cGVjdGF0aW9uXFxuICAgIC8vIFRPRE86IGNvcHkgaW5zdGVhZCBvZiBtdXRhdGUgb3B0aW9uc1xcbiAgICBvcHRpb25zLmlzTm90ID0gdHJ1ZTtcXG4gICAgZXhwZWN0Lm5vdCA9IG5ldyBFeHBlY3RhdGlvbihvcHRpb25zKTtcXG5cXG4gICAgcmV0dXJuIGV4cGVjdDtcXG4gIH07XFxuXFxuICByZXR1cm4gRXhwZWN0YXRpb247XFxufTtcXG5cXG4vL1RPRE86IGV4cGVjdGF0aW9uIHJlc3VsdCBtYXkgbWFrZSBtb3JlIHNlbnNlIGFzIGEgcHJlc2VudGF0aW9uIG9mIGFuIGV4cGVjdGF0aW9uLlxcbmdldEphc21pbmVSZXF1aXJlT2JqKCkuYnVpbGRFeHBlY3RhdGlvblJlc3VsdCA9IGZ1bmN0aW9uKCkge1xcbiAgZnVuY3Rpb24gYnVpbGRFeHBlY3RhdGlvblJlc3VsdChvcHRpb25zKSB7XFxuICAgIHZhciBtZXNzYWdlRm9ybWF0dGVyID0gb3B0aW9ucy5tZXNzYWdlRm9ybWF0dGVyIHx8IGZ1bmN0aW9uKCkge30sXFxuICAgICAgc3RhY2tGb3JtYXR0ZXIgPSBvcHRpb25zLnN0YWNrRm9ybWF0dGVyIHx8IGZ1bmN0aW9uKCkge307XFxuXFxuICAgIHZhciByZXN1bHQgPSB7XFxuICAgICAgbWF0Y2hlck5hbWU6IG9wdGlvbnMubWF0Y2hlck5hbWUsXFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSgpLFxcbiAgICAgIHN0YWNrOiBzdGFjaygpLFxcbiAgICAgIHBhc3NlZDogb3B0aW9ucy5wYXNzZWRcXG4gICAgfTtcXG5cXG4gICAgaWYoIXJlc3VsdC5wYXNzZWQpIHtcXG4gICAgICByZXN1bHQuZXhwZWN0ZWQgPSBvcHRpb25zLmV4cGVjdGVkO1xcbiAgICAgIHJlc3VsdC5hY3R1YWwgPSBvcHRpb25zLmFjdHVhbDtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gcmVzdWx0O1xcblxcbiAgICBmdW5jdGlvbiBtZXNzYWdlKCkge1xcbiAgICAgIGlmIChvcHRpb25zLnBhc3NlZCkge1xcbiAgICAgICAgcmV0dXJuICdQYXNzZWQuJztcXG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMubWVzc2FnZSkge1xcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMubWVzc2FnZTtcXG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuZXJyb3IpIHtcXG4gICAgICAgIHJldHVybiBtZXNzYWdlRm9ybWF0dGVyKG9wdGlvbnMuZXJyb3IpO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gJyc7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gc3RhY2soKSB7XFxuICAgICAgaWYgKG9wdGlvbnMucGFzc2VkKSB7XFxuICAgICAgICByZXR1cm4gJyc7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBlcnJvciA9IG9wdGlvbnMuZXJyb3I7XFxuICAgICAgaWYgKCFlcnJvcikge1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UoKSk7XFxuICAgICAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICAgIGVycm9yID0gZTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHN0YWNrRm9ybWF0dGVyKGVycm9yKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgcmV0dXJuIGJ1aWxkRXhwZWN0YXRpb25SZXN1bHQ7XFxufTtcXG5cXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLk1vY2tEYXRlID0gZnVuY3Rpb24oKSB7XFxuICBmdW5jdGlvbiBNb2NrRGF0ZShnbG9iYWwpIHtcXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgICB2YXIgY3VycmVudFRpbWUgPSAwO1xcblxcbiAgICBpZiAoIWdsb2JhbCB8fCAhZ2xvYmFsLkRhdGUpIHtcXG4gICAgICBzZWxmLmluc3RhbGwgPSBmdW5jdGlvbigpIHt9O1xcbiAgICAgIHNlbGYudGljayA9IGZ1bmN0aW9uKCkge307XFxuICAgICAgc2VsZi51bmluc3RhbGwgPSBmdW5jdGlvbigpIHt9O1xcbiAgICAgIHJldHVybiBzZWxmO1xcbiAgICB9XFxuXFxuICAgIHZhciBHbG9iYWxEYXRlID0gZ2xvYmFsLkRhdGU7XFxuXFxuICAgIHNlbGYuaW5zdGFsbCA9IGZ1bmN0aW9uKG1vY2tEYXRlKSB7XFxuICAgICAgaWYgKG1vY2tEYXRlIGluc3RhbmNlb2YgR2xvYmFsRGF0ZSkge1xcbiAgICAgICAgY3VycmVudFRpbWUgPSBtb2NrRGF0ZS5nZXRUaW1lKCk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGN1cnJlbnRUaW1lID0gbmV3IEdsb2JhbERhdGUoKS5nZXRUaW1lKCk7XFxuICAgICAgfVxcblxcbiAgICAgIGdsb2JhbC5EYXRlID0gRmFrZURhdGU7XFxuICAgIH07XFxuXFxuICAgIHNlbGYudGljayA9IGZ1bmN0aW9uKG1pbGxpcykge1xcbiAgICAgIG1pbGxpcyA9IG1pbGxpcyB8fCAwO1xcbiAgICAgIGN1cnJlbnRUaW1lID0gY3VycmVudFRpbWUgKyBtaWxsaXM7XFxuICAgIH07XFxuXFxuICAgIHNlbGYudW5pbnN0YWxsID0gZnVuY3Rpb24oKSB7XFxuICAgICAgY3VycmVudFRpbWUgPSAwO1xcbiAgICAgIGdsb2JhbC5EYXRlID0gR2xvYmFsRGF0ZTtcXG4gICAgfTtcXG5cXG4gICAgY3JlYXRlRGF0ZVByb3BlcnRpZXMoKTtcXG5cXG4gICAgcmV0dXJuIHNlbGY7XFxuXFxuICAgIGZ1bmN0aW9uIEZha2VEYXRlKCkge1xcbiAgICAgIHN3aXRjaChhcmd1bWVudHMubGVuZ3RoKSB7XFxuICAgICAgICBjYXNlIDA6XFxuICAgICAgICAgIHJldHVybiBuZXcgR2xvYmFsRGF0ZShjdXJyZW50VGltZSk7XFxuICAgICAgICBjYXNlIDE6XFxuICAgICAgICAgIHJldHVybiBuZXcgR2xvYmFsRGF0ZShhcmd1bWVudHNbMF0pO1xcbiAgICAgICAgY2FzZSAyOlxcbiAgICAgICAgICByZXR1cm4gbmV3IEdsb2JhbERhdGUoYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0pO1xcbiAgICAgICAgY2FzZSAzOlxcbiAgICAgICAgICByZXR1cm4gbmV3IEdsb2JhbERhdGUoYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XFxuICAgICAgICBjYXNlIDQ6XFxuICAgICAgICAgIHJldHVybiBuZXcgR2xvYmFsRGF0ZShhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdLCBhcmd1bWVudHNbM10pO1xcbiAgICAgICAgY2FzZSA1OlxcbiAgICAgICAgICByZXR1cm4gbmV3IEdsb2JhbERhdGUoYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSwgYXJndW1lbnRzWzNdLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzWzRdKTtcXG4gICAgICAgIGNhc2UgNjpcXG4gICAgICAgICAgcmV0dXJuIG5ldyBHbG9iYWxEYXRlKGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0sIGFyZ3VtZW50c1szXSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50c1s0XSwgYXJndW1lbnRzWzVdKTtcXG4gICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgIHJldHVybiBuZXcgR2xvYmFsRGF0ZShhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdLCBhcmd1bWVudHNbM10sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHNbNF0sIGFyZ3VtZW50c1s1XSwgYXJndW1lbnRzWzZdKTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gY3JlYXRlRGF0ZVByb3BlcnRpZXMoKSB7XFxuICAgICAgRmFrZURhdGUucHJvdG90eXBlID0gR2xvYmFsRGF0ZS5wcm90b3R5cGU7XFxuXFxuICAgICAgRmFrZURhdGUubm93ID0gZnVuY3Rpb24oKSB7XFxuICAgICAgICBpZiAoR2xvYmFsRGF0ZS5ub3cpIHtcXG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnRUaW1lO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCcm93c2VyIGRvZXMgbm90IHN1cHBvcnQgRGF0ZS5ub3coKScpO1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuXFxuICAgICAgRmFrZURhdGUudG9Tb3VyY2UgPSBHbG9iYWxEYXRlLnRvU291cmNlO1xcbiAgICAgIEZha2VEYXRlLnRvU3RyaW5nID0gR2xvYmFsRGF0ZS50b1N0cmluZztcXG4gICAgICBGYWtlRGF0ZS5wYXJzZSA9IEdsb2JhbERhdGUucGFyc2U7XFxuICAgICAgRmFrZURhdGUuVVRDID0gR2xvYmFsRGF0ZS5VVEM7XFxuICAgIH1cXG5cXHR9XFxuXFxuICByZXR1cm4gTW9ja0RhdGU7XFxufTtcXG5cXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnBwID0gZnVuY3Rpb24oaiQpIHtcXG5cXG4gIGZ1bmN0aW9uIFByZXR0eVByaW50ZXIoKSB7XFxuICAgIHRoaXMucHBOZXN0TGV2ZWxfID0gMDtcXG4gICAgdGhpcy5zZWVuID0gW107XFxuICB9XFxuXFxuICBQcmV0dHlQcmludGVyLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbih2YWx1ZSkge1xcbiAgICB0aGlzLnBwTmVzdExldmVsXysrO1xcbiAgICB0cnkge1xcbiAgICAgIGlmIChqJC51dGlsLmlzVW5kZWZpbmVkKHZhbHVlKSkge1xcbiAgICAgICAgdGhpcy5lbWl0U2NhbGFyKCd1bmRlZmluZWQnKTtcXG4gICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSBudWxsKSB7XFxuICAgICAgICB0aGlzLmVtaXRTY2FsYXIoJ251bGwnKTtcXG4gICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAwICYmIDEvdmFsdWUgPT09IC1JbmZpbml0eSkge1xcbiAgICAgICAgdGhpcy5lbWl0U2NhbGFyKCctMCcpO1xcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IGokLmdldEdsb2JhbCgpKSB7XFxuICAgICAgICB0aGlzLmVtaXRTY2FsYXIoJzxnbG9iYWw+Jyk7XFxuICAgICAgfSBlbHNlIGlmICh2YWx1ZS5qYXNtaW5lVG9TdHJpbmcpIHtcXG4gICAgICAgIHRoaXMuZW1pdFNjYWxhcih2YWx1ZS5qYXNtaW5lVG9TdHJpbmcoKSk7XFxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XFxuICAgICAgICB0aGlzLmVtaXRTdHJpbmcodmFsdWUpO1xcbiAgICAgIH0gZWxzZSBpZiAoaiQuaXNTcHkodmFsdWUpKSB7XFxuICAgICAgICB0aGlzLmVtaXRTY2FsYXIoJ3NweSBvbiAnICsgdmFsdWUuYW5kLmlkZW50aXR5KCkpO1xcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcXG4gICAgICAgIHRoaXMuZW1pdFNjYWxhcih2YWx1ZS50b1N0cmluZygpKTtcXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgdGhpcy5lbWl0U2NhbGFyKCdGdW5jdGlvbicpO1xcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlLm5vZGVUeXBlID09PSAnbnVtYmVyJykge1xcbiAgICAgICAgdGhpcy5lbWl0U2NhbGFyKCdIVE1MTm9kZScpO1xcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XFxuICAgICAgICB0aGlzLmVtaXRTY2FsYXIoJ0RhdGUoJyArIHZhbHVlICsgJyknKTtcXG4gICAgICB9IGVsc2UgaWYgKGokLnV0aWwuYXJyYXlDb250YWlucyh0aGlzLnNlZW4sIHZhbHVlKSkge1xcbiAgICAgICAgdGhpcy5lbWl0U2NhbGFyKCc8Y2lyY3VsYXIgcmVmZXJlbmNlOiAnICsgKGokLmlzQXJyYXlfKHZhbHVlKSA/ICdBcnJheScgOiAnT2JqZWN0JykgKyAnPicpO1xcbiAgICAgIH0gZWxzZSBpZiAoaiQuaXNBcnJheV8odmFsdWUpIHx8IGokLmlzQV8oJ09iamVjdCcsIHZhbHVlKSkge1xcbiAgICAgICAgdGhpcy5zZWVuLnB1c2godmFsdWUpO1xcbiAgICAgICAgaWYgKGokLmlzQXJyYXlfKHZhbHVlKSkge1xcbiAgICAgICAgICB0aGlzLmVtaXRBcnJheSh2YWx1ZSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICB0aGlzLmVtaXRPYmplY3QodmFsdWUpO1xcbiAgICAgICAgfVxcbiAgICAgICAgdGhpcy5zZWVuLnBvcCgpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0aGlzLmVtaXRTY2FsYXIodmFsdWUudG9TdHJpbmcoKSk7XFxuICAgICAgfVxcbiAgICB9IGZpbmFsbHkge1xcbiAgICAgIHRoaXMucHBOZXN0TGV2ZWxfLS07XFxuICAgIH1cXG4gIH07XFxuXFxuICBQcmV0dHlQcmludGVyLnByb3RvdHlwZS5pdGVyYXRlT2JqZWN0ID0gZnVuY3Rpb24ob2JqLCBmbikge1xcbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBvYmopIHtcXG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3BlcnR5KSkgeyBjb250aW51ZTsgfVxcbiAgICAgIGZuKHByb3BlcnR5LCBvYmouX19sb29rdXBHZXR0ZXJfXyA/ICghaiQudXRpbC5pc1VuZGVmaW5lZChvYmouX19sb29rdXBHZXR0ZXJfXyhwcm9wZXJ0eSkpICYmXFxuICAgICAgICAgIG9iai5fX2xvb2t1cEdldHRlcl9fKHByb3BlcnR5KSAhPT0gbnVsbCkgOiBmYWxzZSk7XFxuICAgIH1cXG4gIH07XFxuXFxuICBQcmV0dHlQcmludGVyLnByb3RvdHlwZS5lbWl0QXJyYXkgPSBqJC51bmltcGxlbWVudGVkTWV0aG9kXztcXG4gIFByZXR0eVByaW50ZXIucHJvdG90eXBlLmVtaXRPYmplY3QgPSBqJC51bmltcGxlbWVudGVkTWV0aG9kXztcXG4gIFByZXR0eVByaW50ZXIucHJvdG90eXBlLmVtaXRTY2FsYXIgPSBqJC51bmltcGxlbWVudGVkTWV0aG9kXztcXG4gIFByZXR0eVByaW50ZXIucHJvdG90eXBlLmVtaXRTdHJpbmcgPSBqJC51bmltcGxlbWVudGVkTWV0aG9kXztcXG5cXG4gIGZ1bmN0aW9uIFN0cmluZ1ByZXR0eVByaW50ZXIoKSB7XFxuICAgIFByZXR0eVByaW50ZXIuY2FsbCh0aGlzKTtcXG5cXG4gICAgdGhpcy5zdHJpbmcgPSAnJztcXG4gIH1cXG5cXG4gIGokLnV0aWwuaW5oZXJpdChTdHJpbmdQcmV0dHlQcmludGVyLCBQcmV0dHlQcmludGVyKTtcXG5cXG4gIFN0cmluZ1ByZXR0eVByaW50ZXIucHJvdG90eXBlLmVtaXRTY2FsYXIgPSBmdW5jdGlvbih2YWx1ZSkge1xcbiAgICB0aGlzLmFwcGVuZCh2YWx1ZSk7XFxuICB9O1xcblxcbiAgU3RyaW5nUHJldHR5UHJpbnRlci5wcm90b3R5cGUuZW1pdFN0cmluZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XFxuICAgIHRoaXMuYXBwZW5kKCdcXFxcJycgKyB2YWx1ZSArICdcXFxcJycpO1xcbiAgfTtcXG5cXG4gIFN0cmluZ1ByZXR0eVByaW50ZXIucHJvdG90eXBlLmVtaXRBcnJheSA9IGZ1bmN0aW9uKGFycmF5KSB7XFxuICAgIGlmICh0aGlzLnBwTmVzdExldmVsXyA+IGokLk1BWF9QUkVUVFlfUFJJTlRfREVQVEgpIHtcXG4gICAgICB0aGlzLmFwcGVuZCgnQXJyYXknKTtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG4gICAgdmFyIGxlbmd0aCA9IE1hdGgubWluKGFycmF5Lmxlbmd0aCwgaiQuTUFYX1BSRVRUWV9QUklOVF9BUlJBWV9MRU5HVEgpO1xcbiAgICB0aGlzLmFwcGVuZCgnWyAnKTtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xcbiAgICAgIGlmIChpID4gMCkge1xcbiAgICAgICAgdGhpcy5hcHBlbmQoJywgJyk7XFxuICAgICAgfVxcbiAgICAgIHRoaXMuZm9ybWF0KGFycmF5W2ldKTtcXG4gICAgfVxcbiAgICBpZihhcnJheS5sZW5ndGggPiBsZW5ndGgpe1xcbiAgICAgIHRoaXMuYXBwZW5kKCcsIC4uLicpO1xcbiAgICB9XFxuXFxuICAgIHZhciBzZWxmID0gdGhpcztcXG4gICAgdmFyIGZpcnN0ID0gYXJyYXkubGVuZ3RoID09PSAwO1xcbiAgICB0aGlzLml0ZXJhdGVPYmplY3QoYXJyYXksIGZ1bmN0aW9uKHByb3BlcnR5LCBpc0dldHRlcikge1xcbiAgICAgIGlmIChwcm9wZXJ0eS5tYXRjaCgvXlxcXFxkKyQvKSkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoZmlyc3QpIHtcXG4gICAgICAgIGZpcnN0ID0gZmFsc2U7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHNlbGYuYXBwZW5kKCcsICcpO1xcbiAgICAgIH1cXG5cXG4gICAgICBzZWxmLmZvcm1hdFByb3BlcnR5KGFycmF5LCBwcm9wZXJ0eSwgaXNHZXR0ZXIpO1xcbiAgICB9KTtcXG5cXG4gICAgdGhpcy5hcHBlbmQoJyBdJyk7XFxuICB9O1xcblxcbiAgU3RyaW5nUHJldHR5UHJpbnRlci5wcm90b3R5cGUuZW1pdE9iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xcbiAgICB2YXIgY29uc3RydWN0b3JOYW1lID0gb2JqLmNvbnN0cnVjdG9yID8gaiQuZm5OYW1lRm9yKG9iai5jb25zdHJ1Y3RvcikgOiAnbnVsbCc7XFxuICAgIHRoaXMuYXBwZW5kKGNvbnN0cnVjdG9yTmFtZSk7XFxuXFxuICAgIGlmICh0aGlzLnBwTmVzdExldmVsXyA+IGokLk1BWF9QUkVUVFlfUFJJTlRfREVQVEgpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgICB0aGlzLmFwcGVuZCgnKHsgJyk7XFxuICAgIHZhciBmaXJzdCA9IHRydWU7XFxuXFxuICAgIHRoaXMuaXRlcmF0ZU9iamVjdChvYmosIGZ1bmN0aW9uKHByb3BlcnR5LCBpc0dldHRlcikge1xcbiAgICAgIGlmIChmaXJzdCkge1xcbiAgICAgICAgZmlyc3QgPSBmYWxzZTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgc2VsZi5hcHBlbmQoJywgJyk7XFxuICAgICAgfVxcblxcbiAgICAgIHNlbGYuZm9ybWF0UHJvcGVydHkob2JqLCBwcm9wZXJ0eSwgaXNHZXR0ZXIpO1xcbiAgICB9KTtcXG5cXG4gICAgdGhpcy5hcHBlbmQoJyB9KScpO1xcbiAgfTtcXG5cXG4gIFN0cmluZ1ByZXR0eVByaW50ZXIucHJvdG90eXBlLmZvcm1hdFByb3BlcnR5ID0gZnVuY3Rpb24ob2JqLCBwcm9wZXJ0eSwgaXNHZXR0ZXIpIHtcXG4gICAgICB0aGlzLmFwcGVuZChwcm9wZXJ0eSk7XFxuICAgICAgdGhpcy5hcHBlbmQoJzogJyk7XFxuICAgICAgaWYgKGlzR2V0dGVyKSB7XFxuICAgICAgICB0aGlzLmFwcGVuZCgnPGdldHRlcj4nKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdGhpcy5mb3JtYXQob2JqW3Byb3BlcnR5XSk7XFxuICAgICAgfVxcbiAgfTtcXG5cXG4gIFN0cmluZ1ByZXR0eVByaW50ZXIucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uKHZhbHVlKSB7XFxuICAgIHRoaXMuc3RyaW5nICs9IHZhbHVlO1xcbiAgfTtcXG5cXG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xcbiAgICB2YXIgc3RyaW5nUHJldHR5UHJpbnRlciA9IG5ldyBTdHJpbmdQcmV0dHlQcmludGVyKCk7XFxuICAgIHN0cmluZ1ByZXR0eVByaW50ZXIuZm9ybWF0KHZhbHVlKTtcXG4gICAgcmV0dXJuIHN0cmluZ1ByZXR0eVByaW50ZXIuc3RyaW5nO1xcbiAgfTtcXG59O1xcblxcbmdldEphc21pbmVSZXF1aXJlT2JqKCkuUXVldWVSdW5uZXIgPSBmdW5jdGlvbihqJCkge1xcblxcbiAgZnVuY3Rpb24gb25jZShmbikge1xcbiAgICB2YXIgY2FsbGVkID0gZmFsc2U7XFxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcXG4gICAgICBpZiAoIWNhbGxlZCkge1xcbiAgICAgICAgY2FsbGVkID0gdHJ1ZTtcXG4gICAgICAgIGZuKCk7XFxuICAgICAgfVxcbiAgICB9O1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gUXVldWVSdW5uZXIoYXR0cnMpIHtcXG4gICAgdGhpcy5xdWV1ZWFibGVGbnMgPSBhdHRycy5xdWV1ZWFibGVGbnMgfHwgW107XFxuICAgIHRoaXMub25Db21wbGV0ZSA9IGF0dHJzLm9uQ29tcGxldGUgfHwgZnVuY3Rpb24oKSB7fTtcXG4gICAgdGhpcy5jbGVhclN0YWNrID0gYXR0cnMuY2xlYXJTdGFjayB8fCBmdW5jdGlvbihmbikge2ZuKCk7fTtcXG4gICAgdGhpcy5vbkV4Y2VwdGlvbiA9IGF0dHJzLm9uRXhjZXB0aW9uIHx8IGZ1bmN0aW9uKCkge307XFxuICAgIHRoaXMuY2F0Y2hFeGNlcHRpb24gPSBhdHRycy5jYXRjaEV4Y2VwdGlvbiB8fCBmdW5jdGlvbigpIHsgcmV0dXJuIHRydWU7IH07XFxuICAgIHRoaXMudXNlckNvbnRleHQgPSBhdHRycy51c2VyQ29udGV4dCB8fCB7fTtcXG4gICAgdGhpcy50aW1lb3V0ID0gYXR0cnMudGltZW91dCB8fCB7c2V0VGltZW91dDogc2V0VGltZW91dCwgY2xlYXJUaW1lb3V0OiBjbGVhclRpbWVvdXR9O1xcbiAgICB0aGlzLmZhaWwgPSBhdHRycy5mYWlsIHx8IGZ1bmN0aW9uKCkge307XFxuICB9XFxuXFxuICBRdWV1ZVJ1bm5lci5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xcbiAgICB0aGlzLnJ1bih0aGlzLnF1ZXVlYWJsZUZucywgMCk7XFxuICB9O1xcblxcbiAgUXVldWVSdW5uZXIucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKHF1ZXVlYWJsZUZucywgcmVjdXJzaXZlSW5kZXgpIHtcXG4gICAgdmFyIGxlbmd0aCA9IHF1ZXVlYWJsZUZucy5sZW5ndGgsXFxuICAgICAgc2VsZiA9IHRoaXMsXFxuICAgICAgaXRlcmF0aXZlSW5kZXg7XFxuXFxuXFxuICAgIGZvcihpdGVyYXRpdmVJbmRleCA9IHJlY3Vyc2l2ZUluZGV4OyBpdGVyYXRpdmVJbmRleCA8IGxlbmd0aDsgaXRlcmF0aXZlSW5kZXgrKykge1xcbiAgICAgIHZhciBxdWV1ZWFibGVGbiA9IHF1ZXVlYWJsZUZuc1tpdGVyYXRpdmVJbmRleF07XFxuICAgICAgaWYgKHF1ZXVlYWJsZUZuLmZuLmxlbmd0aCA+IDApIHtcXG4gICAgICAgIGF0dGVtcHRBc3luYyhxdWV1ZWFibGVGbik7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGF0dGVtcHRTeW5jKHF1ZXVlYWJsZUZuKTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgdmFyIHJ1bm5lckRvbmUgPSBpdGVyYXRpdmVJbmRleCA+PSBsZW5ndGg7XFxuXFxuICAgIGlmIChydW5uZXJEb25lKSB7XFxuICAgICAgdGhpcy5jbGVhclN0YWNrKHRoaXMub25Db21wbGV0ZSk7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gYXR0ZW1wdFN5bmMocXVldWVhYmxlRm4pIHtcXG4gICAgICB0cnkge1xcbiAgICAgICAgcXVldWVhYmxlRm4uZm4uY2FsbChzZWxmLnVzZXJDb250ZXh0KTtcXG4gICAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICBoYW5kbGVFeGNlcHRpb24oZSwgcXVldWVhYmxlRm4pO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBhdHRlbXB0QXN5bmMocXVldWVhYmxlRm4pIHtcXG4gICAgICB2YXIgY2xlYXJUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkoc2VsZi50aW1lb3V0LmNsZWFyVGltZW91dCwgW2okLmdldEdsb2JhbCgpLCBbdGltZW91dElkXV0pO1xcbiAgICAgICAgfSxcXG4gICAgICAgIG5leHQgPSBvbmNlKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XFxuICAgICAgICAgIHNlbGYucnVuKHF1ZXVlYWJsZUZucywgaXRlcmF0aXZlSW5kZXggKyAxKTtcXG4gICAgICAgIH0pLFxcbiAgICAgICAgdGltZW91dElkO1xcblxcbiAgICAgIG5leHQuZmFpbCA9IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgc2VsZi5mYWlsLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XFxuICAgICAgICBuZXh0KCk7XFxuICAgICAgfTtcXG5cXG4gICAgICBpZiAocXVldWVhYmxlRm4udGltZW91dCkge1xcbiAgICAgICAgdGltZW91dElkID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmFwcGx5KHNlbGYudGltZW91dC5zZXRUaW1lb3V0LCBbaiQuZ2V0R2xvYmFsKCksIFtmdW5jdGlvbigpIHtcXG4gICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdUaW1lb3V0IC0gQXN5bmMgY2FsbGJhY2sgd2FzIG5vdCBpbnZva2VkIHdpdGhpbiB0aW1lb3V0IHNwZWNpZmllZCBieSBqYXNtaW5lLkRFRkFVTFRfVElNRU9VVF9JTlRFUlZBTC4nKTtcXG4gICAgICAgICAgb25FeGNlcHRpb24oZXJyb3IsIHF1ZXVlYWJsZUZuKTtcXG4gICAgICAgICAgbmV4dCgpO1xcbiAgICAgICAgfSwgcXVldWVhYmxlRm4udGltZW91dCgpXV0pO1xcbiAgICAgIH1cXG5cXG4gICAgICB0cnkge1xcbiAgICAgICAgcXVldWVhYmxlRm4uZm4uY2FsbChzZWxmLnVzZXJDb250ZXh0LCBuZXh0KTtcXG4gICAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICBoYW5kbGVFeGNlcHRpb24oZSwgcXVldWVhYmxlRm4pO1xcbiAgICAgICAgbmV4dCgpO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBvbkV4Y2VwdGlvbihlLCBxdWV1ZWFibGVGbikge1xcbiAgICAgIHNlbGYub25FeGNlcHRpb24oZSk7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gaGFuZGxlRXhjZXB0aW9uKGUsIHF1ZXVlYWJsZUZuKSB7XFxuICAgICAgb25FeGNlcHRpb24oZSwgcXVldWVhYmxlRm4pO1xcbiAgICAgIGlmICghc2VsZi5jYXRjaEV4Y2VwdGlvbihlKSkge1xcbiAgICAgICAgLy9UT0RPOiBzZXQgYSB2YXIgd2hlbiB3ZSBjYXRjaCBhbiBleGNlcHRpb24gYW5kXFxuICAgICAgICAvL3VzZSBhIGZpbmFsbHkgYmxvY2sgdG8gY2xvc2UgdGhlIGxvb3AgaW4gYSBuaWNlIHdheS4uXFxuICAgICAgICB0aHJvdyBlO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfTtcXG5cXG4gIHJldHVybiBRdWV1ZVJ1bm5lcjtcXG59O1xcblxcbmdldEphc21pbmVSZXF1aXJlT2JqKCkuUmVwb3J0RGlzcGF0Y2hlciA9IGZ1bmN0aW9uKCkge1xcbiAgZnVuY3Rpb24gUmVwb3J0RGlzcGF0Y2hlcihtZXRob2RzKSB7XFxuXFxuICAgIHZhciBkaXNwYXRjaGVkTWV0aG9kcyA9IG1ldGhvZHMgfHwgW107XFxuXFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzcGF0Y2hlZE1ldGhvZHMubGVuZ3RoOyBpKyspIHtcXG4gICAgICB2YXIgbWV0aG9kID0gZGlzcGF0Y2hlZE1ldGhvZHNbaV07XFxuICAgICAgdGhpc1ttZXRob2RdID0gKGZ1bmN0aW9uKG0pIHtcXG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcXG4gICAgICAgICAgZGlzcGF0Y2gobSwgYXJndW1lbnRzKTtcXG4gICAgICAgIH07XFxuICAgICAgfShtZXRob2QpKTtcXG4gICAgfVxcblxcbiAgICB2YXIgcmVwb3J0ZXJzID0gW107XFxuXFxuICAgIHRoaXMuYWRkUmVwb3J0ZXIgPSBmdW5jdGlvbihyZXBvcnRlcikge1xcbiAgICAgIHJlcG9ydGVycy5wdXNoKHJlcG9ydGVyKTtcXG4gICAgfTtcXG5cXG4gICAgcmV0dXJuIHRoaXM7XFxuXFxuICAgIGZ1bmN0aW9uIGRpc3BhdGNoKG1ldGhvZCwgYXJncykge1xcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVwb3J0ZXJzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICB2YXIgcmVwb3J0ZXIgPSByZXBvcnRlcnNbaV07XFxuICAgICAgICBpZiAocmVwb3J0ZXJbbWV0aG9kXSkge1xcbiAgICAgICAgICByZXBvcnRlclttZXRob2RdLmFwcGx5KHJlcG9ydGVyLCBhcmdzKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiBSZXBvcnREaXNwYXRjaGVyO1xcbn07XFxuXFxuXFxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5TcHlSZWdpc3RyeSA9IGZ1bmN0aW9uKGokKSB7XFxuXFxuICBmdW5jdGlvbiBTcHlSZWdpc3RyeShvcHRpb25zKSB7XFxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xcbiAgICB2YXIgY3VycmVudFNwaWVzID0gb3B0aW9ucy5jdXJyZW50U3BpZXMgfHwgZnVuY3Rpb24oKSB7IHJldHVybiBbXTsgfTtcXG5cXG4gICAgdGhpcy5zcHlPbiA9IGZ1bmN0aW9uKG9iaiwgbWV0aG9kTmFtZSkge1xcbiAgICAgIGlmIChqJC51dGlsLmlzVW5kZWZpbmVkKG9iaikpIHtcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc3B5T24gY291bGQgbm90IGZpbmQgYW4gb2JqZWN0IHRvIHNweSB1cG9uIGZvciAnICsgbWV0aG9kTmFtZSArICcoKScpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoaiQudXRpbC5pc1VuZGVmaW5lZChtZXRob2ROYW1lKSkge1xcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBtZXRob2QgbmFtZSBzdXBwbGllZCcpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoaiQudXRpbC5pc1VuZGVmaW5lZChvYmpbbWV0aG9kTmFtZV0pKSB7XFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWV0aG9kTmFtZSArICcoKSBtZXRob2QgZG9lcyBub3QgZXhpc3QnKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKG9ialttZXRob2ROYW1lXSAmJiBqJC5pc1NweShvYmpbbWV0aG9kTmFtZV0pKSB7XFxuICAgICAgICAvL1RPRE8/OiBzaG91bGQgdGhpcyByZXR1cm4gdGhlIGN1cnJlbnQgc3B5PyBEb3duc2lkZTogbWF5IGNhdXNlIHVzZXIgY29uZnVzaW9uIGFib3V0IHNweSBzdGF0ZVxcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1ldGhvZE5hbWUgKyAnIGhhcyBhbHJlYWR5IGJlZW4gc3BpZWQgdXBvbicpO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgc3B5ID0gaiQuY3JlYXRlU3B5KG1ldGhvZE5hbWUsIG9ialttZXRob2ROYW1lXSk7XFxuXFxuICAgICAgY3VycmVudFNwaWVzKCkucHVzaCh7XFxuICAgICAgICBzcHk6IHNweSxcXG4gICAgICAgIGJhc2VPYmo6IG9iaixcXG4gICAgICAgIG1ldGhvZE5hbWU6IG1ldGhvZE5hbWUsXFxuICAgICAgICBvcmlnaW5hbFZhbHVlOiBvYmpbbWV0aG9kTmFtZV1cXG4gICAgICB9KTtcXG5cXG4gICAgICBvYmpbbWV0aG9kTmFtZV0gPSBzcHk7XFxuXFxuICAgICAgcmV0dXJuIHNweTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5jbGVhclNwaWVzID0gZnVuY3Rpb24oKSB7XFxuICAgICAgdmFyIHNwaWVzID0gY3VycmVudFNwaWVzKCk7XFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGllcy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgdmFyIHNweUVudHJ5ID0gc3BpZXNbaV07XFxuICAgICAgICBzcHlFbnRyeS5iYXNlT2JqW3NweUVudHJ5Lm1ldGhvZE5hbWVdID0gc3B5RW50cnkub3JpZ2luYWxWYWx1ZTtcXG4gICAgICB9XFxuICAgIH07XFxuICB9XFxuXFxuICByZXR1cm4gU3B5UmVnaXN0cnk7XFxufTtcXG5cXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLlNweVN0cmF0ZWd5ID0gZnVuY3Rpb24oKSB7XFxuXFxuICBmdW5jdGlvbiBTcHlTdHJhdGVneShvcHRpb25zKSB7XFxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xcblxcbiAgICB2YXIgaWRlbnRpdHkgPSBvcHRpb25zLm5hbWUgfHwgJ3Vua25vd24nLFxcbiAgICAgICAgb3JpZ2luYWxGbiA9IG9wdGlvbnMuZm4gfHwgZnVuY3Rpb24oKSB7fSxcXG4gICAgICAgIGdldFNweSA9IG9wdGlvbnMuZ2V0U3B5IHx8IGZ1bmN0aW9uKCkge30sXFxuICAgICAgICBwbGFuID0gZnVuY3Rpb24oKSB7fTtcXG5cXG4gICAgdGhpcy5pZGVudGl0eSA9IGZ1bmN0aW9uKCkge1xcbiAgICAgIHJldHVybiBpZGVudGl0eTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5leGVjID0gZnVuY3Rpb24oKSB7XFxuICAgICAgcmV0dXJuIHBsYW4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5jYWxsVGhyb3VnaCA9IGZ1bmN0aW9uKCkge1xcbiAgICAgIHBsYW4gPSBvcmlnaW5hbEZuO1xcbiAgICAgIHJldHVybiBnZXRTcHkoKTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5yZXR1cm5WYWx1ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XFxuICAgICAgcGxhbiA9IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xcbiAgICAgIH07XFxuICAgICAgcmV0dXJuIGdldFNweSgpO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLnJldHVyblZhbHVlcyA9IGZ1bmN0aW9uKCkge1xcbiAgICAgIHZhciB2YWx1ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xcbiAgICAgIHBsYW4gPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICByZXR1cm4gdmFsdWVzLnNoaWZ0KCk7XFxuICAgICAgfTtcXG4gICAgICByZXR1cm4gZ2V0U3B5KCk7XFxuICAgIH07XFxuXFxuICAgIHRoaXMudGhyb3dFcnJvciA9IGZ1bmN0aW9uKHNvbWV0aGluZykge1xcbiAgICAgIHZhciBlcnJvciA9IChzb21ldGhpbmcgaW5zdGFuY2VvZiBFcnJvcikgPyBzb21ldGhpbmcgOiBuZXcgRXJyb3Ioc29tZXRoaW5nKTtcXG4gICAgICBwbGFuID0gZnVuY3Rpb24oKSB7XFxuICAgICAgICB0aHJvdyBlcnJvcjtcXG4gICAgICB9O1xcbiAgICAgIHJldHVybiBnZXRTcHkoKTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5jYWxsRmFrZSA9IGZ1bmN0aW9uKGZuKSB7XFxuICAgICAgcGxhbiA9IGZuO1xcbiAgICAgIHJldHVybiBnZXRTcHkoKTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5zdHViID0gZnVuY3Rpb24oZm4pIHtcXG4gICAgICBwbGFuID0gZnVuY3Rpb24oKSB7fTtcXG4gICAgICByZXR1cm4gZ2V0U3B5KCk7XFxuICAgIH07XFxuICB9XFxuXFxuICByZXR1cm4gU3B5U3RyYXRlZ3k7XFxufTtcXG5cXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLlN1aXRlID0gZnVuY3Rpb24oaiQpIHtcXG4gIGZ1bmN0aW9uIFN1aXRlKGF0dHJzKSB7XFxuICAgIHRoaXMuZW52ID0gYXR0cnMuZW52O1xcbiAgICB0aGlzLmlkID0gYXR0cnMuaWQ7XFxuICAgIHRoaXMucGFyZW50U3VpdGUgPSBhdHRycy5wYXJlbnRTdWl0ZTtcXG4gICAgdGhpcy5kZXNjcmlwdGlvbiA9IGF0dHJzLmRlc2NyaXB0aW9uO1xcbiAgICB0aGlzLmV4cGVjdGF0aW9uRmFjdG9yeSA9IGF0dHJzLmV4cGVjdGF0aW9uRmFjdG9yeTtcXG4gICAgdGhpcy5leHBlY3RhdGlvblJlc3VsdEZhY3RvcnkgPSBhdHRycy5leHBlY3RhdGlvblJlc3VsdEZhY3Rvcnk7XFxuICAgIHRoaXMudGhyb3dPbkV4cGVjdGF0aW9uRmFpbHVyZSA9ICEhYXR0cnMudGhyb3dPbkV4cGVjdGF0aW9uRmFpbHVyZTtcXG5cXG4gICAgdGhpcy5iZWZvcmVGbnMgPSBbXTtcXG4gICAgdGhpcy5hZnRlckZucyA9IFtdO1xcbiAgICB0aGlzLmJlZm9yZUFsbEZucyA9IFtdO1xcbiAgICB0aGlzLmFmdGVyQWxsRm5zID0gW107XFxuICAgIHRoaXMuZGlzYWJsZWQgPSBmYWxzZTtcXG5cXG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xcblxcbiAgICB0aGlzLnJlc3VsdCA9IHtcXG4gICAgICBpZDogdGhpcy5pZCxcXG4gICAgICBkZXNjcmlwdGlvbjogdGhpcy5kZXNjcmlwdGlvbixcXG4gICAgICBmdWxsTmFtZTogdGhpcy5nZXRGdWxsTmFtZSgpLFxcbiAgICAgIGZhaWxlZEV4cGVjdGF0aW9uczogW11cXG4gICAgfTtcXG4gIH1cXG5cXG4gIFN1aXRlLnByb3RvdHlwZS5leHBlY3QgPSBmdW5jdGlvbihhY3R1YWwpIHtcXG4gICAgcmV0dXJuIHRoaXMuZXhwZWN0YXRpb25GYWN0b3J5KGFjdHVhbCwgdGhpcyk7XFxuICB9O1xcblxcbiAgU3VpdGUucHJvdG90eXBlLmdldEZ1bGxOYW1lID0gZnVuY3Rpb24oKSB7XFxuICAgIHZhciBmdWxsTmFtZSA9IHRoaXMuZGVzY3JpcHRpb247XFxuICAgIGZvciAodmFyIHBhcmVudFN1aXRlID0gdGhpcy5wYXJlbnRTdWl0ZTsgcGFyZW50U3VpdGU7IHBhcmVudFN1aXRlID0gcGFyZW50U3VpdGUucGFyZW50U3VpdGUpIHtcXG4gICAgICBpZiAocGFyZW50U3VpdGUucGFyZW50U3VpdGUpIHtcXG4gICAgICAgIGZ1bGxOYW1lID0gcGFyZW50U3VpdGUuZGVzY3JpcHRpb24gKyAnICcgKyBmdWxsTmFtZTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgcmV0dXJuIGZ1bGxOYW1lO1xcbiAgfTtcXG5cXG4gIFN1aXRlLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24oKSB7XFxuICAgIHRoaXMuZGlzYWJsZWQgPSB0cnVlO1xcbiAgfTtcXG5cXG4gIFN1aXRlLnByb3RvdHlwZS5iZWZvcmVFYWNoID0gZnVuY3Rpb24oZm4pIHtcXG4gICAgdGhpcy5iZWZvcmVGbnMudW5zaGlmdChmbik7XFxuICB9O1xcblxcbiAgU3VpdGUucHJvdG90eXBlLmJlZm9yZUFsbCA9IGZ1bmN0aW9uKGZuKSB7XFxuICAgIHRoaXMuYmVmb3JlQWxsRm5zLnB1c2goZm4pO1xcbiAgfTtcXG5cXG4gIFN1aXRlLnByb3RvdHlwZS5hZnRlckVhY2ggPSBmdW5jdGlvbihmbikge1xcbiAgICB0aGlzLmFmdGVyRm5zLnVuc2hpZnQoZm4pO1xcbiAgfTtcXG5cXG4gIFN1aXRlLnByb3RvdHlwZS5hZnRlckFsbCA9IGZ1bmN0aW9uKGZuKSB7XFxuICAgIHRoaXMuYWZ0ZXJBbGxGbnMucHVzaChmbik7XFxuICB9O1xcblxcbiAgU3VpdGUucHJvdG90eXBlLmFkZENoaWxkID0gZnVuY3Rpb24oY2hpbGQpIHtcXG4gICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcXG4gIH07XFxuXFxuICBTdWl0ZS5wcm90b3R5cGUuc3RhdHVzID0gZnVuY3Rpb24oKSB7XFxuICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XFxuICAgICAgcmV0dXJuICdkaXNhYmxlZCc7XFxuICAgIH1cXG5cXG4gICAgaWYgKHRoaXMucmVzdWx0LmZhaWxlZEV4cGVjdGF0aW9ucy5sZW5ndGggPiAwKSB7XFxuICAgICAgcmV0dXJuICdmYWlsZWQnO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHJldHVybiAnZmluaXNoZWQnO1xcbiAgICB9XFxuICB9O1xcblxcbiAgU3VpdGUucHJvdG90eXBlLmlzRXhlY3V0YWJsZSA9IGZ1bmN0aW9uKCkge1xcbiAgICByZXR1cm4gIXRoaXMuZGlzYWJsZWQ7XFxuICB9O1xcblxcbiAgU3VpdGUucHJvdG90eXBlLmNhbkJlUmVlbnRlcmVkID0gZnVuY3Rpb24oKSB7XFxuICAgIHJldHVybiB0aGlzLmJlZm9yZUFsbEZucy5sZW5ndGggPT09IDAgJiYgdGhpcy5hZnRlckFsbEZucy5sZW5ndGggPT09IDA7XFxuICB9O1xcblxcbiAgU3VpdGUucHJvdG90eXBlLmdldFJlc3VsdCA9IGZ1bmN0aW9uKCkge1xcbiAgICB0aGlzLnJlc3VsdC5zdGF0dXMgPSB0aGlzLnN0YXR1cygpO1xcbiAgICByZXR1cm4gdGhpcy5yZXN1bHQ7XFxuICB9O1xcblxcbiAgU3VpdGUucHJvdG90eXBlLnNoYXJlZFVzZXJDb250ZXh0ID0gZnVuY3Rpb24oKSB7XFxuICAgIGlmICghdGhpcy5zaGFyZWRDb250ZXh0KSB7XFxuICAgICAgdGhpcy5zaGFyZWRDb250ZXh0ID0gdGhpcy5wYXJlbnRTdWl0ZSA/IGNsb25lKHRoaXMucGFyZW50U3VpdGUuc2hhcmVkVXNlckNvbnRleHQoKSkgOiB7fTtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gdGhpcy5zaGFyZWRDb250ZXh0O1xcbiAgfTtcXG5cXG4gIFN1aXRlLnByb3RvdHlwZS5jbG9uZWRTaGFyZWRVc2VyQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xcbiAgICByZXR1cm4gY2xvbmUodGhpcy5zaGFyZWRVc2VyQ29udGV4dCgpKTtcXG4gIH07XFxuXFxuICBTdWl0ZS5wcm90b3R5cGUub25FeGNlcHRpb24gPSBmdW5jdGlvbigpIHtcXG4gICAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIGokLmVycm9ycy5FeHBlY3RhdGlvbkZhaWxlZCkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBpZihpc0FmdGVyQWxsKHRoaXMuY2hpbGRyZW4pKSB7XFxuICAgICAgdmFyIGRhdGEgPSB7XFxuICAgICAgICBtYXRjaGVyTmFtZTogJycsXFxuICAgICAgICBwYXNzZWQ6IGZhbHNlLFxcbiAgICAgICAgZXhwZWN0ZWQ6ICcnLFxcbiAgICAgICAgYWN0dWFsOiAnJyxcXG4gICAgICAgIGVycm9yOiBhcmd1bWVudHNbMF1cXG4gICAgICB9O1xcbiAgICAgIHRoaXMucmVzdWx0LmZhaWxlZEV4cGVjdGF0aW9ucy5wdXNoKHRoaXMuZXhwZWN0YXRpb25SZXN1bHRGYWN0b3J5KGRhdGEpKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XFxuICAgICAgICBjaGlsZC5vbkV4Y2VwdGlvbi5hcHBseShjaGlsZCwgYXJndW1lbnRzKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH07XFxuXFxuICBTdWl0ZS5wcm90b3R5cGUuYWRkRXhwZWN0YXRpb25SZXN1bHQgPSBmdW5jdGlvbiAoKSB7XFxuICAgIGlmKGlzQWZ0ZXJBbGwodGhpcy5jaGlsZHJlbikgJiYgaXNGYWlsdXJlKGFyZ3VtZW50cykpe1xcbiAgICAgIHZhciBkYXRhID0gYXJndW1lbnRzWzFdO1xcbiAgICAgIHRoaXMucmVzdWx0LmZhaWxlZEV4cGVjdGF0aW9ucy5wdXNoKHRoaXMuZXhwZWN0YXRpb25SZXN1bHRGYWN0b3J5KGRhdGEpKTtcXG4gICAgICBpZih0aGlzLnRocm93T25FeHBlY3RhdGlvbkZhaWx1cmUpIHtcXG4gICAgICAgIHRocm93IG5ldyBqJC5lcnJvcnMuRXhwZWN0YXRpb25GYWlsZWQoKTtcXG4gICAgICB9XFxuICAgIH0gZWxzZSB7XFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgY2hpbGQuYWRkRXhwZWN0YXRpb25SZXN1bHQuYXBwbHkoY2hpbGQsIGFyZ3VtZW50cyk7XFxuICAgICAgICB9IGNhdGNoKGUpIHtcXG4gICAgICAgICAgLy8ga2VlcCBnb2luZ1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcbiAgfTtcXG5cXG4gIGZ1bmN0aW9uIGlzQWZ0ZXJBbGwoY2hpbGRyZW4pIHtcXG4gICAgcmV0dXJuIGNoaWxkcmVuICYmIGNoaWxkcmVuWzBdLnJlc3VsdC5zdGF0dXM7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBpc0ZhaWx1cmUoYXJncykge1xcbiAgICByZXR1cm4gIWFyZ3NbMF07XFxuICB9XFxuXFxuICBmdW5jdGlvbiBjbG9uZShvYmopIHtcXG4gICAgdmFyIGNsb25lZE9iaiA9IHt9O1xcbiAgICBmb3IgKHZhciBwcm9wIGluIG9iaikge1xcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocHJvcCkpIHtcXG4gICAgICAgIGNsb25lZE9ialtwcm9wXSA9IG9ialtwcm9wXTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIGNsb25lZE9iajtcXG4gIH1cXG5cXG4gIHJldHVybiBTdWl0ZTtcXG59O1xcblxcbmlmICh0eXBlb2Ygd2luZG93ID09IHZvaWQgMCAmJiB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0Jykge1xcbiAgZXhwb3J0cy5TdWl0ZSA9IGphc21pbmVSZXF1aXJlLlN1aXRlO1xcbn1cXG5cXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLlRpbWVyID0gZnVuY3Rpb24oKSB7XFxuICB2YXIgZGVmYXVsdE5vdyA9IChmdW5jdGlvbihEYXRlKSB7XFxuICAgIHJldHVybiBmdW5jdGlvbigpIHsgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpOyB9O1xcbiAgfSkoRGF0ZSk7XFxuXFxuICBmdW5jdGlvbiBUaW1lcihvcHRpb25zKSB7XFxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xcblxcbiAgICB2YXIgbm93ID0gb3B0aW9ucy5ub3cgfHwgZGVmYXVsdE5vdyxcXG4gICAgICBzdGFydFRpbWU7XFxuXFxuICAgIHRoaXMuc3RhcnQgPSBmdW5jdGlvbigpIHtcXG4gICAgICBzdGFydFRpbWUgPSBub3coKTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5lbGFwc2VkID0gZnVuY3Rpb24oKSB7XFxuICAgICAgcmV0dXJuIG5vdygpIC0gc3RhcnRUaW1lO1xcbiAgICB9O1xcbiAgfVxcblxcbiAgcmV0dXJuIFRpbWVyO1xcbn07XFxuXFxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5UcmVlUHJvY2Vzc29yID0gZnVuY3Rpb24oKSB7XFxuICBmdW5jdGlvbiBUcmVlUHJvY2Vzc29yKGF0dHJzKSB7XFxuICAgIHZhciB0cmVlID0gYXR0cnMudHJlZSxcXG4gICAgICAgIHJ1bm5hYmxlSWRzID0gYXR0cnMucnVubmFibGVJZHMsXFxuICAgICAgICBxdWV1ZVJ1bm5lckZhY3RvcnkgPSBhdHRycy5xdWV1ZVJ1bm5lckZhY3RvcnksXFxuICAgICAgICBub2RlU3RhcnQgPSBhdHRycy5ub2RlU3RhcnQgfHwgZnVuY3Rpb24oKSB7fSxcXG4gICAgICAgIG5vZGVDb21wbGV0ZSA9IGF0dHJzLm5vZGVDb21wbGV0ZSB8fCBmdW5jdGlvbigpIHt9LFxcbiAgICAgICAgc3RhdHMgPSB7IHZhbGlkOiB0cnVlIH0sXFxuICAgICAgICBwcm9jZXNzZWQgPSBmYWxzZSxcXG4gICAgICAgIGRlZmF1bHRNaW4gPSBJbmZpbml0eSxcXG4gICAgICAgIGRlZmF1bHRNYXggPSAxIC0gSW5maW5pdHk7XFxuXFxuICAgIHRoaXMucHJvY2Vzc1RyZWUgPSBmdW5jdGlvbigpIHtcXG4gICAgICBwcm9jZXNzTm9kZSh0cmVlLCBmYWxzZSk7XFxuICAgICAgcHJvY2Vzc2VkID0gdHJ1ZTtcXG4gICAgICByZXR1cm4gc3RhdHM7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuZXhlY3V0ZSA9IGZ1bmN0aW9uKGRvbmUpIHtcXG4gICAgICBpZiAoIXByb2Nlc3NlZCkge1xcbiAgICAgICAgdGhpcy5wcm9jZXNzVHJlZSgpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIXN0YXRzLnZhbGlkKSB7XFxuICAgICAgICB0aHJvdyAnaW52YWxpZCBvcmRlcic7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBjaGlsZEZucyA9IHdyYXBDaGlsZHJlbih0cmVlLCAwKTtcXG5cXG4gICAgICBxdWV1ZVJ1bm5lckZhY3Rvcnkoe1xcbiAgICAgICAgcXVldWVhYmxlRm5zOiBjaGlsZEZucyxcXG4gICAgICAgIHVzZXJDb250ZXh0OiB0cmVlLnNoYXJlZFVzZXJDb250ZXh0KCksXFxuICAgICAgICBvbkV4Y2VwdGlvbjogZnVuY3Rpb24oKSB7XFxuICAgICAgICAgIHRyZWUub25FeGNlcHRpb24uYXBwbHkodHJlZSwgYXJndW1lbnRzKTtcXG4gICAgICAgIH0sXFxuICAgICAgICBvbkNvbXBsZXRlOiBkb25lXFxuICAgICAgfSk7XFxuICAgIH07XFxuXFxuICAgIGZ1bmN0aW9uIHJ1bm5hYmxlSW5kZXgoaWQpIHtcXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJ1bm5hYmxlSWRzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICBpZiAocnVubmFibGVJZHNbaV0gPT09IGlkKSB7XFxuICAgICAgICAgIHJldHVybiBpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBwcm9jZXNzTm9kZShub2RlLCBwYXJlbnRFbmFibGVkKSB7XFxuICAgICAgdmFyIGV4ZWN1dGFibGVJbmRleCA9IHJ1bm5hYmxlSW5kZXgobm9kZS5pZCk7XFxuXFxuICAgICAgaWYgKGV4ZWN1dGFibGVJbmRleCAhPT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICBwYXJlbnRFbmFibGVkID0gdHJ1ZTtcXG4gICAgICB9XFxuXFxuICAgICAgcGFyZW50RW5hYmxlZCA9IHBhcmVudEVuYWJsZWQgJiYgbm9kZS5pc0V4ZWN1dGFibGUoKTtcXG5cXG4gICAgICBpZiAoIW5vZGUuY2hpbGRyZW4pIHtcXG4gICAgICAgIHN0YXRzW25vZGUuaWRdID0ge1xcbiAgICAgICAgICBleGVjdXRhYmxlOiBwYXJlbnRFbmFibGVkICYmIG5vZGUuaXNFeGVjdXRhYmxlKCksXFxuICAgICAgICAgIHNlZ21lbnRzOiBbe1xcbiAgICAgICAgICAgIGluZGV4OiAwLFxcbiAgICAgICAgICAgIG93bmVyOiBub2RlLFxcbiAgICAgICAgICAgIG5vZGVzOiBbbm9kZV0sXFxuICAgICAgICAgICAgbWluOiBzdGFydGluZ01pbihleGVjdXRhYmxlSW5kZXgpLFxcbiAgICAgICAgICAgIG1heDogc3RhcnRpbmdNYXgoZXhlY3V0YWJsZUluZGV4KVxcbiAgICAgICAgICB9XVxcbiAgICAgICAgfTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdmFyIGhhc0V4ZWN1dGFibGVDaGlsZCA9IGZhbHNlO1xcblxcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XFxuXFxuICAgICAgICAgIHByb2Nlc3NOb2RlKGNoaWxkLCBwYXJlbnRFbmFibGVkKTtcXG5cXG4gICAgICAgICAgaWYgKCFzdGF0cy52YWxpZCkge1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICB2YXIgY2hpbGRTdGF0cyA9IHN0YXRzW2NoaWxkLmlkXTtcXG5cXG4gICAgICAgICAgaGFzRXhlY3V0YWJsZUNoaWxkID0gaGFzRXhlY3V0YWJsZUNoaWxkIHx8IGNoaWxkU3RhdHMuZXhlY3V0YWJsZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHN0YXRzW25vZGUuaWRdID0ge1xcbiAgICAgICAgICBleGVjdXRhYmxlOiBoYXNFeGVjdXRhYmxlQ2hpbGRcXG4gICAgICAgIH07XFxuXFxuICAgICAgICBzZWdtZW50Q2hpbGRyZW4obm9kZSwgc3RhdHNbbm9kZS5pZF0sIGV4ZWN1dGFibGVJbmRleCk7XFxuXFxuICAgICAgICBpZiAoIW5vZGUuY2FuQmVSZWVudGVyZWQoKSAmJiBzdGF0c1tub2RlLmlkXS5zZWdtZW50cy5sZW5ndGggPiAxKSB7XFxuICAgICAgICAgIHN0YXRzID0geyB2YWxpZDogZmFsc2UgfTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gc3RhcnRpbmdNaW4oZXhlY3V0YWJsZUluZGV4KSB7XFxuICAgICAgcmV0dXJuIGV4ZWN1dGFibGVJbmRleCA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdE1pbiA6IGV4ZWN1dGFibGVJbmRleDtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBzdGFydGluZ01heChleGVjdXRhYmxlSW5kZXgpIHtcXG4gICAgICByZXR1cm4gZXhlY3V0YWJsZUluZGV4ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0TWF4IDogZXhlY3V0YWJsZUluZGV4O1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIHNlZ21lbnRDaGlsZHJlbihub2RlLCBub2RlU3RhdHMsIGV4ZWN1dGFibGVJbmRleCkge1xcbiAgICAgIHZhciBjdXJyZW50U2VnbWVudCA9IHsgaW5kZXg6IDAsIG93bmVyOiBub2RlLCBub2RlczogW10sIG1pbjogc3RhcnRpbmdNaW4oZXhlY3V0YWJsZUluZGV4KSwgbWF4OiBzdGFydGluZ01heChleGVjdXRhYmxlSW5kZXgpIH0sXFxuICAgICAgICAgIHJlc3VsdCA9IFtjdXJyZW50U2VnbWVudF0sXFxuICAgICAgICAgIGxhc3RNYXggPSBkZWZhdWx0TWF4LFxcbiAgICAgICAgICBvcmRlcmVkQ2hpbGRTZWdtZW50cyA9IG9yZGVyQ2hpbGRTZWdtZW50cyhub2RlLmNoaWxkcmVuKTtcXG5cXG4gICAgICBmdW5jdGlvbiBpc1NlZ21lbnRCb3VuZGFyeShtaW5JbmRleCkge1xcbiAgICAgICAgcmV0dXJuIGxhc3RNYXggIT09IGRlZmF1bHRNYXggJiYgbWluSW5kZXggIT09IGRlZmF1bHRNaW4gJiYgbGFzdE1heCA8IG1pbkluZGV4IC0gMTtcXG4gICAgICB9XFxuXFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmRlcmVkQ2hpbGRTZWdtZW50cy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgdmFyIGNoaWxkU2VnbWVudCA9IG9yZGVyZWRDaGlsZFNlZ21lbnRzW2ldLFxcbiAgICAgICAgICBtYXhJbmRleCA9IGNoaWxkU2VnbWVudC5tYXgsXFxuICAgICAgICAgIG1pbkluZGV4ID0gY2hpbGRTZWdtZW50Lm1pbjtcXG5cXG4gICAgICAgIGlmIChpc1NlZ21lbnRCb3VuZGFyeShtaW5JbmRleCkpIHtcXG4gICAgICAgICAgY3VycmVudFNlZ21lbnQgPSB7aW5kZXg6IHJlc3VsdC5sZW5ndGgsIG93bmVyOiBub2RlLCBub2RlczogW10sIG1pbjogZGVmYXVsdE1pbiwgbWF4OiBkZWZhdWx0TWF4fTtcXG4gICAgICAgICAgcmVzdWx0LnB1c2goY3VycmVudFNlZ21lbnQpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgY3VycmVudFNlZ21lbnQubm9kZXMucHVzaChjaGlsZFNlZ21lbnQpO1xcbiAgICAgICAgY3VycmVudFNlZ21lbnQubWluID0gTWF0aC5taW4oY3VycmVudFNlZ21lbnQubWluLCBtaW5JbmRleCk7XFxuICAgICAgICBjdXJyZW50U2VnbWVudC5tYXggPSBNYXRoLm1heChjdXJyZW50U2VnbWVudC5tYXgsIG1heEluZGV4KTtcXG4gICAgICAgIGxhc3RNYXggPSBtYXhJbmRleDtcXG4gICAgICB9XFxuXFxuICAgICAgbm9kZVN0YXRzLnNlZ21lbnRzID0gcmVzdWx0O1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIG9yZGVyQ2hpbGRTZWdtZW50cyhjaGlsZHJlbikge1xcbiAgICAgIHZhciBzcGVjaWZpZWRPcmRlciA9IFtdLFxcbiAgICAgICAgICB1bnNwZWNpZmllZE9yZGVyID0gW107XFxuXFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV0sXFxuICAgICAgICAgICAgc2VnbWVudHMgPSBzdGF0c1tjaGlsZC5pZF0uc2VnbWVudHM7XFxuXFxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNlZ21lbnRzLmxlbmd0aDsgaisrKSB7XFxuICAgICAgICAgIHZhciBzZWcgPSBzZWdtZW50c1tqXTtcXG5cXG4gICAgICAgICAgaWYgKHNlZy5taW4gPT09IGRlZmF1bHRNaW4pIHtcXG4gICAgICAgICAgICB1bnNwZWNpZmllZE9yZGVyLnB1c2goc2VnKTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBzcGVjaWZpZWRPcmRlci5wdXNoKHNlZyk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgc3BlY2lmaWVkT3JkZXIuc29ydChmdW5jdGlvbihhLCBiKSB7XFxuICAgICAgICByZXR1cm4gYS5taW4gLSBiLm1pbjtcXG4gICAgICB9KTtcXG5cXG4gICAgICByZXR1cm4gc3BlY2lmaWVkT3JkZXIuY29uY2F0KHVuc3BlY2lmaWVkT3JkZXIpO1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIGV4ZWN1dGVOb2RlKG5vZGUsIHNlZ21lbnROdW1iZXIpIHtcXG4gICAgICBpZiAobm9kZS5jaGlsZHJlbikge1xcbiAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgZm46IGZ1bmN0aW9uKGRvbmUpIHtcXG4gICAgICAgICAgICBub2RlU3RhcnQobm9kZSk7XFxuXFxuICAgICAgICAgICAgcXVldWVSdW5uZXJGYWN0b3J5KHtcXG4gICAgICAgICAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgICAgICAgICBub2RlQ29tcGxldGUobm9kZSwgbm9kZS5nZXRSZXN1bHQoKSk7XFxuICAgICAgICAgICAgICAgIGRvbmUoKTtcXG4gICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICBxdWV1ZWFibGVGbnM6IHdyYXBDaGlsZHJlbihub2RlLCBzZWdtZW50TnVtYmVyKSxcXG4gICAgICAgICAgICAgIHVzZXJDb250ZXh0OiBub2RlLnNoYXJlZFVzZXJDb250ZXh0KCksXFxuICAgICAgICAgICAgICBvbkV4Y2VwdGlvbjogZnVuY3Rpb24oKSB7XFxuICAgICAgICAgICAgICAgIG5vZGUub25FeGNlcHRpb24uYXBwbHkobm9kZSwgYXJndW1lbnRzKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgZm46IGZ1bmN0aW9uKGRvbmUpIHsgbm9kZS5leGVjdXRlKGRvbmUsIHN0YXRzW25vZGUuaWRdLmV4ZWN1dGFibGUpOyB9XFxuICAgICAgICB9O1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiB3cmFwQ2hpbGRyZW4obm9kZSwgc2VnbWVudE51bWJlcikge1xcbiAgICAgIHZhciByZXN1bHQgPSBbXSxcXG4gICAgICAgICAgc2VnbWVudENoaWxkcmVuID0gc3RhdHNbbm9kZS5pZF0uc2VnbWVudHNbc2VnbWVudE51bWJlcl0ubm9kZXM7XFxuXFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgIHJlc3VsdC5wdXNoKGV4ZWN1dGVOb2RlKHNlZ21lbnRDaGlsZHJlbltpXS5vd25lciwgc2VnbWVudENoaWxkcmVuW2ldLmluZGV4KSk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghc3RhdHNbbm9kZS5pZF0uZXhlY3V0YWJsZSkge1xcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIG5vZGUuYmVmb3JlQWxsRm5zLmNvbmNhdChyZXN1bHQpLmNvbmNhdChub2RlLmFmdGVyQWxsRm5zKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgcmV0dXJuIFRyZWVQcm9jZXNzb3I7XFxufTtcXG5cXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLkFueSA9IGZ1bmN0aW9uKGokKSB7XFxuXFxuICBmdW5jdGlvbiBBbnkoZXhwZWN0ZWRPYmplY3QpIHtcXG4gICAgdGhpcy5leHBlY3RlZE9iamVjdCA9IGV4cGVjdGVkT2JqZWN0O1xcbiAgfVxcblxcbiAgQW55LnByb3RvdHlwZS5hc3ltbWV0cmljTWF0Y2ggPSBmdW5jdGlvbihvdGhlcikge1xcbiAgICBpZiAodGhpcy5leHBlY3RlZE9iamVjdCA9PSBTdHJpbmcpIHtcXG4gICAgICByZXR1cm4gdHlwZW9mIG90aGVyID09ICdzdHJpbmcnIHx8IG90aGVyIGluc3RhbmNlb2YgU3RyaW5nO1xcbiAgICB9XFxuXFxuICAgIGlmICh0aGlzLmV4cGVjdGVkT2JqZWN0ID09IE51bWJlcikge1xcbiAgICAgIHJldHVybiB0eXBlb2Ygb3RoZXIgPT0gJ251bWJlcicgfHwgb3RoZXIgaW5zdGFuY2VvZiBOdW1iZXI7XFxuICAgIH1cXG5cXG4gICAgaWYgKHRoaXMuZXhwZWN0ZWRPYmplY3QgPT0gRnVuY3Rpb24pIHtcXG4gICAgICByZXR1cm4gdHlwZW9mIG90aGVyID09ICdmdW5jdGlvbicgfHwgb3RoZXIgaW5zdGFuY2VvZiBGdW5jdGlvbjtcXG4gICAgfVxcblxcbiAgICBpZiAodGhpcy5leHBlY3RlZE9iamVjdCA9PSBPYmplY3QpIHtcXG4gICAgICByZXR1cm4gdHlwZW9mIG90aGVyID09ICdvYmplY3QnO1xcbiAgICB9XFxuXFxuICAgIGlmICh0aGlzLmV4cGVjdGVkT2JqZWN0ID09IEJvb2xlYW4pIHtcXG4gICAgICByZXR1cm4gdHlwZW9mIG90aGVyID09ICdib29sZWFuJztcXG4gICAgfVxcblxcbiAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiB0aGlzLmV4cGVjdGVkT2JqZWN0O1xcbiAgfTtcXG5cXG4gIEFueS5wcm90b3R5cGUuamFzbWluZVRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XFxuICAgIHJldHVybiAnPGphc21pbmUuYW55KCcgKyBqJC5mbk5hbWVGb3IodGhpcy5leHBlY3RlZE9iamVjdCkgKyAnKT4nO1xcbiAgfTtcXG5cXG4gIHJldHVybiBBbnk7XFxufTtcXG5cXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLkFueXRoaW5nID0gZnVuY3Rpb24oaiQpIHtcXG5cXG4gIGZ1bmN0aW9uIEFueXRoaW5nKCkge31cXG5cXG4gIEFueXRoaW5nLnByb3RvdHlwZS5hc3ltbWV0cmljTWF0Y2ggPSBmdW5jdGlvbihvdGhlcikge1xcbiAgICByZXR1cm4gIWokLnV0aWwuaXNVbmRlZmluZWQob3RoZXIpICYmIG90aGVyICE9PSBudWxsO1xcbiAgfTtcXG5cXG4gIEFueXRoaW5nLnByb3RvdHlwZS5qYXNtaW5lVG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcXG4gICAgcmV0dXJuICc8amFzbWluZS5hbnl0aGluZz4nO1xcbiAgfTtcXG5cXG4gIHJldHVybiBBbnl0aGluZztcXG59O1xcblxcbmdldEphc21pbmVSZXF1aXJlT2JqKCkuQXJyYXlDb250YWluaW5nID0gZnVuY3Rpb24oaiQpIHtcXG4gIGZ1bmN0aW9uIEFycmF5Q29udGFpbmluZyhzYW1wbGUpIHtcXG4gICAgdGhpcy5zYW1wbGUgPSBzYW1wbGU7XFxuICB9XFxuXFxuICBBcnJheUNvbnRhaW5pbmcucHJvdG90eXBlLmFzeW1tZXRyaWNNYXRjaCA9IGZ1bmN0aW9uKG90aGVyKSB7XFxuICAgIHZhciBjbGFzc05hbWUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodGhpcy5zYW1wbGUpO1xcbiAgICBpZiAoY2xhc3NOYW1lICE9PSAnW29iamVjdCBBcnJheV0nKSB7IHRocm93IG5ldyBFcnJvcignWW91IG11c3QgcHJvdmlkZSBhbiBhcnJheSB0byBhcnJheUNvbnRhaW5pbmcsIG5vdCBcXFxcJycgKyB0aGlzLnNhbXBsZSArICdcXFxcJy4nKTsgfVxcblxcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc2FtcGxlLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgdmFyIGl0ZW0gPSB0aGlzLnNhbXBsZVtpXTtcXG4gICAgICBpZiAoIWokLm1hdGNoZXJzVXRpbC5jb250YWlucyhvdGhlciwgaXRlbSkpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHRydWU7XFxuICB9O1xcblxcbiAgQXJyYXlDb250YWluaW5nLnByb3RvdHlwZS5qYXNtaW5lVG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XFxuICAgIHJldHVybiAnPGphc21pbmUuYXJyYXlDb250YWluaW5nKCcgKyBqYXNtaW5lLnBwKHRoaXMuc2FtcGxlKSArJyk+JztcXG4gIH07XFxuXFxuICByZXR1cm4gQXJyYXlDb250YWluaW5nO1xcbn07XFxuXFxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5PYmplY3RDb250YWluaW5nID0gZnVuY3Rpb24oaiQpIHtcXG5cXG4gIGZ1bmN0aW9uIE9iamVjdENvbnRhaW5pbmcoc2FtcGxlKSB7XFxuICAgIHRoaXMuc2FtcGxlID0gc2FtcGxlO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gZ2V0UHJvdG90eXBlKG9iaikge1xcbiAgICBpZiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKSB7XFxuICAgICAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopO1xcbiAgICB9XFxuXFxuICAgIGlmIChvYmouY29uc3RydWN0b3IucHJvdG90eXBlID09IG9iaikge1xcbiAgICAgIHJldHVybiBudWxsO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBvYmouY29uc3RydWN0b3IucHJvdG90eXBlO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gaGFzUHJvcGVydHkob2JqLCBwcm9wZXJ0eSkge1xcbiAgICBpZiAoIW9iaikge1xcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcblxcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcGVydHkpKSB7XFxuICAgICAgcmV0dXJuIHRydWU7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIGhhc1Byb3BlcnR5KGdldFByb3RvdHlwZShvYmopLCBwcm9wZXJ0eSk7XFxuICB9XFxuXFxuICBPYmplY3RDb250YWluaW5nLnByb3RvdHlwZS5hc3ltbWV0cmljTWF0Y2ggPSBmdW5jdGlvbihvdGhlcikge1xcbiAgICBpZiAodHlwZW9mKHRoaXMuc2FtcGxlKSAhPT0gJ29iamVjdCcpIHsgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBwcm92aWRlIGFuIG9iamVjdCB0byBvYmplY3RDb250YWluaW5nLCBub3QgXFxcXCcnK3RoaXMuc2FtcGxlKydcXFxcJy4nKTsgfVxcblxcbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiB0aGlzLnNhbXBsZSkge1xcbiAgICAgIGlmICghaGFzUHJvcGVydHkob3RoZXIsIHByb3BlcnR5KSB8fFxcbiAgICAgICAgICAhaiQubWF0Y2hlcnNVdGlsLmVxdWFscyh0aGlzLnNhbXBsZVtwcm9wZXJ0eV0sIG90aGVyW3Byb3BlcnR5XSkpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHRydWU7XFxuICB9O1xcblxcbiAgT2JqZWN0Q29udGFpbmluZy5wcm90b3R5cGUuamFzbWluZVRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XFxuICAgIHJldHVybiAnPGphc21pbmUub2JqZWN0Q29udGFpbmluZygnICsgaiQucHAodGhpcy5zYW1wbGUpICsgJyk+JztcXG4gIH07XFxuXFxuICByZXR1cm4gT2JqZWN0Q29udGFpbmluZztcXG59O1xcblxcbmdldEphc21pbmVSZXF1aXJlT2JqKCkuU3RyaW5nTWF0Y2hpbmcgPSBmdW5jdGlvbihqJCkge1xcblxcbiAgZnVuY3Rpb24gU3RyaW5nTWF0Y2hpbmcoZXhwZWN0ZWQpIHtcXG4gICAgaWYgKCFqJC5pc1N0cmluZ18oZXhwZWN0ZWQpICYmICFqJC5pc0FfKCdSZWdFeHAnLCBleHBlY3RlZCkpIHtcXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGlzIG5vdCBhIFN0cmluZyBvciBhIFJlZ0V4cCcpO1xcbiAgICB9XFxuXFxuICAgIHRoaXMucmVnZXhwID0gbmV3IFJlZ0V4cChleHBlY3RlZCk7XFxuICB9XFxuXFxuICBTdHJpbmdNYXRjaGluZy5wcm90b3R5cGUuYXN5bW1ldHJpY01hdGNoID0gZnVuY3Rpb24ob3RoZXIpIHtcXG4gICAgcmV0dXJuIHRoaXMucmVnZXhwLnRlc3Qob3RoZXIpO1xcbiAgfTtcXG5cXG4gIFN0cmluZ01hdGNoaW5nLnByb3RvdHlwZS5qYXNtaW5lVG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcXG4gICAgcmV0dXJuICc8amFzbWluZS5zdHJpbmdNYXRjaGluZygnICsgdGhpcy5yZWdleHAgKyAnKT4nO1xcbiAgfTtcXG5cXG4gIHJldHVybiBTdHJpbmdNYXRjaGluZztcXG59O1xcblxcbmdldEphc21pbmVSZXF1aXJlT2JqKCkuZXJyb3JzID0gZnVuY3Rpb24oKSB7XFxuICBmdW5jdGlvbiBFeHBlY3RhdGlvbkZhaWxlZCgpIHt9XFxuXFxuICBFeHBlY3RhdGlvbkZhaWxlZC5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcXG4gIEV4cGVjdGF0aW9uRmFpbGVkLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEV4cGVjdGF0aW9uRmFpbGVkO1xcblxcbiAgcmV0dXJuIHtcXG4gICAgRXhwZWN0YXRpb25GYWlsZWQ6IEV4cGVjdGF0aW9uRmFpbGVkXFxuICB9O1xcbn07XFxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5tYXRjaGVyc1V0aWwgPSBmdW5jdGlvbihqJCkge1xcbiAgLy8gVE9ETzogd2hhdCB0byBkbyBhYm91dCBqYXNtaW5lLnBwIG5vdCBiZWluZyBpbmplY3Q/IG1vdmUgdG8gSlNPTi5zdHJpbmdpZnk/IGd1dCBQcmV0dHlQcmludGVyP1xcblxcbiAgcmV0dXJuIHtcXG4gICAgZXF1YWxzOiBmdW5jdGlvbihhLCBiLCBjdXN0b21UZXN0ZXJzKSB7XFxuICAgICAgY3VzdG9tVGVzdGVycyA9IGN1c3RvbVRlc3RlcnMgfHwgW107XFxuXFxuICAgICAgcmV0dXJuIGVxKGEsIGIsIFtdLCBbXSwgY3VzdG9tVGVzdGVycyk7XFxuICAgIH0sXFxuXFxuICAgIGNvbnRhaW5zOiBmdW5jdGlvbihoYXlzdGFjaywgbmVlZGxlLCBjdXN0b21UZXN0ZXJzKSB7XFxuICAgICAgY3VzdG9tVGVzdGVycyA9IGN1c3RvbVRlc3RlcnMgfHwgW107XFxuXFxuICAgICAgaWYgKChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KGhheXN0YWNrKSA9PT0gJ1tvYmplY3QgQXJyYXldJykgfHxcXG4gICAgICAgICghIWhheXN0YWNrICYmICFoYXlzdGFjay5pbmRleE9mKSlcXG4gICAgICB7XFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhheXN0YWNrLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgIGlmIChlcShoYXlzdGFja1tpXSwgbmVlZGxlLCBbXSwgW10sIGN1c3RvbVRlc3RlcnMpKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuICEhaGF5c3RhY2sgJiYgaGF5c3RhY2suaW5kZXhPZihuZWVkbGUpID49IDA7XFxuICAgIH0sXFxuXFxuICAgIGJ1aWxkRmFpbHVyZU1lc3NhZ2U6IGZ1bmN0aW9uKCkge1xcbiAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSxcXG4gICAgICAgIG1hdGNoZXJOYW1lID0gYXJnc1swXSxcXG4gICAgICAgIGlzTm90ID0gYXJnc1sxXSxcXG4gICAgICAgIGFjdHVhbCA9IGFyZ3NbMl0sXFxuICAgICAgICBleHBlY3RlZCA9IGFyZ3Muc2xpY2UoMyksXFxuICAgICAgICBlbmdsaXNoeVByZWRpY2F0ZSA9IG1hdGNoZXJOYW1lLnJlcGxhY2UoL1tBLVpdL2csIGZ1bmN0aW9uKHMpIHsgcmV0dXJuICcgJyArIHMudG9Mb3dlckNhc2UoKTsgfSk7XFxuXFxuICAgICAgdmFyIG1lc3NhZ2UgPSAnRXhwZWN0ZWQgJyArXFxuICAgICAgICBqJC5wcChhY3R1YWwpICtcXG4gICAgICAgIChpc05vdCA/ICcgbm90ICcgOiAnICcpICtcXG4gICAgICAgIGVuZ2xpc2h5UHJlZGljYXRlO1xcblxcbiAgICAgIGlmIChleHBlY3RlZC5sZW5ndGggPiAwKSB7XFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgIGlmIChpID4gMCkge1xcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gJywnO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIG1lc3NhZ2UgKz0gJyAnICsgaiQucHAoZXhwZWN0ZWRbaV0pO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gbWVzc2FnZSArICcuJztcXG4gICAgfVxcbiAgfTtcXG5cXG4gIGZ1bmN0aW9uIGlzQXN5bW1ldHJpYyhvYmopIHtcXG4gICAgcmV0dXJuIG9iaiAmJiBqJC5pc0FfKCdGdW5jdGlvbicsIG9iai5hc3ltbWV0cmljTWF0Y2gpO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gYXN5bW1ldHJpY01hdGNoKGEsIGIpIHtcXG4gICAgdmFyIGFzeW1tZXRyaWNBID0gaXNBc3ltbWV0cmljKGEpLFxcbiAgICAgICAgYXN5bW1ldHJpY0IgPSBpc0FzeW1tZXRyaWMoYik7XFxuXFxuICAgIGlmIChhc3ltbWV0cmljQSAmJiBhc3ltbWV0cmljQikge1xcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XFxuICAgIH1cXG5cXG4gICAgaWYgKGFzeW1tZXRyaWNBKSB7XFxuICAgICAgcmV0dXJuIGEuYXN5bW1ldHJpY01hdGNoKGIpO1xcbiAgICB9XFxuXFxuICAgIGlmIChhc3ltbWV0cmljQikge1xcbiAgICAgIHJldHVybiBiLmFzeW1tZXRyaWNNYXRjaChhKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgLy8gRXF1YWxpdHkgZnVuY3Rpb24gbG92aW5nbHkgYWRhcHRlZCBmcm9tIGlzRXF1YWwgaW5cXG4gIC8vICAgW1VuZGVyc2NvcmVdKGh0dHA6Ly91bmRlcnNjb3JlanMub3JnKVxcbiAgZnVuY3Rpb24gZXEoYSwgYiwgYVN0YWNrLCBiU3RhY2ssIGN1c3RvbVRlc3RlcnMpIHtcXG4gICAgdmFyIHJlc3VsdCA9IHRydWU7XFxuXFxuICAgIHZhciBhc3ltbWV0cmljUmVzdWx0ID0gYXN5bW1ldHJpY01hdGNoKGEsIGIpO1xcbiAgICBpZiAoIWokLnV0aWwuaXNVbmRlZmluZWQoYXN5bW1ldHJpY1Jlc3VsdCkpIHtcXG4gICAgICByZXR1cm4gYXN5bW1ldHJpY1Jlc3VsdDtcXG4gICAgfVxcblxcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGN1c3RvbVRlc3RlcnMubGVuZ3RoOyBpKyspIHtcXG4gICAgICB2YXIgY3VzdG9tVGVzdGVyUmVzdWx0ID0gY3VzdG9tVGVzdGVyc1tpXShhLCBiKTtcXG4gICAgICBpZiAoIWokLnV0aWwuaXNVbmRlZmluZWQoY3VzdG9tVGVzdGVyUmVzdWx0KSkge1xcbiAgICAgICAgcmV0dXJuIGN1c3RvbVRlc3RlclJlc3VsdDtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgaWYgKGEgaW5zdGFuY2VvZiBFcnJvciAmJiBiIGluc3RhbmNlb2YgRXJyb3IpIHtcXG4gICAgICByZXR1cm4gYS5tZXNzYWdlID09IGIubWVzc2FnZTtcXG4gICAgfVxcblxcbiAgICAvLyBJZGVudGljYWwgb2JqZWN0cyBhcmUgZXF1YWwuIGAwID09PSAtMGAsIGJ1dCB0aGV5IGFyZW4ndCBpZGVudGljYWwuXFxuICAgIC8vIFNlZSB0aGUgW0hhcm1vbnkgYGVnYWxgIHByb3Bvc2FsXShodHRwOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1oYXJtb255OmVnYWwpLlxcbiAgICBpZiAoYSA9PT0gYikgeyByZXR1cm4gYSAhPT0gMCB8fCAxIC8gYSA9PSAxIC8gYjsgfVxcbiAgICAvLyBBIHN0cmljdCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIGBudWxsID09IHVuZGVmaW5lZGAuXFxuICAgIGlmIChhID09PSBudWxsIHx8IGIgPT09IG51bGwpIHsgcmV0dXJuIGEgPT09IGI7IH1cXG4gICAgdmFyIGNsYXNzTmFtZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhKTtcXG4gICAgaWYgKGNsYXNzTmFtZSAhPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYikpIHsgcmV0dXJuIGZhbHNlOyB9XFxuICAgIHN3aXRjaCAoY2xhc3NOYW1lKSB7XFxuICAgICAgLy8gU3RyaW5ncywgbnVtYmVycywgZGF0ZXMsIGFuZCBib29sZWFucyBhcmUgY29tcGFyZWQgYnkgdmFsdWUuXFxuICAgICAgY2FzZSAnW29iamVjdCBTdHJpbmddJzpcXG4gICAgICAgIC8vIFByaW1pdGl2ZXMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgb2JqZWN0IHdyYXBwZXJzIGFyZSBlcXVpdmFsZW50OyB0aHVzLCBgXFxcIjVcXFwiYCBpc1xcbiAgICAgICAgLy8gZXF1aXZhbGVudCB0byBgbmV3IFN0cmluZyhcXFwiNVxcXCIpYC5cXG4gICAgICAgIHJldHVybiBhID09IFN0cmluZyhiKTtcXG4gICAgICBjYXNlICdbb2JqZWN0IE51bWJlcl0nOlxcbiAgICAgICAgLy8gYE5hTmBzIGFyZSBlcXVpdmFsZW50LCBidXQgbm9uLXJlZmxleGl2ZS4gQW4gYGVnYWxgIGNvbXBhcmlzb24gaXMgcGVyZm9ybWVkIGZvclxcbiAgICAgICAgLy8gb3RoZXIgbnVtZXJpYyB2YWx1ZXMuXFxuICAgICAgICByZXR1cm4gYSAhPSArYSA/IGIgIT0gK2IgOiAoYSA9PT0gMCA/IDEgLyBhID09IDEgLyBiIDogYSA9PSArYik7XFxuICAgICAgY2FzZSAnW29iamVjdCBEYXRlXSc6XFxuICAgICAgY2FzZSAnW29iamVjdCBCb29sZWFuXSc6XFxuICAgICAgICAvLyBDb2VyY2UgZGF0ZXMgYW5kIGJvb2xlYW5zIHRvIG51bWVyaWMgcHJpbWl0aXZlIHZhbHVlcy4gRGF0ZXMgYXJlIGNvbXBhcmVkIGJ5IHRoZWlyXFxuICAgICAgICAvLyBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnMuIE5vdGUgdGhhdCBpbnZhbGlkIGRhdGVzIHdpdGggbWlsbGlzZWNvbmQgcmVwcmVzZW50YXRpb25zXFxuICAgICAgICAvLyBvZiBgTmFOYCBhcmUgbm90IGVxdWl2YWxlbnQuXFxuICAgICAgICByZXR1cm4gK2EgPT0gK2I7XFxuICAgICAgLy8gUmVnRXhwcyBhcmUgY29tcGFyZWQgYnkgdGhlaXIgc291cmNlIHBhdHRlcm5zIGFuZCBmbGFncy5cXG4gICAgICBjYXNlICdbb2JqZWN0IFJlZ0V4cF0nOlxcbiAgICAgICAgcmV0dXJuIGEuc291cmNlID09IGIuc291cmNlICYmXFxuICAgICAgICAgIGEuZ2xvYmFsID09IGIuZ2xvYmFsICYmXFxuICAgICAgICAgIGEubXVsdGlsaW5lID09IGIubXVsdGlsaW5lICYmXFxuICAgICAgICAgIGEuaWdub3JlQ2FzZSA9PSBiLmlnbm9yZUNhc2U7XFxuICAgIH1cXG4gICAgaWYgKHR5cGVvZiBhICE9ICdvYmplY3QnIHx8IHR5cGVvZiBiICE9ICdvYmplY3QnKSB7IHJldHVybiBmYWxzZTsgfVxcblxcbiAgICB2YXIgYUlzRG9tTm9kZSA9IGokLmlzRG9tTm9kZShhKTtcXG4gICAgdmFyIGJJc0RvbU5vZGUgPSBqJC5pc0RvbU5vZGUoYik7XFxuICAgIGlmIChhSXNEb21Ob2RlICYmIGJJc0RvbU5vZGUpIHtcXG4gICAgICAvLyBBdCBmaXJzdCB0cnkgdG8gdXNlIERPTTMgbWV0aG9kIGlzRXF1YWxOb2RlXFxuICAgICAgaWYgKGEuaXNFcXVhbE5vZGUpIHtcXG4gICAgICAgIHJldHVybiBhLmlzRXF1YWxOb2RlKGIpO1xcbiAgICAgIH1cXG4gICAgICAvLyBJRTggZG9lc24ndCBzdXBwb3J0IGlzRXF1YWxOb2RlLCB0cnkgdG8gdXNlIG91dGVySFRNTCAmJiBpbm5lclRleHRcXG4gICAgICB2YXIgYUlzRWxlbWVudCA9IGEgaW5zdGFuY2VvZiBFbGVtZW50O1xcbiAgICAgIHZhciBiSXNFbGVtZW50ID0gYiBpbnN0YW5jZW9mIEVsZW1lbnQ7XFxuICAgICAgaWYgKGFJc0VsZW1lbnQgJiYgYklzRWxlbWVudCkge1xcbiAgICAgICAgcmV0dXJuIGEub3V0ZXJIVE1MID09IGIub3V0ZXJIVE1MO1xcbiAgICAgIH1cXG4gICAgICBpZiAoYUlzRWxlbWVudCB8fCBiSXNFbGVtZW50KSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBhLmlubmVyVGV4dCA9PSBiLmlubmVyVGV4dCAmJiBhLnRleHRDb250ZW50ID09IGIudGV4dENvbnRlbnQ7XFxuICAgIH1cXG4gICAgaWYgKGFJc0RvbU5vZGUgfHwgYklzRG9tTm9kZSkge1xcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcblxcbiAgICAvLyBBc3N1bWUgZXF1YWxpdHkgZm9yIGN5Y2xpYyBzdHJ1Y3R1cmVzLiBUaGUgYWxnb3JpdGhtIGZvciBkZXRlY3RpbmcgY3ljbGljXFxuICAgIC8vIHN0cnVjdHVyZXMgaXMgYWRhcHRlZCBmcm9tIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMsIGFic3RyYWN0IG9wZXJhdGlvbiBgSk9gLlxcbiAgICB2YXIgbGVuZ3RoID0gYVN0YWNrLmxlbmd0aDtcXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XFxuICAgICAgLy8gTGluZWFyIHNlYXJjaC4gUGVyZm9ybWFuY2UgaXMgaW52ZXJzZWx5IHByb3BvcnRpb25hbCB0byB0aGUgbnVtYmVyIG9mXFxuICAgICAgLy8gdW5pcXVlIG5lc3RlZCBzdHJ1Y3R1cmVzLlxcbiAgICAgIGlmIChhU3RhY2tbbGVuZ3RoXSA9PSBhKSB7IHJldHVybiBiU3RhY2tbbGVuZ3RoXSA9PSBiOyB9XFxuICAgIH1cXG4gICAgLy8gQWRkIHRoZSBmaXJzdCBvYmplY3QgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxcbiAgICBhU3RhY2sucHVzaChhKTtcXG4gICAgYlN0YWNrLnB1c2goYik7XFxuICAgIHZhciBzaXplID0gMDtcXG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIGFuZCBhcnJheXMuXFxuICAgIC8vIENvbXBhcmUgYXJyYXkgbGVuZ3RocyB0byBkZXRlcm1pbmUgaWYgYSBkZWVwIGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5LlxcbiAgICBpZiAoY2xhc3NOYW1lID09ICdbb2JqZWN0IEFycmF5XScgJiYgYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XFxuICAgICAgcmVzdWx0ID0gZmFsc2U7XFxuICAgIH1cXG5cXG4gICAgaWYgKHJlc3VsdCkge1xcbiAgICAgIC8vIE9iamVjdHMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1aXZhbGVudCwgYnV0IGBPYmplY3Rgc1xcbiAgICAgIC8vIG9yIGBBcnJheWBzIGZyb20gZGlmZmVyZW50IGZyYW1lcyBhcmUuXFxuICAgICAgaWYgKGNsYXNzTmFtZSAhPT0gJ1tvYmplY3QgQXJyYXldJykge1xcbiAgICAgICAgdmFyIGFDdG9yID0gYS5jb25zdHJ1Y3RvciwgYkN0b3IgPSBiLmNvbnN0cnVjdG9yO1xcbiAgICAgICAgaWYgKGFDdG9yICE9PSBiQ3RvciAmJiAhKGlzRnVuY3Rpb24oYUN0b3IpICYmIGFDdG9yIGluc3RhbmNlb2YgYUN0b3IgJiZcXG4gICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGJDdG9yKSAmJiBiQ3RvciBpbnN0YW5jZW9mIGJDdG9yKSkge1xcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIC8vIERlZXAgY29tcGFyZSBvYmplY3RzLlxcbiAgICAgIGZvciAodmFyIGtleSBpbiBhKSB7XFxuICAgICAgICBpZiAoaGFzKGEsIGtleSkpIHtcXG4gICAgICAgICAgLy8gQ291bnQgdGhlIGV4cGVjdGVkIG51bWJlciBvZiBwcm9wZXJ0aWVzLlxcbiAgICAgICAgICBzaXplKys7XFxuICAgICAgICAgIC8vIERlZXAgY29tcGFyZSBlYWNoIG1lbWJlci5cXG4gICAgICAgICAgaWYgKCEocmVzdWx0ID0gaGFzKGIsIGtleSkgJiYgZXEoYVtrZXldLCBiW2tleV0sIGFTdGFjaywgYlN0YWNrLCBjdXN0b21UZXN0ZXJzKSkpIHsgYnJlYWs7IH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgLy8gRW5zdXJlIHRoYXQgYm90aCBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUgbnVtYmVyIG9mIHByb3BlcnRpZXMuXFxuICAgICAgaWYgKHJlc3VsdCkge1xcbiAgICAgICAgZm9yIChrZXkgaW4gYikge1xcbiAgICAgICAgICBpZiAoaGFzKGIsIGtleSkgJiYgIShzaXplLS0pKSB7IGJyZWFrOyB9XFxuICAgICAgICB9XFxuICAgICAgICByZXN1bHQgPSAhc2l6ZTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgLy8gUmVtb3ZlIHRoZSBmaXJzdCBvYmplY3QgZnJvbSB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXFxuICAgIGFTdGFjay5wb3AoKTtcXG4gICAgYlN0YWNrLnBvcCgpO1xcblxcbiAgICByZXR1cm4gcmVzdWx0O1xcblxcbiAgICBmdW5jdGlvbiBoYXMob2JqLCBrZXkpIHtcXG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uKG9iaikge1xcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nO1xcbiAgICB9XFxuICB9XFxufTtcXG5cXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvQmUgPSBmdW5jdGlvbigpIHtcXG4gIGZ1bmN0aW9uIHRvQmUoKSB7XFxuICAgIHJldHVybiB7XFxuICAgICAgY29tcGFyZTogZnVuY3Rpb24oYWN0dWFsLCBleHBlY3RlZCkge1xcbiAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgcGFzczogYWN0dWFsID09PSBleHBlY3RlZFxcbiAgICAgICAgfTtcXG4gICAgICB9XFxuICAgIH07XFxuICB9XFxuXFxuICByZXR1cm4gdG9CZTtcXG59O1xcblxcbmdldEphc21pbmVSZXF1aXJlT2JqKCkudG9CZUNsb3NlVG8gPSBmdW5jdGlvbigpIHtcXG5cXG4gIGZ1bmN0aW9uIHRvQmVDbG9zZVRvKCkge1xcbiAgICByZXR1cm4ge1xcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGFjdHVhbCwgZXhwZWN0ZWQsIHByZWNpc2lvbikge1xcbiAgICAgICAgaWYgKHByZWNpc2lvbiAhPT0gMCkge1xcbiAgICAgICAgICBwcmVjaXNpb24gPSBwcmVjaXNpb24gfHwgMjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgIHBhc3M6IE1hdGguYWJzKGV4cGVjdGVkIC0gYWN0dWFsKSA8IChNYXRoLnBvdygxMCwgLXByZWNpc2lvbikgLyAyKVxcbiAgICAgICAgfTtcXG4gICAgICB9XFxuICAgIH07XFxuICB9XFxuXFxuICByZXR1cm4gdG9CZUNsb3NlVG87XFxufTtcXG5cXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvQmVEZWZpbmVkID0gZnVuY3Rpb24oKSB7XFxuICBmdW5jdGlvbiB0b0JlRGVmaW5lZCgpIHtcXG4gICAgcmV0dXJuIHtcXG4gICAgICBjb21wYXJlOiBmdW5jdGlvbihhY3R1YWwpIHtcXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgIHBhc3M6ICh2b2lkIDAgIT09IGFjdHVhbClcXG4gICAgICAgIH07XFxuICAgICAgfVxcbiAgICB9O1xcbiAgfVxcblxcbiAgcmV0dXJuIHRvQmVEZWZpbmVkO1xcbn07XFxuXFxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS50b0JlRmFsc3kgPSBmdW5jdGlvbigpIHtcXG4gIGZ1bmN0aW9uIHRvQmVGYWxzeSgpIHtcXG4gICAgcmV0dXJuIHtcXG4gICAgICBjb21wYXJlOiBmdW5jdGlvbihhY3R1YWwpIHtcXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgIHBhc3M6ICEhIWFjdHVhbFxcbiAgICAgICAgfTtcXG4gICAgICB9XFxuICAgIH07XFxuICB9XFxuXFxuICByZXR1cm4gdG9CZUZhbHN5O1xcbn07XFxuXFxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS50b0JlR3JlYXRlclRoYW4gPSBmdW5jdGlvbigpIHtcXG5cXG4gIGZ1bmN0aW9uIHRvQmVHcmVhdGVyVGhhbigpIHtcXG4gICAgcmV0dXJuIHtcXG4gICAgICBjb21wYXJlOiBmdW5jdGlvbihhY3R1YWwsIGV4cGVjdGVkKSB7XFxuICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICBwYXNzOiBhY3R1YWwgPiBleHBlY3RlZFxcbiAgICAgICAgfTtcXG4gICAgICB9XFxuICAgIH07XFxuICB9XFxuXFxuICByZXR1cm4gdG9CZUdyZWF0ZXJUaGFuO1xcbn07XFxuXFxuXFxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS50b0JlTGVzc1RoYW4gPSBmdW5jdGlvbigpIHtcXG4gIGZ1bmN0aW9uIHRvQmVMZXNzVGhhbigpIHtcXG4gICAgcmV0dXJuIHtcXG5cXG4gICAgICBjb21wYXJlOiBmdW5jdGlvbihhY3R1YWwsIGV4cGVjdGVkKSB7XFxuICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICBwYXNzOiBhY3R1YWwgPCBleHBlY3RlZFxcbiAgICAgICAgfTtcXG4gICAgICB9XFxuICAgIH07XFxuICB9XFxuXFxuICByZXR1cm4gdG9CZUxlc3NUaGFuO1xcbn07XFxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS50b0JlTmFOID0gZnVuY3Rpb24oaiQpIHtcXG5cXG4gIGZ1bmN0aW9uIHRvQmVOYU4oKSB7XFxuICAgIHJldHVybiB7XFxuICAgICAgY29tcGFyZTogZnVuY3Rpb24oYWN0dWFsKSB7XFxuICAgICAgICB2YXIgcmVzdWx0ID0ge1xcbiAgICAgICAgICBwYXNzOiAoYWN0dWFsICE9PSBhY3R1YWwpXFxuICAgICAgICB9O1xcblxcbiAgICAgICAgaWYgKHJlc3VsdC5wYXNzKSB7XFxuICAgICAgICAgIHJlc3VsdC5tZXNzYWdlID0gJ0V4cGVjdGVkIGFjdHVhbCBub3QgdG8gYmUgTmFOLic7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICByZXN1bHQubWVzc2FnZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gJ0V4cGVjdGVkICcgKyBqJC5wcChhY3R1YWwpICsgJyB0byBiZSBOYU4uJzsgfTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgICAgfVxcbiAgICB9O1xcbiAgfVxcblxcbiAgcmV0dXJuIHRvQmVOYU47XFxufTtcXG5cXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvQmVOdWxsID0gZnVuY3Rpb24oKSB7XFxuXFxuICBmdW5jdGlvbiB0b0JlTnVsbCgpIHtcXG4gICAgcmV0dXJuIHtcXG4gICAgICBjb21wYXJlOiBmdW5jdGlvbihhY3R1YWwpIHtcXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgIHBhc3M6IGFjdHVhbCA9PT0gbnVsbFxcbiAgICAgICAgfTtcXG4gICAgICB9XFxuICAgIH07XFxuICB9XFxuXFxuICByZXR1cm4gdG9CZU51bGw7XFxufTtcXG5cXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvQmVUcnV0aHkgPSBmdW5jdGlvbigpIHtcXG5cXG4gIGZ1bmN0aW9uIHRvQmVUcnV0aHkoKSB7XFxuICAgIHJldHVybiB7XFxuICAgICAgY29tcGFyZTogZnVuY3Rpb24oYWN0dWFsKSB7XFxuICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICBwYXNzOiAhIWFjdHVhbFxcbiAgICAgICAgfTtcXG4gICAgICB9XFxuICAgIH07XFxuICB9XFxuXFxuICByZXR1cm4gdG9CZVRydXRoeTtcXG59O1xcblxcbmdldEphc21pbmVSZXF1aXJlT2JqKCkudG9CZVVuZGVmaW5lZCA9IGZ1bmN0aW9uKCkge1xcblxcbiAgZnVuY3Rpb24gdG9CZVVuZGVmaW5lZCgpIHtcXG4gICAgcmV0dXJuIHtcXG4gICAgICBjb21wYXJlOiBmdW5jdGlvbihhY3R1YWwpIHtcXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgIHBhc3M6IHZvaWQgMCA9PT0gYWN0dWFsXFxuICAgICAgICB9O1xcbiAgICAgIH1cXG4gICAgfTtcXG4gIH1cXG5cXG4gIHJldHVybiB0b0JlVW5kZWZpbmVkO1xcbn07XFxuXFxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS50b0NvbnRhaW4gPSBmdW5jdGlvbigpIHtcXG4gIGZ1bmN0aW9uIHRvQ29udGFpbih1dGlsLCBjdXN0b21FcXVhbGl0eVRlc3RlcnMpIHtcXG4gICAgY3VzdG9tRXF1YWxpdHlUZXN0ZXJzID0gY3VzdG9tRXF1YWxpdHlUZXN0ZXJzIHx8IFtdO1xcblxcbiAgICByZXR1cm4ge1xcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpIHtcXG5cXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgIHBhc3M6IHV0aWwuY29udGFpbnMoYWN0dWFsLCBleHBlY3RlZCwgY3VzdG9tRXF1YWxpdHlUZXN0ZXJzKVxcbiAgICAgICAgfTtcXG4gICAgICB9XFxuICAgIH07XFxuICB9XFxuXFxuICByZXR1cm4gdG9Db250YWluO1xcbn07XFxuXFxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS50b0VxdWFsID0gZnVuY3Rpb24oKSB7XFxuXFxuICBmdW5jdGlvbiB0b0VxdWFsKHV0aWwsIGN1c3RvbUVxdWFsaXR5VGVzdGVycykge1xcbiAgICBjdXN0b21FcXVhbGl0eVRlc3RlcnMgPSBjdXN0b21FcXVhbGl0eVRlc3RlcnMgfHwgW107XFxuXFxuICAgIHJldHVybiB7XFxuICAgICAgY29tcGFyZTogZnVuY3Rpb24oYWN0dWFsLCBleHBlY3RlZCkge1xcbiAgICAgICAgdmFyIHJlc3VsdCA9IHtcXG4gICAgICAgICAgcGFzczogZmFsc2VcXG4gICAgICAgIH07XFxuXFxuICAgICAgICByZXN1bHQucGFzcyA9IHV0aWwuZXF1YWxzKGFjdHVhbCwgZXhwZWN0ZWQsIGN1c3RvbUVxdWFsaXR5VGVzdGVycyk7XFxuXFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICAgIH1cXG4gICAgfTtcXG4gIH1cXG5cXG4gIHJldHVybiB0b0VxdWFsO1xcbn07XFxuXFxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS50b0hhdmVCZWVuQ2FsbGVkID0gZnVuY3Rpb24oaiQpIHtcXG5cXG4gIGZ1bmN0aW9uIHRvSGF2ZUJlZW5DYWxsZWQoKSB7XFxuICAgIHJldHVybiB7XFxuICAgICAgY29tcGFyZTogZnVuY3Rpb24oYWN0dWFsKSB7XFxuICAgICAgICB2YXIgcmVzdWx0ID0ge307XFxuXFxuICAgICAgICBpZiAoIWokLmlzU3B5KGFjdHVhbCkpIHtcXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBhIHNweSwgYnV0IGdvdCAnICsgaiQucHAoYWN0dWFsKSArICcuJyk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0b0hhdmVCZWVuQ2FsbGVkIGRvZXMgbm90IHRha2UgYXJndW1lbnRzLCB1c2UgdG9IYXZlQmVlbkNhbGxlZFdpdGgnKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJlc3VsdC5wYXNzID0gYWN0dWFsLmNhbGxzLmFueSgpO1xcblxcbiAgICAgICAgcmVzdWx0Lm1lc3NhZ2UgPSByZXN1bHQucGFzcyA/XFxuICAgICAgICAgICdFeHBlY3RlZCBzcHkgJyArIGFjdHVhbC5hbmQuaWRlbnRpdHkoKSArICcgbm90IHRvIGhhdmUgYmVlbiBjYWxsZWQuJyA6XFxuICAgICAgICAgICdFeHBlY3RlZCBzcHkgJyArIGFjdHVhbC5hbmQuaWRlbnRpdHkoKSArICcgdG8gaGF2ZSBiZWVuIGNhbGxlZC4nO1xcblxcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgICB9XFxuICAgIH07XFxuICB9XFxuXFxuICByZXR1cm4gdG9IYXZlQmVlbkNhbGxlZDtcXG59O1xcblxcbmdldEphc21pbmVSZXF1aXJlT2JqKCkudG9IYXZlQmVlbkNhbGxlZFdpdGggPSBmdW5jdGlvbihqJCkge1xcblxcbiAgZnVuY3Rpb24gdG9IYXZlQmVlbkNhbGxlZFdpdGgodXRpbCwgY3VzdG9tRXF1YWxpdHlUZXN0ZXJzKSB7XFxuICAgIHJldHVybiB7XFxuICAgICAgY29tcGFyZTogZnVuY3Rpb24oKSB7XFxuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCksXFxuICAgICAgICAgIGFjdHVhbCA9IGFyZ3NbMF0sXFxuICAgICAgICAgIGV4cGVjdGVkQXJncyA9IGFyZ3Muc2xpY2UoMSksXFxuICAgICAgICAgIHJlc3VsdCA9IHsgcGFzczogZmFsc2UgfTtcXG5cXG4gICAgICAgIGlmICghaiQuaXNTcHkoYWN0dWFsKSkge1xcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGEgc3B5LCBidXQgZ290ICcgKyBqJC5wcChhY3R1YWwpICsgJy4nKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICghYWN0dWFsLmNhbGxzLmFueSgpKSB7XFxuICAgICAgICAgIHJlc3VsdC5tZXNzYWdlID0gZnVuY3Rpb24oKSB7IHJldHVybiAnRXhwZWN0ZWQgc3B5ICcgKyBhY3R1YWwuYW5kLmlkZW50aXR5KCkgKyAnIHRvIGhhdmUgYmVlbiBjYWxsZWQgd2l0aCAnICsgaiQucHAoZXhwZWN0ZWRBcmdzKSArICcgYnV0IGl0IHdhcyBuZXZlciBjYWxsZWQuJzsgfTtcXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICh1dGlsLmNvbnRhaW5zKGFjdHVhbC5jYWxscy5hbGxBcmdzKCksIGV4cGVjdGVkQXJncywgY3VzdG9tRXF1YWxpdHlUZXN0ZXJzKSkge1xcbiAgICAgICAgICByZXN1bHQucGFzcyA9IHRydWU7XFxuICAgICAgICAgIHJlc3VsdC5tZXNzYWdlID0gZnVuY3Rpb24oKSB7IHJldHVybiAnRXhwZWN0ZWQgc3B5ICcgKyBhY3R1YWwuYW5kLmlkZW50aXR5KCkgKyAnIG5vdCB0byBoYXZlIGJlZW4gY2FsbGVkIHdpdGggJyArIGokLnBwKGV4cGVjdGVkQXJncykgKyAnIGJ1dCBpdCB3YXMuJzsgfTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHJlc3VsdC5tZXNzYWdlID0gZnVuY3Rpb24oKSB7IHJldHVybiAnRXhwZWN0ZWQgc3B5ICcgKyBhY3R1YWwuYW5kLmlkZW50aXR5KCkgKyAnIHRvIGhhdmUgYmVlbiBjYWxsZWQgd2l0aCAnICsgaiQucHAoZXhwZWN0ZWRBcmdzKSArICcgYnV0IGFjdHVhbCBjYWxscyB3ZXJlICcgKyBqJC5wcChhY3R1YWwuY2FsbHMuYWxsQXJncygpKS5yZXBsYWNlKC9eXFxcXFsgfCBcXFxcXSQvZywgJycpICsgJy4nOyB9O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgICB9XFxuICAgIH07XFxuICB9XFxuXFxuICByZXR1cm4gdG9IYXZlQmVlbkNhbGxlZFdpdGg7XFxufTtcXG5cXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvTWF0Y2ggPSBmdW5jdGlvbihqJCkge1xcblxcbiAgZnVuY3Rpb24gdG9NYXRjaCgpIHtcXG4gICAgcmV0dXJuIHtcXG4gICAgICBjb21wYXJlOiBmdW5jdGlvbihhY3R1YWwsIGV4cGVjdGVkKSB7XFxuICAgICAgICBpZiAoIWokLmlzU3RyaW5nXyhleHBlY3RlZCkgJiYgIWokLmlzQV8oJ1JlZ0V4cCcsIGV4cGVjdGVkKSkge1xcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGlzIG5vdCBhIFN0cmluZyBvciBhIFJlZ0V4cCcpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdmFyIHJlZ2V4cCA9IG5ldyBSZWdFeHAoZXhwZWN0ZWQpO1xcblxcbiAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgcGFzczogcmVnZXhwLnRlc3QoYWN0dWFsKVxcbiAgICAgICAgfTtcXG4gICAgICB9XFxuICAgIH07XFxuICB9XFxuXFxuICByZXR1cm4gdG9NYXRjaDtcXG59O1xcblxcbmdldEphc21pbmVSZXF1aXJlT2JqKCkudG9UaHJvdyA9IGZ1bmN0aW9uKGokKSB7XFxuXFxuICBmdW5jdGlvbiB0b1Rocm93KHV0aWwpIHtcXG4gICAgcmV0dXJuIHtcXG4gICAgICBjb21wYXJlOiBmdW5jdGlvbihhY3R1YWwsIGV4cGVjdGVkKSB7XFxuICAgICAgICB2YXIgcmVzdWx0ID0geyBwYXNzOiBmYWxzZSB9LFxcbiAgICAgICAgICB0aHJldyA9IGZhbHNlLFxcbiAgICAgICAgICB0aHJvd247XFxuXFxuICAgICAgICBpZiAodHlwZW9mIGFjdHVhbCAhPSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQWN0dWFsIGlzIG5vdCBhIEZ1bmN0aW9uJyk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICBhY3R1YWwoKTtcXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgICAgdGhyZXcgPSB0cnVlO1xcbiAgICAgICAgICB0aHJvd24gPSBlO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKCF0aHJldykge1xcbiAgICAgICAgICByZXN1bHQubWVzc2FnZSA9ICdFeHBlY3RlZCBmdW5jdGlvbiB0byB0aHJvdyBhbiBleGNlcHRpb24uJztcXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEpIHtcXG4gICAgICAgICAgcmVzdWx0LnBhc3MgPSB0cnVlO1xcbiAgICAgICAgICByZXN1bHQubWVzc2FnZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gJ0V4cGVjdGVkIGZ1bmN0aW9uIG5vdCB0byB0aHJvdywgYnV0IGl0IHRocmV3ICcgKyBqJC5wcCh0aHJvd24pICsgJy4nOyB9O1xcblxcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKHV0aWwuZXF1YWxzKHRocm93biwgZXhwZWN0ZWQpKSB7XFxuICAgICAgICAgIHJlc3VsdC5wYXNzID0gdHJ1ZTtcXG4gICAgICAgICAgcmVzdWx0Lm1lc3NhZ2UgPSBmdW5jdGlvbigpIHsgcmV0dXJuICdFeHBlY3RlZCBmdW5jdGlvbiBub3QgdG8gdGhyb3cgJyArIGokLnBwKGV4cGVjdGVkKSArICcuJzsgfTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHJlc3VsdC5tZXNzYWdlID0gZnVuY3Rpb24oKSB7IHJldHVybiAnRXhwZWN0ZWQgZnVuY3Rpb24gdG8gdGhyb3cgJyArIGokLnBwKGV4cGVjdGVkKSArICcsIGJ1dCBpdCB0aHJldyAnICsgIGokLnBwKHRocm93bikgKyAnLic7IH07XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICAgIH1cXG4gICAgfTtcXG4gIH1cXG5cXG4gIHJldHVybiB0b1Rocm93O1xcbn07XFxuXFxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS50b1Rocm93RXJyb3IgPSBmdW5jdGlvbihqJCkge1xcbiAgZnVuY3Rpb24gdG9UaHJvd0Vycm9yICh1dGlsKSB7XFxuICAgIHJldHVybiB7XFxuICAgICAgY29tcGFyZTogZnVuY3Rpb24oYWN0dWFsKSB7XFxuICAgICAgICB2YXIgdGhyZXcgPSBmYWxzZSxcXG4gICAgICAgICAgcGFzcyA9IHtwYXNzOiB0cnVlfSxcXG4gICAgICAgICAgZmFpbCA9IHtwYXNzOiBmYWxzZX0sXFxuICAgICAgICAgIHRocm93bjtcXG5cXG4gICAgICAgIGlmICh0eXBlb2YgYWN0dWFsICE9ICdmdW5jdGlvbicpIHtcXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBY3R1YWwgaXMgbm90IGEgRnVuY3Rpb24nKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHZhciBlcnJvck1hdGNoZXIgPSBnZXRNYXRjaGVyLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XFxuXFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICBhY3R1YWwoKTtcXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgICAgdGhyZXcgPSB0cnVlO1xcbiAgICAgICAgICB0aHJvd24gPSBlO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKCF0aHJldykge1xcbiAgICAgICAgICBmYWlsLm1lc3NhZ2UgPSAnRXhwZWN0ZWQgZnVuY3Rpb24gdG8gdGhyb3cgYW4gRXJyb3IuJztcXG4gICAgICAgICAgcmV0dXJuIGZhaWw7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoISh0aHJvd24gaW5zdGFuY2VvZiBFcnJvcikpIHtcXG4gICAgICAgICAgZmFpbC5tZXNzYWdlID0gZnVuY3Rpb24oKSB7IHJldHVybiAnRXhwZWN0ZWQgZnVuY3Rpb24gdG8gdGhyb3cgYW4gRXJyb3IsIGJ1dCBpdCB0aHJldyAnICsgaiQucHAodGhyb3duKSArICcuJzsgfTtcXG4gICAgICAgICAgcmV0dXJuIGZhaWw7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoZXJyb3JNYXRjaGVyLmhhc05vU3BlY2lmaWNzKCkpIHtcXG4gICAgICAgICAgcGFzcy5tZXNzYWdlID0gJ0V4cGVjdGVkIGZ1bmN0aW9uIG5vdCB0byB0aHJvdyBhbiBFcnJvciwgYnV0IGl0IHRocmV3ICcgKyBqJC5mbk5hbWVGb3IodGhyb3duKSArICcuJztcXG4gICAgICAgICAgcmV0dXJuIHBhc3M7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoZXJyb3JNYXRjaGVyLm1hdGNoZXModGhyb3duKSkge1xcbiAgICAgICAgICBwYXNzLm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcXG4gICAgICAgICAgICByZXR1cm4gJ0V4cGVjdGVkIGZ1bmN0aW9uIG5vdCB0byB0aHJvdyAnICsgZXJyb3JNYXRjaGVyLmVycm9yVHlwZURlc2NyaXB0aW9uICsgZXJyb3JNYXRjaGVyLm1lc3NhZ2VEZXNjcmlwdGlvbigpICsgJy4nO1xcbiAgICAgICAgICB9O1xcbiAgICAgICAgICByZXR1cm4gcGFzcztcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGZhaWwubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgICAgIHJldHVybiAnRXhwZWN0ZWQgZnVuY3Rpb24gdG8gdGhyb3cgJyArIGVycm9yTWF0Y2hlci5lcnJvclR5cGVEZXNjcmlwdGlvbiArIGVycm9yTWF0Y2hlci5tZXNzYWdlRGVzY3JpcHRpb24oKSArXFxuICAgICAgICAgICAgICAnLCBidXQgaXQgdGhyZXcgJyArIGVycm9yTWF0Y2hlci50aHJvd25EZXNjcmlwdGlvbih0aHJvd24pICsgJy4nO1xcbiAgICAgICAgICB9O1xcbiAgICAgICAgICByZXR1cm4gZmFpbDtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH07XFxuXFxuICAgIGZ1bmN0aW9uIGdldE1hdGNoZXIoKSB7XFxuICAgICAgdmFyIGV4cGVjdGVkID0gbnVsbCxcXG4gICAgICAgICAgZXJyb3JUeXBlID0gbnVsbDtcXG5cXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAyKSB7XFxuICAgICAgICBleHBlY3RlZCA9IGFyZ3VtZW50c1sxXTtcXG4gICAgICAgIGlmIChpc0FuRXJyb3JUeXBlKGV4cGVjdGVkKSkge1xcbiAgICAgICAgICBlcnJvclR5cGUgPSBleHBlY3RlZDtcXG4gICAgICAgICAgZXhwZWN0ZWQgPSBudWxsO1xcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcXG4gICAgICAgIGVycm9yVHlwZSA9IGFyZ3VtZW50c1sxXTtcXG4gICAgICAgIGV4cGVjdGVkID0gYXJndW1lbnRzWzJdO1xcbiAgICAgICAgaWYgKCFpc0FuRXJyb3JUeXBlKGVycm9yVHlwZSkpIHtcXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBlcnJvciB0eXBlIGlzIG5vdCBhbiBFcnJvci4nKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGV4cGVjdGVkICYmICFpc1N0cmluZ09yUmVnRXhwKGV4cGVjdGVkKSkge1xcbiAgICAgICAgaWYgKGVycm9yVHlwZSkge1xcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGVycm9yIG1lc3NhZ2UgaXMgbm90IGEgc3RyaW5nIG9yIFJlZ0V4cC4nKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgaXMgbm90IGFuIEVycm9yLCBzdHJpbmcsIG9yIFJlZ0V4cC4nKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgZnVuY3Rpb24gbWVzc2FnZU1hdGNoKG1lc3NhZ2UpIHtcXG4gICAgICAgIGlmICh0eXBlb2YgZXhwZWN0ZWQgPT0gJ3N0cmluZycpIHtcXG4gICAgICAgICAgcmV0dXJuIGV4cGVjdGVkID09IG1lc3NhZ2U7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICByZXR1cm4gZXhwZWN0ZWQudGVzdChtZXNzYWdlKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHtcXG4gICAgICAgIGVycm9yVHlwZURlc2NyaXB0aW9uOiBlcnJvclR5cGUgPyBqJC5mbk5hbWVGb3IoZXJyb3JUeXBlKSA6ICdhbiBleGNlcHRpb24nLFxcbiAgICAgICAgdGhyb3duRGVzY3JpcHRpb246IGZ1bmN0aW9uKHRocm93bikge1xcbiAgICAgICAgICB2YXIgdGhyb3duTmFtZSA9IGVycm9yVHlwZSA/IGokLmZuTmFtZUZvcih0aHJvd24uY29uc3RydWN0b3IpIDogJ2FuIGV4Y2VwdGlvbicsXFxuICAgICAgICAgICAgICB0aHJvd25NZXNzYWdlID0gJyc7XFxuXFxuICAgICAgICAgIGlmIChleHBlY3RlZCkge1xcbiAgICAgICAgICAgIHRocm93bk1lc3NhZ2UgPSAnIHdpdGggbWVzc2FnZSAnICsgaiQucHAodGhyb3duLm1lc3NhZ2UpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHJldHVybiB0aHJvd25OYW1lICsgdGhyb3duTWVzc2FnZTtcXG4gICAgICAgIH0sXFxuICAgICAgICBtZXNzYWdlRGVzY3JpcHRpb246IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgICBpZiAoZXhwZWN0ZWQgPT09IG51bGwpIHtcXG4gICAgICAgICAgICByZXR1cm4gJyc7XFxuICAgICAgICAgIH0gZWxzZSBpZiAoZXhwZWN0ZWQgaW5zdGFuY2VvZiBSZWdFeHApIHtcXG4gICAgICAgICAgICByZXR1cm4gJyB3aXRoIGEgbWVzc2FnZSBtYXRjaGluZyAnICsgaiQucHAoZXhwZWN0ZWQpO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHJldHVybiAnIHdpdGggbWVzc2FnZSAnICsgaiQucHAoZXhwZWN0ZWQpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgaGFzTm9TcGVjaWZpY3M6IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgICByZXR1cm4gZXhwZWN0ZWQgPT09IG51bGwgJiYgZXJyb3JUeXBlID09PSBudWxsO1xcbiAgICAgICAgfSxcXG4gICAgICAgIG1hdGNoZXM6IGZ1bmN0aW9uKGVycm9yKSB7XFxuICAgICAgICAgIHJldHVybiAoZXJyb3JUeXBlID09PSBudWxsIHx8IGVycm9yIGluc3RhbmNlb2YgZXJyb3JUeXBlKSAmJlxcbiAgICAgICAgICAgIChleHBlY3RlZCA9PT0gbnVsbCB8fCBtZXNzYWdlTWF0Y2goZXJyb3IubWVzc2FnZSkpO1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gaXNTdHJpbmdPclJlZ0V4cChwb3RlbnRpYWwpIHtcXG4gICAgICByZXR1cm4gcG90ZW50aWFsIGluc3RhbmNlb2YgUmVnRXhwIHx8ICh0eXBlb2YgcG90ZW50aWFsID09ICdzdHJpbmcnKTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBpc0FuRXJyb3JUeXBlKHR5cGUpIHtcXG4gICAgICBpZiAodHlwZW9mIHR5cGUgIT09ICdmdW5jdGlvbicpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIFN1cnJvZ2F0ZSA9IGZ1bmN0aW9uKCkge307XFxuICAgICAgU3Vycm9nYXRlLnByb3RvdHlwZSA9IHR5cGUucHJvdG90eXBlO1xcbiAgICAgIHJldHVybiAobmV3IFN1cnJvZ2F0ZSgpKSBpbnN0YW5jZW9mIEVycm9yO1xcbiAgICB9XFxuICB9XFxuXFxuICByZXR1cm4gdG9UaHJvd0Vycm9yO1xcbn07XFxuXFxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5pbnRlcmZhY2UgPSBmdW5jdGlvbihqYXNtaW5lLCBlbnYpIHtcXG4gIHZhciBqYXNtaW5lSW50ZXJmYWNlID0ge1xcbiAgICBkZXNjcmliZTogZnVuY3Rpb24oZGVzY3JpcHRpb24sIHNwZWNEZWZpbml0aW9ucykge1xcbiAgICAgIHJldHVybiBlbnYuZGVzY3JpYmUoZGVzY3JpcHRpb24sIHNwZWNEZWZpbml0aW9ucyk7XFxuICAgIH0sXFxuXFxuICAgIHhkZXNjcmliZTogZnVuY3Rpb24oZGVzY3JpcHRpb24sIHNwZWNEZWZpbml0aW9ucykge1xcbiAgICAgIHJldHVybiBlbnYueGRlc2NyaWJlKGRlc2NyaXB0aW9uLCBzcGVjRGVmaW5pdGlvbnMpO1xcbiAgICB9LFxcblxcbiAgICBmZGVzY3JpYmU6IGZ1bmN0aW9uKGRlc2NyaXB0aW9uLCBzcGVjRGVmaW5pdGlvbnMpIHtcXG4gICAgICByZXR1cm4gZW52LmZkZXNjcmliZShkZXNjcmlwdGlvbiwgc3BlY0RlZmluaXRpb25zKTtcXG4gICAgfSxcXG5cXG4gICAgaXQ6IGZ1bmN0aW9uKCkge1xcbiAgICAgIHJldHVybiBlbnYuaXQuYXBwbHkoZW52LCBhcmd1bWVudHMpO1xcbiAgICB9LFxcblxcbiAgICB4aXQ6IGZ1bmN0aW9uKCkge1xcbiAgICAgIHJldHVybiBlbnYueGl0LmFwcGx5KGVudiwgYXJndW1lbnRzKTtcXG4gICAgfSxcXG5cXG4gICAgZml0OiBmdW5jdGlvbigpIHtcXG4gICAgICByZXR1cm4gZW52LmZpdC5hcHBseShlbnYsIGFyZ3VtZW50cyk7XFxuICAgIH0sXFxuXFxuICAgIGJlZm9yZUVhY2g6IGZ1bmN0aW9uKCkge1xcbiAgICAgIHJldHVybiBlbnYuYmVmb3JlRWFjaC5hcHBseShlbnYsIGFyZ3VtZW50cyk7XFxuICAgIH0sXFxuXFxuICAgIGFmdGVyRWFjaDogZnVuY3Rpb24oKSB7XFxuICAgICAgcmV0dXJuIGVudi5hZnRlckVhY2guYXBwbHkoZW52LCBhcmd1bWVudHMpO1xcbiAgICB9LFxcblxcbiAgICBiZWZvcmVBbGw6IGZ1bmN0aW9uKCkge1xcbiAgICAgIHJldHVybiBlbnYuYmVmb3JlQWxsLmFwcGx5KGVudiwgYXJndW1lbnRzKTtcXG4gICAgfSxcXG5cXG4gICAgYWZ0ZXJBbGw6IGZ1bmN0aW9uKCkge1xcbiAgICAgIHJldHVybiBlbnYuYWZ0ZXJBbGwuYXBwbHkoZW52LCBhcmd1bWVudHMpO1xcbiAgICB9LFxcblxcbiAgICBleHBlY3Q6IGZ1bmN0aW9uKGFjdHVhbCkge1xcbiAgICAgIHJldHVybiBlbnYuZXhwZWN0KGFjdHVhbCk7XFxuICAgIH0sXFxuXFxuICAgIHBlbmRpbmc6IGZ1bmN0aW9uKCkge1xcbiAgICAgIHJldHVybiBlbnYucGVuZGluZy5hcHBseShlbnYsIGFyZ3VtZW50cyk7XFxuICAgIH0sXFxuXFxuICAgIGZhaWw6IGZ1bmN0aW9uKCkge1xcbiAgICAgIHJldHVybiBlbnYuZmFpbC5hcHBseShlbnYsIGFyZ3VtZW50cyk7XFxuICAgIH0sXFxuXFxuICAgIHNweU9uOiBmdW5jdGlvbihvYmosIG1ldGhvZE5hbWUpIHtcXG4gICAgICByZXR1cm4gZW52LnNweU9uKG9iaiwgbWV0aG9kTmFtZSk7XFxuICAgIH0sXFxuXFxuICAgIGpzQXBpUmVwb3J0ZXI6IG5ldyBqYXNtaW5lLkpzQXBpUmVwb3J0ZXIoe1xcbiAgICAgIHRpbWVyOiBuZXcgamFzbWluZS5UaW1lcigpXFxuICAgIH0pLFxcblxcbiAgICBqYXNtaW5lOiBqYXNtaW5lXFxuICB9O1xcblxcbiAgamFzbWluZS5hZGRDdXN0b21FcXVhbGl0eVRlc3RlciA9IGZ1bmN0aW9uKHRlc3Rlcikge1xcbiAgICBlbnYuYWRkQ3VzdG9tRXF1YWxpdHlUZXN0ZXIodGVzdGVyKTtcXG4gIH07XFxuXFxuICBqYXNtaW5lLmFkZE1hdGNoZXJzID0gZnVuY3Rpb24obWF0Y2hlcnMpIHtcXG4gICAgcmV0dXJuIGVudi5hZGRNYXRjaGVycyhtYXRjaGVycyk7XFxuICB9O1xcblxcbiAgamFzbWluZS5jbG9jayA9IGZ1bmN0aW9uKCkge1xcbiAgICByZXR1cm4gZW52LmNsb2NrO1xcbiAgfTtcXG5cXG4gIHJldHVybiBqYXNtaW5lSW50ZXJmYWNlO1xcbn07XFxuXFxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS52ZXJzaW9uID0gZnVuY3Rpb24oKSB7XFxuICByZXR1cm4gJzIuMy40JztcXG59O1xcblwiXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbGliL2phc21pbmUtMi4zLjQvamFzbWluZS5qc1xuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCIvKlxcbkNvcHlyaWdodCAoYykgMjAwOC0yMDE1IFBpdm90YWwgTGFic1xcblxcblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZ1xcbmEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxcblxcXCJTb2Z0d2FyZVxcXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcXG53aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXFxuZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXFxucGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvXFxudGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxcblxcblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXFxuaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXFxuXFxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFxcXCJBUyBJU1xcXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXFxuRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXFxuTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcXG5OT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFXFxuTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTlxcbk9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTlxcbldJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxcbiovXFxuamFzbWluZVJlcXVpcmUuaHRtbCA9IGZ1bmN0aW9uKGokKSB7XFxuICBqJC5SZXN1bHRzTm9kZSA9IGphc21pbmVSZXF1aXJlLlJlc3VsdHNOb2RlKCk7XFxuICBqJC5IdG1sUmVwb3J0ZXIgPSBqYXNtaW5lUmVxdWlyZS5IdG1sUmVwb3J0ZXIoaiQpO1xcbiAgaiQuUXVlcnlTdHJpbmcgPSBqYXNtaW5lUmVxdWlyZS5RdWVyeVN0cmluZygpO1xcbiAgaiQuSHRtbFNwZWNGaWx0ZXIgPSBqYXNtaW5lUmVxdWlyZS5IdG1sU3BlY0ZpbHRlcigpO1xcbn07XFxuXFxuamFzbWluZVJlcXVpcmUuSHRtbFJlcG9ydGVyID0gZnVuY3Rpb24oaiQpIHtcXG5cXG4gIHZhciBub29wVGltZXIgPSB7XFxuICAgIHN0YXJ0OiBmdW5jdGlvbigpIHt9LFxcbiAgICBlbGFwc2VkOiBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH1cXG4gIH07XFxuXFxuICBmdW5jdGlvbiBIdG1sUmVwb3J0ZXIob3B0aW9ucykge1xcbiAgICB2YXIgZW52ID0gb3B0aW9ucy5lbnYgfHwge30sXFxuICAgICAgZ2V0Q29udGFpbmVyID0gb3B0aW9ucy5nZXRDb250YWluZXIsXFxuICAgICAgY3JlYXRlRWxlbWVudCA9IG9wdGlvbnMuY3JlYXRlRWxlbWVudCxcXG4gICAgICBjcmVhdGVUZXh0Tm9kZSA9IG9wdGlvbnMuY3JlYXRlVGV4dE5vZGUsXFxuICAgICAgb25SYWlzZUV4Y2VwdGlvbnNDbGljayA9IG9wdGlvbnMub25SYWlzZUV4Y2VwdGlvbnNDbGljayB8fCBmdW5jdGlvbigpIHt9LFxcbiAgICAgIG9uVGhyb3dFeHBlY3RhdGlvbnNDbGljayA9IG9wdGlvbnMub25UaHJvd0V4cGVjdGF0aW9uc0NsaWNrIHx8IGZ1bmN0aW9uKCkge30sXFxuICAgICAgYWRkVG9FeGlzdGluZ1F1ZXJ5U3RyaW5nID0gb3B0aW9ucy5hZGRUb0V4aXN0aW5nUXVlcnlTdHJpbmcgfHwgZGVmYXVsdFF1ZXJ5U3RyaW5nLFxcbiAgICAgIHRpbWVyID0gb3B0aW9ucy50aW1lciB8fCBub29wVGltZXIsXFxuICAgICAgcmVzdWx0cyA9IFtdLFxcbiAgICAgIHNwZWNzRXhlY3V0ZWQgPSAwLFxcbiAgICAgIGZhaWx1cmVDb3VudCA9IDAsXFxuICAgICAgcGVuZGluZ1NwZWNDb3VudCA9IDAsXFxuICAgICAgaHRtbFJlcG9ydGVyTWFpbixcXG4gICAgICBzeW1ib2xzLFxcbiAgICAgIGZhaWxlZFN1aXRlcyA9IFtdO1xcblxcbiAgICB0aGlzLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHtcXG4gICAgICBjbGVhclByaW9yKCk7XFxuICAgICAgaHRtbFJlcG9ydGVyTWFpbiA9IGNyZWF0ZURvbSgnZGl2Jywge2NsYXNzTmFtZTogJ2phc21pbmVfaHRtbC1yZXBvcnRlcid9LFxcbiAgICAgICAgY3JlYXRlRG9tKCdkaXYnLCB7Y2xhc3NOYW1lOiAnYmFubmVyJ30sXFxuICAgICAgICAgIGNyZWF0ZURvbSgnYScsIHtjbGFzc05hbWU6ICd0aXRsZScsIGhyZWY6ICdodHRwOi8vamFzbWluZS5naXRodWIuaW8vJywgdGFyZ2V0OiAnX2JsYW5rJ30pLFxcbiAgICAgICAgICBjcmVhdGVEb20oJ3NwYW4nLCB7Y2xhc3NOYW1lOiAndmVyc2lvbid9LCBqJC52ZXJzaW9uKVxcbiAgICAgICAgKSxcXG4gICAgICAgIGNyZWF0ZURvbSgndWwnLCB7Y2xhc3NOYW1lOiAnc3ltYm9sLXN1bW1hcnknfSksXFxuICAgICAgICBjcmVhdGVEb20oJ2RpdicsIHtjbGFzc05hbWU6ICdhbGVydCd9KSxcXG4gICAgICAgIGNyZWF0ZURvbSgnZGl2Jywge2NsYXNzTmFtZTogJ3Jlc3VsdHMnfSxcXG4gICAgICAgICAgY3JlYXRlRG9tKCdkaXYnLCB7Y2xhc3NOYW1lOiAnZmFpbHVyZXMnfSlcXG4gICAgICAgIClcXG4gICAgICApO1xcbiAgICAgIGdldENvbnRhaW5lcigpLmFwcGVuZENoaWxkKGh0bWxSZXBvcnRlck1haW4pO1xcblxcbiAgICAgIHN5bWJvbHMgPSBmaW5kKCcuc3ltYm9sLXN1bW1hcnknKTtcXG4gICAgfTtcXG5cXG4gICAgdmFyIHRvdGFsU3BlY3NEZWZpbmVkO1xcbiAgICB0aGlzLmphc21pbmVTdGFydGVkID0gZnVuY3Rpb24ob3B0aW9ucykge1xcbiAgICAgIHRvdGFsU3BlY3NEZWZpbmVkID0gb3B0aW9ucy50b3RhbFNwZWNzRGVmaW5lZCB8fCAwO1xcbiAgICAgIHRpbWVyLnN0YXJ0KCk7XFxuICAgIH07XFxuXFxuICAgIHZhciBzdW1tYXJ5ID0gY3JlYXRlRG9tKCdkaXYnLCB7Y2xhc3NOYW1lOiAnc3VtbWFyeSd9KTtcXG5cXG4gICAgdmFyIHRvcFJlc3VsdHMgPSBuZXcgaiQuUmVzdWx0c05vZGUoe30sICcnLCBudWxsKSxcXG4gICAgICBjdXJyZW50UGFyZW50ID0gdG9wUmVzdWx0cztcXG5cXG4gICAgdGhpcy5zdWl0ZVN0YXJ0ZWQgPSBmdW5jdGlvbihyZXN1bHQpIHtcXG4gICAgICBjdXJyZW50UGFyZW50LmFkZENoaWxkKHJlc3VsdCwgJ3N1aXRlJyk7XFxuICAgICAgY3VycmVudFBhcmVudCA9IGN1cnJlbnRQYXJlbnQubGFzdCgpO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLnN1aXRlRG9uZSA9IGZ1bmN0aW9uKHJlc3VsdCkge1xcbiAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09ICdmYWlsZWQnKSB7XFxuICAgICAgICBmYWlsZWRTdWl0ZXMucHVzaChyZXN1bHQpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoY3VycmVudFBhcmVudCA9PSB0b3BSZXN1bHRzKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGN1cnJlbnRQYXJlbnQgPSBjdXJyZW50UGFyZW50LnBhcmVudDtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5zcGVjU3RhcnRlZCA9IGZ1bmN0aW9uKHJlc3VsdCkge1xcbiAgICAgIGN1cnJlbnRQYXJlbnQuYWRkQ2hpbGQocmVzdWx0LCAnc3BlYycpO1xcbiAgICB9O1xcblxcbiAgICB2YXIgZmFpbHVyZXMgPSBbXTtcXG4gICAgdGhpcy5zcGVjRG9uZSA9IGZ1bmN0aW9uKHJlc3VsdCkge1xcbiAgICAgIGlmKG5vRXhwZWN0YXRpb25zKHJlc3VsdCkgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjb25zb2xlLmVycm9yICE9PSAndW5kZWZpbmVkJykge1xcbiAgICAgICAgY29uc29sZS5lcnJvcignU3BlYyBcXFxcJycgKyByZXN1bHQuZnVsbE5hbWUgKyAnXFxcXCcgaGFzIG5vIGV4cGVjdGF0aW9ucy4nKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgIT0gJ2Rpc2FibGVkJykge1xcbiAgICAgICAgc3BlY3NFeGVjdXRlZCsrO1xcbiAgICAgIH1cXG5cXG4gICAgICBzeW1ib2xzLmFwcGVuZENoaWxkKGNyZWF0ZURvbSgnbGknLCB7XFxuICAgICAgICAgIGNsYXNzTmFtZTogbm9FeHBlY3RhdGlvbnMocmVzdWx0KSA/ICdlbXB0eScgOiByZXN1bHQuc3RhdHVzLFxcbiAgICAgICAgICBpZDogJ3NwZWNfJyArIHJlc3VsdC5pZCxcXG4gICAgICAgICAgdGl0bGU6IHJlc3VsdC5mdWxsTmFtZVxcbiAgICAgICAgfVxcbiAgICAgICkpO1xcblxcbiAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09ICdmYWlsZWQnKSB7XFxuICAgICAgICBmYWlsdXJlQ291bnQrKztcXG5cXG4gICAgICAgIHZhciBmYWlsdXJlID1cXG4gICAgICAgICAgY3JlYXRlRG9tKCdkaXYnLCB7Y2xhc3NOYW1lOiAnc3BlYy1kZXRhaWwgZmFpbGVkJ30sXFxuICAgICAgICAgICAgY3JlYXRlRG9tKCdkaXYnLCB7Y2xhc3NOYW1lOiAnZGVzY3JpcHRpb24nfSxcXG4gICAgICAgICAgICAgIGNyZWF0ZURvbSgnYScsIHt0aXRsZTogcmVzdWx0LmZ1bGxOYW1lLCBocmVmOiBzcGVjSHJlZihyZXN1bHQpfSwgcmVzdWx0LmZ1bGxOYW1lKVxcbiAgICAgICAgICAgICksXFxuICAgICAgICAgICAgY3JlYXRlRG9tKCdkaXYnLCB7Y2xhc3NOYW1lOiAnbWVzc2FnZXMnfSlcXG4gICAgICAgICAgKTtcXG4gICAgICAgIHZhciBtZXNzYWdlcyA9IGZhaWx1cmUuY2hpbGROb2Rlc1sxXTtcXG5cXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0LmZhaWxlZEV4cGVjdGF0aW9ucy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgICB2YXIgZXhwZWN0YXRpb24gPSByZXN1bHQuZmFpbGVkRXhwZWN0YXRpb25zW2ldO1xcbiAgICAgICAgICBtZXNzYWdlcy5hcHBlbmRDaGlsZChjcmVhdGVEb20oJ2RpdicsIHtjbGFzc05hbWU6ICdyZXN1bHQtbWVzc2FnZSd9LCBleHBlY3RhdGlvbi5tZXNzYWdlKSk7XFxuICAgICAgICAgIG1lc3NhZ2VzLmFwcGVuZENoaWxkKGNyZWF0ZURvbSgnZGl2Jywge2NsYXNzTmFtZTogJ3N0YWNrLXRyYWNlJ30sIGV4cGVjdGF0aW9uLnN0YWNrKSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBmYWlsdXJlcy5wdXNoKGZhaWx1cmUpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PSAncGVuZGluZycpIHtcXG4gICAgICAgIHBlbmRpbmdTcGVjQ291bnQrKztcXG4gICAgICB9XFxuICAgIH07XFxuXFxuICAgIHRoaXMuamFzbWluZURvbmUgPSBmdW5jdGlvbigpIHtcXG4gICAgICB2YXIgYmFubmVyID0gZmluZCgnLmJhbm5lcicpO1xcbiAgICAgIHZhciBhbGVydCA9IGZpbmQoJy5hbGVydCcpO1xcbiAgICAgIGFsZXJ0LmFwcGVuZENoaWxkKGNyZWF0ZURvbSgnc3BhbicsIHtjbGFzc05hbWU6ICdkdXJhdGlvbid9LCAnZmluaXNoZWQgaW4gJyArIHRpbWVyLmVsYXBzZWQoKSAvIDEwMDAgKyAncycpKTtcXG5cXG4gICAgICBiYW5uZXIuYXBwZW5kQ2hpbGQoXFxuICAgICAgICBjcmVhdGVEb20oJ2RpdicsIHsgY2xhc3NOYW1lOiAncnVuLW9wdGlvbnMnIH0sXFxuICAgICAgICAgIGNyZWF0ZURvbSgnc3BhbicsIHsgY2xhc3NOYW1lOiAndHJpZ2dlcicgfSwgJ09wdGlvbnMnKSxcXG4gICAgICAgICAgY3JlYXRlRG9tKCdkaXYnLCB7IGNsYXNzTmFtZTogJ3BheWxvYWQnIH0sXFxuICAgICAgICAgICAgY3JlYXRlRG9tKCdkaXYnLCB7IGNsYXNzTmFtZTogJ2V4Y2VwdGlvbnMnIH0sXFxuICAgICAgICAgICAgICBjcmVhdGVEb20oJ2lucHV0Jywge1xcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdyYWlzZScsXFxuICAgICAgICAgICAgICAgIGlkOiAncmFpc2UtZXhjZXB0aW9ucycsXFxuICAgICAgICAgICAgICAgIHR5cGU6ICdjaGVja2JveCdcXG4gICAgICAgICAgICAgIH0pLFxcbiAgICAgICAgICAgICAgY3JlYXRlRG9tKCdsYWJlbCcsIHsgY2xhc3NOYW1lOiAnbGFiZWwnLCAnZm9yJzogJ3JhaXNlLWV4Y2VwdGlvbnMnIH0sICdyYWlzZSBleGNlcHRpb25zJykpLFxcbiAgICAgICAgICAgIGNyZWF0ZURvbSgnZGl2JywgeyBjbGFzc05hbWU6ICd0aHJvdy1mYWlsdXJlcycgfSxcXG4gICAgICAgICAgICAgIGNyZWF0ZURvbSgnaW5wdXQnLCB7XFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ3Rocm93JyxcXG4gICAgICAgICAgICAgICAgaWQ6ICd0aHJvdy1mYWlsdXJlcycsXFxuICAgICAgICAgICAgICAgIHR5cGU6ICdjaGVja2JveCdcXG4gICAgICAgICAgICAgIH0pLFxcbiAgICAgICAgICAgICAgY3JlYXRlRG9tKCdsYWJlbCcsIHsgY2xhc3NOYW1lOiAnbGFiZWwnLCAnZm9yJzogJ3Rocm93LWZhaWx1cmVzJyB9LCAnc3RvcCBzcGVjIG9uIGV4cGVjdGF0aW9uIGZhaWx1cmUnKSlcXG4gICAgICAgICAgKVxcbiAgICAgICAgKSk7XFxuXFxuICAgICAgdmFyIHJhaXNlQ2hlY2tib3ggPSBmaW5kKCcjcmFpc2UtZXhjZXB0aW9ucycpO1xcblxcbiAgICAgIHJhaXNlQ2hlY2tib3guY2hlY2tlZCA9ICFlbnYuY2F0Y2hpbmdFeGNlcHRpb25zKCk7XFxuICAgICAgcmFpc2VDaGVja2JveC5vbmNsaWNrID0gb25SYWlzZUV4Y2VwdGlvbnNDbGljaztcXG5cXG4gICAgICB2YXIgdGhyb3dDaGVja2JveCA9IGZpbmQoJyN0aHJvdy1mYWlsdXJlcycpO1xcbiAgICAgIHRocm93Q2hlY2tib3guY2hlY2tlZCA9IGVudi50aHJvd2luZ0V4cGVjdGF0aW9uRmFpbHVyZXMoKTtcXG4gICAgICB0aHJvd0NoZWNrYm94Lm9uY2xpY2sgPSBvblRocm93RXhwZWN0YXRpb25zQ2xpY2s7XFxuXFxuICAgICAgdmFyIG9wdGlvbnNNZW51ID0gZmluZCgnLnJ1bi1vcHRpb25zJyksXFxuICAgICAgICAgIG9wdGlvbnNUcmlnZ2VyID0gb3B0aW9uc01lbnUucXVlcnlTZWxlY3RvcignLnRyaWdnZXInKSxcXG4gICAgICAgICAgb3B0aW9uc1BheWxvYWQgPSBvcHRpb25zTWVudS5xdWVyeVNlbGVjdG9yKCcucGF5bG9hZCcpLFxcbiAgICAgICAgICBpc09wZW4gPSAvXFxcXGJvcGVuXFxcXGIvO1xcblxcbiAgICAgIG9wdGlvbnNUcmlnZ2VyLm9uY2xpY2sgPSBmdW5jdGlvbigpIHtcXG4gICAgICAgIGlmIChpc09wZW4udGVzdChvcHRpb25zUGF5bG9hZC5jbGFzc05hbWUpKSB7XFxuICAgICAgICAgIG9wdGlvbnNQYXlsb2FkLmNsYXNzTmFtZSA9IG9wdGlvbnNQYXlsb2FkLmNsYXNzTmFtZS5yZXBsYWNlKGlzT3BlbiwgJycpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgb3B0aW9uc1BheWxvYWQuY2xhc3NOYW1lICs9ICcgb3Blbic7XFxuICAgICAgICB9XFxuICAgICAgfTtcXG5cXG4gICAgICBpZiAoc3BlY3NFeGVjdXRlZCA8IHRvdGFsU3BlY3NEZWZpbmVkKSB7XFxuICAgICAgICB2YXIgc2tpcHBlZE1lc3NhZ2UgPSAnUmFuICcgKyBzcGVjc0V4ZWN1dGVkICsgJyBvZiAnICsgdG90YWxTcGVjc0RlZmluZWQgKyAnIHNwZWNzIC0gcnVuIGFsbCc7XFxuICAgICAgICBhbGVydC5hcHBlbmRDaGlsZChcXG4gICAgICAgICAgY3JlYXRlRG9tKCdzcGFuJywge2NsYXNzTmFtZTogJ2JhciBza2lwcGVkJ30sXFxuICAgICAgICAgICAgY3JlYXRlRG9tKCdhJywge2hyZWY6ICc/JywgdGl0bGU6ICdSdW4gYWxsIHNwZWNzJ30sIHNraXBwZWRNZXNzYWdlKVxcbiAgICAgICAgICApXFxuICAgICAgICApO1xcbiAgICAgIH1cXG4gICAgICB2YXIgc3RhdHVzQmFyTWVzc2FnZSA9ICcnO1xcbiAgICAgIHZhciBzdGF0dXNCYXJDbGFzc05hbWUgPSAnYmFyICc7XFxuXFxuICAgICAgaWYgKHRvdGFsU3BlY3NEZWZpbmVkID4gMCkge1xcbiAgICAgICAgc3RhdHVzQmFyTWVzc2FnZSArPSBwbHVyYWxpemUoJ3NwZWMnLCBzcGVjc0V4ZWN1dGVkKSArICcsICcgKyBwbHVyYWxpemUoJ2ZhaWx1cmUnLCBmYWlsdXJlQ291bnQpO1xcbiAgICAgICAgaWYgKHBlbmRpbmdTcGVjQ291bnQpIHsgc3RhdHVzQmFyTWVzc2FnZSArPSAnLCAnICsgcGx1cmFsaXplKCdwZW5kaW5nIHNwZWMnLCBwZW5kaW5nU3BlY0NvdW50KTsgfVxcbiAgICAgICAgc3RhdHVzQmFyQ2xhc3NOYW1lICs9IChmYWlsdXJlQ291bnQgPiAwKSA/ICdmYWlsZWQnIDogJ3Bhc3NlZCc7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHN0YXR1c0JhckNsYXNzTmFtZSArPSAnc2tpcHBlZCc7XFxuICAgICAgICBzdGF0dXNCYXJNZXNzYWdlICs9ICdObyBzcGVjcyBmb3VuZCc7XFxuICAgICAgfVxcblxcbiAgICAgIGFsZXJ0LmFwcGVuZENoaWxkKGNyZWF0ZURvbSgnc3BhbicsIHtjbGFzc05hbWU6IHN0YXR1c0JhckNsYXNzTmFtZX0sIHN0YXR1c0Jhck1lc3NhZ2UpKTtcXG5cXG4gICAgICBmb3IoaSA9IDA7IGkgPCBmYWlsZWRTdWl0ZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgIHZhciBmYWlsZWRTdWl0ZSA9IGZhaWxlZFN1aXRlc1tpXTtcXG4gICAgICAgIGZvcih2YXIgaiA9IDA7IGogPCBmYWlsZWRTdWl0ZS5mYWlsZWRFeHBlY3RhdGlvbnMubGVuZ3RoOyBqKyspIHtcXG4gICAgICAgICAgdmFyIGVycm9yQmFyTWVzc2FnZSA9ICdBZnRlckFsbCAnICsgZmFpbGVkU3VpdGUuZmFpbGVkRXhwZWN0YXRpb25zW2pdLm1lc3NhZ2U7XFxuICAgICAgICAgIHZhciBlcnJvckJhckNsYXNzTmFtZSA9ICdiYXIgZXJyb3JlZCc7XFxuICAgICAgICAgIGFsZXJ0LmFwcGVuZENoaWxkKGNyZWF0ZURvbSgnc3BhbicsIHtjbGFzc05hbWU6IGVycm9yQmFyQ2xhc3NOYW1lfSwgZXJyb3JCYXJNZXNzYWdlKSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHZhciByZXN1bHRzID0gZmluZCgnLnJlc3VsdHMnKTtcXG4gICAgICByZXN1bHRzLmFwcGVuZENoaWxkKHN1bW1hcnkpO1xcblxcbiAgICAgIHN1bW1hcnlMaXN0KHRvcFJlc3VsdHMsIHN1bW1hcnkpO1xcblxcbiAgICAgIGZ1bmN0aW9uIHN1bW1hcnlMaXN0KHJlc3VsdHNUcmVlLCBkb21QYXJlbnQpIHtcXG4gICAgICAgIHZhciBzcGVjTGlzdE5vZGU7XFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdHNUcmVlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgIHZhciByZXN1bHROb2RlID0gcmVzdWx0c1RyZWUuY2hpbGRyZW5baV07XFxuICAgICAgICAgIGlmIChyZXN1bHROb2RlLnR5cGUgPT0gJ3N1aXRlJykge1xcbiAgICAgICAgICAgIHZhciBzdWl0ZUxpc3ROb2RlID0gY3JlYXRlRG9tKCd1bCcsIHtjbGFzc05hbWU6ICdzdWl0ZScsIGlkOiAnc3VpdGUtJyArIHJlc3VsdE5vZGUucmVzdWx0LmlkfSxcXG4gICAgICAgICAgICAgIGNyZWF0ZURvbSgnbGknLCB7Y2xhc3NOYW1lOiAnc3VpdGUtZGV0YWlsJ30sXFxuICAgICAgICAgICAgICAgIGNyZWF0ZURvbSgnYScsIHtocmVmOiBzcGVjSHJlZihyZXN1bHROb2RlLnJlc3VsdCl9LCByZXN1bHROb2RlLnJlc3VsdC5kZXNjcmlwdGlvbilcXG4gICAgICAgICAgICAgIClcXG4gICAgICAgICAgICApO1xcblxcbiAgICAgICAgICAgIHN1bW1hcnlMaXN0KHJlc3VsdE5vZGUsIHN1aXRlTGlzdE5vZGUpO1xcbiAgICAgICAgICAgIGRvbVBhcmVudC5hcHBlbmRDaGlsZChzdWl0ZUxpc3ROb2RlKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpZiAocmVzdWx0Tm9kZS50eXBlID09ICdzcGVjJykge1xcbiAgICAgICAgICAgIGlmIChkb21QYXJlbnQuZ2V0QXR0cmlidXRlKCdjbGFzcycpICE9ICdzcGVjcycpIHtcXG4gICAgICAgICAgICAgIHNwZWNMaXN0Tm9kZSA9IGNyZWF0ZURvbSgndWwnLCB7Y2xhc3NOYW1lOiAnc3BlY3MnfSk7XFxuICAgICAgICAgICAgICBkb21QYXJlbnQuYXBwZW5kQ2hpbGQoc3BlY0xpc3ROb2RlKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgdmFyIHNwZWNEZXNjcmlwdGlvbiA9IHJlc3VsdE5vZGUucmVzdWx0LmRlc2NyaXB0aW9uO1xcbiAgICAgICAgICAgIGlmKG5vRXhwZWN0YXRpb25zKHJlc3VsdE5vZGUucmVzdWx0KSkge1xcbiAgICAgICAgICAgICAgc3BlY0Rlc2NyaXB0aW9uID0gJ1NQRUMgSEFTIE5PIEVYUEVDVEFUSU9OUyAnICsgc3BlY0Rlc2NyaXB0aW9uO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZihyZXN1bHROb2RlLnJlc3VsdC5zdGF0dXMgPT09ICdwZW5kaW5nJyAmJiByZXN1bHROb2RlLnJlc3VsdC5wZW5kaW5nUmVhc29uICE9PSAnJykge1xcbiAgICAgICAgICAgICAgc3BlY0Rlc2NyaXB0aW9uID0gc3BlY0Rlc2NyaXB0aW9uICsgJyBQRU5ESU5HIFdJVEggTUVTU0FHRTogJyArIHJlc3VsdE5vZGUucmVzdWx0LnBlbmRpbmdSZWFzb247XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHNwZWNMaXN0Tm9kZS5hcHBlbmRDaGlsZChcXG4gICAgICAgICAgICAgIGNyZWF0ZURvbSgnbGknLCB7XFxuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiByZXN1bHROb2RlLnJlc3VsdC5zdGF0dXMsXFxuICAgICAgICAgICAgICAgICAgaWQ6ICdzcGVjLScgKyByZXN1bHROb2RlLnJlc3VsdC5pZFxcbiAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICBjcmVhdGVEb20oJ2EnLCB7aHJlZjogc3BlY0hyZWYocmVzdWx0Tm9kZS5yZXN1bHQpfSwgc3BlY0Rlc2NyaXB0aW9uKVxcbiAgICAgICAgICAgICAgKVxcbiAgICAgICAgICAgICk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGZhaWx1cmVzLmxlbmd0aCkge1xcbiAgICAgICAgYWxlcnQuYXBwZW5kQ2hpbGQoXFxuICAgICAgICAgIGNyZWF0ZURvbSgnc3BhbicsIHtjbGFzc05hbWU6ICdtZW51IGJhciBzcGVjLWxpc3QnfSxcXG4gICAgICAgICAgICBjcmVhdGVEb20oJ3NwYW4nLCB7fSwgJ1NwZWMgTGlzdCB8ICcpLFxcbiAgICAgICAgICAgIGNyZWF0ZURvbSgnYScsIHtjbGFzc05hbWU6ICdmYWlsdXJlcy1tZW51JywgaHJlZjogJyMnfSwgJ0ZhaWx1cmVzJykpKTtcXG4gICAgICAgIGFsZXJ0LmFwcGVuZENoaWxkKFxcbiAgICAgICAgICBjcmVhdGVEb20oJ3NwYW4nLCB7Y2xhc3NOYW1lOiAnbWVudSBiYXIgZmFpbHVyZS1saXN0J30sXFxuICAgICAgICAgICAgY3JlYXRlRG9tKCdhJywge2NsYXNzTmFtZTogJ3NwZWMtbGlzdC1tZW51JywgaHJlZjogJyMnfSwgJ1NwZWMgTGlzdCcpLFxcbiAgICAgICAgICAgIGNyZWF0ZURvbSgnc3BhbicsIHt9LCAnIHwgRmFpbHVyZXMgJykpKTtcXG5cXG4gICAgICAgIGZpbmQoJy5mYWlsdXJlcy1tZW51Jykub25jbGljayA9IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgICBzZXRNZW51TW9kZVRvKCdmYWlsdXJlLWxpc3QnKTtcXG4gICAgICAgIH07XFxuICAgICAgICBmaW5kKCcuc3BlYy1saXN0LW1lbnUnKS5vbmNsaWNrID0gZnVuY3Rpb24oKSB7XFxuICAgICAgICAgIHNldE1lbnVNb2RlVG8oJ3NwZWMtbGlzdCcpO1xcbiAgICAgICAgfTtcXG5cXG4gICAgICAgIHNldE1lbnVNb2RlVG8oJ2ZhaWx1cmUtbGlzdCcpO1xcblxcbiAgICAgICAgdmFyIGZhaWx1cmVOb2RlID0gZmluZCgnLmZhaWx1cmVzJyk7XFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZhaWx1cmVzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgIGZhaWx1cmVOb2RlLmFwcGVuZENoaWxkKGZhaWx1cmVzW2ldKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH07XFxuXFxuICAgIHJldHVybiB0aGlzO1xcblxcbiAgICBmdW5jdGlvbiBmaW5kKHNlbGVjdG9yKSB7XFxuICAgICAgcmV0dXJuIGdldENvbnRhaW5lcigpLnF1ZXJ5U2VsZWN0b3IoJy5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgJyArIHNlbGVjdG9yKTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBjbGVhclByaW9yKCkge1xcbiAgICAgIC8vIHJldHVybiB0aGUgcmVwb3J0ZXJcXG4gICAgICB2YXIgb2xkUmVwb3J0ZXIgPSBmaW5kKCcnKTtcXG5cXG4gICAgICBpZihvbGRSZXBvcnRlcikge1xcbiAgICAgICAgZ2V0Q29udGFpbmVyKCkucmVtb3ZlQ2hpbGQob2xkUmVwb3J0ZXIpO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBjcmVhdGVEb20odHlwZSwgYXR0cnMsIGNoaWxkcmVuVmFyQXJncykge1xcbiAgICAgIHZhciBlbCA9IGNyZWF0ZUVsZW1lbnQodHlwZSk7XFxuXFxuICAgICAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgIHZhciBjaGlsZCA9IGFyZ3VtZW50c1tpXTtcXG5cXG4gICAgICAgIGlmICh0eXBlb2YgY2hpbGQgPT09ICdzdHJpbmcnKSB7XFxuICAgICAgICAgIGVsLmFwcGVuZENoaWxkKGNyZWF0ZVRleHROb2RlKGNoaWxkKSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBpZiAoY2hpbGQpIHtcXG4gICAgICAgICAgICBlbC5hcHBlbmRDaGlsZChjaGlsZCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgZm9yICh2YXIgYXR0ciBpbiBhdHRycykge1xcbiAgICAgICAgaWYgKGF0dHIgPT0gJ2NsYXNzTmFtZScpIHtcXG4gICAgICAgICAgZWxbYXR0cl0gPSBhdHRyc1thdHRyXTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZShhdHRyLCBhdHRyc1thdHRyXSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBlbDtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBwbHVyYWxpemUoc2luZ3VsYXIsIGNvdW50KSB7XFxuICAgICAgdmFyIHdvcmQgPSAoY291bnQgPT0gMSA/IHNpbmd1bGFyIDogc2luZ3VsYXIgKyAncycpO1xcblxcbiAgICAgIHJldHVybiAnJyArIGNvdW50ICsgJyAnICsgd29yZDtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBzcGVjSHJlZihyZXN1bHQpIHtcXG4gICAgICByZXR1cm4gYWRkVG9FeGlzdGluZ1F1ZXJ5U3RyaW5nKCdzcGVjJywgcmVzdWx0LmZ1bGxOYW1lKTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBkZWZhdWx0UXVlcnlTdHJpbmcoa2V5LCB2YWx1ZSkge1xcbiAgICAgIHJldHVybiAnPycgKyBrZXkgKyAnPScgKyB2YWx1ZTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBzZXRNZW51TW9kZVRvKG1vZGUpIHtcXG4gICAgICBodG1sUmVwb3J0ZXJNYWluLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnamFzbWluZV9odG1sLXJlcG9ydGVyICcgKyBtb2RlKTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBub0V4cGVjdGF0aW9ucyhyZXN1bHQpIHtcXG4gICAgICByZXR1cm4gKHJlc3VsdC5mYWlsZWRFeHBlY3RhdGlvbnMubGVuZ3RoICsgcmVzdWx0LnBhc3NlZEV4cGVjdGF0aW9ucy5sZW5ndGgpID09PSAwICYmXFxuICAgICAgICByZXN1bHQuc3RhdHVzID09PSAncGFzc2VkJztcXG4gICAgfVxcbiAgfVxcblxcbiAgcmV0dXJuIEh0bWxSZXBvcnRlcjtcXG59O1xcblxcbmphc21pbmVSZXF1aXJlLkh0bWxTcGVjRmlsdGVyID0gZnVuY3Rpb24oKSB7XFxuICBmdW5jdGlvbiBIdG1sU3BlY0ZpbHRlcihvcHRpb25zKSB7XFxuICAgIHZhciBmaWx0ZXJTdHJpbmcgPSBvcHRpb25zICYmIG9wdGlvbnMuZmlsdGVyU3RyaW5nKCkgJiYgb3B0aW9ucy5maWx0ZXJTdHJpbmcoKS5yZXBsYWNlKC9bLVtcXFxcXXt9KCkqKz8uLFxcXFxcXFxcXiR8I1xcXFxzXS9nLCAnXFxcXFxcXFwkJicpO1xcbiAgICB2YXIgZmlsdGVyUGF0dGVybiA9IG5ldyBSZWdFeHAoZmlsdGVyU3RyaW5nKTtcXG5cXG4gICAgdGhpcy5tYXRjaGVzID0gZnVuY3Rpb24oc3BlY05hbWUpIHtcXG4gICAgICByZXR1cm4gZmlsdGVyUGF0dGVybi50ZXN0KHNwZWNOYW1lKTtcXG4gICAgfTtcXG4gIH1cXG5cXG4gIHJldHVybiBIdG1sU3BlY0ZpbHRlcjtcXG59O1xcblxcbmphc21pbmVSZXF1aXJlLlJlc3VsdHNOb2RlID0gZnVuY3Rpb24oKSB7XFxuICBmdW5jdGlvbiBSZXN1bHRzTm9kZShyZXN1bHQsIHR5cGUsIHBhcmVudCkge1xcbiAgICB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcXG4gICAgdGhpcy50eXBlID0gdHlwZTtcXG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XFxuXFxuICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcXG5cXG4gICAgdGhpcy5hZGRDaGlsZCA9IGZ1bmN0aW9uKHJlc3VsdCwgdHlwZSkge1xcbiAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChuZXcgUmVzdWx0c05vZGUocmVzdWx0LCB0eXBlLCB0aGlzKSk7XFxuICAgIH07XFxuXFxuICAgIHRoaXMubGFzdCA9IGZ1bmN0aW9uKCkge1xcbiAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuW3RoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMV07XFxuICAgIH07XFxuICB9XFxuXFxuICByZXR1cm4gUmVzdWx0c05vZGU7XFxufTtcXG5cXG5qYXNtaW5lUmVxdWlyZS5RdWVyeVN0cmluZyA9IGZ1bmN0aW9uKCkge1xcbiAgZnVuY3Rpb24gUXVlcnlTdHJpbmcob3B0aW9ucykge1xcblxcbiAgICB0aGlzLm5hdmlnYXRlV2l0aE5ld1BhcmFtID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xcbiAgICAgIG9wdGlvbnMuZ2V0V2luZG93TG9jYXRpb24oKS5zZWFyY2ggPSB0aGlzLmZ1bGxTdHJpbmdXaXRoTmV3UGFyYW0oa2V5LCB2YWx1ZSk7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuZnVsbFN0cmluZ1dpdGhOZXdQYXJhbSA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcXG4gICAgICB2YXIgcGFyYW1NYXAgPSBxdWVyeVN0cmluZ1RvUGFyYW1NYXAoKTtcXG4gICAgICBwYXJhbU1hcFtrZXldID0gdmFsdWU7XFxuICAgICAgcmV0dXJuIHRvUXVlcnlTdHJpbmcocGFyYW1NYXApO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLmdldFBhcmFtID0gZnVuY3Rpb24oa2V5KSB7XFxuICAgICAgcmV0dXJuIHF1ZXJ5U3RyaW5nVG9QYXJhbU1hcCgpW2tleV07XFxuICAgIH07XFxuXFxuICAgIHJldHVybiB0aGlzO1xcblxcbiAgICBmdW5jdGlvbiB0b1F1ZXJ5U3RyaW5nKHBhcmFtTWFwKSB7XFxuICAgICAgdmFyIHFTdHJQYWlycyA9IFtdO1xcbiAgICAgIGZvciAodmFyIHByb3AgaW4gcGFyYW1NYXApIHtcXG4gICAgICAgIHFTdHJQYWlycy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChwcm9wKSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChwYXJhbU1hcFtwcm9wXSkpO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gJz8nICsgcVN0clBhaXJzLmpvaW4oJyYnKTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBxdWVyeVN0cmluZ1RvUGFyYW1NYXAoKSB7XFxuICAgICAgdmFyIHBhcmFtU3RyID0gb3B0aW9ucy5nZXRXaW5kb3dMb2NhdGlvbigpLnNlYXJjaC5zdWJzdHJpbmcoMSksXFxuICAgICAgICBwYXJhbXMgPSBbXSxcXG4gICAgICAgIHBhcmFtTWFwID0ge307XFxuXFxuICAgICAgaWYgKHBhcmFtU3RyLmxlbmd0aCA+IDApIHtcXG4gICAgICAgIHBhcmFtcyA9IHBhcmFtU3RyLnNwbGl0KCcmJyk7XFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgICB2YXIgcCA9IHBhcmFtc1tpXS5zcGxpdCgnPScpO1xcbiAgICAgICAgICB2YXIgdmFsdWUgPSBkZWNvZGVVUklDb21wb25lbnQocFsxXSk7XFxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJ3RydWUnIHx8IHZhbHVlID09PSAnZmFsc2UnKSB7XFxuICAgICAgICAgICAgdmFsdWUgPSBKU09OLnBhcnNlKHZhbHVlKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBwYXJhbU1hcFtkZWNvZGVVUklDb21wb25lbnQocFswXSldID0gdmFsdWU7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBwYXJhbU1hcDtcXG4gICAgfVxcblxcbiAgfVxcblxcbiAgcmV0dXJuIFF1ZXJ5U3RyaW5nO1xcbn07XFxuXCJcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9saWIvamFzbWluZS0yLjMuNC9qYXNtaW5lLWh0bWwuanNcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiLyoqXFxuIFN0YXJ0aW5nIHdpdGggdmVyc2lvbiAyLjAsIHRoaXMgZmlsZSBcXFwiYm9vdHNcXFwiIEphc21pbmUsIHBlcmZvcm1pbmcgYWxsIG9mIHRoZSBuZWNlc3NhcnkgaW5pdGlhbGl6YXRpb24gYmVmb3JlIGV4ZWN1dGluZyB0aGUgbG9hZGVkIGVudmlyb25tZW50IGFuZCBhbGwgb2YgYSBwcm9qZWN0J3Mgc3BlY3MuIFRoaXMgZmlsZSBzaG91bGQgYmUgbG9hZGVkIGFmdGVyIGBqYXNtaW5lLmpzYCBhbmQgYGphc21pbmVfaHRtbC5qc2AsIGJ1dCBiZWZvcmUgYW55IHByb2plY3Qgc291cmNlIGZpbGVzIG9yIHNwZWMgZmlsZXMgYXJlIGxvYWRlZC4gVGh1cyB0aGlzIGZpbGUgY2FuIGFsc28gYmUgdXNlZCB0byBjdXN0b21pemUgSmFzbWluZSBmb3IgYSBwcm9qZWN0LlxcblxcbiBJZiBhIHByb2plY3QgaXMgdXNpbmcgSmFzbWluZSB2aWEgdGhlIHN0YW5kYWxvbmUgZGlzdHJpYnV0aW9uLCB0aGlzIGZpbGUgY2FuIGJlIGN1c3RvbWl6ZWQgZGlyZWN0bHkuIElmIGEgcHJvamVjdCBpcyB1c2luZyBKYXNtaW5lIHZpYSB0aGUgW1J1YnkgZ2VtXVtqYXNtaW5lLWdlbV0sIHRoaXMgZmlsZSBjYW4gYmUgY29waWVkIGludG8gdGhlIHN1cHBvcnQgZGlyZWN0b3J5IHZpYSBgamFzbWluZSBjb3B5X2Jvb3RfanNgLiBPdGhlciBlbnZpcm9ubWVudHMgKGUuZy4sIFB5dGhvbikgd2lsbCBoYXZlIGRpZmZlcmVudCBtZWNoYW5pc21zLlxcblxcbiBUaGUgbG9jYXRpb24gb2YgYGJvb3QuanNgIGNhbiBiZSBzcGVjaWZpZWQgYW5kL29yIG92ZXJyaWRkZW4gaW4gYGphc21pbmUueW1sYC5cXG5cXG4gW2phc21pbmUtZ2VtXTogaHR0cDovL2dpdGh1Yi5jb20vcGl2b3RhbC9qYXNtaW5lLWdlbVxcbiAqL1xcblxcbihmdW5jdGlvbigpIHtcXG5cXG4gIC8qKlxcbiAgICogIyMgUmVxdWlyZSAmYW1wOyBJbnN0YW50aWF0ZVxcbiAgICpcXG4gICAqIFJlcXVpcmUgSmFzbWluZSdzIGNvcmUgZmlsZXMuIFNwZWNpZmljYWxseSwgdGhpcyByZXF1aXJlcyBhbmQgYXR0YWNoZXMgYWxsIG9mIEphc21pbmUncyBjb2RlIHRvIHRoZSBgamFzbWluZWAgcmVmZXJlbmNlLlxcbiAgICovXFxuICB3aW5kb3cuamFzbWluZSA9IGphc21pbmVSZXF1aXJlLmNvcmUoamFzbWluZVJlcXVpcmUpO1xcblxcbiAgLyoqXFxuICAgKiBTaW5jZSB0aGlzIGlzIGJlaW5nIHJ1biBpbiBhIGJyb3dzZXIgYW5kIHRoZSByZXN1bHRzIHNob3VsZCBwb3B1bGF0ZSB0byBhbiBIVE1MIHBhZ2UsIHJlcXVpcmUgdGhlIEhUTUwtc3BlY2lmaWMgSmFzbWluZSBjb2RlLCBpbmplY3RpbmcgdGhlIHNhbWUgcmVmZXJlbmNlLlxcbiAgICovXFxuICBqYXNtaW5lUmVxdWlyZS5odG1sKGphc21pbmUpO1xcblxcbiAgLyoqXFxuICAgKiBDcmVhdGUgdGhlIEphc21pbmUgZW52aXJvbm1lbnQuIFRoaXMgaXMgdXNlZCB0byBydW4gYWxsIHNwZWNzIGluIGEgcHJvamVjdC5cXG4gICAqL1xcbiAgdmFyIGVudiA9IGphc21pbmUuZ2V0RW52KCk7XFxuXFxuICAvKipcXG4gICAqICMjIFRoZSBHbG9iYWwgSW50ZXJmYWNlXFxuICAgKlxcbiAgICogQnVpbGQgdXAgdGhlIGZ1bmN0aW9ucyB0aGF0IHdpbGwgYmUgZXhwb3NlZCBhcyB0aGUgSmFzbWluZSBwdWJsaWMgaW50ZXJmYWNlLiBBIHByb2plY3QgY2FuIGN1c3RvbWl6ZSwgcmVuYW1lIG9yIGFsaWFzIGFueSBvZiB0aGVzZSBmdW5jdGlvbnMgYXMgZGVzaXJlZCwgcHJvdmlkZWQgdGhlIGltcGxlbWVudGF0aW9uIHJlbWFpbnMgdW5jaGFuZ2VkLlxcbiAgICovXFxuICB2YXIgamFzbWluZUludGVyZmFjZSA9IGphc21pbmVSZXF1aXJlLmludGVyZmFjZShqYXNtaW5lLCBlbnYpO1xcblxcbiAgLyoqXFxuICAgKiBBZGQgYWxsIG9mIHRoZSBKYXNtaW5lIGdsb2JhbC9wdWJsaWMgaW50ZXJmYWNlIHRvIHRoZSBnbG9iYWwgc2NvcGUsIHNvIGEgcHJvamVjdCBjYW4gdXNlIHRoZSBwdWJsaWMgaW50ZXJmYWNlIGRpcmVjdGx5LiBGb3IgZXhhbXBsZSwgY2FsbGluZyBgZGVzY3JpYmVgIGluIHNwZWNzIGluc3RlYWQgb2YgYGphc21pbmUuZ2V0RW52KCkuZGVzY3JpYmVgLlxcbiAgICovXFxuICBleHRlbmQod2luZG93LCBqYXNtaW5lSW50ZXJmYWNlKTtcXG5cXG4gIC8qKlxcbiAgICogIyMgUnVubmVyIFBhcmFtZXRlcnNcXG4gICAqXFxuICAgKiBNb3JlIGJyb3dzZXIgc3BlY2lmaWMgY29kZSAtIHdyYXAgdGhlIHF1ZXJ5IHN0cmluZyBpbiBhbiBvYmplY3QgYW5kIHRvIGFsbG93IGZvciBnZXR0aW5nL3NldHRpbmcgcGFyYW1ldGVycyBmcm9tIHRoZSBydW5uZXIgdXNlciBpbnRlcmZhY2UuXFxuICAgKi9cXG5cXG4gIHZhciBxdWVyeVN0cmluZyA9IG5ldyBqYXNtaW5lLlF1ZXJ5U3RyaW5nKHtcXG4gICAgZ2V0V2luZG93TG9jYXRpb246IGZ1bmN0aW9uKCkgeyByZXR1cm4gd2luZG93LmxvY2F0aW9uOyB9XFxuICB9KTtcXG5cXG4gIHZhciBjYXRjaGluZ0V4Y2VwdGlvbnMgPSBxdWVyeVN0cmluZy5nZXRQYXJhbShcXFwiY2F0Y2hcXFwiKTtcXG4gIGVudi5jYXRjaEV4Y2VwdGlvbnModHlwZW9mIGNhdGNoaW5nRXhjZXB0aW9ucyA9PT0gXFxcInVuZGVmaW5lZFxcXCIgPyB0cnVlIDogY2F0Y2hpbmdFeGNlcHRpb25zKTtcXG5cXG4gIHZhciB0aHJvd2luZ0V4cGVjdGF0aW9uRmFpbHVyZXMgPSBxdWVyeVN0cmluZy5nZXRQYXJhbShcXFwidGhyb3dGYWlsdXJlc1xcXCIpO1xcbiAgZW52LnRocm93T25FeHBlY3RhdGlvbkZhaWx1cmUodGhyb3dpbmdFeHBlY3RhdGlvbkZhaWx1cmVzKTtcXG5cXG4gIC8qKlxcbiAgICogIyMgUmVwb3J0ZXJzXFxuICAgKiBUaGUgYEh0bWxSZXBvcnRlcmAgYnVpbGRzIGFsbCBvZiB0aGUgSFRNTCBVSSBmb3IgdGhlIHJ1bm5lciBwYWdlLiBUaGlzIHJlcG9ydGVyIHBhaW50cyB0aGUgZG90cywgc3RhcnMsIGFuZCB4J3MgZm9yIHNwZWNzLCBhcyB3ZWxsIGFzIGFsbCBzcGVjIG5hbWVzIGFuZCBhbGwgZmFpbHVyZXMgKGlmIGFueSkuXFxuICAgKi9cXG4gIHZhciBodG1sUmVwb3J0ZXIgPSBuZXcgamFzbWluZS5IdG1sUmVwb3J0ZXIoe1xcbiAgICBlbnY6IGVudixcXG4gICAgb25SYWlzZUV4Y2VwdGlvbnNDbGljazogZnVuY3Rpb24oKSB7IHF1ZXJ5U3RyaW5nLm5hdmlnYXRlV2l0aE5ld1BhcmFtKFxcXCJjYXRjaFxcXCIsICFlbnYuY2F0Y2hpbmdFeGNlcHRpb25zKCkpOyB9LFxcbiAgICBvblRocm93RXhwZWN0YXRpb25zQ2xpY2s6IGZ1bmN0aW9uKCkgeyBxdWVyeVN0cmluZy5uYXZpZ2F0ZVdpdGhOZXdQYXJhbShcXFwidGhyb3dGYWlsdXJlc1xcXCIsICFlbnYudGhyb3dpbmdFeHBlY3RhdGlvbkZhaWx1cmVzKCkpOyB9LFxcbiAgICBhZGRUb0V4aXN0aW5nUXVlcnlTdHJpbmc6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHsgcmV0dXJuIHF1ZXJ5U3RyaW5nLmZ1bGxTdHJpbmdXaXRoTmV3UGFyYW0oa2V5LCB2YWx1ZSk7IH0sXFxuICAgIGdldENvbnRhaW5lcjogZnVuY3Rpb24oKSB7IHJldHVybiBkb2N1bWVudC5ib2R5OyB9LFxcbiAgICBjcmVhdGVFbGVtZW50OiBmdW5jdGlvbigpIHsgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQuYXBwbHkoZG9jdW1lbnQsIGFyZ3VtZW50cyk7IH0sXFxuICAgIGNyZWF0ZVRleHROb2RlOiBmdW5jdGlvbigpIHsgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlLmFwcGx5KGRvY3VtZW50LCBhcmd1bWVudHMpOyB9LFxcbiAgICB0aW1lcjogbmV3IGphc21pbmUuVGltZXIoKVxcbiAgfSk7XFxuXFxuICAvKipcXG4gICAqIFRoZSBganNBcGlSZXBvcnRlcmAgYWxzbyByZWNlaXZlcyBzcGVjIHJlc3VsdHMsIGFuZCBpcyB1c2VkIGJ5IGFueSBlbnZpcm9ubWVudCB0aGF0IG5lZWRzIHRvIGV4dHJhY3QgdGhlIHJlc3VsdHMgIGZyb20gSmF2YVNjcmlwdC5cXG4gICAqL1xcbiAgZW52LmFkZFJlcG9ydGVyKGphc21pbmVJbnRlcmZhY2UuanNBcGlSZXBvcnRlcik7XFxuICBlbnYuYWRkUmVwb3J0ZXIoaHRtbFJlcG9ydGVyKTtcXG5cXG4gIC8qKlxcbiAgICogRmlsdGVyIHdoaWNoIHNwZWNzIHdpbGwgYmUgcnVuIGJ5IG1hdGNoaW5nIHRoZSBzdGFydCBvZiB0aGUgZnVsbCBuYW1lIGFnYWluc3QgdGhlIGBzcGVjYCBxdWVyeSBwYXJhbS5cXG4gICAqL1xcbiAgdmFyIHNwZWNGaWx0ZXIgPSBuZXcgamFzbWluZS5IdG1sU3BlY0ZpbHRlcih7XFxuICAgIGZpbHRlclN0cmluZzogZnVuY3Rpb24oKSB7IHJldHVybiBxdWVyeVN0cmluZy5nZXRQYXJhbShcXFwic3BlY1xcXCIpOyB9XFxuICB9KTtcXG5cXG4gIGVudi5zcGVjRmlsdGVyID0gZnVuY3Rpb24oc3BlYykge1xcbiAgICByZXR1cm4gc3BlY0ZpbHRlci5tYXRjaGVzKHNwZWMuZ2V0RnVsbE5hbWUoKSk7XFxuICB9O1xcblxcbiAgLyoqXFxuICAgKiBTZXR0aW5nIHVwIHRpbWluZyBmdW5jdGlvbnMgdG8gYmUgYWJsZSB0byBiZSBvdmVycmlkZGVuLiBDZXJ0YWluIGJyb3dzZXJzIChTYWZhcmksIElFIDgsIHBoYW50b21qcykgcmVxdWlyZSB0aGlzIGhhY2suXFxuICAgKi9cXG4gIHdpbmRvdy5zZXRUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQ7XFxuICB3aW5kb3cuc2V0SW50ZXJ2YWwgPSB3aW5kb3cuc2V0SW50ZXJ2YWw7XFxuICB3aW5kb3cuY2xlYXJUaW1lb3V0ID0gd2luZG93LmNsZWFyVGltZW91dDtcXG4gIHdpbmRvdy5jbGVhckludGVydmFsID0gd2luZG93LmNsZWFySW50ZXJ2YWw7XFxuXFxuICAvKipcXG4gICAqICMjIEV4ZWN1dGlvblxcbiAgICpcXG4gICAqIFJlcGxhY2UgdGhlIGJyb3dzZXIgd2luZG93J3MgYG9ubG9hZGAsIGVuc3VyZSBpdCdzIGNhbGxlZCwgYW5kIHRoZW4gcnVuIGFsbCBvZiB0aGUgbG9hZGVkIHNwZWNzLiBUaGlzIGluY2x1ZGVzIGluaXRpYWxpemluZyB0aGUgYEh0bWxSZXBvcnRlcmAgaW5zdGFuY2UgYW5kIHRoZW4gZXhlY3V0aW5nIHRoZSBsb2FkZWQgSmFzbWluZSBlbnZpcm9ubWVudC4gQWxsIG9mIHRoaXMgd2lsbCBoYXBwZW4gYWZ0ZXIgYWxsIG9mIHRoZSBzcGVjcyBhcmUgbG9hZGVkLlxcbiAgICovXFxuICB2YXIgY3VycmVudFdpbmRvd09ubG9hZCA9IHdpbmRvdy5vbmxvYWQ7XFxuXFxuICB3aW5kb3cub25sb2FkID0gZnVuY3Rpb24oKSB7XFxuICAgIGlmIChjdXJyZW50V2luZG93T25sb2FkKSB7XFxuICAgICAgY3VycmVudFdpbmRvd09ubG9hZCgpO1xcbiAgICB9XFxuICAgIGh0bWxSZXBvcnRlci5pbml0aWFsaXplKCk7XFxuICAgIGVudi5leGVjdXRlKCk7XFxuICB9O1xcblxcbiAgLyoqXFxuICAgKiBIZWxwZXIgZnVuY3Rpb24gZm9yIHJlYWRhYmlsaXR5IGFib3ZlLlxcbiAgICovXFxuICBmdW5jdGlvbiBleHRlbmQoZGVzdGluYXRpb24sIHNvdXJjZSkge1xcbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBzb3VyY2UpIGRlc3RpbmF0aW9uW3Byb3BlcnR5XSA9IHNvdXJjZVtwcm9wZXJ0eV07XFxuICAgIHJldHVybiBkZXN0aW5hdGlvbjtcXG4gIH1cXG5cXG59KCkpO1xcblwiXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbGliL2phc21pbmUtMi4zLjQvYm9vdC5qc1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=
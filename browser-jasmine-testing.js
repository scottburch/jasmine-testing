/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	bindPolyfill();
	
	__webpack_require__(1);
	__webpack_require__(5);
	var scripts = [__webpack_require__(6), __webpack_require__(7), __webpack_require__(8), __webpack_require__(9)].join(';');
	
	eval.call(global, scripts);
	sourceMapSupport.install();
	
	// Needed for phantomJS which does not include Function.prototype.bind()
	function bindPolyfill() {
	    if (!Function.prototype.bind) {
	        Function.prototype.bind = function (oThis) {
	            if (typeof this !== 'function') {
	                // closest thing possible to the ECMAScript 5
	                // internal IsCallable function
	                throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
	            }
	
	            var aArgs = Array.prototype.slice.call(arguments, 1),
	                fToBind = this,
	                fNOP = function fNOP() {},
	                fBound = function fBound() {
	                return fToBind.apply(this instanceof fNOP ? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments)));
	            };
	
	            if (this.prototype) {
	                // native functions don't have a prototype
	                fNOP.prototype = this.prototype;
	            }
	            fBound.prototype = new fNOP();
	
	            return fBound;
	        };
	    }
	}
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(2);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(4)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../node_modules/css-loader/index.js!./jasmine.css", function() {
				var newContent = require("!!./../../../node_modules/css-loader/index.js!./jasmine.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(3)();
	// imports
	
	
	// module
	exports.push([module.id, "body { overflow-y: scroll; }\n\n.jasmine_html-reporter { background-color: #eee; padding: 5px; margin: -8px; font-size: 11px; font-family: Monaco, \"Lucida Console\", monospace; line-height: 14px; color: #333; }\n.jasmine_html-reporter a { text-decoration: none; }\n.jasmine_html-reporter a:hover { text-decoration: underline; }\n.jasmine_html-reporter p, .jasmine_html-reporter h1, .jasmine_html-reporter h2, .jasmine_html-reporter h3, .jasmine_html-reporter h4, .jasmine_html-reporter h5, .jasmine_html-reporter h6 { margin: 0; line-height: 14px; }\n.jasmine_html-reporter .jasmine-banner, .jasmine_html-reporter .jasmine-symbol-summary, .jasmine_html-reporter .jasmine-summary, .jasmine_html-reporter .jasmine-result-message, .jasmine_html-reporter .jasmine-spec .jasmine-description, .jasmine_html-reporter .jasmine-spec-detail .jasmine-description, .jasmine_html-reporter .jasmine-alert .jasmine-bar, .jasmine_html-reporter .jasmine-stack-trace { padding-left: 9px; padding-right: 9px; }\n.jasmine_html-reporter .jasmine-banner { position: relative; }\n.jasmine_html-reporter .jasmine-banner .jasmine-title { background: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAAAZCAMAAACGusnyAAACdlBMVEX/////AP+AgICqVaqAQICZM5mAVYCSSZKAQICOOY6ATYCLRouAQICJO4mSSYCIRIiPQICHPIeOR4CGQ4aMQICGPYaLRoCFQ4WKQICPPYWJRYCOQoSJQICNPoSIRICMQoSHQICHRICKQoOHQICKPoOJO4OJQYOMQICMQ4CIQYKLQICIPoKLQ4CKQICNPoKJQISMQ4KJQoSLQYKJQISLQ4KIQoSKQYKIQICIQISMQoSKQYKLQIOLQoOJQYGLQIOKQIOMQoGKQYOLQYGKQIOLQoGJQYOJQIOKQYGJQIOKQoGKQIGLQIKLQ4KKQoGLQYKJQIGKQYKJQIGKQIKJQoGKQYKLQIGKQYKLQIOJQoKKQoOJQYKKQIOJQoKKQoOKQIOLQoKKQYOLQYKJQIOKQoKKQYKKQoKJQYOKQYKLQIOKQoKLQYOKQYKLQIOJQoGKQYKJQYGJQoGKQYKLQoGLQYGKQoGJQYKKQYGJQIKKQoGJQYKLQIKKQYGLQYKKQYGKQYGKQYKJQYOKQoKJQYOKQYKLQYOLQYOKQYKLQYOKQoKKQYKKQYOKQYOJQYKKQYKLQYKKQIKKQoKKQYKKQYKKQoKJQIKKQYKLQYKKQYKKQIKKQYKKQYKKQYKKQIKKQYKJQYGLQYGKQYKKQYKKQYGKQIKKQYGKQYOJQoKKQYOLQYKKQYOKQoKKQYKKQoKKQYKKQYKJQYKLQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKJQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKLQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKmIDpEAAAA0XRSTlMAAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobHB0eHyAiIyQlJycoKissLS4wMTQ1Njc4OTo7PDw+P0BCQ0RISUpLTE1OUFNUVVdYWFlaW15fYGFiY2ZnaGlqa2xtb3BxcnN0dnh5ent8fX5/gIGChIWIioyNjo+QkZOUlZaYmZqbnJ2eoKGio6WmqKmsra6vsLGztre4ubq7vL2+wMHDxMjJysvNzs/Q0dLU1tfY2dvc3t/g4eLj5ebn6Onq6+zt7u/w8vP09fb3+Pn6+/z9/vkVQXAAAAMaSURBVHhe5dXxV1N1GMfxz2ABbDgIAm5VDJOyVDIJLUMaVpBWUZUaGbmqoGpZRSiGiRWp6KoZ5AB0ZY50RImZQIlahKkMYXv/R90dBvET/rJfOr3Ouc8v99zPec59zvf56j+vYKlViSf7250X4Mr3O29Tgq08BdGB4DhcekEJ5YkQKFsgWZdtj9JpV+I8xPjLFqkrsEIqO8PHSpis36jWazcqjEsfJjkvRssVU37SdIOu4XCf5vEJPsnwJpnRNU9JmxhMk8l1gehIrq7hTFjzOD+Vf88629qKMJVNltInFeRexRQyJlNeqd1iGDlSzrIUIyXbyFfm3RYprcQRe7lqtWyGYbfc6dT0R2vmdOOkX3u55C1rP37ftiH+tDby4r/RBT0w8TyEkr+epB9XgPDmSYYWbrhCuFYaIyw3fDQAXTnSkh+ANofiHmWf9l+FY1I90FdQTetstO00o23novzVsJ7uB3/C5TkbjRwZ5JerwV4iRWq9HFbFMaK/d0TYqayRiQPuIxxS3Bu8JWU90/60tKi7vkhaznez0a/TbVOKj5CaOZh6fWG6/Lyv9B/ZLR1gw/S/fpbeVD3MCW1li6SvWDOn65tr99/uvWtBS0XDm4s1t+sOHpG0kpBKx/l77wOSnxLpcx6TXmXLTPQOKYOf9Q1dfr8/SJ2mFdCvl1Yl93DiHUZvXeLJbGSzYu5gVJ2slbSakOR8dxCq5adQ2oFLqsE9Ex3L4qQO0eOPeU5x56bypXp4onSEb5OkICX6lDat55TeoztNKQcJaakrz9KCb95oD69IKq+yKW4XPjknaS52V0TZqE2cTtXjcHSCRmUO88e+85hj3EP74i9p8pylw7lxgMDyyl6OV7ZejnjNMfatu87LxRbH0IS35gt2a4ZjmGpVBdKK3Wr6INk8jWWSGqbA55CKgjBRC6E9w78ydTg3ABS3AFV1QN0Y4Aa2pgEjWnQURj9L0ayK6R2ysEqxHUKzYnLvvyU+i9KM2JHJzE4vyZOyDcOwOsySajeLPc8sNvPJkFlyJd20wpqAzZeAfZ3oWybxd+P/3j+SG3uSBdf2VQAAAABJRU5ErkJggg==') no-repeat; background: url('data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgoKPHN2ZwogICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgIHhtbG5zOmNjPSJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9ucyMiCiAgIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyIKICAgeG1sbnM6c3ZnPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxuczppbmtzY2FwZT0iaHR0cDovL3d3dy5pbmtzY2FwZS5vcmcvbmFtZXNwYWNlcy9pbmtzY2FwZSIKICAgdmVyc2lvbj0iMS4xIgogICB3aWR0aD0iNjgxLjk2MjUyIgogICBoZWlnaHQ9IjE4Ny41IgogICBpZD0ic3ZnMiIKICAgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+PG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhOCI+PHJkZjpSREY+PGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPjxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PjxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz48L2NjOldvcms+PC9yZGY6UkRGPjwvbWV0YWRhdGE+PGRlZnMKICAgICBpZD0iZGVmczYiPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoMTgiPjxwYXRoCiAgICAgICAgIGQ9Ik0gMCwxNTAwIDAsMCBsIDU0NTUuNzQsMCAwLDE1MDAgTCAwLDE1MDAgeiIKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgaWQ9InBhdGgyMCIgLz48L2NsaXBQYXRoPjwvZGVmcz48ZwogICAgIHRyYW5zZm9ybT0ibWF0cml4KDEuMjUsMCwwLC0xLjI1LDAsMTg3LjUpIgogICAgIGlkPSJnMTAiPjxnCiAgICAgICB0cmFuc2Zvcm09InNjYWxlKDAuMSwwLjEpIgogICAgICAgaWQ9ImcxMiI+PGcKICAgICAgICAgaWQ9ImcxNCI+PGcKICAgICAgICAgICBjbGlwLXBhdGg9InVybCgjY2xpcFBhdGgxOCkiCiAgICAgICAgICAgaWQ9ImcxNiI+PHBhdGgKICAgICAgICAgICAgIGQ9Im0gMTU0NCw1OTkuNDM0IGMgMC45MiwtNDAuMzUyIDI1LjY4LC04MS42MDIgNzEuNTMsLTgxLjYwMiAyNy41MSwwIDQ3LjY4LDEyLjgzMiA2MS40NCwzNS43NTQgMTIuODMsMjIuOTMgMTIuODMsNTYuODUyIDEyLjgzLDgyLjUyNyBsIDAsMzI5LjE4NCAtNzEuNTIsMCAwLDEwNC41NDMgMjY2LjgzLDAgMCwtMTA0LjU0MyAtNzAuNiwwIDAsLTM0NC43NyBjIDAsLTU4LjY5MSAtMy42OCwtMTA0LjUzMSAtNDQuOTMsLTE1Mi4yMTggLTM2LjY4LC00Mi4xOCAtOTYuMjgsLTY2LjAyIC0xNTMuMTQsLTY2LjAyIC0xMTcuMzcsMCAtMjA3LjI0LDc3Ljk0MSAtMjAyLjY0LDE5Ny4xNDUgbCAxMzAuMiwwIgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoMjIiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDIzMDEuNCw2NjIuNjk1IGMgMCw4MC43MDMgLTY2Ljk0LDE0NS44MTMgLTE0Ny42MywxNDUuODEzIC04My40NCwwIC0xNDcuNjMsLTY4Ljc4MSAtMTQ3LjYzLC0xNTEuMzAxIDAsLTc5Ljc4NSA2Ni45NCwtMTQ1LjgwMSAxNDUuOCwtMTQ1LjgwMSA4NC4zNSwwIDE0OS40Niw2Ny44NTIgMTQ5LjQ2LDE1MS4yODkgeiBtIC0xLjgzLC0xODEuNTQ3IGMgLTM1Ljc3LC01NC4wOTcgLTkzLjUzLC03OC44NTkgLTE1Ny43MiwtNzguODU5IC0xNDAuMywwIC0yNTEuMjQsMTE2LjQ0OSAtMjUxLjI0LDI1NC45MTggMCwxNDIuMTI5IDExMy43LDI2MC40MSAyNTYuNzQsMjYwLjQxIDYzLjI3LDAgMTE4LjI5LC0yOS4zMzYgMTUyLjIyLC04Mi41MjMgbCAwLDY5LjY4NyAxNzUuMTQsMCAwLC0xMDQuNTI3IC02MS40NCwwIDAsLTI4MC41OTggNjEuNDQsMCAwLC0xMDQuNTI3IC0xNzUuMTQsMCAwLDY2LjAxOSIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDI0IgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSAyNjIyLjMzLDU1Ny4yNTggYyAzLjY3LC00NC4wMTYgMzMuMDEsLTczLjM0OCA3OC44NiwtNzMuMzQ4IDMzLjkzLDAgNjYuOTMsMjMuODI0IDY2LjkzLDYwLjUwNCAwLDQ4LjYwNiAtNDUuODQsNTYuODU2IC04My40NCw2Ni45NDEgLTg1LjI4LDIyLjAwNCAtMTc4LjgxLDQ4LjYwNiAtMTc4LjgxLDE1NS44NzkgMCw5My41MzYgNzguODYsMTQ3LjYzMyAxNjUuOTgsMTQ3LjYzMyA0NCwwIDgzLjQzLC05LjE3NiAxMTAuOTQsLTQ0LjAwOCBsIDAsMzMuOTIyIDgyLjUzLDAgMCwtMTMyLjk2NSAtMTA4LjIxLDAgYyAtMS44MywzNC44NTYgLTI4LjQyLDU3Ljc3NCAtNjMuMjYsNTcuNzc0IC0zMC4yNiwwIC02Mi4zNSwtMTcuNDIyIC02Mi4zNSwtNTEuMzQ4IDAsLTQ1Ljg0NyA0NC45MywtNTUuOTMgODAuNjksLTY0LjE4IDg4LjAyLC0yMC4xNzUgMTgyLjQ3LC00Ny42OTUgMTgyLjQ3LC0xNTcuNzM0IDAsLTk5LjAyNyAtODMuNDQsLTE1NC4wMzkgLTE3NS4xMywtMTU0LjAzOSAtNDkuNTMsMCAtOTQuNDYsMTUuNTgyIC0xMjYuNTUsNTMuMTggbCAwLC00MC4zNCAtODUuMjcsMCAwLDE0Mi4xMjkgMTE0LjYyLDAiCiAgICAgICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgICAgICAgaWQ9InBhdGgyNiIKICAgICAgICAgICAgIHN0eWxlPSJmaWxsOiM4YTQxODI7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiIC8+PHBhdGgKICAgICAgICAgICAgIGQ9Im0gMjk4OC4xOCw4MDAuMjU0IC02My4yNiwwIDAsMTA0LjUyNyAxNjUuMDUsMCAwLC03My4zNTUgYyAzMS4xOCw1MS4zNDcgNzguODYsODUuMjc3IDE0MS4yMSw4NS4yNzcgNjcuODUsMCAxMjQuNzEsLTQxLjI1OCAxNTIuMjEsLTEwMi42OTkgMjYuNiw2Mi4zNTEgOTIuNjIsMTAyLjY5OSAxNjAuNDcsMTAyLjY5OSA1My4xOSwwIDEwNS40NiwtMjIgMTQxLjIxLC02Mi4zNTEgMzguNTIsLTQ0LjkzOCAzOC41MiwtOTMuNTMyIDM4LjUyLC0xNDkuNDU3IGwgMCwtMTg1LjIzOSA2My4yNywwIDAsLTEwNC41MjcgLTIzOC40MiwwIDAsMTA0LjUyNyA2My4yOCwwIDAsMTU3LjcxNSBjIDAsMzIuMTAyIDAsNjAuNTI3IC0xNC42Nyw4OC45NTcgLTE4LjM0LDI2LjU4MiAtNDguNjEsNDAuMzQ0IC03OS43Nyw0MC4zNDQgLTMwLjI2LDAgLTYzLjI4LC0xMi44NDQgLTgyLjUzLC0zNi42NzIgLTIyLjkzLC0yOS4zNTUgLTIyLjkzLC01Ni44NjMgLTIyLjkzLC05Mi42MjkgbCAwLC0xNTcuNzE1IDYzLjI3LDAgMCwtMTA0LjUyNyAtMjM4LjQxLDAgMCwxMDQuNTI3IDYzLjI4LDAgMCwxNTAuMzgzIGMgMCwyOS4zNDggMCw2Ni4wMjMgLTE0LjY3LDkxLjY5OSAtMTUuNTksMjkuMzM2IC00Ny42OSw0NC45MzQgLTgwLjcsNDQuOTM0IC0zMS4xOCwwIC01Ny43NywtMTEuMDA4IC03Ny45NCwtMzUuNzc0IC0yNC43NywtMzAuMjUzIC0yNi42LC02Mi4zNDMgLTI2LjYsLTk5Ljk0MSBsIDAsLTE1MS4zMDEgNjMuMjcsMCAwLC0xMDQuNTI3IC0yMzguNCwwIDAsMTA0LjUyNyA2My4yNiwwIDAsMjgwLjU5OCIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDI4IgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSAzOTk4LjY2LDk1MS41NDcgLTExMS44NywwIDAsMTE4LjI5MyAxMTEuODcsMCAwLC0xMTguMjkzIHogbSAwLC00MzEuODkxIDYzLjI3LDAgMCwtMTA0LjUyNyAtMjM5LjMzLDAgMCwxMDQuNTI3IDY0LjE5LDAgMCwyODAuNTk4IC02My4yNywwIDAsMTA0LjUyNyAxNzUuMTQsMCAwLC0zODUuMTI1IgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoMzAiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDQxNTkuMTIsODAwLjI1NCAtNjMuMjcsMCAwLDEwNC41MjcgMTc1LjE0LDAgMCwtNjkuNjg3IGMgMjkuMzUsNTQuMTAxIDg0LjM2LDgwLjY5OSAxNDQuODcsODAuNjk5IDUzLjE5LDAgMTA1LjQ1LC0yMi4wMTYgMTQxLjIyLC02MC41MjcgNDAuMzQsLTQ0LjkzNCA0MS4yNiwtODguMDMyIDQxLjI2LC0xNDMuOTU3IGwgMCwtMTkxLjY1MyA2My4yNywwIDAsLTEwNC41MjcgLTIzOC40LDAgMCwxMDQuNTI3IDYzLjI2LDAgMCwxNTguNjM3IGMgMCwzMC4yNjIgMCw2MS40MzQgLTE5LjI2LDg4LjAzNSAtMjAuMTcsMjYuNTgyIC01My4xOCwzOS40MTQgLTg2LjE5LDM5LjQxNCAtMzMuOTMsMCAtNjguNzcsLTEzLjc1IC04OC45NCwtNDEuMjUgLTIxLjA5LC0yNy41IC0yMS4wOSwtNjkuNjg3IC0yMS4wOSwtMTAyLjcwNyBsIDAsLTE0Mi4xMjkgNjMuMjYsMCAwLC0xMDQuNTI3IC0yMzguNCwwIDAsMTA0LjUyNyA2My4yNywwIDAsMjgwLjU5OCIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDMyIgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSA1MDgyLjQ4LDcwMy45NjUgYyAtMTkuMjQsNzAuNjA1IC04MS42LDExNS41NDcgLTE1NC4wNCwxMTUuNTQ3IC02Ni4wNCwwIC0xMjkuMywtNTEuMzQ4IC0xNDMuMDUsLTExNS41NDcgbCAyOTcuMDksMCB6IG0gODUuMjcsLTE0NC44ODMgYyAtMzguNTEsLTkzLjUyMyAtMTI5LjI3LC0xNTYuNzkzIC0yMzEuMDUsLTE1Ni43OTMgLTE0My4wNywwIC0yNTcuNjgsMTExLjg3MSAtMjU3LjY4LDI1NS44MzYgMCwxNDQuODgzIDEwOS4xMiwyNjEuMzI4IDI1NC45MSwyNjEuMzI4IDY3Ljg3LDAgMTM1LjcyLC0zMC4yNTggMTgzLjM5LC03OC44NjMgNDguNjIsLTUxLjM0NCA2OC43OSwtMTEzLjY5NSA2OC43OSwtMTgzLjM4MyBsIC0zLjY3LC0zOS40MzQgLTM5Ni4xMywwIGMgMTQuNjcsLTY3Ljg2MyA3Ny4wMywtMTE3LjM2MyAxNDYuNzIsLTExNy4zNjMgNDguNTksMCA5MC43NiwxOC4zMjggMTE4LjI4LDU4LjY3MiBsIDExNi40NCwwIgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoMzQiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDY5MC44OTUsODUwLjcwMyA5MC43NSwwIDIyLjU0MywzMS4wMzUgMCwyNDMuMTIyIC0xMzUuODI5LDAgMCwtMjQzLjE0MSAyMi41MzYsLTMxLjAxNiIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDM2IgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSA2MzIuMzk1LDc0Mi4yNTggMjguMDM5LDg2LjMwNCAtMjIuNTUxLDMxLjA0IC0yMzEuMjIzLDc1LjEyOCAtNDEuOTc2LC0xMjkuMTgzIDIzMS4yNTcsLTc1LjEzNyAzNi40NTQsMTEuODQ4IgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoMzgiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDcxNy40NDksNjUzLjEwNSAtNzMuNDEsNTMuMzYgLTM2LjQ4OCwtMTEuODc1IC0xNDIuOTAzLC0xOTYuNjkyIDEwOS44ODMsLTc5LjgyOCAxNDIuOTE4LDE5Ni43MDMgMCwzOC4zMzIiCiAgICAgICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgICAgICAgaWQ9InBhdGg0MCIKICAgICAgICAgICAgIHN0eWxlPSJmaWxsOiM4YTQxODI7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiIC8+PHBhdGgKICAgICAgICAgICAgIGQ9Im0gODI4LjUyLDcwNi40NjUgLTczLjQyNiwtNTMuMzQgMC4wMTEsLTM4LjM1OSBMIDg5OC4wMDQsNDE4LjA3IDEwMDcuOSw0OTcuODk4IDg2NC45NzMsNjk0LjYwOSA4MjguNTIsNzA2LjQ2NSIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDQyIgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSA4MTIuMDg2LDgyOC41ODYgMjguMDU1LC04Ni4zMiAzNi40ODQsLTExLjgzNiAyMzEuMjI1LDc1LjExNyAtNDEuOTcsMTI5LjE4MyAtMjMxLjIzOSwtNzUuMTQgLTIyLjU1NSwtMzEuMDA0IgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoNDQiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDczNi4zMDEsMTMzNS44OCBjIC0zMjMuMDQ3LDAgLTU4NS44NzUsLTI2Mi43OCAtNTg1Ljg3NSwtNTg1Ljc4MiAwLC0zMjMuMTE4IDI2Mi44MjgsLTU4NS45NzcgNTg1Ljg3NSwtNTg1Ljk3NyAzMjMuMDE5LDAgNTg1LjgwOSwyNjIuODU5IDU4NS44MDksNTg1Ljk3NyAwLDMyMy4wMDIgLTI2Mi43OSw1ODUuNzgyIC01ODUuODA5LDU4NS43ODIgbCAwLDAgeiBtIDAsLTExOC42MSBjIDI1Ny45NzIsMCA0NjcuMTg5LC0yMDkuMTMgNDY3LjE4OSwtNDY3LjE3MiAwLC0yNTguMTI5IC0yMDkuMjE3LC00NjcuMzQ4IC00NjcuMTg5LC00NjcuMzQ4IC0yNTguMDc0LDAgLTQ2Ny4yNTQsMjA5LjIxOSAtNDY3LjI1NCw0NjcuMzQ4IDAsMjU4LjA0MiAyMDkuMTgsNDY3LjE3MiA0NjcuMjU0LDQ2Ny4xNzIiCiAgICAgICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgICAgICAgaWQ9InBhdGg0NiIKICAgICAgICAgICAgIHN0eWxlPSJmaWxsOiM4YTQxODI7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiIC8+PHBhdGgKICAgICAgICAgICAgIGQ9Im0gMTA5MS4xMyw2MTkuODgzIC0xNzUuNzcxLDU3LjEyMSAxMS42MjksMzUuODA4IDE3NS43NjIsLTU3LjEyMSAtMTEuNjIsLTM1LjgwOCIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDQ4IgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0iTSA4NjYuOTU3LDkwMi4wNzQgODM2LjUsOTI0LjE5OSA5NDUuMTIxLDEwNzMuNzMgOTc1LjU4NiwxMDUxLjYxIDg2Ni45NTcsOTAyLjA3NCIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDUwIgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0iTSA2MDcuNDY1LDkwMy40NDUgNDk4Ljg1NSwxMDUyLjk3IDUyOS4zMiwxMDc1LjEgNjM3LjkzLDkyNS41NjYgNjA3LjQ2NSw5MDMuNDQ1IgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoNTIiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDM4MC42ODgsNjIyLjEyOSAtMTEuNjI2LDM1LjgwMSAxNzUuNzU4LDU3LjA5IDExLjYyMSwtMzUuODAxIC0xNzUuNzUzLC01Ny4wOSIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDU0IgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSA3MTYuMjg5LDM3Ni41OSAzNy42NDA2LDAgMCwxODQuODE2IC0zNy42NDA2LDAgMCwtMTg0LjgxNiB6IgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoNTYiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjwvZz48L2c+PC9nPjwvZz48L3N2Zz4=') no-repeat, none; -moz-background-size: 100%; -o-background-size: 100%; -webkit-background-size: 100%; background-size: 100%; display: block; float: left; width: 90px; height: 25px; }\n.jasmine_html-reporter .jasmine-banner .jasmine-version { margin-left: 14px; position: relative; top: 6px; }\n.jasmine_html-reporter #jasmine_content { position: fixed; right: 100%; }\n.jasmine_html-reporter .jasmine-version { color: #aaa; }\n.jasmine_html-reporter .jasmine-banner { margin-top: 14px; }\n.jasmine_html-reporter .jasmine-duration { color: #fff; float: right; line-height: 28px; padding-right: 9px; }\n.jasmine_html-reporter .jasmine-symbol-summary { overflow: hidden; *zoom: 1; margin: 14px 0; }\n.jasmine_html-reporter .jasmine-symbol-summary li { display: inline-block; height: 10px; width: 14px; font-size: 16px; }\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-passed { font-size: 14px; }\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-passed:before { color: #007069; content: \"\\2022\"; }\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-failed { line-height: 9px; }\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-failed:before { color: #ca3a11; content: \"\\D7\"; font-weight: bold; margin-left: -1px; }\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-disabled { font-size: 14px; }\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-disabled:before { color: #bababa; content: \"\\2022\"; }\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-pending { line-height: 17px; }\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-pending:before { color: #ba9d37; content: \"*\"; }\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-empty { font-size: 14px; }\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-empty:before { color: #ba9d37; content: \"\\2022\"; }\n.jasmine_html-reporter .jasmine-run-options { float: right; margin-right: 5px; border: 1px solid #8a4182; color: #8a4182; position: relative; line-height: 20px; }\n.jasmine_html-reporter .jasmine-run-options .jasmine-trigger { cursor: pointer; padding: 8px 16px; }\n.jasmine_html-reporter .jasmine-run-options .jasmine-payload { position: absolute; display: none; right: -1px; border: 1px solid #8a4182; background-color: #eee; white-space: nowrap; padding: 4px 8px; }\n.jasmine_html-reporter .jasmine-run-options .jasmine-payload.jasmine-open { display: block; }\n.jasmine_html-reporter .jasmine-bar { line-height: 28px; font-size: 14px; display: block; color: #eee; }\n.jasmine_html-reporter .jasmine-bar.jasmine-failed { background-color: #ca3a11; }\n.jasmine_html-reporter .jasmine-bar.jasmine-passed { background-color: #007069; }\n.jasmine_html-reporter .jasmine-bar.jasmine-skipped { background-color: #bababa; }\n.jasmine_html-reporter .jasmine-bar.jasmine-errored { background-color: #ca3a11; }\n.jasmine_html-reporter .jasmine-bar.jasmine-menu { background-color: #fff; color: #aaa; }\n.jasmine_html-reporter .jasmine-bar.jasmine-menu a { color: #333; }\n.jasmine_html-reporter .jasmine-bar a { color: white; }\n.jasmine_html-reporter.jasmine-spec-list .jasmine-bar.jasmine-menu.jasmine-failure-list, .jasmine_html-reporter.jasmine-spec-list .jasmine-results .jasmine-failures { display: none; }\n.jasmine_html-reporter.jasmine-failure-list .jasmine-bar.jasmine-menu.jasmine-spec-list, .jasmine_html-reporter.jasmine-failure-list .jasmine-summary { display: none; }\n.jasmine_html-reporter .jasmine-results { margin-top: 14px; }\n.jasmine_html-reporter .jasmine-summary { margin-top: 14px; }\n.jasmine_html-reporter .jasmine-summary ul { list-style-type: none; margin-left: 14px; padding-top: 0; padding-left: 0; }\n.jasmine_html-reporter .jasmine-summary ul.jasmine-suite { margin-top: 7px; margin-bottom: 7px; }\n.jasmine_html-reporter .jasmine-summary li.jasmine-passed a { color: #007069; }\n.jasmine_html-reporter .jasmine-summary li.jasmine-failed a { color: #ca3a11; }\n.jasmine_html-reporter .jasmine-summary li.jasmine-empty a { color: #ba9d37; }\n.jasmine_html-reporter .jasmine-summary li.jasmine-pending a { color: #ba9d37; }\n.jasmine_html-reporter .jasmine-summary li.jasmine-disabled a { color: #bababa; }\n.jasmine_html-reporter .jasmine-description + .jasmine-suite { margin-top: 0; }\n.jasmine_html-reporter .jasmine-suite { margin-top: 14px; }\n.jasmine_html-reporter .jasmine-suite a { color: #333; }\n.jasmine_html-reporter .jasmine-failures .jasmine-spec-detail { margin-bottom: 28px; }\n.jasmine_html-reporter .jasmine-failures .jasmine-spec-detail .jasmine-description { background-color: #ca3a11; }\n.jasmine_html-reporter .jasmine-failures .jasmine-spec-detail .jasmine-description a { color: white; }\n.jasmine_html-reporter .jasmine-result-message { padding-top: 14px; color: #333; white-space: pre; }\n.jasmine_html-reporter .jasmine-result-message span.jasmine-result { display: block; }\n.jasmine_html-reporter .jasmine-stack-trace { margin: 5px 0 0 0; max-height: 224px; overflow: auto; line-height: 18px; color: #666; border: 1px solid #ddd; background: white; white-space: pre; }\n", ""]);
	
	// exports


/***/ },
/* 3 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	// css base code, injected by the css-loader
	module.exports = function() {
		var list = [];
	
		// return the list of modules as css string
		list.toString = function toString() {
			var result = [];
			for(var i = 0; i < this.length; i++) {
				var item = this[i];
				if(item[2]) {
					result.push("@media " + item[2] + "{" + item[1] + "}");
				} else {
					result.push(item[1]);
				}
			}
			return result.join("");
		};
	
		// import a list of modules into the list
		list.i = function(modules, mediaQuery) {
			if(typeof modules === "string")
				modules = [[null, modules, ""]];
			var alreadyImportedModules = {};
			for(var i = 0; i < this.length; i++) {
				var id = this[i][0];
				if(typeof id === "number")
					alreadyImportedModules[id] = true;
			}
			for(i = 0; i < modules.length; i++) {
				var item = modules[i];
				// skip already imported module
				// this implementation is not 100% perfect for weird media query combinations
				//  when a module is imported multiple times with different media queries.
				//  I hope this will never occur (Hey this way we have smaller bundles)
				if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
					if(mediaQuery && !item[2]) {
						item[2] = mediaQuery;
					} else if(mediaQuery) {
						item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
					}
					list.push(item);
				}
			}
		};
		return list;
	};


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var stylesInDom = {},
		memoize = function(fn) {
			var memo;
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		},
		isOldIE = memoize(function() {
			return /msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase());
		}),
		getHeadElement = memoize(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		singletonElement = null,
		singletonCounter = 0,
		styleElementsInsertedAtTop = [];
	
	module.exports = function(list, options) {
		if(false) {
			if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}
	
		options = options || {};
		// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (typeof options.singleton === "undefined") options.singleton = isOldIE();
	
		// By default, add <style> tags to the bottom of <head>.
		if (typeof options.insertAt === "undefined") options.insertAt = "bottom";
	
		var styles = listToStyles(list);
		addStylesToDom(styles, options);
	
		return function update(newList) {
			var mayRemove = [];
			for(var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
			if(newList) {
				var newStyles = listToStyles(newList);
				addStylesToDom(newStyles, options);
			}
			for(var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
				if(domStyle.refs === 0) {
					for(var j = 0; j < domStyle.parts.length; j++)
						domStyle.parts[j]();
					delete stylesInDom[domStyle.id];
				}
			}
		};
	}
	
	function addStylesToDom(styles, options) {
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			if(domStyle) {
				domStyle.refs++;
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}
	
	function listToStyles(list) {
		var styles = [];
		var newStyles = {};
		for(var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
			if(!newStyles[id])
				styles.push(newStyles[id] = {id: id, parts: [part]});
			else
				newStyles[id].parts.push(part);
		}
		return styles;
	}
	
	function insertStyleElement(options, styleElement) {
		var head = getHeadElement();
		var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
		if (options.insertAt === "top") {
			if(!lastStyleElementInsertedAtTop) {
				head.insertBefore(styleElement, head.firstChild);
			} else if(lastStyleElementInsertedAtTop.nextSibling) {
				head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
			} else {
				head.appendChild(styleElement);
			}
			styleElementsInsertedAtTop.push(styleElement);
		} else if (options.insertAt === "bottom") {
			head.appendChild(styleElement);
		} else {
			throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
		}
	}
	
	function removeStyleElement(styleElement) {
		styleElement.parentNode.removeChild(styleElement);
		var idx = styleElementsInsertedAtTop.indexOf(styleElement);
		if(idx >= 0) {
			styleElementsInsertedAtTop.splice(idx, 1);
		}
	}
	
	function createStyleElement(options) {
		var styleElement = document.createElement("style");
		styleElement.type = "text/css";
		insertStyleElement(options, styleElement);
		return styleElement;
	}
	
	function createLinkElement(options) {
		var linkElement = document.createElement("link");
		linkElement.rel = "stylesheet";
		insertStyleElement(options, linkElement);
		return linkElement;
	}
	
	function addStyle(obj, options) {
		var styleElement, update, remove;
	
		if (options.singleton) {
			var styleIndex = singletonCounter++;
			styleElement = singletonElement || (singletonElement = createStyleElement(options));
			update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
			remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
		} else if(obj.sourceMap &&
			typeof URL === "function" &&
			typeof URL.createObjectURL === "function" &&
			typeof URL.revokeObjectURL === "function" &&
			typeof Blob === "function" &&
			typeof btoa === "function") {
			styleElement = createLinkElement(options);
			update = updateLink.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
				if(styleElement.href)
					URL.revokeObjectURL(styleElement.href);
			};
		} else {
			styleElement = createStyleElement(options);
			update = applyToTag.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
			};
		}
	
		update(obj);
	
		return function updateStyle(newObj) {
			if(newObj) {
				if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
					return;
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}
	
	var replaceText = (function () {
		var textStore = [];
	
		return function (index, replacement) {
			textStore[index] = replacement;
			return textStore.filter(Boolean).join('\n');
		};
	})();
	
	function applyToSingletonTag(styleElement, index, remove, obj) {
		var css = remove ? "" : obj.css;
	
		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = replaceText(index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = styleElement.childNodes;
			if (childNodes[index]) styleElement.removeChild(childNodes[index]);
			if (childNodes.length) {
				styleElement.insertBefore(cssNode, childNodes[index]);
			} else {
				styleElement.appendChild(cssNode);
			}
		}
	}
	
	function applyToTag(styleElement, obj) {
		var css = obj.css;
		var media = obj.media;
		var sourceMap = obj.sourceMap;
	
		if(media) {
			styleElement.setAttribute("media", media)
		}
	
		if(styleElement.styleSheet) {
			styleElement.styleSheet.cssText = css;
		} else {
			while(styleElement.firstChild) {
				styleElement.removeChild(styleElement.firstChild);
			}
			styleElement.appendChild(document.createTextNode(css));
		}
	}
	
	function updateLink(linkElement, obj) {
		var css = obj.css;
		var media = obj.media;
		var sourceMap = obj.sourceMap;
	
		if(sourceMap) {
			// http://stackoverflow.com/a/26603875
			css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
		}
	
		var blob = new Blob([css], { type: "text/css" });
	
		var oldSrc = linkElement.href;
	
		linkElement.href = URL.createObjectURL(blob);
	
		if(oldSrc)
			URL.revokeObjectURL(oldSrc);
	}


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * https://github.com/es-shims/es5-shim
	 * @license es5-shim Copyright 2009-2015 by contributors, MIT License
	 * see https://github.com/es-shims/es5-shim/blob/master/LICENSE
	 */
	
	// vim: ts=4 sts=4 sw=4 expandtab
	
	// Add semicolon to prevent IIFE from being passed as argument to concatenated code.
	;
	
	// UMD (Universal Module Definition)
	// see https://github.com/umdjs/umd/blob/master/templates/returnExports.js
	(function (root, factory) {
	    'use strict';
	
	    /* global define, exports, module */
	    if (true) {
	        // AMD. Register as an anonymous module.
	        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof exports === 'object') {
	        // Node. Does not work with strict CommonJS, but
	        // only CommonJS-like enviroments that support module.exports,
	        // like Node.
	        module.exports = factory();
	    } else {
	        // Browser globals (root is window)
	        root.returnExports = factory();
	    }
	}(this, function () {
	
	/**
	 * Brings an environment as close to ECMAScript 5 compliance
	 * as is possible with the facilities of erstwhile engines.
	 *
	 * Annotated ES5: http://es5.github.com/ (specific links below)
	 * ES5 Spec: http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf
	 * Required reading: http://javascriptweblog.wordpress.com/2011/12/05/extending-javascript-natives/
	 */
	
	// Shortcut to an often accessed properties, in order to avoid multiple
	// dereference that costs universally. This also holds a reference to known-good
	// functions.
	var $Array = Array;
	var ArrayPrototype = $Array.prototype;
	var $Object = Object;
	var ObjectPrototype = $Object.prototype;
	var FunctionPrototype = Function.prototype;
	var $String = String;
	var StringPrototype = $String.prototype;
	var $Number = Number;
	var NumberPrototype = $Number.prototype;
	var array_slice = ArrayPrototype.slice;
	var array_splice = ArrayPrototype.splice;
	var array_push = ArrayPrototype.push;
	var array_unshift = ArrayPrototype.unshift;
	var array_concat = ArrayPrototype.concat;
	var call = FunctionPrototype.call;
	var apply = FunctionPrototype.apply;
	var max = Math.max;
	var min = Math.min;
	
	// Having a toString local variable name breaks in Opera so use to_string.
	var to_string = ObjectPrototype.toString;
	
	var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';
	var isCallable; /* inlined from https://npmjs.com/is-callable */ var fnToStr = Function.prototype.toString, tryFunctionObject = function tryFunctionObject(value) { try { fnToStr.call(value); return true; } catch (e) { return false; } }, fnClass = '[object Function]', genClass = '[object GeneratorFunction]'; isCallable = function isCallable(value) { if (typeof value !== 'function') { return false; } if (hasToStringTag) { return tryFunctionObject(value); } var strClass = to_string.call(value); return strClass === fnClass || strClass === genClass; };
	var isRegex; /* inlined from https://npmjs.com/is-regex */ var regexExec = RegExp.prototype.exec, tryRegexExec = function tryRegexExec(value) { try { regexExec.call(value); return true; } catch (e) { return false; } }, regexClass = '[object RegExp]'; isRegex = function isRegex(value) { if (typeof value !== 'object') { return false; } return hasToStringTag ? tryRegexExec(value) : to_string.call(value) === regexClass; };
	var isString; /* inlined from https://npmjs.com/is-string */ var strValue = String.prototype.valueOf, tryStringObject = function tryStringObject(value) { try { strValue.call(value); return true; } catch (e) { return false; } }, stringClass = '[object String]'; isString = function isString(value) { if (typeof value === 'string') { return true; } if (typeof value !== 'object') { return false; } return hasToStringTag ? tryStringObject(value) : to_string.call(value) === stringClass; };
	
	/* inlined from http://npmjs.com/define-properties */
	var supportsDescriptors = $Object.defineProperty && (function () {
	    try {
	        var obj = {};
	        $Object.defineProperty(obj, 'x', { enumerable: false, value: obj });
	        for (var _ in obj) { return false; }
	        return obj.x === obj;
	    } catch (e) { /* this is ES3 */
	        return false;
	    }
	}());
	var defineProperties = (function (has) {
	  // Define configurable, writable, and non-enumerable props
	  // if they don't exist.
	  var defineProperty;
	  if (supportsDescriptors) {
	      defineProperty = function (object, name, method, forceAssign) {
	          if (!forceAssign && (name in object)) { return; }
	          $Object.defineProperty(object, name, {
	              configurable: true,
	              enumerable: false,
	              writable: true,
	              value: method
	          });
	      };
	  } else {
	      defineProperty = function (object, name, method, forceAssign) {
	          if (!forceAssign && (name in object)) { return; }
	          object[name] = method;
	      };
	  }
	  return function defineProperties(object, map, forceAssign) {
	      for (var name in map) {
	          if (has.call(map, name)) {
	            defineProperty(object, name, map[name], forceAssign);
	          }
	      }
	  };
	}(ObjectPrototype.hasOwnProperty));
	
	//
	// Util
	// ======
	//
	
	/* replaceable with https://npmjs.com/package/es-abstract /helpers/isPrimitive */
	var isPrimitive = function isPrimitive(input) {
	    var type = typeof input;
	    return input === null || (type !== 'object' && type !== 'function');
	};
	
	var isActualNaN = $Number.isNaN || function (x) { return x !== x; };
	
	var ES = {
	    // ES5 9.4
	    // http://es5.github.com/#x9.4
	    // http://jsperf.com/to-integer
	    /* replaceable with https://npmjs.com/package/es-abstract ES5.ToInteger */
	    ToInteger: function ToInteger(num) {
	        var n = +num;
	        if (isActualNaN(n)) {
	            n = 0;
	        } else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {
	            n = (n > 0 || -1) * Math.floor(Math.abs(n));
	        }
	        return n;
	    },
	
	    /* replaceable with https://npmjs.com/package/es-abstract ES5.ToPrimitive */
	    ToPrimitive: function ToPrimitive(input) {
	        var val, valueOf, toStr;
	        if (isPrimitive(input)) {
	            return input;
	        }
	        valueOf = input.valueOf;
	        if (isCallable(valueOf)) {
	            val = valueOf.call(input);
	            if (isPrimitive(val)) {
	                return val;
	            }
	        }
	        toStr = input.toString;
	        if (isCallable(toStr)) {
	            val = toStr.call(input);
	            if (isPrimitive(val)) {
	                return val;
	            }
	        }
	        throw new TypeError();
	    },
	
	    // ES5 9.9
	    // http://es5.github.com/#x9.9
	    /* replaceable with https://npmjs.com/package/es-abstract ES5.ToObject */
	    ToObject: function (o) {
	        if (o == null) { // this matches both null and undefined
	            throw new TypeError("can't convert " + o + ' to object');
	        }
	        return $Object(o);
	    },
	
	    /* replaceable with https://npmjs.com/package/es-abstract ES5.ToUint32 */
	    ToUint32: function ToUint32(x) {
	        return x >>> 0;
	    }
	};
	
	//
	// Function
	// ========
	//
	
	// ES-5 15.3.4.5
	// http://es5.github.com/#x15.3.4.5
	
	var Empty = function Empty() {};
	
	defineProperties(FunctionPrototype, {
	    bind: function bind(that) { // .length is 1
	        // 1. Let Target be the this value.
	        var target = this;
	        // 2. If IsCallable(Target) is false, throw a TypeError exception.
	        if (!isCallable(target)) {
	            throw new TypeError('Function.prototype.bind called on incompatible ' + target);
	        }
	        // 3. Let A be a new (possibly empty) internal list of all of the
	        //   argument values provided after thisArg (arg1, arg2 etc), in order.
	        // XXX slicedArgs will stand in for "A" if used
	        var args = array_slice.call(arguments, 1); // for normal call
	        // 4. Let F be a new native ECMAScript object.
	        // 11. Set the [[Prototype]] internal property of F to the standard
	        //   built-in Function prototype object as specified in 15.3.3.1.
	        // 12. Set the [[Call]] internal property of F as described in
	        //   15.3.4.5.1.
	        // 13. Set the [[Construct]] internal property of F as described in
	        //   15.3.4.5.2.
	        // 14. Set the [[HasInstance]] internal property of F as described in
	        //   15.3.4.5.3.
	        var bound;
	        var binder = function () {
	
	            if (this instanceof bound) {
	                // 15.3.4.5.2 [[Construct]]
	                // When the [[Construct]] internal method of a function object,
	                // F that was created using the bind function is called with a
	                // list of arguments ExtraArgs, the following steps are taken:
	                // 1. Let target be the value of F's [[TargetFunction]]
	                //   internal property.
	                // 2. If target has no [[Construct]] internal method, a
	                //   TypeError exception is thrown.
	                // 3. Let boundArgs be the value of F's [[BoundArgs]] internal
	                //   property.
	                // 4. Let args be a new list containing the same values as the
	                //   list boundArgs in the same order followed by the same
	                //   values as the list ExtraArgs in the same order.
	                // 5. Return the result of calling the [[Construct]] internal
	                //   method of target providing args as the arguments.
	
	                var result = target.apply(
	                    this,
	                    array_concat.call(args, array_slice.call(arguments))
	                );
	                if ($Object(result) === result) {
	                    return result;
	                }
	                return this;
	
	            } else {
	                // 15.3.4.5.1 [[Call]]
	                // When the [[Call]] internal method of a function object, F,
	                // which was created using the bind function is called with a
	                // this value and a list of arguments ExtraArgs, the following
	                // steps are taken:
	                // 1. Let boundArgs be the value of F's [[BoundArgs]] internal
	                //   property.
	                // 2. Let boundThis be the value of F's [[BoundThis]] internal
	                //   property.
	                // 3. Let target be the value of F's [[TargetFunction]] internal
	                //   property.
	                // 4. Let args be a new list containing the same values as the
	                //   list boundArgs in the same order followed by the same
	                //   values as the list ExtraArgs in the same order.
	                // 5. Return the result of calling the [[Call]] internal method
	                //   of target providing boundThis as the this value and
	                //   providing args as the arguments.
	
	                // equiv: target.call(this, ...boundArgs, ...args)
	                return target.apply(
	                    that,
	                    array_concat.call(args, array_slice.call(arguments))
	                );
	
	            }
	
	        };
	
	        // 15. If the [[Class]] internal property of Target is "Function", then
	        //     a. Let L be the length property of Target minus the length of A.
	        //     b. Set the length own property of F to either 0 or L, whichever is
	        //       larger.
	        // 16. Else set the length own property of F to 0.
	
	        var boundLength = max(0, target.length - args.length);
	
	        // 17. Set the attributes of the length own property of F to the values
	        //   specified in 15.3.5.1.
	        var boundArgs = [];
	        for (var i = 0; i < boundLength; i++) {
	            array_push.call(boundArgs, '$' + i);
	        }
	
	        // XXX Build a dynamic function with desired amount of arguments is the only
	        // way to set the length property of a function.
	        // In environments where Content Security Policies enabled (Chrome extensions,
	        // for ex.) all use of eval or Function costructor throws an exception.
	        // However in all of these environments Function.prototype.bind exists
	        // and so this code will never be executed.
	        bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this, arguments); }')(binder);
	
	        if (target.prototype) {
	            Empty.prototype = target.prototype;
	            bound.prototype = new Empty();
	            // Clean up dangling references.
	            Empty.prototype = null;
	        }
	
	        // TODO
	        // 18. Set the [[Extensible]] internal property of F to true.
	
	        // TODO
	        // 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).
	        // 20. Call the [[DefineOwnProperty]] internal method of F with
	        //   arguments "caller", PropertyDescriptor {[[Get]]: thrower, [[Set]]:
	        //   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and
	        //   false.
	        // 21. Call the [[DefineOwnProperty]] internal method of F with
	        //   arguments "arguments", PropertyDescriptor {[[Get]]: thrower,
	        //   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},
	        //   and false.
	
	        // TODO
	        // NOTE Function objects created using Function.prototype.bind do not
	        // have a prototype property or the [[Code]], [[FormalParameters]], and
	        // [[Scope]] internal properties.
	        // XXX can't delete prototype in pure-js.
	
	        // 22. Return F.
	        return bound;
	    }
	});
	
	// _Please note: Shortcuts are defined after `Function.prototype.bind` as we
	// use it in defining shortcuts.
	var owns = call.bind(ObjectPrototype.hasOwnProperty);
	var toStr = call.bind(ObjectPrototype.toString);
	var arraySlice = call.bind(array_slice);
	var arraySliceApply = apply.bind(array_slice);
	var strSlice = call.bind(StringPrototype.slice);
	var strSplit = call.bind(StringPrototype.split);
	var strIndexOf = call.bind(StringPrototype.indexOf);
	var push = call.bind(array_push);
	var isEnum = call.bind(ObjectPrototype.propertyIsEnumerable);
	var arraySort = call.bind(ArrayPrototype.sort);
	
	//
	// Array
	// =====
	//
	
	var isArray = $Array.isArray || function isArray(obj) {
	    return toStr(obj) === '[object Array]';
	};
	
	// ES5 15.4.4.12
	// http://es5.github.com/#x15.4.4.13
	// Return len+argCount.
	// [bugfix, ielt8]
	// IE < 8 bug: [].unshift(0) === undefined but should be "1"
	var hasUnshiftReturnValueBug = [].unshift(0) !== 1;
	defineProperties(ArrayPrototype, {
	    unshift: function () {
	        array_unshift.apply(this, arguments);
	        return this.length;
	    }
	}, hasUnshiftReturnValueBug);
	
	// ES5 15.4.3.2
	// http://es5.github.com/#x15.4.3.2
	// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray
	defineProperties($Array, { isArray: isArray });
	
	// The IsCallable() check in the Array functions
	// has been replaced with a strict check on the
	// internal class of the object to trap cases where
	// the provided function was actually a regular
	// expression literal, which in V8 and
	// JavaScriptCore is a typeof "function".  Only in
	// V8 are regular expression literals permitted as
	// reduce parameters, so it is desirable in the
	// general case for the shim to match the more
	// strict and common behavior of rejecting regular
	// expressions.
	
	// ES5 15.4.4.18
	// http://es5.github.com/#x15.4.4.18
	// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/array/forEach
	
	// Check failure of by-index access of string characters (IE < 9)
	// and failure of `0 in boxedString` (Rhino)
	var boxedString = $Object('a');
	var splitString = boxedString[0] !== 'a' || !(0 in boxedString);
	
	var properlyBoxesContext = function properlyBoxed(method) {
	    // Check node 0.6.21 bug where third parameter is not boxed
	    var properlyBoxesNonStrict = true;
	    var properlyBoxesStrict = true;
	    if (method) {
	        method.call('foo', function (_, __, context) {
	            if (typeof context !== 'object') { properlyBoxesNonStrict = false; }
	        });
	
	        method.call([1], function () {
	            'use strict';
	
	            properlyBoxesStrict = typeof this === 'string';
	        }, 'x');
	    }
	    return !!method && properlyBoxesNonStrict && properlyBoxesStrict;
	};
	
	defineProperties(ArrayPrototype, {
	    forEach: function forEach(callbackfn/*, thisArg*/) {
	        var object = ES.ToObject(this);
	        var self = splitString && isString(this) ? strSplit(this, '') : object;
	        var i = -1;
	        var length = ES.ToUint32(self.length);
	        var T;
	        if (arguments.length > 1) {
	          T = arguments[1];
	        }
	
	        // If no callback function or if callback is not a callable function
	        if (!isCallable(callbackfn)) {
	            throw new TypeError('Array.prototype.forEach callback must be a function');
	        }
	
	        while (++i < length) {
	            if (i in self) {
	                // Invoke the callback function with call, passing arguments:
	                // context, property value, property key, thisArg object
	                if (typeof T === 'undefined') {
	                    callbackfn(self[i], i, object);
	                } else {
	                    callbackfn.call(T, self[i], i, object);
	                }
	            }
	        }
	    }
	}, !properlyBoxesContext(ArrayPrototype.forEach));
	
	// ES5 15.4.4.19
	// http://es5.github.com/#x15.4.4.19
	// https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map
	defineProperties(ArrayPrototype, {
	    map: function map(callbackfn/*, thisArg*/) {
	        var object = ES.ToObject(this);
	        var self = splitString && isString(this) ? strSplit(this, '') : object;
	        var length = ES.ToUint32(self.length);
	        var result = $Array(length);
	        var T;
	        if (arguments.length > 1) {
	            T = arguments[1];
	        }
	
	        // If no callback function or if callback is not a callable function
	        if (!isCallable(callbackfn)) {
	            throw new TypeError('Array.prototype.map callback must be a function');
	        }
	
	        for (var i = 0; i < length; i++) {
	            if (i in self) {
	                if (typeof T === 'undefined') {
	                    result[i] = callbackfn(self[i], i, object);
	                } else {
	                    result[i] = callbackfn.call(T, self[i], i, object);
	                }
	            }
	        }
	        return result;
	    }
	}, !properlyBoxesContext(ArrayPrototype.map));
	
	// ES5 15.4.4.20
	// http://es5.github.com/#x15.4.4.20
	// https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter
	defineProperties(ArrayPrototype, {
	    filter: function filter(callbackfn/*, thisArg*/) {
	        var object = ES.ToObject(this);
	        var self = splitString && isString(this) ? strSplit(this, '') : object;
	        var length = ES.ToUint32(self.length);
	        var result = [];
	        var value;
	        var T;
	        if (arguments.length > 1) {
	            T = arguments[1];
	        }
	
	        // If no callback function or if callback is not a callable function
	        if (!isCallable(callbackfn)) {
	            throw new TypeError('Array.prototype.filter callback must be a function');
	        }
	
	        for (var i = 0; i < length; i++) {
	            if (i in self) {
	                value = self[i];
	                if (typeof T === 'undefined' ? callbackfn(value, i, object) : callbackfn.call(T, value, i, object)) {
	                    push(result, value);
	                }
	            }
	        }
	        return result;
	    }
	}, !properlyBoxesContext(ArrayPrototype.filter));
	
	// ES5 15.4.4.16
	// http://es5.github.com/#x15.4.4.16
	// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/every
	defineProperties(ArrayPrototype, {
	    every: function every(callbackfn/*, thisArg*/) {
	        var object = ES.ToObject(this);
	        var self = splitString && isString(this) ? strSplit(this, '') : object;
	        var length = ES.ToUint32(self.length);
	        var T;
	        if (arguments.length > 1) {
	            T = arguments[1];
	        }
	
	        // If no callback function or if callback is not a callable function
	        if (!isCallable(callbackfn)) {
	            throw new TypeError('Array.prototype.every callback must be a function');
	        }
	
	        for (var i = 0; i < length; i++) {
	            if (i in self && !(typeof T === 'undefined' ? callbackfn(self[i], i, object) : callbackfn.call(T, self[i], i, object))) {
	                return false;
	            }
	        }
	        return true;
	    }
	}, !properlyBoxesContext(ArrayPrototype.every));
	
	// ES5 15.4.4.17
	// http://es5.github.com/#x15.4.4.17
	// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/some
	defineProperties(ArrayPrototype, {
	    some: function some(callbackfn/*, thisArg */) {
	        var object = ES.ToObject(this);
	        var self = splitString && isString(this) ? strSplit(this, '') : object;
	        var length = ES.ToUint32(self.length);
	        var T;
	        if (arguments.length > 1) {
	            T = arguments[1];
	        }
	
	        // If no callback function or if callback is not a callable function
	        if (!isCallable(callbackfn)) {
	            throw new TypeError('Array.prototype.some callback must be a function');
	        }
	
	        for (var i = 0; i < length; i++) {
	            if (i in self && (typeof T === 'undefined' ? callbackfn(self[i], i, object) : callbackfn.call(T, self[i], i, object))) {
	                return true;
	            }
	        }
	        return false;
	    }
	}, !properlyBoxesContext(ArrayPrototype.some));
	
	// ES5 15.4.4.21
	// http://es5.github.com/#x15.4.4.21
	// https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/reduce
	var reduceCoercesToObject = false;
	if (ArrayPrototype.reduce) {
	    reduceCoercesToObject = typeof ArrayPrototype.reduce.call('es5', function (_, __, ___, list) { return list; }) === 'object';
	}
	defineProperties(ArrayPrototype, {
	    reduce: function reduce(callbackfn/*, initialValue*/) {
	        var object = ES.ToObject(this);
	        var self = splitString && isString(this) ? strSplit(this, '') : object;
	        var length = ES.ToUint32(self.length);
	
	        // If no callback function or if callback is not a callable function
	        if (!isCallable(callbackfn)) {
	            throw new TypeError('Array.prototype.reduce callback must be a function');
	        }
	
	        // no value to return if no initial value and an empty array
	        if (length === 0 && arguments.length === 1) {
	            throw new TypeError('reduce of empty array with no initial value');
	        }
	
	        var i = 0;
	        var result;
	        if (arguments.length >= 2) {
	            result = arguments[1];
	        } else {
	            do {
	                if (i in self) {
	                    result = self[i++];
	                    break;
	                }
	
	                // if array contains no values, no initial value to return
	                if (++i >= length) {
	                    throw new TypeError('reduce of empty array with no initial value');
	                }
	            } while (true);
	        }
	
	        for (; i < length; i++) {
	            if (i in self) {
	                result = callbackfn(result, self[i], i, object);
	            }
	        }
	
	        return result;
	    }
	}, !reduceCoercesToObject);
	
	// ES5 15.4.4.22
	// http://es5.github.com/#x15.4.4.22
	// https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/reduceRight
	var reduceRightCoercesToObject = false;
	if (ArrayPrototype.reduceRight) {
	    reduceRightCoercesToObject = typeof ArrayPrototype.reduceRight.call('es5', function (_, __, ___, list) { return list; }) === 'object';
	}
	defineProperties(ArrayPrototype, {
	    reduceRight: function reduceRight(callbackfn/*, initial*/) {
	        var object = ES.ToObject(this);
	        var self = splitString && isString(this) ? strSplit(this, '') : object;
	        var length = ES.ToUint32(self.length);
	
	        // If no callback function or if callback is not a callable function
	        if (!isCallable(callbackfn)) {
	            throw new TypeError('Array.prototype.reduceRight callback must be a function');
	        }
	
	        // no value to return if no initial value, empty array
	        if (length === 0 && arguments.length === 1) {
	            throw new TypeError('reduceRight of empty array with no initial value');
	        }
	
	        var result;
	        var i = length - 1;
	        if (arguments.length >= 2) {
	            result = arguments[1];
	        } else {
	            do {
	                if (i in self) {
	                    result = self[i--];
	                    break;
	                }
	
	                // if array contains no values, no initial value to return
	                if (--i < 0) {
	                    throw new TypeError('reduceRight of empty array with no initial value');
	                }
	            } while (true);
	        }
	
	        if (i < 0) {
	            return result;
	        }
	
	        do {
	            if (i in self) {
	                result = callbackfn(result, self[i], i, object);
	            }
	        } while (i--);
	
	        return result;
	    }
	}, !reduceRightCoercesToObject);
	
	// ES5 15.4.4.14
	// http://es5.github.com/#x15.4.4.14
	// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf
	var hasFirefox2IndexOfBug = ArrayPrototype.indexOf && [0, 1].indexOf(1, 2) !== -1;
	defineProperties(ArrayPrototype, {
	    indexOf: function indexOf(searchElement/*, fromIndex */) {
	        var self = splitString && isString(this) ? strSplit(this, '') : ES.ToObject(this);
	        var length = ES.ToUint32(self.length);
	
	        if (length === 0) {
	            return -1;
	        }
	
	        var i = 0;
	        if (arguments.length > 1) {
	            i = ES.ToInteger(arguments[1]);
	        }
	
	        // handle negative indices
	        i = i >= 0 ? i : max(0, length + i);
	        for (; i < length; i++) {
	            if (i in self && self[i] === searchElement) {
	                return i;
	            }
	        }
	        return -1;
	    }
	}, hasFirefox2IndexOfBug);
	
	// ES5 15.4.4.15
	// http://es5.github.com/#x15.4.4.15
	// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/lastIndexOf
	var hasFirefox2LastIndexOfBug = ArrayPrototype.lastIndexOf && [0, 1].lastIndexOf(0, -3) !== -1;
	defineProperties(ArrayPrototype, {
	    lastIndexOf: function lastIndexOf(searchElement/*, fromIndex */) {
	        var self = splitString && isString(this) ? strSplit(this, '') : ES.ToObject(this);
	        var length = ES.ToUint32(self.length);
	
	        if (length === 0) {
	            return -1;
	        }
	        var i = length - 1;
	        if (arguments.length > 1) {
	            i = min(i, ES.ToInteger(arguments[1]));
	        }
	        // handle negative indices
	        i = i >= 0 ? i : length - Math.abs(i);
	        for (; i >= 0; i--) {
	            if (i in self && searchElement === self[i]) {
	                return i;
	            }
	        }
	        return -1;
	    }
	}, hasFirefox2LastIndexOfBug);
	
	// ES5 15.4.4.12
	// http://es5.github.com/#x15.4.4.12
	var spliceNoopReturnsEmptyArray = (function () {
	    var a = [1, 2];
	    var result = a.splice();
	    return a.length === 2 && isArray(result) && result.length === 0;
	}());
	defineProperties(ArrayPrototype, {
	    // Safari 5.0 bug where .splice() returns undefined
	    splice: function splice(start, deleteCount) {
	        if (arguments.length === 0) {
	            return [];
	        } else {
	            return array_splice.apply(this, arguments);
	        }
	    }
	}, !spliceNoopReturnsEmptyArray);
	
	var spliceWorksWithEmptyObject = (function () {
	    var obj = {};
	    ArrayPrototype.splice.call(obj, 0, 0, 1);
	    return obj.length === 1;
	}());
	defineProperties(ArrayPrototype, {
	    splice: function splice(start, deleteCount) {
	        if (arguments.length === 0) { return []; }
	        var args = arguments;
	        this.length = max(ES.ToInteger(this.length), 0);
	        if (arguments.length > 0 && typeof deleteCount !== 'number') {
	            args = arraySlice(arguments);
	            if (args.length < 2) {
	                push(args, this.length - start);
	            } else {
	                args[1] = ES.ToInteger(deleteCount);
	            }
	        }
	        return array_splice.apply(this, args);
	    }
	}, !spliceWorksWithEmptyObject);
	var spliceWorksWithLargeSparseArrays = (function () {
	    // Per https://github.com/es-shims/es5-shim/issues/295
	    // Safari 7/8 breaks with sparse arrays of size 1e5 or greater
	    var arr = new $Array(1e5);
	    // note: the index MUST be 8 or larger or the test will false pass
	    arr[8] = 'x';
	    arr.splice(1, 1);
	    // note: this test must be defined *after* the indexOf shim
	    // per https://github.com/es-shims/es5-shim/issues/313
	    return arr.indexOf('x') === 7;
	}());
	var spliceWorksWithSmallSparseArrays = (function () {
	    // Per https://github.com/es-shims/es5-shim/issues/295
	    // Opera 12.15 breaks on this, no idea why.
	    var n = 256;
	    var arr = [];
	    arr[n] = 'a';
	    arr.splice(n + 1, 0, 'b');
	    return arr[n] === 'a';
	}());
	defineProperties(ArrayPrototype, {
	    splice: function splice(start, deleteCount) {
	        var O = ES.ToObject(this);
	        var A = [];
	        var len = ES.ToUint32(O.length);
	        var relativeStart = ES.ToInteger(start);
	        var actualStart = relativeStart < 0 ? max((len + relativeStart), 0) : min(relativeStart, len);
	        var actualDeleteCount = min(max(ES.ToInteger(deleteCount), 0), len - actualStart);
	
	        var k = 0;
	        var from;
	        while (k < actualDeleteCount) {
	            from = $String(actualStart + k);
	            if (owns(O, from)) {
	                A[k] = O[from];
	            }
	            k += 1;
	        }
	
	        var items = arraySlice(arguments, 2);
	        var itemCount = items.length;
	        var to;
	        if (itemCount < actualDeleteCount) {
	            k = actualStart;
	            while (k < (len - actualDeleteCount)) {
	                from = $String(k + actualDeleteCount);
	                to = $String(k + itemCount);
	                if (owns(O, from)) {
	                    O[to] = O[from];
	                } else {
	                    delete O[to];
	                }
	                k += 1;
	            }
	            k = len;
	            while (k > (len - actualDeleteCount + itemCount)) {
	                delete O[k - 1];
	                k -= 1;
	            }
	        } else if (itemCount > actualDeleteCount) {
	            k = len - actualDeleteCount;
	            while (k > actualStart) {
	                from = $String(k + actualDeleteCount - 1);
	                to = $String(k + itemCount - 1);
	                if (owns(O, from)) {
	                    O[to] = O[from];
	                } else {
	                    delete O[to];
	                }
	                k -= 1;
	            }
	        }
	        k = actualStart;
	        for (var i = 0; i < items.length; ++i) {
	            O[k] = items[i];
	            k += 1;
	        }
	        O.length = len - actualDeleteCount + itemCount;
	
	        return A;
	    }
	}, !spliceWorksWithLargeSparseArrays || !spliceWorksWithSmallSparseArrays);
	
	var originalJoin = ArrayPrototype.join;
	var hasStringJoinBug;
	try {
	    hasStringJoinBug = Array.prototype.join.call('123', ',') !== '1,2,3';
	} catch (e) {
	    hasStringJoinBug = true;
	}
	if (hasStringJoinBug) {
	    defineProperties(ArrayPrototype, {
	        join: function join(separator) {
	            var sep = typeof separator === 'undefined' ? ',' : separator;
	            return originalJoin.call(isString(this) ? strSplit(this, '') : this, sep);
	        }
	    }, hasStringJoinBug);
	}
	
	var hasJoinUndefinedBug = [1, 2].join(undefined) !== '1,2';
	if (hasJoinUndefinedBug) {
	    defineProperties(ArrayPrototype, {
	        join: function join(separator) {
	            var sep = typeof separator === 'undefined' ? ',' : separator;
	            return originalJoin.call(this, sep);
	        }
	    }, hasJoinUndefinedBug);
	}
	
	var pushShim = function push(item) {
	    var O = ES.ToObject(this);
	    var n = ES.ToUint32(O.length);
	    var i = 0;
	    while (i < arguments.length) {
	        O[n + i] = arguments[i];
	        i += 1;
	    }
	    O.length = n + i;
	    return n + i;
	};
	
	var pushIsNotGeneric = (function () {
	    var obj = {};
	    var result = Array.prototype.push.call(obj, undefined);
	    return result !== 1 || obj.length !== 1 || typeof obj[0] !== 'undefined' || !owns(obj, 0);
	}());
	defineProperties(ArrayPrototype, {
	    push: function push(item) {
	        if (isArray(this)) {
	            return array_push.apply(this, arguments);
	        }
	        return pushShim.apply(this, arguments);
	    }
	}, pushIsNotGeneric);
	
	// This fixes a very weird bug in Opera 10.6 when pushing `undefined
	var pushUndefinedIsWeird = (function () {
	    var arr = [];
	    var result = arr.push(undefined);
	    return result !== 1 || arr.length !== 1 || typeof arr[0] !== 'undefined' || !owns(arr, 0);
	}());
	defineProperties(ArrayPrototype, { push: pushShim }, pushUndefinedIsWeird);
	
	// ES5 15.2.3.14
	// http://es5.github.io/#x15.4.4.10
	// Fix boxed string bug
	defineProperties(ArrayPrototype, {
	    slice: function (start, end) {
	        var arr = isString(this) ? strSplit(this, '') : this;
	        return arraySliceApply(arr, arguments);
	    }
	}, splitString);
	
	var sortIgnoresNonFunctions = (function () {
	    try {
	        [1, 2].sort(null);
	        [1, 2].sort({});
	        return true;
	    } catch (e) { /**/ }
	    return false;
	}());
	var sortThrowsOnRegex = (function () {
	    // this is a problem in Firefox 4, in which `typeof /a/ === 'function'`
	    try {
	        [1, 2].sort(/a/);
	        return false;
	    } catch (e) { /**/ }
	    return true;
	}());
	var sortIgnoresUndefined = (function () {
	    // applies in IE 8, for one.
	    try {
	        [1, 2].sort(undefined);
	        return true;
	    } catch (e) { /**/ }
	    return false;
	}());
	defineProperties(ArrayPrototype, {
	    sort: function sort(compareFn) {
	        if (typeof compareFn === 'undefined') {
	            return arraySort(this);
	        }
	        if (!isCallable(compareFn)) {
	            throw new TypeError('Array.prototype.sort callback must be a function');
	        }
	        return arraySort(this, compareFn);
	    }
	}, sortIgnoresNonFunctions || !sortIgnoresUndefined || !sortThrowsOnRegex);
	
	//
	// Object
	// ======
	//
	
	// ES5 15.2.3.14
	// http://es5.github.com/#x15.2.3.14
	
	// http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation
	var hasDontEnumBug = !({ 'toString': null }).propertyIsEnumerable('toString');
	var hasProtoEnumBug = function () {}.propertyIsEnumerable('prototype');
	var hasStringEnumBug = !owns('x', '0');
	var equalsConstructorPrototype = function (o) {
	    var ctor = o.constructor;
	    return ctor && ctor.prototype === o;
	};
	var blacklistedKeys = {
	    $window: true,
	    $console: true,
	    $parent: true,
	    $self: true,
	    $frame: true,
	    $frames: true,
	    $frameElement: true,
	    $webkitIndexedDB: true,
	    $webkitStorageInfo: true,
	    $external: true
	};
	var hasAutomationEqualityBug = (function () {
	    /* globals window */
	    if (typeof window === 'undefined') { return false; }
	    for (var k in window) {
	        try {
	            if (!blacklistedKeys['$' + k] && owns(window, k) && window[k] !== null && typeof window[k] === 'object') {
	                equalsConstructorPrototype(window[k]);
	            }
	        } catch (e) {
	            return true;
	        }
	    }
	    return false;
	}());
	var equalsConstructorPrototypeIfNotBuggy = function (object) {
	    if (typeof window === 'undefined' || !hasAutomationEqualityBug) { return equalsConstructorPrototype(object); }
	    try {
	        return equalsConstructorPrototype(object);
	    } catch (e) {
	        return false;
	    }
	};
	var dontEnums = [
	    'toString',
	    'toLocaleString',
	    'valueOf',
	    'hasOwnProperty',
	    'isPrototypeOf',
	    'propertyIsEnumerable',
	    'constructor'
	];
	var dontEnumsLength = dontEnums.length;
	
	// taken directly from https://github.com/ljharb/is-arguments/blob/master/index.js
	// can be replaced with require('is-arguments') if we ever use a build process instead
	var isStandardArguments = function isArguments(value) {
	    return toStr(value) === '[object Arguments]';
	};
	var isLegacyArguments = function isArguments(value) {
	    return value !== null &&
	        typeof value === 'object' &&
	        typeof value.length === 'number' &&
	        value.length >= 0 &&
	        !isArray(value) &&
	        isCallable(value.callee);
	};
	var isArguments = isStandardArguments(arguments) ? isStandardArguments : isLegacyArguments;
	
	defineProperties($Object, {
	    keys: function keys(object) {
	        var isFn = isCallable(object);
	        var isArgs = isArguments(object);
	        var isObject = object !== null && typeof object === 'object';
	        var isStr = isObject && isString(object);
	
	        if (!isObject && !isFn && !isArgs) {
	            throw new TypeError('Object.keys called on a non-object');
	        }
	
	        var theKeys = [];
	        var skipProto = hasProtoEnumBug && isFn;
	        if ((isStr && hasStringEnumBug) || isArgs) {
	            for (var i = 0; i < object.length; ++i) {
	                push(theKeys, $String(i));
	            }
	        }
	
	        if (!isArgs) {
	            for (var name in object) {
	                if (!(skipProto && name === 'prototype') && owns(object, name)) {
	                    push(theKeys, $String(name));
	                }
	            }
	        }
	
	        if (hasDontEnumBug) {
	            var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
	            for (var j = 0; j < dontEnumsLength; j++) {
	                var dontEnum = dontEnums[j];
	                if (!(skipConstructor && dontEnum === 'constructor') && owns(object, dontEnum)) {
	                    push(theKeys, dontEnum);
	                }
	            }
	        }
	        return theKeys;
	    }
	});
	
	var keysWorksWithArguments = $Object.keys && (function () {
	    // Safari 5.0 bug
	    return $Object.keys(arguments).length === 2;
	}(1, 2));
	var keysHasArgumentsLengthBug = $Object.keys && (function () {
	    var argKeys = $Object.keys(arguments);
	    return arguments.length !== 1 || argKeys.length !== 1 || argKeys[0] !== 1;
	}(1));
	var originalKeys = $Object.keys;
	defineProperties($Object, {
	    keys: function keys(object) {
	        if (isArguments(object)) {
	            return originalKeys(arraySlice(object));
	        } else {
	            return originalKeys(object);
	        }
	    }
	}, !keysWorksWithArguments || keysHasArgumentsLengthBug);
	
	//
	// Date
	// ====
	//
	
	// ES5 15.9.5.43
	// http://es5.github.com/#x15.9.5.43
	// This function returns a String value represent the instance in time
	// represented by this Date object. The format of the String is the Date Time
	// string format defined in 15.9.1.15. All fields are present in the String.
	// The time zone is always UTC, denoted by the suffix Z. If the time value of
	// this object is not a finite Number a RangeError exception is thrown.
	var negativeDate = -62198755200000;
	var negativeYearString = '-000001';
	var hasNegativeDateBug = Date.prototype.toISOString && new Date(negativeDate).toISOString().indexOf(negativeYearString) === -1;
	var hasSafari51DateBug = Date.prototype.toISOString && new Date(-1).toISOString() !== '1969-12-31T23:59:59.999Z';
	
	defineProperties(Date.prototype, {
	    toISOString: function toISOString() {
	        var result, length, value, year, month;
	        if (!isFinite(this)) {
	            throw new RangeError('Date.prototype.toISOString called on non-finite value.');
	        }
	
	        year = this.getUTCFullYear();
	
	        month = this.getUTCMonth();
	        // see https://github.com/es-shims/es5-shim/issues/111
	        year += Math.floor(month / 12);
	        month = (month % 12 + 12) % 12;
	
	        // the date time string format is specified in 15.9.1.15.
	        result = [month + 1, this.getUTCDate(), this.getUTCHours(), this.getUTCMinutes(), this.getUTCSeconds()];
	        year = (
	            (year < 0 ? '-' : (year > 9999 ? '+' : '')) +
	            strSlice('00000' + Math.abs(year), (0 <= year && year <= 9999) ? -4 : -6)
	        );
	
	        length = result.length;
	        while (length--) {
	            value = result[length];
	            // pad months, days, hours, minutes, and seconds to have two
	            // digits.
	            if (value < 10) {
	                result[length] = '0' + value;
	            }
	        }
	        // pad milliseconds to have three digits.
	        return (
	            year + '-' + arraySlice(result, 0, 2).join('-') +
	            'T' + arraySlice(result, 2).join(':') + '.' +
	            strSlice('000' + this.getUTCMilliseconds(), -3) + 'Z'
	        );
	    }
	}, hasNegativeDateBug || hasSafari51DateBug);
	
	// ES5 15.9.5.44
	// http://es5.github.com/#x15.9.5.44
	// This function provides a String representation of a Date object for use by
	// JSON.stringify (15.12.3).
	var dateToJSONIsSupported = (function () {
	    try {
	        return Date.prototype.toJSON &&
	            new Date(NaN).toJSON() === null &&
	            new Date(negativeDate).toJSON().indexOf(negativeYearString) !== -1 &&
	            Date.prototype.toJSON.call({ // generic
	                toISOString: function () { return true; }
	            });
	    } catch (e) {
	        return false;
	    }
	}());
	if (!dateToJSONIsSupported) {
	    Date.prototype.toJSON = function toJSON(key) {
	        // When the toJSON method is called with argument key, the following
	        // steps are taken:
	
	        // 1.  Let O be the result of calling ToObject, giving it the this
	        // value as its argument.
	        // 2. Let tv be ES.ToPrimitive(O, hint Number).
	        var O = $Object(this);
	        var tv = ES.ToPrimitive(O);
	        // 3. If tv is a Number and is not finite, return null.
	        if (typeof tv === 'number' && !isFinite(tv)) {
	            return null;
	        }
	        // 4. Let toISO be the result of calling the [[Get]] internal method of
	        // O with argument "toISOString".
	        var toISO = O.toISOString;
	        // 5. If IsCallable(toISO) is false, throw a TypeError exception.
	        if (!isCallable(toISO)) {
	            throw new TypeError('toISOString property is not callable');
	        }
	        // 6. Return the result of calling the [[Call]] internal method of
	        //  toISO with O as the this value and an empty argument list.
	        return toISO.call(O);
	
	        // NOTE 1 The argument is ignored.
	
	        // NOTE 2 The toJSON function is intentionally generic; it does not
	        // require that its this value be a Date object. Therefore, it can be
	        // transferred to other kinds of objects for use as a method. However,
	        // it does require that any such object have a toISOString method. An
	        // object is free to use the argument key to filter its
	        // stringification.
	    };
	}
	
	// ES5 15.9.4.2
	// http://es5.github.com/#x15.9.4.2
	// based on work shared by Daniel Friesen (dantman)
	// http://gist.github.com/303249
	var supportsExtendedYears = Date.parse('+033658-09-27T01:46:40.000Z') === 1e15;
	var acceptsInvalidDates = !isNaN(Date.parse('2012-04-04T24:00:00.500Z')) || !isNaN(Date.parse('2012-11-31T23:59:59.000Z')) || !isNaN(Date.parse('2012-12-31T23:59:60.000Z'));
	var doesNotParseY2KNewYear = isNaN(Date.parse('2000-01-01T00:00:00.000Z'));
	if (doesNotParseY2KNewYear || acceptsInvalidDates || !supportsExtendedYears) {
	    // XXX global assignment won't work in embeddings that use
	    // an alternate object for the context.
	    /* global Date: true */
	    /* eslint-disable no-undef */
	    var maxSafeUnsigned32Bit = Math.pow(2, 31) - 1;
	    var hasSafariSignedIntBug = isActualNaN(new Date(1970, 0, 1, 0, 0, 0, maxSafeUnsigned32Bit + 1).getTime());
	    Date = (function (NativeDate) {
	    /* eslint-enable no-undef */
	        // Date.length === 7
	        var DateShim = function Date(Y, M, D, h, m, s, ms) {
	            var length = arguments.length;
	            var date;
	            if (this instanceof NativeDate) {
	                var seconds = s;
	                var millis = ms;
	                if (hasSafariSignedIntBug && length >= 7 && ms > maxSafeUnsigned32Bit) {
	                    // work around a Safari 8/9 bug where it treats the seconds as signed
	                    var msToShift = Math.floor(ms / maxSafeUnsigned32Bit) * maxSafeUnsigned32Bit;
	                    var sToShift = Math.floor(msToShift / 1e3);
	                    seconds += sToShift;
	                    millis -= sToShift * 1e3;
	                }
	                date = length === 1 && $String(Y) === Y ? // isString(Y)
	                    // We explicitly pass it through parse:
	                    new NativeDate(DateShim.parse(Y)) :
	                    // We have to manually make calls depending on argument
	                    // length here
	                    length >= 7 ? new NativeDate(Y, M, D, h, m, seconds, millis) :
	                    length >= 6 ? new NativeDate(Y, M, D, h, m, seconds) :
	                    length >= 5 ? new NativeDate(Y, M, D, h, m) :
	                    length >= 4 ? new NativeDate(Y, M, D, h) :
	                    length >= 3 ? new NativeDate(Y, M, D) :
	                    length >= 2 ? new NativeDate(Y, M) :
	                    length >= 1 ? new NativeDate(Y) :
	                                  new NativeDate();
	            } else {
	                date = NativeDate.apply(this, arguments);
	            }
	            if (!isPrimitive(date)) {
	              // Prevent mixups with unfixed Date object
	              defineProperties(date, { constructor: DateShim }, true);
	            }
	            return date;
	        };
	
	        // 15.9.1.15 Date Time String Format.
	        var isoDateExpression = new RegExp('^' +
	            '(\\d{4}|[+-]\\d{6})' + // four-digit year capture or sign +
	                                      // 6-digit extended year
	            '(?:-(\\d{2})' + // optional month capture
	            '(?:-(\\d{2})' + // optional day capture
	            '(?:' + // capture hours:minutes:seconds.milliseconds
	                'T(\\d{2})' + // hours capture
	                ':(\\d{2})' + // minutes capture
	                '(?:' + // optional :seconds.milliseconds
	                    ':(\\d{2})' + // seconds capture
	                    '(?:(\\.\\d{1,}))?' + // milliseconds capture
	                ')?' +
	            '(' + // capture UTC offset component
	                'Z|' + // UTC capture
	                '(?:' + // offset specifier +/-hours:minutes
	                    '([-+])' + // sign capture
	                    '(\\d{2})' + // hours offset capture
	                    ':(\\d{2})' + // minutes offset capture
	                ')' +
	            ')?)?)?)?' +
	        '$');
	
	        var months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365];
	
	        var dayFromMonth = function dayFromMonth(year, month) {
	            var t = month > 1 ? 1 : 0;
	            return (
	                months[month] +
	                Math.floor((year - 1969 + t) / 4) -
	                Math.floor((year - 1901 + t) / 100) +
	                Math.floor((year - 1601 + t) / 400) +
	                365 * (year - 1970)
	            );
	        };
	
	        var toUTC = function toUTC(t) {
	            var s = 0;
	            var ms = t;
	            if (hasSafariSignedIntBug && ms > maxSafeUnsigned32Bit) {
	                // work around a Safari 8/9 bug where it treats the seconds as signed
	                var msToShift = Math.floor(ms / maxSafeUnsigned32Bit) * maxSafeUnsigned32Bit;
	                var sToShift = Math.floor(msToShift / 1e3);
	                s += sToShift;
	                ms -= sToShift * 1e3;
	            }
	            return $Number(new NativeDate(1970, 0, 1, 0, 0, s, ms));
	        };
	
	        // Copy any custom methods a 3rd party library may have added
	        for (var key in NativeDate) {
	            if (owns(NativeDate, key)) {
	                DateShim[key] = NativeDate[key];
	            }
	        }
	
	        // Copy "native" methods explicitly; they may be non-enumerable
	        defineProperties(DateShim, {
	            now: NativeDate.now,
	            UTC: NativeDate.UTC
	        }, true);
	        DateShim.prototype = NativeDate.prototype;
	        defineProperties(DateShim.prototype, {
	            constructor: DateShim
	        }, true);
	
	        // Upgrade Date.parse to handle simplified ISO 8601 strings
	        var parseShim = function parse(string) {
	            var match = isoDateExpression.exec(string);
	            if (match) {
	                // parse months, days, hours, minutes, seconds, and milliseconds
	                // provide default values if necessary
	                // parse the UTC offset component
	                var year = $Number(match[1]),
	                    month = $Number(match[2] || 1) - 1,
	                    day = $Number(match[3] || 1) - 1,
	                    hour = $Number(match[4] || 0),
	                    minute = $Number(match[5] || 0),
	                    second = $Number(match[6] || 0),
	                    millisecond = Math.floor($Number(match[7] || 0) * 1000),
	                    // When time zone is missed, local offset should be used
	                    // (ES 5.1 bug)
	                    // see https://bugs.ecmascript.org/show_bug.cgi?id=112
	                    isLocalTime = Boolean(match[4] && !match[8]),
	                    signOffset = match[9] === '-' ? 1 : -1,
	                    hourOffset = $Number(match[10] || 0),
	                    minuteOffset = $Number(match[11] || 0),
	                    result;
	                var hasMinutesOrSecondsOrMilliseconds = minute > 0 || second > 0 || millisecond > 0;
	                if (
	                    hour < (hasMinutesOrSecondsOrMilliseconds ? 24 : 25) &&
	                    minute < 60 && second < 60 && millisecond < 1000 &&
	                    month > -1 && month < 12 && hourOffset < 24 &&
	                    minuteOffset < 60 && // detect invalid offsets
	                    day > -1 &&
	                    day < (dayFromMonth(year, month + 1) - dayFromMonth(year, month))
	                ) {
	                    result = (
	                        (dayFromMonth(year, month) + day) * 24 +
	                        hour +
	                        hourOffset * signOffset
	                    ) * 60;
	                    result = (
	                        (result + minute + minuteOffset * signOffset) * 60 +
	                        second
	                    ) * 1000 + millisecond;
	                    if (isLocalTime) {
	                        result = toUTC(result);
	                    }
	                    if (-8.64e15 <= result && result <= 8.64e15) {
	                        return result;
	                    }
	                }
	                return NaN;
	            }
	            return NativeDate.parse.apply(this, arguments);
	        };
	        defineProperties(DateShim, { parse: parseShim });
	
	        return DateShim;
	    }(Date));
	    /* global Date: false */
	}
	
	// ES5 15.9.4.4
	// http://es5.github.com/#x15.9.4.4
	if (!Date.now) {
	    Date.now = function now() {
	        return new Date().getTime();
	    };
	}
	
	//
	// Number
	// ======
	//
	
	// ES5.1 15.7.4.5
	// http://es5.github.com/#x15.7.4.5
	var hasToFixedBugs = NumberPrototype.toFixed && (
	  (0.00008).toFixed(3) !== '0.000' ||
	  (0.9).toFixed(0) !== '1' ||
	  (1.255).toFixed(2) !== '1.25' ||
	  (1000000000000000128).toFixed(0) !== '1000000000000000128'
	);
	
	var toFixedHelpers = {
	  base: 1e7,
	  size: 6,
	  data: [0, 0, 0, 0, 0, 0],
	  multiply: function multiply(n, c) {
	      var i = -1;
	      var c2 = c;
	      while (++i < toFixedHelpers.size) {
	          c2 += n * toFixedHelpers.data[i];
	          toFixedHelpers.data[i] = c2 % toFixedHelpers.base;
	          c2 = Math.floor(c2 / toFixedHelpers.base);
	      }
	  },
	  divide: function divide(n) {
	      var i = toFixedHelpers.size, c = 0;
	      while (--i >= 0) {
	          c += toFixedHelpers.data[i];
	          toFixedHelpers.data[i] = Math.floor(c / n);
	          c = (c % n) * toFixedHelpers.base;
	      }
	  },
	  numToString: function numToString() {
	      var i = toFixedHelpers.size;
	      var s = '';
	      while (--i >= 0) {
	          if (s !== '' || i === 0 || toFixedHelpers.data[i] !== 0) {
	              var t = $String(toFixedHelpers.data[i]);
	              if (s === '') {
	                  s = t;
	              } else {
	                  s += strSlice('0000000', 0, 7 - t.length) + t;
	              }
	          }
	      }
	      return s;
	  },
	  pow: function pow(x, n, acc) {
	      return (n === 0 ? acc : (n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc)));
	  },
	  log: function log(x) {
	      var n = 0;
	      var x2 = x;
	      while (x2 >= 4096) {
	          n += 12;
	          x2 /= 4096;
	      }
	      while (x2 >= 2) {
	          n += 1;
	          x2 /= 2;
	      }
	      return n;
	  }
	};
	
	var toFixedShim = function toFixed(fractionDigits) {
	    var f, x, s, m, e, z, j, k;
	
	    // Test for NaN and round fractionDigits down
	    f = $Number(fractionDigits);
	    f = isActualNaN(f) ? 0 : Math.floor(f);
	
	    if (f < 0 || f > 20) {
	        throw new RangeError('Number.toFixed called with invalid number of decimals');
	    }
	
	    x = $Number(this);
	
	    if (isActualNaN(x)) {
	        return 'NaN';
	    }
	
	    // If it is too big or small, return the string value of the number
	    if (x <= -1e21 || x >= 1e21) {
	        return $String(x);
	    }
	
	    s = '';
	
	    if (x < 0) {
	        s = '-';
	        x = -x;
	    }
	
	    m = '0';
	
	    if (x > 1e-21) {
	        // 1e-21 < x < 1e21
	        // -70 < log2(x) < 70
	        e = toFixedHelpers.log(x * toFixedHelpers.pow(2, 69, 1)) - 69;
	        z = (e < 0 ? x * toFixedHelpers.pow(2, -e, 1) : x / toFixedHelpers.pow(2, e, 1));
	        z *= 0x10000000000000; // Math.pow(2, 52);
	        e = 52 - e;
	
	        // -18 < e < 122
	        // x = z / 2 ^ e
	        if (e > 0) {
	            toFixedHelpers.multiply(0, z);
	            j = f;
	
	            while (j >= 7) {
	                toFixedHelpers.multiply(1e7, 0);
	                j -= 7;
	            }
	
	            toFixedHelpers.multiply(toFixedHelpers.pow(10, j, 1), 0);
	            j = e - 1;
	
	            while (j >= 23) {
	                toFixedHelpers.divide(1 << 23);
	                j -= 23;
	            }
	
	            toFixedHelpers.divide(1 << j);
	            toFixedHelpers.multiply(1, 1);
	            toFixedHelpers.divide(2);
	            m = toFixedHelpers.numToString();
	        } else {
	            toFixedHelpers.multiply(0, z);
	            toFixedHelpers.multiply(1 << (-e), 0);
	            m = toFixedHelpers.numToString() + strSlice('0.00000000000000000000', 2, 2 + f);
	        }
	    }
	
	    if (f > 0) {
	        k = m.length;
	
	        if (k <= f) {
	            m = s + strSlice('0.0000000000000000000', 0, f - k + 2) + m;
	        } else {
	            m = s + strSlice(m, 0, k - f) + '.' + strSlice(m, k - f);
	        }
	    } else {
	        m = s + m;
	    }
	
	    return m;
	};
	defineProperties(NumberPrototype, { toFixed: toFixedShim }, hasToFixedBugs);
	
	var hasToPrecisionUndefinedBug = (function () {
	    try {
	        return 1.0.toPrecision(undefined) === '1';
	    } catch (e) {
	        return true;
	    }
	}());
	var originalToPrecision = NumberPrototype.toPrecision;
	defineProperties(NumberPrototype, {
	    toPrecision: function toPrecision(precision) {
	        return typeof precision === 'undefined' ? originalToPrecision.call(this) : originalToPrecision.call(this, precision);
	    }
	}, hasToPrecisionUndefinedBug);
	
	//
	// String
	// ======
	//
	
	// ES5 15.5.4.14
	// http://es5.github.com/#x15.5.4.14
	
	// [bugfix, IE lt 9, firefox 4, Konqueror, Opera, obscure browsers]
	// Many browsers do not split properly with regular expressions or they
	// do not perform the split correctly under obscure conditions.
	// See http://blog.stevenlevithan.com/archives/cross-browser-split
	// I've tested in many browsers and this seems to cover the deviant ones:
	//    'ab'.split(/(?:ab)*/) should be ["", ""], not [""]
	//    '.'.split(/(.?)(.?)/) should be ["", ".", "", ""], not ["", ""]
	//    'tesst'.split(/(s)*/) should be ["t", undefined, "e", "s", "t"], not
	//       [undefined, "t", undefined, "e", ...]
	//    ''.split(/.?/) should be [], not [""]
	//    '.'.split(/()()/) should be ["."], not ["", "", "."]
	
	if (
	    'ab'.split(/(?:ab)*/).length !== 2 ||
	    '.'.split(/(.?)(.?)/).length !== 4 ||
	    'tesst'.split(/(s)*/)[1] === 't' ||
	    'test'.split(/(?:)/, -1).length !== 4 ||
	    ''.split(/.?/).length ||
	    '.'.split(/()()/).length > 1
	) {
	    (function () {
	        var compliantExecNpcg = typeof (/()??/).exec('')[1] === 'undefined'; // NPCG: nonparticipating capturing group
	        var maxSafe32BitInt = Math.pow(2, 32) - 1;
	
	        StringPrototype.split = function (separator, limit) {
	            var string = String(this);
	            if (typeof separator === 'undefined' && limit === 0) {
	                return [];
	            }
	
	            // If `separator` is not a regex, use native split
	            if (!isRegex(separator)) {
	                return strSplit(this, separator, limit);
	            }
	
	            var output = [];
	            var flags = (separator.ignoreCase ? 'i' : '') +
	                        (separator.multiline ? 'm' : '') +
	                        (separator.unicode ? 'u' : '') + // in ES6
	                        (separator.sticky ? 'y' : ''), // Firefox 3+ and ES6
	                lastLastIndex = 0,
	                // Make `global` and avoid `lastIndex` issues by working with a copy
	                separator2, match, lastIndex, lastLength;
	            var separatorCopy = new RegExp(separator.source, flags + 'g');
	            if (!compliantExecNpcg) {
	                // Doesn't need flags gy, but they don't hurt
	                separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);
	            }
	            /* Values for `limit`, per the spec:
	             * If undefined: 4294967295 // maxSafe32BitInt
	             * If 0, Infinity, or NaN: 0
	             * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
	             * If negative number: 4294967296 - Math.floor(Math.abs(limit))
	             * If other: Type-convert, then use the above rules
	             */
	            var splitLimit = typeof limit === 'undefined' ? maxSafe32BitInt : ES.ToUint32(limit);
	            match = separatorCopy.exec(string);
	            while (match) {
	                // `separatorCopy.lastIndex` is not reliable cross-browser
	                lastIndex = match.index + match[0].length;
	                if (lastIndex > lastLastIndex) {
	                    push(output, strSlice(string, lastLastIndex, match.index));
	                    // Fix browsers whose `exec` methods don't consistently return `undefined` for
	                    // nonparticipating capturing groups
	                    if (!compliantExecNpcg && match.length > 1) {
	                        /* eslint-disable no-loop-func */
	                        match[0].replace(separator2, function () {
	                            for (var i = 1; i < arguments.length - 2; i++) {
	                                if (typeof arguments[i] === 'undefined') {
	                                    match[i] = void 0;
	                                }
	                            }
	                        });
	                        /* eslint-enable no-loop-func */
	                    }
	                    if (match.length > 1 && match.index < string.length) {
	                        array_push.apply(output, arraySlice(match, 1));
	                    }
	                    lastLength = match[0].length;
	                    lastLastIndex = lastIndex;
	                    if (output.length >= splitLimit) {
	                        break;
	                    }
	                }
	                if (separatorCopy.lastIndex === match.index) {
	                    separatorCopy.lastIndex++; // Avoid an infinite loop
	                }
	                match = separatorCopy.exec(string);
	            }
	            if (lastLastIndex === string.length) {
	                if (lastLength || !separatorCopy.test('')) {
	                    push(output, '');
	                }
	            } else {
	                push(output, strSlice(string, lastLastIndex));
	            }
	            return output.length > splitLimit ? strSlice(output, 0, splitLimit) : output;
	        };
	    }());
	
	// [bugfix, chrome]
	// If separator is undefined, then the result array contains just one String,
	// which is the this value (converted to a String). If limit is not undefined,
	// then the output array is truncated so that it contains no more than limit
	// elements.
	// "0".split(undefined, 0) -> []
	} else if ('0'.split(void 0, 0).length) {
	    StringPrototype.split = function split(separator, limit) {
	        if (typeof separator === 'undefined' && limit === 0) { return []; }
	        return strSplit(this, separator, limit);
	    };
	}
	
	var str_replace = StringPrototype.replace;
	var replaceReportsGroupsCorrectly = (function () {
	    var groups = [];
	    'x'.replace(/x(.)?/g, function (match, group) {
	        push(groups, group);
	    });
	    return groups.length === 1 && typeof groups[0] === 'undefined';
	}());
	
	if (!replaceReportsGroupsCorrectly) {
	    StringPrototype.replace = function replace(searchValue, replaceValue) {
	        var isFn = isCallable(replaceValue);
	        var hasCapturingGroups = isRegex(searchValue) && (/\)[*?]/).test(searchValue.source);
	        if (!isFn || !hasCapturingGroups) {
	            return str_replace.call(this, searchValue, replaceValue);
	        } else {
	            var wrappedReplaceValue = function (match) {
	                var length = arguments.length;
	                var originalLastIndex = searchValue.lastIndex;
	                searchValue.lastIndex = 0;
	                var args = searchValue.exec(match) || [];
	                searchValue.lastIndex = originalLastIndex;
	                push(args, arguments[length - 2], arguments[length - 1]);
	                return replaceValue.apply(this, args);
	            };
	            return str_replace.call(this, searchValue, wrappedReplaceValue);
	        }
	    };
	}
	
	// ECMA-262, 3rd B.2.3
	// Not an ECMAScript standard, although ECMAScript 3rd Edition has a
	// non-normative section suggesting uniform semantics and it should be
	// normalized across all browsers
	// [bugfix, IE lt 9] IE < 9 substr() with negative value not working in IE
	var string_substr = StringPrototype.substr;
	var hasNegativeSubstrBug = ''.substr && '0b'.substr(-1) !== 'b';
	defineProperties(StringPrototype, {
	    substr: function substr(start, length) {
	        var normalizedStart = start;
	        if (start < 0) {
	            normalizedStart = max(this.length + start, 0);
	        }
	        return string_substr.call(this, normalizedStart, length);
	    }
	}, hasNegativeSubstrBug);
	
	// ES5 15.5.4.20
	// whitespace from: http://es5.github.io/#x15.5.4.20
	var ws = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
	    '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028' +
	    '\u2029\uFEFF';
	var zeroWidth = '\u200b';
	var wsRegexChars = '[' + ws + ']';
	var trimBeginRegexp = new RegExp('^' + wsRegexChars + wsRegexChars + '*');
	var trimEndRegexp = new RegExp(wsRegexChars + wsRegexChars + '*$');
	var hasTrimWhitespaceBug = StringPrototype.trim && (ws.trim() || !zeroWidth.trim());
	defineProperties(StringPrototype, {
	    // http://blog.stevenlevithan.com/archives/faster-trim-javascript
	    // http://perfectionkills.com/whitespace-deviations/
	    trim: function trim() {
	        if (typeof this === 'undefined' || this === null) {
	            throw new TypeError("can't convert " + this + ' to object');
	        }
	        return $String(this).replace(trimBeginRegexp, '').replace(trimEndRegexp, '');
	    }
	}, hasTrimWhitespaceBug);
	
	var hasLastIndexBug = StringPrototype.lastIndexOf && 'abc'.lastIndexOf('', 2) !== -1;
	defineProperties(StringPrototype, {
	    lastIndexOf: function lastIndexOf(searchString) {
	        if (typeof this === 'undefined' || this === null) {
	            throw new TypeError("can't convert " + this + ' to object');
	        }
	        var S = $String(this);
	        var searchStr = $String(searchString);
	        var numPos = arguments.length > 1 ? $Number(arguments[1]) : NaN;
	        var pos = isActualNaN(numPos) ? Infinity : ES.ToInteger(numPos);
	        var start = min(max(pos, 0), S.length);
	        var searchLen = searchStr.length;
	        var k = start + searchLen;
	        while (k > 0) {
	            k = max(0, k - searchLen);
	            var index = strIndexOf(strSlice(S, k, start + searchLen), searchStr);
	            if (index !== -1) {
	                return k + index;
	            }
	        }
	        return -1;
	    }
	}, hasLastIndexBug);
	
	var originalLastIndexOf = StringPrototype.lastIndexOf;
	defineProperties(StringPrototype, {
	    lastIndexOf: function lastIndexOf(searchString) {
	        return originalLastIndexOf.apply(this, arguments);
	    }
	}, StringPrototype.lastIndexOf.length !== 1);
	
	// ES-5 15.1.2.2
	/* eslint-disable radix */
	if (parseInt(ws + '08') !== 8 || parseInt(ws + '0x16') !== 22) {
	/* eslint-enable radix */
	    /* global parseInt: true */
	    parseInt = (function (origParseInt) {
	        var hexRegex = /^[\-+]?0[xX]/;
	        return function parseInt(str, radix) {
	            var string = $String(str).trim();
	            var defaultedRadix = $Number(radix) || (hexRegex.test(string) ? 16 : 10);
	            return origParseInt(string, defaultedRadix);
	        };
	    }(parseInt));
	}
	
	if (String(new RangeError('test')) !== 'RangeError: test') {
	    var errorToStringShim = function toString() {
	        if (typeof this === 'undefined' || this === null) {
	            throw new TypeError("can't convert " + this + ' to object');
	        }
	        var name = this.name;
	        if (typeof name === 'undefined') {
	            name = 'Error';
	        } else if (typeof name !== 'string') {
	            name = $String(name);
	        }
	        var msg = this.message;
	        if (typeof msg === 'undefined') {
	            msg = '';
	        } else if (typeof msg !== 'string') {
	            msg = $String(msg);
	        }
	        if (!name) {
	            return msg;
	        }
	        if (!msg) {
	            return name;
	        }
	        return name + ': ' + msg;
	    };
	    // can't use defineProperties here because of toString enumeration issue in IE <= 8
	    Error.prototype.toString = errorToStringShim;
	}
	
	if (supportsDescriptors) {
	    var ensureNonEnumerable = function (obj, prop) {
	        if (isEnum(obj, prop)) {
	            var desc = Object.getOwnPropertyDescriptor(obj, prop);
	            desc.enumerable = false;
	            Object.defineProperty(obj, prop, desc);
	        }
	    };
	    ensureNonEnumerable(Error.prototype, 'message');
	    if (Error.prototype.message !== '') {
	      Error.prototype.message = '';
	    }
	    ensureNonEnumerable(Error.prototype, 'name');
	}
	
	if (String(/a/mig) !== '/a/gim') {
	    var regexToString = function toString() {
	        var str = '/' + this.source + '/';
	        if (this.global) {
	            str += 'g';
	        }
	        if (this.ignoreCase) {
	            str += 'i';
	        }
	        if (this.multiline) {
	            str += 'm';
	        }
	        return str;
	    };
	    // can't use defineProperties here because of toString enumeration issue in IE <= 8
	    RegExp.prototype.toString = regexToString;
	}
	
	}));


/***/ },
/* 6 */
/***/ function(module, exports) {

	module.exports = "/*\n * Support for source maps in V8 stack traces\n * https://github.com/evanw/node-source-map-support\n */\n(this.define||function(K,N){this.sourceMapSupport=N()})(\"browser-source-map-support\",function(K){(function n(w,t,e){function r(g,b){if(!t[g]){if(!w[g]){var f=\"function\"==typeof require&&require;if(!b&&f)return f(g,!0);if(l)return l(g,!0);throw Error(\"Cannot find module '\"+g+\"'\");}f=t[g]={exports:{}};w[g][0].call(f.exports,function(b){var a=w[g][1][b];return r(a?a:b)},f,f.exports,n,w,t,e)}return t[g].exports}for(var l=\"function\"==typeof require&&require,m=0;m<e.length;m++)r(e[m]);return r})({1:[function(n,\nw,t){K=n(\"./source-map-support\")},{\"./source-map-support\":18}],2:[function(n,w,t){(function(e,r){w.exports=function(l,m){function g(c,d){var a;if(c&&\".\"===c.charAt(0)&&d){a=d.split(\"/\");a=a.slice(0,a.length-1);var b=a=a.concat(c.split(\"/\")),f,k;for(f=0;b[f];f+=1)if(k=b[f],\".\"===k)b.splice(f,1),--f;else if(\"..\"===k)if(1!==f||\"..\"!==b[2]&&\"..\"!==b[0])0<f&&(b.splice(f-1,2),f-=2);else break;c=a.join(\"/\")}return c}function b(c){return function(a){return g(a,c)}}function f(c){function a(b){d[c]=b}a.fromText=\nfunction(c,a){throw Error(\"amdefine does not implement load.fromText\");};return a}function k(c,a,b){var f,k,g;if(c)k=d[c]={},g={id:c,uri:r,exports:k},f=A(m,k,g,c);else{if(y)throw Error(\"amdefine with no module ID cannot be called more than once per file.\");y=!0;k=l.exports;g=l;f=A(m,k,g,l.id)}a&&(a=a.map(function(c){return f(c)}));a=\"function\"===typeof b?b.apply(g.exports,a):b;void 0!==a&&(g.exports=a,c&&(d[c]=g.exports))}function a(a,d,b){Array.isArray(a)?(b=d,d=a,a=void 0):\"string\"!==typeof a&&\n(b=a,a=d=void 0);d&&!Array.isArray(d)&&(b=d,d=void 0);d||(d=[\"require\",\"exports\",\"module\"]);a?c[a]=[a,d,b]:k(a,d,b)}var c={},d={},y=!1,x=n(\"path\"),A,B;A=function(c,a,d,b){function f(k,g){if(\"string\"===typeof k)return B(c,a,d,k,b);k=k.map(function(f){return B(c,a,d,f,b)});g&&e.nextTick(function(){g.apply(null,k)})}f.toUrl=function(c){return 0===c.indexOf(\".\")?g(c,x.dirname(d.filename)):c};return f};m=m||function(){return l.require.apply(l,arguments)};B=function(a,e,y,m,x){var l=m.indexOf(\"!\"),r=m;\nif(-1===l){m=g(m,x);if(\"require\"===m)return A(a,e,y,x);if(\"exports\"===m)return e;if(\"module\"===m)return y;if(d.hasOwnProperty(m))return d[m];if(c[m])return k.apply(null,c[m]),d[m];if(a)return a(r);throw Error(\"No module with ID: \"+m);}r=m.substring(0,l);m=m.substring(l+1,m.length);l=B(a,e,y,r,x);m=l.normalize?l.normalize(m,b(x)):g(m,x);d[m]||l.load(m,A(a,e,y,x),f(m),{});return d[m]};a.require=function(a){if(d[a])return d[a];if(c[a])return k.apply(null,c[a]),d[a]};a.amd={};return a}}).call(this,n(\"node_modules/process/browser.js\"),\n\"/node_modules/amdefine/amdefine.js\")},{\"node_modules/process/browser.js\":8,path:7}],3:[function(n,w,t){(function(e){function r(e){e=e.charCodeAt(0);if(43===e||45===e)return 62;if(47===e||95===e)return 63;if(48>e)return-1;if(58>e)return e-48+52;if(91>e)return e-65;if(123>e)return e-97+26}var l=\"undefined\"!==typeof Uint8Array?Uint8Array:Array;e.toByteArray=function(e){function g(a){c[d++]=a}var b,f,k,a,c;if(0<e.length%4)throw Error(\"Invalid string. Length must be a multiple of 4\");b=e.length;a=\"=\"===\ne.charAt(b-2)?2:\"=\"===e.charAt(b-1)?1:0;c=new l(3*e.length/4-a);f=0<a?e.length-4:e.length;var d=0;for(b=0;b<f;b+=4)k=r(e.charAt(b))<<18|r(e.charAt(b+1))<<12|r(e.charAt(b+2))<<6|r(e.charAt(b+3)),g((k&16711680)>>16),g((k&65280)>>8),g(k&255);2===a?(k=r(e.charAt(b))<<2|r(e.charAt(b+1))>>4,g(k&255)):1===a&&(k=r(e.charAt(b))<<10|r(e.charAt(b+1))<<4|r(e.charAt(b+2))>>2,g(k>>8&255),g(k&255));return c};e.fromByteArray=function(e){var g,b=e.length%3,f=\"\",k,a;g=0;for(a=e.length-b;g<a;g+=3)k=(e[g]<<16)+(e[g+\n1]<<8)+e[g+2],k=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".charAt(k>>18&63)+\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".charAt(k>>12&63)+\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".charAt(k>>6&63)+\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".charAt(k&63),f+=k;switch(b){case 1:k=e[e.length-1];f+=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".charAt(k>>2);f+=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".charAt(k<<\n4&63);f+=\"==\";break;case 2:k=(e[e.length-2]<<8)+e[e.length-1],f+=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".charAt(k>>10),f+=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".charAt(k>>4&63),f+=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".charAt(k<<2&63),f+=\"=\"}return f}})(\"undefined\"===typeof t?this.base64js={}:t)},{}],4:[function(n,w,t){},{}],5:[function(n,w,t){function e(h,q,c){if(!(this instanceof e))return new e(h,q,c);var a=typeof h;\nif(\"base64\"===q&&\"string\"===a)for(h=h.trim?h.trim():h.replace(/^\\s+|\\s+$/g,\"\");0!==h.length%4;)h+=\"=\";var d;if(\"number\"===a)d=F(h);else if(\"string\"===a)d=e.byteLength(h,q);else if(\"object\"===a)d=F(h.length);else throw Error(\"First argument needs to be a number, array or string.\");var b;e._useTypedArrays?b=e._augment(new Uint8Array(d)):(b=this,b.length=d,b._isBuffer=!0);if(e._useTypedArrays&&\"number\"===typeof h.byteLength)b._set(h);else{var f=h;if(E(f)||e.isBuffer(f)||f&&\"object\"===typeof f&&\"number\"===\ntypeof f.length)for(q=0;q<d;q++)e.isBuffer(h)?b[q]=h.readUInt8(q):b[q]=h[q];else if(\"string\"===a)b.write(h,0,q);else if(\"number\"===a&&!e._useTypedArrays&&!c)for(q=0;q<d;q++)b[q]=0}return b}function r(h,q,c){var a=\"\";for(c=Math.min(h.length,c);q<c;q++)a+=String.fromCharCode(h[q]);return a}function l(h,q,c,a){a||(p(\"boolean\"===typeof c,\"missing or invalid endian\"),p(void 0!==q&&null!==q,\"missing offset\"),p(q+1<h.length,\"Trying to read beyond buffer length\"));a=h.length;if(!(q>=a))return c?(c=h[q],q+\n1<a&&(c|=h[q+1]<<8)):(c=h[q]<<8,q+1<a&&(c|=h[q+1])),c}function m(h,q,c,a){a||(p(\"boolean\"===typeof c,\"missing or invalid endian\"),p(void 0!==q&&null!==q,\"missing offset\"),p(q+3<h.length,\"Trying to read beyond buffer length\"));a=h.length;if(!(q>=a)){var d;c?(q+2<a&&(d=h[q+2]<<16),q+1<a&&(d|=h[q+1]<<8),d|=h[q],q+3<a&&(d+=h[q+3]<<24>>>0)):(q+1<a&&(d=h[q+1]<<16),q+2<a&&(d|=h[q+2]<<8),q+3<a&&(d|=h[q+3]),d+=h[q]<<24>>>0);return d}}function g(h,q,a,c){c||(p(\"boolean\"===typeof a,\"missing or invalid endian\"),\np(void 0!==q&&null!==q,\"missing offset\"),p(q+1<h.length,\"Trying to read beyond buffer length\"));if(!(q>=h.length))return h=l(h,q,a,!0),h&32768?-1*(65535-h+1):h}function b(h,q,a,c){c||(p(\"boolean\"===typeof a,\"missing or invalid endian\"),p(void 0!==q&&null!==q,\"missing offset\"),p(q+3<h.length,\"Trying to read beyond buffer length\"));if(!(q>=h.length))return h=m(h,q,a,!0),h&2147483648?-1*(4294967295-h+1):h}function f(h,q,a,c){c||(p(\"boolean\"===typeof a,\"missing or invalid endian\"),p(q+3<h.length,\"Trying to read beyond buffer length\"));\nreturn I.read(h,q,a,23,4)}function k(h,q,a,c){c||(p(\"boolean\"===typeof a,\"missing or invalid endian\"),p(q+7<h.length,\"Trying to read beyond buffer length\"));return I.read(h,q,a,52,8)}function a(h,a,c,d,b){b||(p(void 0!==a&&null!==a,\"missing value\"),p(\"boolean\"===typeof d,\"missing or invalid endian\"),p(void 0!==c&&null!==c,\"missing offset\"),p(c+1<h.length,\"trying to write beyond buffer length\"),H(a,65535));var f=h.length;if(!(c>=f))for(b=0,f=Math.min(f-c,2);b<f;b++)h[c+b]=(a&255<<8*(d?b:1-b))>>>8*\n(d?b:1-b)}function c(h,a,c,d,b){b||(p(void 0!==a&&null!==a,\"missing value\"),p(\"boolean\"===typeof d,\"missing or invalid endian\"),p(void 0!==c&&null!==c,\"missing offset\"),p(c+3<h.length,\"trying to write beyond buffer length\"),H(a,4294967295));var f=h.length;if(!(c>=f))for(b=0,f=Math.min(f-c,4);b<f;b++)h[c+b]=a>>>8*(d?b:3-b)&255}function d(h,c,d,b,f){f||(p(void 0!==c&&null!==c,\"missing value\"),p(\"boolean\"===typeof b,\"missing or invalid endian\"),p(void 0!==d&&null!==d,\"missing offset\"),p(d+1<h.length,\n\"Trying to write beyond buffer length\"),L(c,32767,-32768));d>=h.length||(0<=c?a(h,c,d,b,f):a(h,65535+c+1,d,b,f))}function y(h,a,d,b,f){f||(p(void 0!==a&&null!==a,\"missing value\"),p(\"boolean\"===typeof b,\"missing or invalid endian\"),p(void 0!==d&&null!==d,\"missing offset\"),p(d+3<h.length,\"Trying to write beyond buffer length\"),L(a,2147483647,-2147483648));d>=h.length||(0<=a?c(h,a,d,b,f):c(h,4294967295+a+1,d,b,f))}function x(h,a,c,d,b){b||(p(void 0!==a&&null!==a,\"missing value\"),p(\"boolean\"===typeof d,\n\"missing or invalid endian\"),p(void 0!==c&&null!==c,\"missing offset\"),p(c+3<h.length,\"Trying to write beyond buffer length\"),M(a,3.4028234663852886E38,-3.4028234663852886E38));c>=h.length||I.write(h,a,c,d,23,4)}function A(h,c,a,d,b){b||(p(void 0!==c&&null!==c,\"missing value\"),p(\"boolean\"===typeof d,\"missing or invalid endian\"),p(void 0!==a&&null!==a,\"missing offset\"),p(a+7<h.length,\"Trying to write beyond buffer length\"),M(c,1.7976931348623157E308,-1.7976931348623157E308));a>=h.length||I.write(h,\nc,a,d,52,8)}function B(h,a,c){if(\"number\"!==typeof h)return c;h=~~h;if(h>=a)return a;if(0<=h)return h;h+=a;return 0<=h?h:0}function F(h){h=~~Math.ceil(+h);return 0>h?0:h}function E(h){return(Array.isArray||function(h){return\"[object Array]\"===Object.prototype.toString.call(h)})(h)}function G(h){return 16>h?\"0\"+h.toString(16):h.toString(16)}function u(h){for(var a=[],c=0;c<h.length;c++){var d=h.charCodeAt(c);if(127>=d)a.push(h.charCodeAt(c));else{var b=c;55296<=d&&57343>=d&&c++;d=encodeURIComponent(h.slice(b,\nc+1)).substr(1).split(\"%\");for(b=0;b<d.length;b++)a.push(parseInt(d[b],16))}}return a}function C(h){for(var c=[],a=0;a<h.length;a++)c.push(h.charCodeAt(a)&255);return c}function z(h,c,a,d){for(var b=0;b<d&&!(b+a>=c.length||b>=h.length);b++)c[b+a]=h[b];return b}function D(h){try{return decodeURIComponent(h)}catch(c){return String.fromCharCode(65533)}}function H(h,c){p(\"number\"===typeof h,\"cannot write a non-number as a number\");p(0<=h,\"specified a negative value for writing an unsigned value\");p(h<=\nc,\"value is larger than maximum value for type\");p(Math.floor(h)===h,\"value has a fractional component\")}function L(h,c,a){p(\"number\"===typeof h,\"cannot write a non-number as a number\");p(h<=c,\"value larger than maximum allowed value\");p(h>=a,\"value smaller than minimum allowed value\");p(Math.floor(h)===h,\"value has a fractional component\")}function M(h,c,a){p(\"number\"===typeof h,\"cannot write a non-number as a number\");p(h<=c,\"value larger than maximum allowed value\");p(h>=a,\"value smaller than minimum allowed value\")}\nfunction p(h,c){if(!h)throw Error(c||\"Failed assertion\");}var J=n(\"base64-js\"),I=n(\"ieee754\");t.Buffer=e;t.SlowBuffer=e;t.INSPECT_MAX_BYTES=50;e.poolSize=8192;e._useTypedArrays=function(){try{var h=new ArrayBuffer(0),c=new Uint8Array(h);c.foo=function(){return 42};return 42===c.foo()&&\"function\"===typeof c.subarray}catch(a){return!1}}();e.isEncoding=function(h){switch(String(h).toLowerCase()){case \"hex\":case \"utf8\":case \"utf-8\":case \"ascii\":case \"binary\":case \"base64\":case \"raw\":case \"ucs2\":case \"ucs-2\":case \"utf16le\":case \"utf-16le\":return!0;\ndefault:return!1}};e.isBuffer=function(h){return!(null===h||void 0===h||!h._isBuffer)};e.byteLength=function(h,c){var a;h+=\"\";switch(c||\"utf8\"){case \"hex\":a=h.length/2;break;case \"utf8\":case \"utf-8\":a=u(h).length;break;case \"ascii\":case \"binary\":case \"raw\":a=h.length;break;case \"base64\":a=J.toByteArray(h).length;break;case \"ucs2\":case \"ucs-2\":case \"utf16le\":case \"utf-16le\":a=2*h.length;break;default:throw Error(\"Unknown encoding\");}return a};e.concat=function(h,c){p(E(h),\"Usage: Buffer.concat(list, [totalLength])\\nlist should be an Array.\");\nif(0===h.length)return new e(0);if(1===h.length)return h[0];var a;if(\"number\"!==typeof c)for(a=c=0;a<h.length;a++)c+=h[a].length;var d=new e(c),b=0;for(a=0;a<h.length;a++){var f=h[a];f.copy(d,b);b+=f.length}return d};e.prototype.write=function(h,c,a,d){if(isFinite(c))isFinite(a)||(d=a,a=void 0);else{var b=d;d=c;c=a;a=b}c=Number(c)||0;b=this.length-c;a?(a=Number(a),a>b&&(a=b)):a=b;d=String(d||\"utf8\").toLowerCase();switch(d){case \"hex\":c=Number(c)||0;d=this.length-c;a?(a=Number(a),a>d&&(a=d)):a=d;d=\nh.length;p(0===d%2,\"Invalid hex string\");a>d/2&&(a=d/2);for(d=0;d<a;d++)b=parseInt(h.substr(2*d,2),16),p(!isNaN(b),\"Invalid hex string\"),this[c+d]=b;e._charsWritten=2*d;h=d;break;case \"utf8\":case \"utf-8\":h=e._charsWritten=z(u(h),this,c,a);break;case \"ascii\":h=e._charsWritten=z(C(h),this,c,a);break;case \"binary\":h=e._charsWritten=z(C(h),this,c,a);break;case \"base64\":h=e._charsWritten=z(J.toByteArray(h),this,c,a);break;case \"ucs2\":case \"ucs-2\":case \"utf16le\":case \"utf-16le\":for(var f,b=[],k=0;k<h.length;k++)f=\nh.charCodeAt(k),d=f>>8,f%=256,b.push(f),b.push(d);h=e._charsWritten=z(b,this,c,a);break;default:throw Error(\"Unknown encoding\");}return h};e.prototype.toString=function(a,c,d){a=String(a||\"utf8\").toLowerCase();c=Number(c)||0;d=void 0!==d?Number(d):d=this.length;if(d===c)return\"\";switch(a){case \"hex\":a=this.length;if(!c||0>c)c=0;if(!d||0>d||d>a)d=a;for(a=\"\";c<d;c++)a+=G(this[c]);d=a;break;case \"utf8\":case \"utf-8\":var b=a=\"\";for(d=Math.min(this.length,d);c<d;c++)127>=this[c]?(a+=D(b)+String.fromCharCode(this[c]),\nb=\"\"):b+=\"%\"+this[c].toString(16);d=a+D(b);break;case \"ascii\":d=r(this,c,d);break;case \"binary\":d=r(this,c,d);break;case \"base64\":d=0===c&&d===this.length?J.fromByteArray(this):J.fromByteArray(this.slice(c,d));break;case \"ucs2\":case \"ucs-2\":case \"utf16le\":case \"utf-16le\":d=this.slice(c,d);c=\"\";for(a=0;a<d.length;a+=2)c+=String.fromCharCode(d[a]+256*d[a+1]);d=c;break;default:throw Error(\"Unknown encoding\");}return d};e.prototype.toJSON=function(){return{type:\"Buffer\",data:Array.prototype.slice.call(this._arr||\nthis,0)}};e.prototype.copy=function(a,c,d,b){d||(d=0);b||0===b||(b=this.length);c||(c=0);if(b!==d&&0!==a.length&&0!==this.length)if(p(b>=d,\"sourceEnd < sourceStart\"),p(0<=c&&c<a.length,\"targetStart out of bounds\"),p(0<=d&&d<this.length,\"sourceStart out of bounds\"),p(0<=b&&b<=this.length,\"sourceEnd out of bounds\"),b>this.length&&(b=this.length),a.length-c<b-d&&(b=a.length-c+d),b-=d,100>b||!e._useTypedArrays)for(var f=0;f<b;f++)a[f+c]=this[f+d];else a._set(this.subarray(d,d+b),c)};e.prototype.slice=\nfunction(a,c){var d=this.length;a=B(a,d,0);c=B(c,d,d);if(e._useTypedArrays)return e._augment(this.subarray(a,c));for(var d=c-a,b=new e(d,void 0,!0),f=0;f<d;f++)b[f]=this[f+a];return b};e.prototype.get=function(a){console.log(\".get() is deprecated. Access using array indexes instead.\");return this.readUInt8(a)};e.prototype.set=function(a,c){console.log(\".set() is deprecated. Access using array indexes instead.\");return this.writeUInt8(a,c)};e.prototype.readUInt8=function(a,c){c||(p(void 0!==a&&null!==\na,\"missing offset\"),p(a<this.length,\"Trying to read beyond buffer length\"));if(!(a>=this.length))return this[a]};e.prototype.readUInt16LE=function(a,c){return l(this,a,!0,c)};e.prototype.readUInt16BE=function(a,c){return l(this,a,!1,c)};e.prototype.readUInt32LE=function(a,c){return m(this,a,!0,c)};e.prototype.readUInt32BE=function(a,c){return m(this,a,!1,c)};e.prototype.readInt8=function(a,c){c||(p(void 0!==a&&null!==a,\"missing offset\"),p(a<this.length,\"Trying to read beyond buffer length\"));if(!(a>=\nthis.length))return this[a]&128?-1*(255-this[a]+1):this[a]};e.prototype.readInt16LE=function(a,c){return g(this,a,!0,c)};e.prototype.readInt16BE=function(a,c){return g(this,a,!1,c)};e.prototype.readInt32LE=function(a,c){return b(this,a,!0,c)};e.prototype.readInt32BE=function(a,c){return b(this,a,!1,c)};e.prototype.readFloatLE=function(a,c){return f(this,a,!0,c)};e.prototype.readFloatBE=function(a,c){return f(this,a,!1,c)};e.prototype.readDoubleLE=function(a,c){return k(this,a,!0,c)};e.prototype.readDoubleBE=\nfunction(a,c){return k(this,a,!1,c)};e.prototype.writeUInt8=function(a,c,d){d||(p(void 0!==a&&null!==a,\"missing value\"),p(void 0!==c&&null!==c,\"missing offset\"),p(c<this.length,\"trying to write beyond buffer length\"),H(a,255));c>=this.length||(this[c]=a)};e.prototype.writeUInt16LE=function(c,d,b){a(this,c,d,!0,b)};e.prototype.writeUInt16BE=function(c,d,b){a(this,c,d,!1,b)};e.prototype.writeUInt32LE=function(a,d,b){c(this,a,d,!0,b)};e.prototype.writeUInt32BE=function(a,d,b){c(this,a,d,!1,b)};e.prototype.writeInt8=\nfunction(a,c,d){d||(p(void 0!==a&&null!==a,\"missing value\"),p(void 0!==c&&null!==c,\"missing offset\"),p(c<this.length,\"Trying to write beyond buffer length\"),L(a,127,-128));c>=this.length||(0<=a?this.writeUInt8(a,c,d):this.writeUInt8(255+a+1,c,d))};e.prototype.writeInt16LE=function(a,c,b){d(this,a,c,!0,b)};e.prototype.writeInt16BE=function(a,c,b){d(this,a,c,!1,b)};e.prototype.writeInt32LE=function(a,c,d){y(this,a,c,!0,d)};e.prototype.writeInt32BE=function(a,c,d){y(this,a,c,!1,d)};e.prototype.writeFloatLE=\nfunction(a,c,d){x(this,a,c,!0,d)};e.prototype.writeFloatBE=function(a,c,d){x(this,a,c,!1,d)};e.prototype.writeDoubleLE=function(a,c,d){A(this,a,c,!0,d)};e.prototype.writeDoubleBE=function(a,c,d){A(this,a,c,!1,d)};e.prototype.fill=function(a,c,d){a||(a=0);c||(c=0);d||(d=this.length);\"string\"===typeof a&&(a=a.charCodeAt(0));p(\"number\"===typeof a&&!isNaN(a),\"value is not a number\");p(d>=c,\"end < start\");if(d!==c&&0!==this.length)for(p(0<=c&&c<this.length,\"start out of bounds\"),p(0<=d&&d<=this.length,\n\"end out of bounds\");c<d;c++)this[c]=a};e.prototype.inspect=function(){for(var a=[],c=this.length,d=0;d<c;d++)if(a[d]=G(this[d]),d===t.INSPECT_MAX_BYTES){a[d+1]=\"...\";break}return\"<Buffer \"+a.join(\" \")+\">\"};e.prototype.toArrayBuffer=function(){if(\"undefined\"!==typeof Uint8Array){if(e._useTypedArrays)return(new e(this)).buffer;for(var a=new Uint8Array(this.length),c=0,d=a.length;c<d;c+=1)a[c]=this[c];return a.buffer}throw Error(\"Buffer.toArrayBuffer not supported in this browser\");};var v=e.prototype;\ne._augment=function(a){a._isBuffer=!0;a._get=a.get;a._set=a.set;a.get=v.get;a.set=v.set;a.write=v.write;a.toString=v.toString;a.toLocaleString=v.toString;a.toJSON=v.toJSON;a.copy=v.copy;a.slice=v.slice;a.readUInt8=v.readUInt8;a.readUInt16LE=v.readUInt16LE;a.readUInt16BE=v.readUInt16BE;a.readUInt32LE=v.readUInt32LE;a.readUInt32BE=v.readUInt32BE;a.readInt8=v.readInt8;a.readInt16LE=v.readInt16LE;a.readInt16BE=v.readInt16BE;a.readInt32LE=v.readInt32LE;a.readInt32BE=v.readInt32BE;a.readFloatLE=v.readFloatLE;\na.readFloatBE=v.readFloatBE;a.readDoubleLE=v.readDoubleLE;a.readDoubleBE=v.readDoubleBE;a.writeUInt8=v.writeUInt8;a.writeUInt16LE=v.writeUInt16LE;a.writeUInt16BE=v.writeUInt16BE;a.writeUInt32LE=v.writeUInt32LE;a.writeUInt32BE=v.writeUInt32BE;a.writeInt8=v.writeInt8;a.writeInt16LE=v.writeInt16LE;a.writeInt16BE=v.writeInt16BE;a.writeInt32LE=v.writeInt32LE;a.writeInt32BE=v.writeInt32BE;a.writeFloatLE=v.writeFloatLE;a.writeFloatBE=v.writeFloatBE;a.writeDoubleLE=v.writeDoubleLE;a.writeDoubleBE=v.writeDoubleBE;\na.fill=v.fill;a.inspect=v.inspect;a.toArrayBuffer=v.toArrayBuffer;return a}},{\"base64-js\":3,ieee754:6}],6:[function(n,w,t){t.read=function(e,r,l,m,g){var b;b=8*g-m-1;var f=(1<<b)-1,k=f>>1,a=-7;g=l?g-1:0;var c=l?-1:1,d=e[r+g];g+=c;l=d&(1<<-a)-1;d>>=-a;for(a+=b;0<a;l=256*l+e[r+g],g+=c,a-=8);b=l&(1<<-a)-1;l>>=-a;for(a+=m;0<a;b=256*b+e[r+g],g+=c,a-=8);if(0===l)l=1-k;else{if(l===f)return b?NaN:Infinity*(d?-1:1);b+=Math.pow(2,m);l-=k}return(d?-1:1)*b*Math.pow(2,l-m)};t.write=function(e,r,l,m,g,b){var f,\nk=8*b-g-1,a=(1<<k)-1,c=a>>1,d=23===g?Math.pow(2,-24)-Math.pow(2,-77):0;b=m?0:b-1;var y=m?1:-1,x=0>r||0===r&&0>1/r?1:0;r=Math.abs(r);isNaN(r)||Infinity===r?(r=isNaN(r)?1:0,m=a):(m=Math.floor(Math.log(r)/Math.LN2),1>r*(f=Math.pow(2,-m))&&(m--,f*=2),r=1<=m+c?r+d/f:r+d*Math.pow(2,1-c),2<=r*f&&(m++,f/=2),m+c>=a?(r=0,m=a):1<=m+c?(r=(r*f-1)*Math.pow(2,g),m+=c):(r=r*Math.pow(2,c-1)*Math.pow(2,g),m=0));for(;8<=g;e[l+b]=r&255,b+=y,r/=256,g-=8);m=m<<g|r;for(k+=g;0<k;e[l+b]=m&255,b+=y,m/=256,k-=8);e[l+b-y]|=\n128*x}},{}],7:[function(n,w,t){(function(e){function r(b,f){for(var e=0,a=b.length-1;0<=a;a--){var c=b[a];\".\"===c?b.splice(a,1):\"..\"===c?(b.splice(a,1),e++):e&&(b.splice(a,1),e--)}if(f)for(;e--;e)b.unshift(\"..\");return b}function l(b,f){if(b.filter)return b.filter(f);for(var e=[],a=0;a<b.length;a++)f(b[a],a,b)&&e.push(b[a]);return e}var m=/^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;t.resolve=function(){for(var b=\"\",f=!1,k=arguments.length-1;-1<=k&&!f;k--){var a=0<=k?arguments[k]:\ne.cwd();if(\"string\"!==typeof a)throw new TypeError(\"Arguments to path.resolve must be strings\");a&&(b=a+\"/\"+b,f=\"/\"===a.charAt(0))}b=r(l(b.split(\"/\"),function(a){return!!a}),!f).join(\"/\");return(f?\"/\":\"\")+b||\".\"};t.normalize=function(b){var f=t.isAbsolute(b),e=\"/\"===g(b,-1);(b=r(l(b.split(\"/\"),function(a){return!!a}),!f).join(\"/\"))||f||(b=\".\");b&&e&&(b+=\"/\");return(f?\"/\":\"\")+b};t.isAbsolute=function(b){return\"/\"===b.charAt(0)};t.join=function(){var b=Array.prototype.slice.call(arguments,0);return t.normalize(l(b,\nfunction(b,e){if(\"string\"!==typeof b)throw new TypeError(\"Arguments to path.join must be strings\");return b}).join(\"/\"))};t.relative=function(b,f){function e(a){for(var c=0;c<a.length&&\"\"===a[c];c++);for(var d=a.length-1;0<=d&&\"\"===a[d];d--);return c>d?[]:a.slice(c,d-c+1)}b=t.resolve(b).substr(1);f=t.resolve(f).substr(1);for(var a=e(b.split(\"/\")),c=e(f.split(\"/\")),d=Math.min(a.length,c.length),g=d,x=0;x<d;x++)if(a[x]!==c[x]){g=x;break}d=[];for(x=g;x<a.length;x++)d.push(\"..\");d=d.concat(c.slice(g));\nreturn d.join(\"/\")};t.sep=\"/\";t.delimiter=\":\";t.dirname=function(b){var f=m.exec(b).slice(1);b=f[0];f=f[1];if(!b&&!f)return\".\";f&&(f=f.substr(0,f.length-1));return b+f};t.basename=function(b,f){var e=m.exec(b).slice(1)[2];f&&e.substr(-1*f.length)===f&&(e=e.substr(0,e.length-f.length));return e};t.extname=function(b){return m.exec(b).slice(1)[3]};var g=\"b\"===\"ab\".substr(-1)?function(b,f,e){return b.substr(f,e)}:function(b,f,e){0>f&&(f=b.length+f);return b.substr(f,e)}}).call(this,n(\"node_modules/process/browser.js\"))},\n{\"node_modules/process/browser.js\":8}],8:[function(n,w,t){function e(){}n=w.exports={};n.nextTick=function(){if(\"undefined\"!==typeof window&&window.setImmediate)return function(e){return window.setImmediate(e)};if(\"undefined\"!==typeof window&&window.postMessage&&window.addEventListener){var e=[];window.addEventListener(\"message\",function(l){var m=l.source;m!==window&&null!==m||\"process-tick\"!==l.data||(l.stopPropagation(),0<e.length&&e.shift()())},!0);return function(l){e.push(l);window.postMessage(\"process-tick\",\n\"*\")}}return function(e){setTimeout(e,0)}}();n.title=\"browser\";n.browser=!0;n.env={};n.argv=[];n.on=e;n.once=e;n.off=e;n.emit=e;n.binding=function(e){throw Error(\"process.binding is not supported\");};n.cwd=function(){return\"/\"};n.chdir=function(e){throw Error(\"process.chdir is not supported\");}},{}],9:[function(n,w,t){t.SourceMapGenerator=n(\"./source-map/source-map-generator\").SourceMapGenerator;t.SourceMapConsumer=n(\"./source-map/source-map-consumer\").SourceMapConsumer;t.SourceNode=n(\"./source-map/source-node\").SourceNode},\n{\"./source-map/source-map-consumer\":14,\"./source-map/source-map-generator\":15,\"./source-map/source-node\":16}],10:[function(n,w,t){if(\"function\"!==typeof e)var e=n(\"amdefine\")(w,n);e(function(e,l,m){function g(){this._array=[];this._set={}}var b=e(\"./util\");g.fromArray=function(b,e){for(var a=new g,c=0,d=b.length;c<d;c++)a.add(b[c],e);return a};g.prototype.add=function(f,e){var a=this.has(f),c=this._array.length;a&&!e||this._array.push(f);a||(this._set[b.toSetString(f)]=c)};g.prototype.has=function(f){return Object.prototype.hasOwnProperty.call(this._set,\nb.toSetString(f))};g.prototype.indexOf=function(f){if(this.has(f))return this._set[b.toSetString(f)];throw Error('\"'+f+'\" is not in the set.');};g.prototype.at=function(b){if(0<=b&&b<this._array.length)return this._array[b];throw Error(\"No element indexed by \"+b);};g.prototype.toArray=function(){return this._array.slice()};l.ArraySet=g})},{\"./util\":17,amdefine:2}],11:[function(n,w,t){if(\"function\"!==typeof e)var e=n(\"amdefine\")(w,n);e(function(e,l,m){var g=e(\"./base64\");l.encode=function(b){var e=\n\"\",k=0>b?(-b<<1)+1:(b<<1)+0;do b=k&31,k>>>=5,0<k&&(b|=32),e+=g.encode(b);while(0<k);return e};l.decode=function(b){var e=0,k=b.length,a=0,c=0,d,y;do{if(e>=k)throw Error(\"Expected more digits in base 64 VLQ value.\");y=g.decode(b.charAt(e++));d=!!(y&32);y&=31;a+=y<<c;c+=5}while(d);k=a>>1;return{value:1===(a&1)?-k:k,rest:b.slice(e)}}})},{\"./base64\":12,amdefine:2}],12:[function(n,w,t){if(\"function\"!==typeof e)var e=n(\"amdefine\")(w,n);e(function(e,l,m){var g={},b={};\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".split(\"\").forEach(function(e,\nk){g[e]=k;b[k]=e});l.encode=function(e){if(e in b)return b[e];throw new TypeError(\"Must be between 0 and 63: \"+e);};l.decode=function(b){if(b in g)return g[b];throw new TypeError(\"Not a valid base 64 digit: \"+b);}})},{amdefine:2}],13:[function(n,w,t){if(\"function\"!==typeof e)var e=n(\"amdefine\")(w,n);e(function(e,l,m){function g(b,e,k,a,c){var d=Math.floor((e-b)/2)+b,y=c(k,a[d],!0);return 0===y?a[d]:0<y?1<e-d?g(d,e,k,a,c):a[d]:1<d-b?g(b,d,k,a,c):0>b?null:a[b]}l.search=function(b,e,k){return 0<e.length?\ng(-1,e.length,b,e,k):null}})},{amdefine:2}],14:[function(n,w,t){if(\"function\"!==typeof e)var e=n(\"amdefine\")(w,n);e(function(e,l,m){function g(a){var d=a;\"string\"===typeof a&&(d=JSON.parse(a.replace(/^\\)\\]\\}'/,\"\")));a=b.getArg(d,\"version\");var e=b.getArg(d,\"sources\"),f=b.getArg(d,\"names\",[]),g=b.getArg(d,\"sourceRoot\",null),l=b.getArg(d,\"sourcesContent\",null),m=b.getArg(d,\"mappings\"),d=b.getArg(d,\"file\",null);if(a!=this._version)throw Error(\"Unsupported version: \"+a);this._names=k.fromArray(f,!0);\nthis._sources=k.fromArray(e,!0);this.sourceRoot=g;this.sourcesContent=l;this._mappings=m;this.file=d}var b=e(\"./util\"),f=e(\"./binary-search\"),k=e(\"./array-set\").ArraySet,a=e(\"./base64-vlq\");g.fromSourceMap=function(a){var d=Object.create(g.prototype);d._names=k.fromArray(a._names.toArray(),!0);d._sources=k.fromArray(a._sources.toArray(),!0);d.sourceRoot=a._sourceRoot;d.sourcesContent=a._generateSourcesContent(d._sources.toArray(),d.sourceRoot);d.file=a._file;d.__generatedMappings=a._mappings.slice().sort(b.compareByGeneratedPositions);\nd.__originalMappings=a._mappings.slice().sort(b.compareByOriginalPositions);return d};g.prototype._version=3;Object.defineProperty(g.prototype,\"sources\",{get:function(){return this._sources.toArray().map(function(a){return this.sourceRoot?b.join(this.sourceRoot,a):a},this)}});g.prototype.__generatedMappings=null;Object.defineProperty(g.prototype,\"_generatedMappings\",{get:function(){this.__generatedMappings||(this.__generatedMappings=[],this.__originalMappings=[],this._parseMappings(this._mappings,\nthis.sourceRoot));return this.__generatedMappings}});g.prototype.__originalMappings=null;Object.defineProperty(g.prototype,\"_originalMappings\",{get:function(){this.__originalMappings||(this.__generatedMappings=[],this.__originalMappings=[],this._parseMappings(this._mappings,this.sourceRoot));return this.__originalMappings}});g.prototype._parseMappings=function(c,d){for(var e=1,f=0,g=0,k=0,l=0,m=0,r=/^[,;]/,u=c,n;0<u.length;)if(\";\"===u.charAt(0))e++,u=u.slice(1),f=0;else if(\",\"===u.charAt(0))u=u.slice(1);\nelse{n={};n.generatedLine=e;u=a.decode(u);n.generatedColumn=f+u.value;f=n.generatedColumn;u=u.rest;if(0<u.length&&!r.test(u.charAt(0))){u=a.decode(u);n.source=this._sources.at(l+u.value);l+=u.value;u=u.rest;if(0===u.length||r.test(u.charAt(0)))throw Error(\"Found a source, but no line and column\");u=a.decode(u);n.originalLine=g+u.value;g=n.originalLine;n.originalLine+=1;u=u.rest;if(0===u.length||r.test(u.charAt(0)))throw Error(\"Found a source and line, but no column\");u=a.decode(u);n.originalColumn=\nk+u.value;k=n.originalColumn;u=u.rest;0<u.length&&!r.test(u.charAt(0))&&(u=a.decode(u),n.name=this._names.at(m+u.value),m+=u.value,u=u.rest)}this.__generatedMappings.push(n);\"number\"===typeof n.originalLine&&this.__originalMappings.push(n)}this.__generatedMappings.sort(b.compareByGeneratedPositions);this.__originalMappings.sort(b.compareByOriginalPositions)};g.prototype._findMapping=function(a,d,b,e,g){if(0>=a[b])throw new TypeError(\"Line must be greater than or equal to 1, got \"+a[b]);if(0>a[e])throw new TypeError(\"Column must be greater than or equal to 0, got \"+\na[e]);return f.search(a,d,g)};g.prototype.originalPositionFor=function(a){a={generatedLine:b.getArg(a,\"line\"),generatedColumn:b.getArg(a,\"column\")};if(a=this._findMapping(a,this._generatedMappings,\"generatedLine\",\"generatedColumn\",b.compareByGeneratedPositions)){var d=b.getArg(a,\"source\",null);d&&this.sourceRoot&&(d=b.join(this.sourceRoot,d));return{source:d,line:b.getArg(a,\"originalLine\",null),column:b.getArg(a,\"originalColumn\",null),name:b.getArg(a,\"name\",null)}}return{source:null,line:null,column:null,\nname:null}};g.prototype.sourceContentFor=function(a){if(!this.sourcesContent)return null;this.sourceRoot&&(a=b.relative(this.sourceRoot,a));if(this._sources.has(a))return this.sourcesContent[this._sources.indexOf(a)];var d;if(this.sourceRoot&&(d=b.urlParse(this.sourceRoot))){var e=a.replace(/^file:\\/\\//,\"\");if(\"file\"==d.scheme&&this._sources.has(e))return this.sourcesContent[this._sources.indexOf(e)];if((!d.path||\"/\"==d.path)&&this._sources.has(\"/\"+a))return this.sourcesContent[this._sources.indexOf(\"/\"+\na)]}throw Error('\"'+a+'\" is not in the SourceMap.');};g.prototype.generatedPositionFor=function(a){a={source:b.getArg(a,\"source\"),originalLine:b.getArg(a,\"line\"),originalColumn:b.getArg(a,\"column\")};this.sourceRoot&&(a.source=b.relative(this.sourceRoot,a.source));return(a=this._findMapping(a,this._originalMappings,\"originalLine\",\"originalColumn\",b.compareByOriginalPositions))?{line:b.getArg(a,\"generatedLine\",null),column:b.getArg(a,\"generatedColumn\",null)}:{line:null,column:null}};g.GENERATED_ORDER=\n1;g.ORIGINAL_ORDER=2;g.prototype.eachMapping=function(a,d,e){d=d||null;switch(e||g.GENERATED_ORDER){case g.GENERATED_ORDER:e=this._generatedMappings;break;case g.ORIGINAL_ORDER:e=this._originalMappings;break;default:throw Error(\"Unknown order of iteration.\");}var f=this.sourceRoot;e.map(function(a){var c=a.source;c&&f&&(c=b.join(f,c));return{source:c,generatedLine:a.generatedLine,generatedColumn:a.generatedColumn,originalLine:a.originalLine,originalColumn:a.originalColumn,name:a.name}}).forEach(a,\nd)};l.SourceMapConsumer=g})},{\"./array-set\":10,\"./base64-vlq\":11,\"./binary-search\":13,\"./util\":17,amdefine:2}],15:[function(n,w,t){if(\"function\"!==typeof e)var e=n(\"amdefine\")(w,n);e(function(e,l,m){function g(a){this._file=f.getArg(a,\"file\");this._sourceRoot=f.getArg(a,\"sourceRoot\",null);this._sources=new k;this._names=new k;this._mappings=[];this._sourcesContents=null}var b=e(\"./base64-vlq\"),f=e(\"./util\"),k=e(\"./array-set\").ArraySet;g.prototype._version=3;g.fromSourceMap=function(a){var c=a.sourceRoot,\nd=new g({file:a.file,sourceRoot:c});a.eachMapping(function(a){var b={generated:{line:a.generatedLine,column:a.generatedColumn}};a.source&&(b.source=a.source,c&&(b.source=f.relative(c,b.source)),b.original={line:a.originalLine,column:a.originalColumn},a.name&&(b.name=a.name));d.addMapping(b)});a.sources.forEach(function(c){var b=a.sourceContentFor(c);b&&d.setSourceContent(c,b)});return d};g.prototype.addMapping=function(a){var c=f.getArg(a,\"generated\"),d=f.getArg(a,\"original\",null),b=f.getArg(a,\"source\",\nnull);a=f.getArg(a,\"name\",null);this._validateMapping(c,d,b,a);b&&!this._sources.has(b)&&this._sources.add(b);a&&!this._names.has(a)&&this._names.add(a);this._mappings.push({generatedLine:c.line,generatedColumn:c.column,originalLine:null!=d&&d.line,originalColumn:null!=d&&d.column,source:b,name:a})};g.prototype.setSourceContent=function(a,c){var d=a;this._sourceRoot&&(d=f.relative(this._sourceRoot,d));null!==c?(this._sourcesContents||(this._sourcesContents={}),this._sourcesContents[f.toSetString(d)]=\nc):(delete this._sourcesContents[f.toSetString(d)],0===Object.keys(this._sourcesContents).length&&(this._sourcesContents=null))};g.prototype.applySourceMap=function(a,c){c||(c=a.file);var d=this._sourceRoot;d&&(c=f.relative(d,c));var b=new k,e=new k;this._mappings.forEach(function(g){if(g.source===c&&g.originalLine){var k=a.originalPositionFor({line:g.originalLine,column:g.originalColumn});null!==k.source&&(g.source=d?f.relative(d,k.source):k.source,g.originalLine=k.line,g.originalColumn=k.column,\nnull!==k.name&&null!==g.name&&(g.name=k.name))}(k=g.source)&&!b.has(k)&&b.add(k);(g=g.name)&&!e.has(g)&&e.add(g)},this);this._sources=b;this._names=e;a.sources.forEach(function(c){var b=a.sourceContentFor(c);b&&(d&&(c=f.relative(d,c)),this.setSourceContent(c,b))},this)};g.prototype._validateMapping=function(a,c,d,b){if(!(a&&\"line\"in a&&\"column\"in a&&0<a.line&&0<=a.column&&!c&&!d&&!b||a&&\"line\"in a&&\"column\"in a&&c&&\"line\"in c&&\"column\"in c&&0<a.line&&0<=a.column&&0<c.line&&0<=c.column&&d))throw Error(\"Invalid mapping: \"+\nJSON.stringify({generated:a,source:d,original:c,name:b}));};g.prototype._serializeMappings=function(){var a=0,c=1,d=0,e=0,g=0,k=0,l=\"\",m;this._mappings.sort(f.compareByGeneratedPositions);for(var n=0,r=this._mappings.length;n<r;n++){m=this._mappings[n];if(m.generatedLine!==c)for(a=0;m.generatedLine!==c;)l+=\";\",c++;else if(0<n){if(!f.compareByGeneratedPositions(m,this._mappings[n-1]))continue;l+=\",\"}l+=b.encode(m.generatedColumn-a);a=m.generatedColumn;m.source&&(l+=b.encode(this._sources.indexOf(m.source)-\nk),k=this._sources.indexOf(m.source),l+=b.encode(m.originalLine-1-e),e=m.originalLine-1,l+=b.encode(m.originalColumn-d),d=m.originalColumn,m.name&&(l+=b.encode(this._names.indexOf(m.name)-g),g=this._names.indexOf(m.name)))}return l};g.prototype._generateSourcesContent=function(a,c){return a.map(function(a){if(!this._sourcesContents)return null;c&&(a=f.relative(c,a));a=f.toSetString(a);return Object.prototype.hasOwnProperty.call(this._sourcesContents,a)?this._sourcesContents[a]:null},this)};g.prototype.toJSON=\nfunction(){var a={version:this._version,file:this._file,sources:this._sources.toArray(),names:this._names.toArray(),mappings:this._serializeMappings()};this._sourceRoot&&(a.sourceRoot=this._sourceRoot);this._sourcesContents&&(a.sourcesContent=this._generateSourcesContent(a.sources,a.sourceRoot));return a};g.prototype.toString=function(){return JSON.stringify(this)};l.SourceMapGenerator=g})},{\"./array-set\":10,\"./base64-vlq\":11,\"./util\":17,amdefine:2}],16:[function(n,w,t){if(\"function\"!==typeof e)var e=\nn(\"amdefine\")(w,n);e(function(e,l,m){function g(b,a,c,d,e){this.children=[];this.sourceContents={};this.line=void 0===b?null:b;this.column=void 0===a?null:a;this.source=void 0===c?null:c;this.name=void 0===e?null:e;null!=d&&this.add(d)}var b=e(\"./source-map-generator\").SourceMapGenerator,f=e(\"./util\");g.fromStringWithSourceMap=function(b,a){function c(a,c){null===a||void 0===a.source?d.add(c):d.add(new g(a.originalLine,a.originalColumn,a.source,c,a.name))}var d=new g,e=b.split(\"\\n\"),f=1,l=0,m=null;\na.eachMapping(function(a){if(null===m){for(;f<a.generatedLine;)d.add(e.shift()+\"\\n\"),f++;if(l<a.generatedColumn){var b=e[0];d.add(b.substr(0,a.generatedColumn));e[0]=b.substr(a.generatedColumn);l=a.generatedColumn}}else{if(f<a.generatedLine){var g=\"\";do g+=e.shift()+\"\\n\",f++,l=0;while(f<a.generatedLine);l<a.generatedColumn&&(b=e[0],g+=b.substr(0,a.generatedColumn),e[0]=b.substr(a.generatedColumn),l=a.generatedColumn)}else b=e[0],g=b.substr(0,a.generatedColumn-l),e[0]=b.substr(a.generatedColumn-l),\nl=a.generatedColumn;c(m,g)}m=a},this);c(m,e.join(\"\\n\"));a.sources.forEach(function(c){var b=a.sourceContentFor(c);b&&d.setSourceContent(c,b)});return d};g.prototype.add=function(b){if(Array.isArray(b))b.forEach(function(a){this.add(a)},this);else if(b instanceof g||\"string\"===typeof b)b&&this.children.push(b);else throw new TypeError(\"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \"+b);return this};g.prototype.prepend=function(b){if(Array.isArray(b))for(var a=b.length-\n1;0<=a;a--)this.prepend(b[a]);else if(b instanceof g||\"string\"===typeof b)this.children.unshift(b);else throw new TypeError(\"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \"+b);return this};g.prototype.walk=function(b){for(var a,c=0,d=this.children.length;c<d;c++)a=this.children[c],a instanceof g?a.walk(b):\"\"!==a&&b(a,{source:this.source,line:this.line,column:this.column,name:this.name})};g.prototype.join=function(b){var a,c,d=this.children.length;if(0<d){a=[];for(c=0;c<\nd-1;c++)a.push(this.children[c]),a.push(b);a.push(this.children[c]);this.children=a}return this};g.prototype.replaceRight=function(b,a){var c=this.children[this.children.length-1];c instanceof g?c.replaceRight(b,a):\"string\"===typeof c?this.children[this.children.length-1]=c.replace(b,a):this.children.push(\"\".replace(b,a));return this};g.prototype.setSourceContent=function(b,a){this.sourceContents[f.toSetString(b)]=a};g.prototype.walkSourceContents=function(b){for(var a=0,c=this.children.length;a<\nc;a++)this.children[a]instanceof g&&this.children[a].walkSourceContents(b);for(var d=Object.keys(this.sourceContents),a=0,c=d.length;a<c;a++)b(f.fromSetString(d[a]),this.sourceContents[d[a]])};g.prototype.toString=function(){var b=\"\";this.walk(function(a){b+=a});return b};g.prototype.toStringWithSourceMap=function(e){var a=\"\",c=1,d=0,f=new b(e),g=!1,l=null,m=null,n=null,r=null;this.walk(function(b,e){a+=b;null!==e.source&&null!==e.line&&null!==e.column?(l===e.source&&m===e.line&&n===e.column&&r===\ne.name||f.addMapping({source:e.source,original:{line:e.line,column:e.column},generated:{line:c,column:d},name:e.name}),l=e.source,m=e.line,n=e.column,r=e.name,g=!0):g&&(f.addMapping({generated:{line:c,column:d}}),l=null,g=!1);b.split(\"\").forEach(function(a){\"\\n\"===a?(c++,d=0):d++})});this.walkSourceContents(function(a,c){f.setSourceContent(a,c)});return{code:a,map:f}};l.SourceNode=g})},{\"./source-map-generator\":15,\"./util\":17,amdefine:2}],17:[function(n,w,t){if(\"function\"!==typeof e)var e=n(\"amdefine\")(w,\nn);e(function(e,l,m){function g(a){return(a=a.match(k))?{scheme:a[1],auth:a[3],host:a[4],port:a[6],path:a[7]}:null}function b(a){var b=a.scheme+\"://\";a.auth&&(b+=a.auth+\"@\");a.host&&(b+=a.host);a.port&&(b+=\":\"+a.port);a.path&&(b+=a.path);return b}function f(a,b){var e=a||\"\",f=b||\"\";return(e>f)-(e<f)}l.getArg=function(a,b,e){if(b in a)return a[b];if(3===arguments.length)return e;throw Error('\"'+b+'\" is a required argument.');};var k=/([\\w+\\-.]+):\\/\\/((\\w+:\\w+)@)?([\\w.]+)?(:(\\d+))?(\\S+)?/,a=/^data:.+\\,.+/;\nl.urlParse=g;l.urlGenerate=b;l.join=function(c,d){var e;return d.match(k)||d.match(a)?d:\"/\"===d.charAt(0)&&(e=g(c))?(e.path=d,b(e)):c.replace(/\\/$/,\"\")+\"/\"+d};l.toSetString=function(a){return\"$\"+a};l.fromSetString=function(a){return a.substr(1)};l.relative=function(a,b){a=a.replace(/\\/$/,\"\");var e=g(a);return\"/\"==b.charAt(0)&&e&&\"/\"==e.path?b.slice(1):0===b.indexOf(a+\"/\")?b.substr(a.length+1):b};l.compareByOriginalPositions=function(a,b,e){var g;return(g=f(a.source,b.source))||(g=a.originalLine-b.originalLine)||\n(g=a.originalColumn-b.originalColumn)||e||(g=f(a.name,b.name))?g:(g=a.generatedLine-b.generatedLine)?g:a.generatedColumn-b.generatedColumn};l.compareByGeneratedPositions=function(a,b,e){var g;return(g=a.generatedLine-b.generatedLine)||(g=a.generatedColumn-b.generatedColumn)||e||(g=f(a.source,b.source))||(g=a.originalLine-b.originalLine)?g:(g=a.originalColumn-b.originalColumn)?g:f(a.name,b.name)}})},{amdefine:2}],18:[function(n,w,t){(function(e,r){function l(){return\"browser\"===C?!0:\"node\"===C?!1:\n\"undefined\"!==typeof window&&\"function\"===typeof XMLHttpRequest}function m(a){a=a.trim();if(a in z)return z[a];try{if(l()){var b=new XMLHttpRequest;b.open(\"GET\",a,!1);b.send(null);var c=null;4===b.readyState&&200===b.status&&(c=b.responseText)}else c=E.readFileSync(a,\"utf8\")}catch(d){c=null}return z[a]=c}function g(a,b){if(!a)return b;var c=F.dirname(a),d=/^\\w+:\\/\\/[^\\/]*/.exec(c),d=d?d[0]:\"\";return d+F.resolve(c.slice(d.length),b)}function b(a){var b;a:{var c;if(l()&&(c=new XMLHttpRequest,c.open(\"GET\",\na,!1),c.send(null),c=c.getResponseHeader(\"SourceMap\")||c.getResponseHeader(\"X-SourceMap\"))){b=c;break a}c=m(a);for(var d=/(?:\\/\\/[@#][ \\t]+sourceMappingURL=([^\\s'\"]+?)[ \\t]*$)|(?:\\/\\*[@#][ \\t]+sourceMappingURL=([^\\*]+?)[ \\t]*(?:\\*\\/)[ \\t]*$)/mg,e;e=d.exec(c);)b=e;b=b?b[1]:null}if(!b)return null;H.test(b)?(a=b.slice(b.indexOf(\",\")+1),a=(new r(a,\"base64\")).toString(),b=null):(b=g(a,b),a=m(b));return a?{url:b,map:a}:null}function f(a){var c=D[a.source];if(!c){var d=b(a.source);d?(c=D[a.source]={url:d.url,\nmap:new B(d.map)},c.map.sourcesContent&&c.map.sources.forEach(function(a,b){var d=c.map.sourcesContent[b];if(d){var e=g(c.url,a);z[e]=d}})):c=D[a.source]={url:null,map:null}}return c&&c.map&&(d=c.map.originalPositionFor(a),null!==d.source)?(d.source=g(c.url,d.source),d):a}function k(a){var b=/^eval at ([^(]+) \\((.+):(\\d+):(\\d+)\\)$/.exec(a);return b?(a=f({source:b[2],line:b[3],column:b[4]-1}),\"eval at \"+b[1]+\" (\"+a.source+\":\"+a.line+\":\"+(a.column+1)+\")\"):(b=/^eval at ([^(]+) \\((.+)\\)$/.exec(a))?\"eval at \"+\nb[1]+\" (\"+k(b[2])+\")\":a}function a(){var a,b=\"\";this.isNative()?b=\"native\":(a=this.getScriptNameOrSourceURL(),!a&&this.isEval()&&(b=this.getEvalOrigin(),b+=\", \"),b=a?b+a:b+\"<anonymous>\",a=this.getLineNumber(),null!=a&&(b+=\":\"+a,(a=this.getColumnNumber())&&(b+=\":\"+a)));a=\"\";var c=this.getFunctionName(),d=!0,e=this.isConstructor();if(this.isToplevel()||e)e?a+=\"new \"+(c||\"<anonymous>\"):c?a+=c:(a+=b,d=!1);else{var e=this.getTypeName(),f=this.getMethodName();c?(e&&0!=c.indexOf(e)&&(a+=e+\".\"),a+=c,f&&c.indexOf(\".\"+\nf)!=c.length-f.length-1&&(a+=\" [as \"+f+\"]\")):a+=e+\".\"+(f||\"<anonymous>\")}d&&(a+=\" (\"+b+\")\");return a}function c(b){var c={};Object.getOwnPropertyNames(Object.getPrototypeOf(b)).forEach(function(a){c[a]=/^(?:is|get)/.test(a)?function(){return b[a].call(b)}:b[a]});c.toString=a;return c}function d(a){var b=a.getFileName()||a.getScriptNameOrSourceURL();if(b){var d=a.getLineNumber(),e=a.getColumnNumber()-1;1!==d||l()||a.isEval()||(e-=62);var g=f({source:b,line:d,column:e});a=c(a);a.getFileName=function(){return g.source};\na.getLineNumber=function(){return g.line};a.getColumnNumber=function(){return g.column+1};a.getScriptNameOrSourceURL=function(){return g.source};return a}var m=a.isEval()&&a.getEvalOrigin();m&&(m=k(m),a=c(a),a.getEvalOrigin=function(){return m});return a}function w(a,b){u&&(z={},D={});return a+b.map(function(a){return\"\\n    at \"+d(a)}).join(\"\")}function x(a){var b=/\\n    at [^(]+ \\((.*):(\\d+):(\\d+)\\)/.exec(a.stack);if(b){a=b[1];var c=+b[2],b=+b[3],d=z[a];!d&&E.existsSync(a)&&(d=E.readFileSync(a,\"utf8\"));\nif(d&&(d=d.split(/(?:\\r\\n|\\r|\\n)/)[c-1]))return a+\":\"+c+\"\\n\"+d+\"\\n\"+Array(b).join(\" \")+\"^\"}return null}function A(){var a=e.emit;e.emit=function(b){if(\"uncaughtException\"===b){var c=arguments[1]&&arguments[1].stack,d=0<this.listeners(b).length;if(c&&!d){c=arguments[1];if(d=x(c))console.error(),console.error(d);console.error(c.stack);e.exit(1);return}}return a.apply(this,arguments)}}var B=n(\"source-map\").SourceMapConsumer,F=n(\"path\"),E=n(\"fs\"),G=!1,u=!1,C=\"auto\",z={},D={},H=/^data:application\\/json[^,]+base64,/;\nt.wrapCallSite=d;t.getErrorSource=x;t.mapSourcePosition=f;t.retrieveSourceMap=b;t.install=function(a){if(!G){G=!0;Error.prepareStackTrace=w;a=a||{};var c=\"handleUncaughtExceptions\"in a?a.handleUncaughtExceptions:!0;u=\"emptyCacheBetweenOperations\"in a?a.emptyCacheBetweenOperations:!1;if(a.environment&&(C=a.environment,-1===[\"node\",\"browser\",\"auto\"].indexOf(C)))throw Error(\"environment \"+C+\" was unknown. Available options are {auto, browser, node}\");a.retrieveFile&&(m=a.retrieveFile);a.retrieveSourceMap&&\n(b=a.retrieveSourceMap);c&&\"object\"===typeof e&&null!==e&&\"function\"===typeof e.on&&A()}}}).call(this,n(\"node_modules/process/browser.js\"),n(\"buffer\").Buffer)},{\"node_modules/process/browser.js\":8,buffer:5,fs:4,path:7,\"source-map\":9}]},{},[1]);return K});\n"

/***/ },
/* 7 */
/***/ function(module, exports) {

	"use strict";
	
	module.exports = "/*\nCopyright (c) 2008-2015 Pivotal Labs\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\nvar getJasmineRequireObj = (function (jasmineGlobal) {\n  var jasmineRequire;\n\n  if (typeof module !== 'undefined' && module.exports) {\n    if (typeof global !== 'undefined') {\n      jasmineGlobal = global;\n    } else {\n      jasmineGlobal = {};\n    }\n    jasmineRequire = exports;\n  } else {\n    if (typeof window !== 'undefined' && typeof window.toString === 'function' && window.toString() === '[object GjsGlobal]') {\n      jasmineGlobal = window;\n    }\n    jasmineRequire = jasmineGlobal.jasmineRequire = jasmineGlobal.jasmineRequire || {};\n  }\n\n  function getJasmineRequire() {\n    return jasmineRequire;\n  }\n\n  getJasmineRequire().core = function(jRequire) {\n    var j$ = {};\n\n    jRequire.base(j$, jasmineGlobal);\n    j$.util = jRequire.util();\n    j$.errors = jRequire.errors();\n    j$.Any = jRequire.Any(j$);\n    j$.Anything = jRequire.Anything(j$);\n    j$.CallTracker = jRequire.CallTracker();\n    j$.MockDate = jRequire.MockDate();\n    j$.Clock = jRequire.Clock();\n    j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler();\n    j$.Env = jRequire.Env(j$);\n    j$.ExceptionFormatter = jRequire.ExceptionFormatter();\n    j$.Expectation = jRequire.Expectation();\n    j$.buildExpectationResult = jRequire.buildExpectationResult();\n    j$.JsApiReporter = jRequire.JsApiReporter();\n    j$.matchersUtil = jRequire.matchersUtil(j$);\n    j$.ObjectContaining = jRequire.ObjectContaining(j$);\n    j$.ArrayContaining = jRequire.ArrayContaining(j$);\n    j$.pp = jRequire.pp(j$);\n    j$.QueueRunner = jRequire.QueueRunner(j$);\n    j$.ReportDispatcher = jRequire.ReportDispatcher();\n    j$.Spec = jRequire.Spec(j$);\n    j$.SpyRegistry = jRequire.SpyRegistry(j$);\n    j$.SpyStrategy = jRequire.SpyStrategy();\n    j$.StringMatching = jRequire.StringMatching(j$);\n    j$.Suite = jRequire.Suite(j$);\n    j$.Timer = jRequire.Timer();\n    j$.TreeProcessor = jRequire.TreeProcessor();\n    j$.version = jRequire.version();\n    j$.Order = jRequire.Order();\n\n    j$.matchers = jRequire.requireMatchers(jRequire, j$);\n\n    return j$;\n  };\n\n  return getJasmineRequire;\n})(this);\n\ngetJasmineRequireObj().requireMatchers = function(jRequire, j$) {\n  var availableMatchers = [\n      'toBe',\n      'toBeCloseTo',\n      'toBeDefined',\n      'toBeFalsy',\n      'toBeGreaterThan',\n      'toBeLessThan',\n      'toBeNaN',\n      'toBeNull',\n      'toBeTruthy',\n      'toBeUndefined',\n      'toContain',\n      'toEqual',\n      'toHaveBeenCalled',\n      'toHaveBeenCalledWith',\n      'toHaveBeenCalledTimes',\n      'toMatch',\n      'toThrow',\n      'toThrowError'\n    ],\n    matchers = {};\n\n  for (var i = 0; i < availableMatchers.length; i++) {\n    var name = availableMatchers[i];\n    matchers[name] = jRequire[name](j$);\n  }\n\n  return matchers;\n};\n\ngetJasmineRequireObj().base = function(j$, jasmineGlobal) {\n  j$.unimplementedMethod_ = function() {\n    throw new Error('unimplemented method');\n  };\n\n  j$.MAX_PRETTY_PRINT_DEPTH = 40;\n  j$.MAX_PRETTY_PRINT_ARRAY_LENGTH = 100;\n  j$.DEFAULT_TIMEOUT_INTERVAL = 5000;\n\n  j$.getGlobal = function() {\n    return jasmineGlobal;\n  };\n\n  j$.getEnv = function(options) {\n    var env = j$.currentEnv_ = j$.currentEnv_ || new j$.Env(options);\n    //jasmine. singletons in here (setTimeout blah blah).\n    return env;\n  };\n\n  j$.isArray_ = function(value) {\n    return j$.isA_('Array', value);\n  };\n\n  j$.isString_ = function(value) {\n    return j$.isA_('String', value);\n  };\n\n  j$.isNumber_ = function(value) {\n    return j$.isA_('Number', value);\n  };\n\n  j$.isA_ = function(typeName, value) {\n    return Object.prototype.toString.apply(value) === '[object ' + typeName + ']';\n  };\n\n  j$.isDomNode = function(obj) {\n    return obj.nodeType > 0;\n  };\n\n  j$.fnNameFor = function(func) {\n    return func.name || func.toString().match(/^\\s*function\\s*(\\w*)\\s*\\(/)[1];\n  };\n\n  j$.any = function(clazz) {\n    return new j$.Any(clazz);\n  };\n\n  j$.anything = function() {\n    return new j$.Anything();\n  };\n\n  j$.objectContaining = function(sample) {\n    return new j$.ObjectContaining(sample);\n  };\n\n  j$.stringMatching = function(expected) {\n    return new j$.StringMatching(expected);\n  };\n\n  j$.arrayContaining = function(sample) {\n    return new j$.ArrayContaining(sample);\n  };\n\n  j$.createSpy = function(name, originalFn) {\n\n    var spyStrategy = new j$.SpyStrategy({\n        name: name,\n        fn: originalFn,\n        getSpy: function() { return spy; }\n      }),\n      callTracker = new j$.CallTracker(),\n      spy = function() {\n        var callData = {\n          object: this,\n          args: Array.prototype.slice.apply(arguments)\n        };\n\n        callTracker.track(callData);\n        var returnValue = spyStrategy.exec.apply(this, arguments);\n        callData.returnValue = returnValue;\n\n        return returnValue;\n      };\n\n    for (var prop in originalFn) {\n      if (prop === 'and' || prop === 'calls') {\n        throw new Error('Jasmine spies would overwrite the \\'and\\' and \\'calls\\' properties on the object being spied upon');\n      }\n\n      spy[prop] = originalFn[prop];\n    }\n\n    spy.and = spyStrategy;\n    spy.calls = callTracker;\n\n    return spy;\n  };\n\n  j$.isSpy = function(putativeSpy) {\n    if (!putativeSpy) {\n      return false;\n    }\n    return putativeSpy.and instanceof j$.SpyStrategy &&\n      putativeSpy.calls instanceof j$.CallTracker;\n  };\n\n  j$.createSpyObj = function(baseName, methodNames) {\n    if (j$.isArray_(baseName) && j$.util.isUndefined(methodNames)) {\n      methodNames = baseName;\n      baseName = 'unknown';\n    }\n\n    if (!j$.isArray_(methodNames) || methodNames.length === 0) {\n      throw 'createSpyObj requires a non-empty array of method names to create spies for';\n    }\n    var obj = {};\n    for (var i = 0; i < methodNames.length; i++) {\n      obj[methodNames[i]] = j$.createSpy(baseName + '.' + methodNames[i]);\n    }\n    return obj;\n  };\n};\n\ngetJasmineRequireObj().util = function() {\n\n  var util = {};\n\n  util.inherit = function(childClass, parentClass) {\n    var Subclass = function() {\n    };\n    Subclass.prototype = parentClass.prototype;\n    childClass.prototype = new Subclass();\n  };\n\n  util.htmlEscape = function(str) {\n    if (!str) {\n      return str;\n    }\n    return str.replace(/&/g, '&amp;')\n      .replace(/</g, '&lt;')\n      .replace(/>/g, '&gt;');\n  };\n\n  util.argsToArray = function(args) {\n    var arrayOfArgs = [];\n    for (var i = 0; i < args.length; i++) {\n      arrayOfArgs.push(args[i]);\n    }\n    return arrayOfArgs;\n  };\n\n  util.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  util.arrayContains = function(array, search) {\n    var i = array.length;\n    while (i--) {\n      if (array[i] === search) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  util.clone = function(obj) {\n    if (Object.prototype.toString.apply(obj) === '[object Array]') {\n      return obj.slice();\n    }\n\n    var cloned = {};\n    for (var prop in obj) {\n      if (obj.hasOwnProperty(prop)) {\n        cloned[prop] = obj[prop];\n      }\n    }\n\n    return cloned;\n  };\n\n  return util;\n};\n\ngetJasmineRequireObj().Spec = function(j$) {\n  function Spec(attrs) {\n    this.expectationFactory = attrs.expectationFactory;\n    this.resultCallback = attrs.resultCallback || function() {};\n    this.id = attrs.id;\n    this.description = attrs.description || '';\n    this.queueableFn = attrs.queueableFn;\n    this.beforeAndAfterFns = attrs.beforeAndAfterFns || function() { return {befores: [], afters: []}; };\n    this.userContext = attrs.userContext || function() { return {}; };\n    this.onStart = attrs.onStart || function() {};\n    this.getSpecName = attrs.getSpecName || function() { return ''; };\n    this.expectationResultFactory = attrs.expectationResultFactory || function() { };\n    this.queueRunnerFactory = attrs.queueRunnerFactory || function() {};\n    this.catchingExceptions = attrs.catchingExceptions || function() { return true; };\n    this.throwOnExpectationFailure = !!attrs.throwOnExpectationFailure;\n\n    if (!this.queueableFn.fn) {\n      this.pend();\n    }\n\n    this.result = {\n      id: this.id,\n      description: this.description,\n      fullName: this.getFullName(),\n      failedExpectations: [],\n      passedExpectations: [],\n      pendingReason: ''\n    };\n  }\n\n  Spec.prototype.addExpectationResult = function(passed, data, isError) {\n    var expectationResult = this.expectationResultFactory(data);\n    if (passed) {\n      this.result.passedExpectations.push(expectationResult);\n    } else {\n      this.result.failedExpectations.push(expectationResult);\n\n      if (this.throwOnExpectationFailure && !isError) {\n        throw new j$.errors.ExpectationFailed();\n      }\n    }\n  };\n\n  Spec.prototype.expect = function(actual) {\n    return this.expectationFactory(actual, this);\n  };\n\n  Spec.prototype.execute = function(onComplete, enabled) {\n    var self = this;\n\n    this.onStart(this);\n\n    if (!this.isExecutable() || this.markedPending || enabled === false) {\n      complete(enabled);\n      return;\n    }\n\n    var fns = this.beforeAndAfterFns();\n    var allFns = fns.befores.concat(this.queueableFn).concat(fns.afters);\n\n    this.queueRunnerFactory({\n      queueableFns: allFns,\n      onException: function() { self.onException.apply(self, arguments); },\n      onComplete: complete,\n      userContext: this.userContext()\n    });\n\n    function complete(enabledAgain) {\n      self.result.status = self.status(enabledAgain);\n      self.resultCallback(self.result);\n\n      if (onComplete) {\n        onComplete();\n      }\n    }\n  };\n\n  Spec.prototype.onException = function onException(e) {\n    if (Spec.isPendingSpecException(e)) {\n      this.pend(extractCustomPendingMessage(e));\n      return;\n    }\n\n    if (e instanceof j$.errors.ExpectationFailed) {\n      return;\n    }\n\n    this.addExpectationResult(false, {\n      matcherName: '',\n      passed: false,\n      expected: '',\n      actual: '',\n      error: e\n    }, true);\n  };\n\n  Spec.prototype.disable = function() {\n    this.disabled = true;\n  };\n\n  Spec.prototype.pend = function(message) {\n    this.markedPending = true;\n    if (message) {\n      this.result.pendingReason = message;\n    }\n  };\n\n  Spec.prototype.getResult = function() {\n    this.result.status = this.status();\n    return this.result;\n  };\n\n  Spec.prototype.status = function(enabled) {\n    if (this.disabled || enabled === false) {\n      return 'disabled';\n    }\n\n    if (this.markedPending) {\n      return 'pending';\n    }\n\n    if (this.result.failedExpectations.length > 0) {\n      return 'failed';\n    } else {\n      return 'passed';\n    }\n  };\n\n  Spec.prototype.isExecutable = function() {\n    return !this.disabled;\n  };\n\n  Spec.prototype.getFullName = function() {\n    return this.getSpecName(this);\n  };\n\n  var extractCustomPendingMessage = function(e) {\n    var fullMessage = e.toString(),\n        boilerplateStart = fullMessage.indexOf(Spec.pendingSpecExceptionMessage),\n        boilerplateEnd = boilerplateStart + Spec.pendingSpecExceptionMessage.length;\n\n    return fullMessage.substr(boilerplateEnd);\n  };\n\n  Spec.pendingSpecExceptionMessage = '=> marked Pending';\n\n  Spec.isPendingSpecException = function(e) {\n    return !!(e && e.toString && e.toString().indexOf(Spec.pendingSpecExceptionMessage) !== -1);\n  };\n\n  return Spec;\n};\n\nif (typeof window == void 0 && typeof exports == 'object') {\n  exports.Spec = jasmineRequire.Spec;\n}\n\n/*jshint bitwise: false*/\n\ngetJasmineRequireObj().Order = function() {\n  function Order(options) {\n    this.random = 'random' in options ? options.random : true;\n    var seed = this.seed = options.seed || generateSeed();\n    this.sort = this.random ? randomOrder : naturalOrder;\n\n    function naturalOrder(items) {\n      return items;\n    }\n\n    function randomOrder(items) {\n      var copy = items.slice();\n      copy.sort(function(a, b) {\n        return jenkinsHash(seed + a.id) - jenkinsHash(seed + b.id);\n      });\n      return copy;\n    }\n\n    function generateSeed() {\n      return String(Math.random()).slice(-5);\n    }\n\n    // Bob Jenkins One-at-a-Time Hash algorithm is a non-cryptographic hash function\n    // used to get a different output when the key changes slighly.\n    // We use your return to sort the children randomly in a consistent way when\n    // used in conjunction with a seed\n\n    function jenkinsHash(key) {\n      var hash, i;\n      for(hash = i = 0; i < key.length; ++i) {\n        hash += key.charCodeAt(i);\n        hash += (hash << 10);\n        hash ^= (hash >> 6);\n      }\n      hash += (hash << 3);\n      hash ^= (hash >> 11);\n      hash += (hash << 15);\n      return hash;\n    }\n\n  }\n\n  return Order;\n};\n\ngetJasmineRequireObj().Env = function(j$) {\n  function Env(options) {\n    options = options || {};\n\n    var self = this;\n    var global = options.global || j$.getGlobal();\n\n    var totalSpecsDefined = 0;\n\n    var catchExceptions = true;\n\n    var realSetTimeout = j$.getGlobal().setTimeout;\n    var realClearTimeout = j$.getGlobal().clearTimeout;\n    this.clock = new j$.Clock(global, function () { return new j$.DelayedFunctionScheduler(); }, new j$.MockDate(global));\n\n    var runnableLookupTable = {};\n    var runnableResources = {};\n\n    var currentSpec = null;\n    var currentlyExecutingSuites = [];\n    var currentDeclarationSuite = null;\n    var throwOnExpectationFailure = false;\n    var random = false;\n    var seed = null;\n\n    var currentSuite = function() {\n      return currentlyExecutingSuites[currentlyExecutingSuites.length - 1];\n    };\n\n    var currentRunnable = function() {\n      return currentSpec || currentSuite();\n    };\n\n    var reporter = new j$.ReportDispatcher([\n      'jasmineStarted',\n      'jasmineDone',\n      'suiteStarted',\n      'suiteDone',\n      'specStarted',\n      'specDone'\n    ]);\n\n    this.specFilter = function() {\n      return true;\n    };\n\n    this.addCustomEqualityTester = function(tester) {\n      if(!currentRunnable()) {\n        throw new Error('Custom Equalities must be added in a before function or a spec');\n      }\n      runnableResources[currentRunnable().id].customEqualityTesters.push(tester);\n    };\n\n    this.addMatchers = function(matchersToAdd) {\n      if(!currentRunnable()) {\n        throw new Error('Matchers must be added in a before function or a spec');\n      }\n      var customMatchers = runnableResources[currentRunnable().id].customMatchers;\n      for (var matcherName in matchersToAdd) {\n        customMatchers[matcherName] = matchersToAdd[matcherName];\n      }\n    };\n\n    j$.Expectation.addCoreMatchers(j$.matchers);\n\n    var nextSpecId = 0;\n    var getNextSpecId = function() {\n      return 'spec' + nextSpecId++;\n    };\n\n    var nextSuiteId = 0;\n    var getNextSuiteId = function() {\n      return 'suite' + nextSuiteId++;\n    };\n\n    var expectationFactory = function(actual, spec) {\n      return j$.Expectation.Factory({\n        util: j$.matchersUtil,\n        customEqualityTesters: runnableResources[spec.id].customEqualityTesters,\n        customMatchers: runnableResources[spec.id].customMatchers,\n        actual: actual,\n        addExpectationResult: addExpectationResult\n      });\n\n      function addExpectationResult(passed, result) {\n        return spec.addExpectationResult(passed, result);\n      }\n    };\n\n    var defaultResourcesForRunnable = function(id, parentRunnableId) {\n      var resources = {spies: [], customEqualityTesters: [], customMatchers: {}};\n\n      if(runnableResources[parentRunnableId]){\n        resources.customEqualityTesters = j$.util.clone(runnableResources[parentRunnableId].customEqualityTesters);\n        resources.customMatchers = j$.util.clone(runnableResources[parentRunnableId].customMatchers);\n      }\n\n      runnableResources[id] = resources;\n    };\n\n    var clearResourcesForRunnable = function(id) {\n        spyRegistry.clearSpies();\n        delete runnableResources[id];\n    };\n\n    var beforeAndAfterFns = function(suite) {\n      return function() {\n        var befores = [],\n          afters = [];\n\n        while(suite) {\n          befores = befores.concat(suite.beforeFns);\n          afters = afters.concat(suite.afterFns);\n\n          suite = suite.parentSuite;\n        }\n\n        return {\n          befores: befores.reverse(),\n          afters: afters\n        };\n      };\n    };\n\n    var getSpecName = function(spec, suite) {\n      return suite.getFullName() + ' ' + spec.description;\n    };\n\n    // TODO: we may just be able to pass in the fn instead of wrapping here\n    var buildExpectationResult = j$.buildExpectationResult,\n        exceptionFormatter = new j$.ExceptionFormatter(),\n        expectationResultFactory = function(attrs) {\n          attrs.messageFormatter = exceptionFormatter.message;\n          attrs.stackFormatter = exceptionFormatter.stack;\n\n          return buildExpectationResult(attrs);\n        };\n\n    // TODO: fix this naming, and here's where the value comes in\n    this.catchExceptions = function(value) {\n      catchExceptions = !!value;\n      return catchExceptions;\n    };\n\n    this.catchingExceptions = function() {\n      return catchExceptions;\n    };\n\n    var maximumSpecCallbackDepth = 20;\n    var currentSpecCallbackDepth = 0;\n\n    function clearStack(fn) {\n      currentSpecCallbackDepth++;\n      if (currentSpecCallbackDepth >= maximumSpecCallbackDepth) {\n        currentSpecCallbackDepth = 0;\n        realSetTimeout(fn, 0);\n      } else {\n        fn();\n      }\n    }\n\n    var catchException = function(e) {\n      return j$.Spec.isPendingSpecException(e) || catchExceptions;\n    };\n\n    this.throwOnExpectationFailure = function(value) {\n      throwOnExpectationFailure = !!value;\n    };\n\n    this.throwingExpectationFailures = function() {\n      return throwOnExpectationFailure;\n    };\n\n    this.randomizeTests = function(value) {\n      random = !!value;\n    };\n\n    this.randomTests = function() {\n      return random;\n    };\n\n    this.seed = function(value) {\n      if (value) {\n        seed = value;\n      }\n      return seed;\n    };\n\n    var queueRunnerFactory = function(options) {\n      options.catchException = catchException;\n      options.clearStack = options.clearStack || clearStack;\n      options.timeout = {setTimeout: realSetTimeout, clearTimeout: realClearTimeout};\n      options.fail = self.fail;\n\n      new j$.QueueRunner(options).execute();\n    };\n\n    var topSuite = new j$.Suite({\n      env: this,\n      id: getNextSuiteId(),\n      description: 'Jasmine__TopLevel__Suite',\n      queueRunner: queueRunnerFactory\n    });\n    runnableLookupTable[topSuite.id] = topSuite;\n    defaultResourcesForRunnable(topSuite.id);\n    currentDeclarationSuite = topSuite;\n\n    this.topSuite = function() {\n      return topSuite;\n    };\n\n    this.execute = function(runnablesToRun) {\n      if(!runnablesToRun) {\n        if (focusedRunnables.length) {\n          runnablesToRun = focusedRunnables;\n        } else {\n          runnablesToRun = [topSuite.id];\n        }\n      }\n\n      var order = new j$.Order({\n        random: random,\n        seed: seed\n      });\n\n      var processor = new j$.TreeProcessor({\n        tree: topSuite,\n        runnableIds: runnablesToRun,\n        queueRunnerFactory: queueRunnerFactory,\n        nodeStart: function(suite) {\n          currentlyExecutingSuites.push(suite);\n          defaultResourcesForRunnable(suite.id, suite.parentSuite.id);\n          reporter.suiteStarted(suite.result);\n        },\n        nodeComplete: function(suite, result) {\n          if (!suite.disabled) {\n            clearResourcesForRunnable(suite.id);\n          }\n          currentlyExecutingSuites.pop();\n          reporter.suiteDone(result);\n        },\n        orderChildren: function(node) {\n          return order.sort(node.children);\n        }\n      });\n\n      if(!processor.processTree().valid) {\n        throw new Error('Invalid order: would cause a beforeAll or afterAll to be run multiple times');\n      }\n\n      reporter.jasmineStarted({\n        totalSpecsDefined: totalSpecsDefined\n      });\n\n      processor.execute(function() {\n        reporter.jasmineDone({\n          order: order\n        });\n      });\n    };\n\n    this.addReporter = function(reporterToAdd) {\n      reporter.addReporter(reporterToAdd);\n    };\n\n    var spyRegistry = new j$.SpyRegistry({currentSpies: function() {\n      if(!currentRunnable()) {\n        throw new Error('Spies must be created in a before function or a spec');\n      }\n      return runnableResources[currentRunnable().id].spies;\n    }});\n\n    this.spyOn = function() {\n      return spyRegistry.spyOn.apply(spyRegistry, arguments);\n    };\n\n    var suiteFactory = function(description) {\n      var suite = new j$.Suite({\n        env: self,\n        id: getNextSuiteId(),\n        description: description,\n        parentSuite: currentDeclarationSuite,\n        expectationFactory: expectationFactory,\n        expectationResultFactory: expectationResultFactory,\n        throwOnExpectationFailure: throwOnExpectationFailure\n      });\n\n      runnableLookupTable[suite.id] = suite;\n      return suite;\n    };\n\n    this.describe = function(description, specDefinitions) {\n      var suite = suiteFactory(description);\n      if (specDefinitions.length > 0) {\n        throw new Error('describe does not expect a done parameter');\n      }\n      if (currentDeclarationSuite.markedPending) {\n        suite.pend();\n      }\n      addSpecsToSuite(suite, specDefinitions);\n      return suite;\n    };\n\n    this.xdescribe = function(description, specDefinitions) {\n      var suite = suiteFactory(description);\n      suite.pend();\n      addSpecsToSuite(suite, specDefinitions);\n      return suite;\n    };\n\n    var focusedRunnables = [];\n\n    this.fdescribe = function(description, specDefinitions) {\n      var suite = suiteFactory(description);\n      suite.isFocused = true;\n\n      focusedRunnables.push(suite.id);\n      unfocusAncestor();\n      addSpecsToSuite(suite, specDefinitions);\n\n      return suite;\n    };\n\n    function addSpecsToSuite(suite, specDefinitions) {\n      var parentSuite = currentDeclarationSuite;\n      parentSuite.addChild(suite);\n      currentDeclarationSuite = suite;\n\n      var declarationError = null;\n      try {\n        specDefinitions.call(suite);\n      } catch (e) {\n        declarationError = e;\n      }\n\n      if (declarationError) {\n        self.it('encountered a declaration exception', function() {\n          throw declarationError;\n        });\n      }\n\n      currentDeclarationSuite = parentSuite;\n    }\n\n    function findFocusedAncestor(suite) {\n      while (suite) {\n        if (suite.isFocused) {\n          return suite.id;\n        }\n        suite = suite.parentSuite;\n      }\n\n      return null;\n    }\n\n    function unfocusAncestor() {\n      var focusedAncestor = findFocusedAncestor(currentDeclarationSuite);\n      if (focusedAncestor) {\n        for (var i = 0; i < focusedRunnables.length; i++) {\n          if (focusedRunnables[i] === focusedAncestor) {\n            focusedRunnables.splice(i, 1);\n            break;\n          }\n        }\n      }\n    }\n\n    var specFactory = function(description, fn, suite, timeout) {\n      totalSpecsDefined++;\n      var spec = new j$.Spec({\n        id: getNextSpecId(),\n        beforeAndAfterFns: beforeAndAfterFns(suite),\n        expectationFactory: expectationFactory,\n        resultCallback: specResultCallback,\n        getSpecName: function(spec) {\n          return getSpecName(spec, suite);\n        },\n        onStart: specStarted,\n        description: description,\n        expectationResultFactory: expectationResultFactory,\n        queueRunnerFactory: queueRunnerFactory,\n        userContext: function() { return suite.clonedSharedUserContext(); },\n        queueableFn: {\n          fn: fn,\n          timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\n        },\n        throwOnExpectationFailure: throwOnExpectationFailure\n      });\n\n      runnableLookupTable[spec.id] = spec;\n\n      if (!self.specFilter(spec)) {\n        spec.disable();\n      }\n\n      return spec;\n\n      function specResultCallback(result) {\n        clearResourcesForRunnable(spec.id);\n        currentSpec = null;\n        reporter.specDone(result);\n      }\n\n      function specStarted(spec) {\n        currentSpec = spec;\n        defaultResourcesForRunnable(spec.id, suite.id);\n        reporter.specStarted(spec.result);\n      }\n    };\n\n    this.it = function(description, fn, timeout) {\n      var spec = specFactory(description, fn, currentDeclarationSuite, timeout);\n      if (currentDeclarationSuite.markedPending) {\n        spec.pend();\n      }\n      currentDeclarationSuite.addChild(spec);\n      return spec;\n    };\n\n    this.xit = function() {\n      var spec = this.it.apply(this, arguments);\n      spec.pend('Temporarily disabled with xit');\n      return spec;\n    };\n\n    this.fit = function(description, fn, timeout){\n      var spec = specFactory(description, fn, currentDeclarationSuite, timeout);\n      currentDeclarationSuite.addChild(spec);\n      focusedRunnables.push(spec.id);\n      unfocusAncestor();\n      return spec;\n    };\n\n    this.expect = function(actual) {\n      if (!currentRunnable()) {\n        throw new Error('\\'expect\\' was used when there was no current spec, this could be because an asynchronous test timed out');\n      }\n\n      return currentRunnable().expect(actual);\n    };\n\n    this.beforeEach = function(beforeEachFunction, timeout) {\n      currentDeclarationSuite.beforeEach({\n        fn: beforeEachFunction,\n        timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\n      });\n    };\n\n    this.beforeAll = function(beforeAllFunction, timeout) {\n      currentDeclarationSuite.beforeAll({\n        fn: beforeAllFunction,\n        timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\n      });\n    };\n\n    this.afterEach = function(afterEachFunction, timeout) {\n      currentDeclarationSuite.afterEach({\n        fn: afterEachFunction,\n        timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\n      });\n    };\n\n    this.afterAll = function(afterAllFunction, timeout) {\n      currentDeclarationSuite.afterAll({\n        fn: afterAllFunction,\n        timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\n      });\n    };\n\n    this.pending = function(message) {\n      var fullMessage = j$.Spec.pendingSpecExceptionMessage;\n      if(message) {\n        fullMessage += message;\n      }\n      throw fullMessage;\n    };\n\n    this.fail = function(error) {\n      var message = 'Failed';\n      if (error) {\n        message += ': ';\n        message += error.message || error;\n      }\n\n      currentRunnable().addExpectationResult(false, {\n        matcherName: '',\n        passed: false,\n        expected: '',\n        actual: '',\n        message: message,\n        error: error && error.message ? error : null\n      });\n    };\n  }\n\n  return Env;\n};\n\ngetJasmineRequireObj().JsApiReporter = function() {\n\n  var noopTimer = {\n    start: function(){},\n    elapsed: function(){ return 0; }\n  };\n\n  function JsApiReporter(options) {\n    var timer = options.timer || noopTimer,\n        status = 'loaded';\n\n    this.started = false;\n    this.finished = false;\n    this.runDetails = {};\n\n    this.jasmineStarted = function() {\n      this.started = true;\n      status = 'started';\n      timer.start();\n    };\n\n    var executionTime;\n\n    this.jasmineDone = function(runDetails) {\n      this.finished = true;\n      this.runDetails = runDetails;\n      executionTime = timer.elapsed();\n      status = 'done';\n    };\n\n    this.status = function() {\n      return status;\n    };\n\n    var suites = [],\n      suites_hash = {};\n\n    this.suiteStarted = function(result) {\n      suites_hash[result.id] = result;\n    };\n\n    this.suiteDone = function(result) {\n      storeSuite(result);\n    };\n\n    this.suiteResults = function(index, length) {\n      return suites.slice(index, index + length);\n    };\n\n    function storeSuite(result) {\n      suites.push(result);\n      suites_hash[result.id] = result;\n    }\n\n    this.suites = function() {\n      return suites_hash;\n    };\n\n    var specs = [];\n\n    this.specDone = function(result) {\n      specs.push(result);\n    };\n\n    this.specResults = function(index, length) {\n      return specs.slice(index, index + length);\n    };\n\n    this.specs = function() {\n      return specs;\n    };\n\n    this.executionTime = function() {\n      return executionTime;\n    };\n\n  }\n\n  return JsApiReporter;\n};\n\ngetJasmineRequireObj().CallTracker = function() {\n\n  function CallTracker() {\n    var calls = [];\n\n    this.track = function(context) {\n      calls.push(context);\n    };\n\n    this.any = function() {\n      return !!calls.length;\n    };\n\n    this.count = function() {\n      return calls.length;\n    };\n\n    this.argsFor = function(index) {\n      var call = calls[index];\n      return call ? call.args : [];\n    };\n\n    this.all = function() {\n      return calls;\n    };\n\n    this.allArgs = function() {\n      var callArgs = [];\n      for(var i = 0; i < calls.length; i++){\n        callArgs.push(calls[i].args);\n      }\n\n      return callArgs;\n    };\n\n    this.first = function() {\n      return calls[0];\n    };\n\n    this.mostRecent = function() {\n      return calls[calls.length - 1];\n    };\n\n    this.reset = function() {\n      calls = [];\n    };\n  }\n\n  return CallTracker;\n};\n\ngetJasmineRequireObj().Clock = function() {\n  function Clock(global, delayedFunctionSchedulerFactory, mockDate) {\n    var self = this,\n      realTimingFunctions = {\n        setTimeout: global.setTimeout,\n        clearTimeout: global.clearTimeout,\n        setInterval: global.setInterval,\n        clearInterval: global.clearInterval\n      },\n      fakeTimingFunctions = {\n        setTimeout: setTimeout,\n        clearTimeout: clearTimeout,\n        setInterval: setInterval,\n        clearInterval: clearInterval\n      },\n      installed = false,\n      delayedFunctionScheduler,\n      timer;\n\n\n    self.install = function() {\n      if(!originalTimingFunctionsIntact()) {\n        throw new Error('Jasmine Clock was unable to install over custom global timer functions. Is the clock already installed?');\n      }\n      replace(global, fakeTimingFunctions);\n      timer = fakeTimingFunctions;\n      delayedFunctionScheduler = delayedFunctionSchedulerFactory();\n      installed = true;\n\n      return self;\n    };\n\n    self.uninstall = function() {\n      delayedFunctionScheduler = null;\n      mockDate.uninstall();\n      replace(global, realTimingFunctions);\n\n      timer = realTimingFunctions;\n      installed = false;\n    };\n\n    self.withMock = function(closure) {\n      this.install();\n      try {\n        closure();\n      } finally {\n        this.uninstall();\n      }\n    };\n\n    self.mockDate = function(initialDate) {\n      mockDate.install(initialDate);\n    };\n\n    self.setTimeout = function(fn, delay, params) {\n      if (legacyIE()) {\n        if (arguments.length > 2) {\n          throw new Error('IE < 9 cannot support extra params to setTimeout without a polyfill');\n        }\n        return timer.setTimeout(fn, delay);\n      }\n      return Function.prototype.apply.apply(timer.setTimeout, [global, arguments]);\n    };\n\n    self.setInterval = function(fn, delay, params) {\n      if (legacyIE()) {\n        if (arguments.length > 2) {\n          throw new Error('IE < 9 cannot support extra params to setInterval without a polyfill');\n        }\n        return timer.setInterval(fn, delay);\n      }\n      return Function.prototype.apply.apply(timer.setInterval, [global, arguments]);\n    };\n\n    self.clearTimeout = function(id) {\n      return Function.prototype.call.apply(timer.clearTimeout, [global, id]);\n    };\n\n    self.clearInterval = function(id) {\n      return Function.prototype.call.apply(timer.clearInterval, [global, id]);\n    };\n\n    self.tick = function(millis) {\n      if (installed) {\n        mockDate.tick(millis);\n        delayedFunctionScheduler.tick(millis);\n      } else {\n        throw new Error('Mock clock is not installed, use jasmine.clock().install()');\n      }\n    };\n\n    return self;\n\n    function originalTimingFunctionsIntact() {\n      return global.setTimeout === realTimingFunctions.setTimeout &&\n        global.clearTimeout === realTimingFunctions.clearTimeout &&\n        global.setInterval === realTimingFunctions.setInterval &&\n        global.clearInterval === realTimingFunctions.clearInterval;\n    }\n\n    function legacyIE() {\n      //if these methods are polyfilled, apply will be present\n      return !(realTimingFunctions.setTimeout || realTimingFunctions.setInterval).apply;\n    }\n\n    function replace(dest, source) {\n      for (var prop in source) {\n        dest[prop] = source[prop];\n      }\n    }\n\n    function setTimeout(fn, delay) {\n      return delayedFunctionScheduler.scheduleFunction(fn, delay, argSlice(arguments, 2));\n    }\n\n    function clearTimeout(id) {\n      return delayedFunctionScheduler.removeFunctionWithId(id);\n    }\n\n    function setInterval(fn, interval) {\n      return delayedFunctionScheduler.scheduleFunction(fn, interval, argSlice(arguments, 2), true);\n    }\n\n    function clearInterval(id) {\n      return delayedFunctionScheduler.removeFunctionWithId(id);\n    }\n\n    function argSlice(argsObj, n) {\n      return Array.prototype.slice.call(argsObj, n);\n    }\n  }\n\n  return Clock;\n};\n\ngetJasmineRequireObj().DelayedFunctionScheduler = function() {\n  function DelayedFunctionScheduler() {\n    var self = this;\n    var scheduledLookup = [];\n    var scheduledFunctions = {};\n    var currentTime = 0;\n    var delayedFnCount = 0;\n\n    self.tick = function(millis) {\n      millis = millis || 0;\n      var endTime = currentTime + millis;\n\n      runScheduledFunctions(endTime);\n      currentTime = endTime;\n    };\n\n    self.scheduleFunction = function(funcToCall, millis, params, recurring, timeoutKey, runAtMillis) {\n      var f;\n      if (typeof(funcToCall) === 'string') {\n        /* jshint evil: true */\n        f = function() { return eval(funcToCall); };\n        /* jshint evil: false */\n      } else {\n        f = funcToCall;\n      }\n\n      millis = millis || 0;\n      timeoutKey = timeoutKey || ++delayedFnCount;\n      runAtMillis = runAtMillis || (currentTime + millis);\n\n      var funcToSchedule = {\n        runAtMillis: runAtMillis,\n        funcToCall: f,\n        recurring: recurring,\n        params: params,\n        timeoutKey: timeoutKey,\n        millis: millis\n      };\n\n      if (runAtMillis in scheduledFunctions) {\n        scheduledFunctions[runAtMillis].push(funcToSchedule);\n      } else {\n        scheduledFunctions[runAtMillis] = [funcToSchedule];\n        scheduledLookup.push(runAtMillis);\n        scheduledLookup.sort(function (a, b) {\n          return a - b;\n        });\n      }\n\n      return timeoutKey;\n    };\n\n    self.removeFunctionWithId = function(timeoutKey) {\n      for (var runAtMillis in scheduledFunctions) {\n        var funcs = scheduledFunctions[runAtMillis];\n        var i = indexOfFirstToPass(funcs, function (func) {\n          return func.timeoutKey === timeoutKey;\n        });\n\n        if (i > -1) {\n          if (funcs.length === 1) {\n            delete scheduledFunctions[runAtMillis];\n            deleteFromLookup(runAtMillis);\n          } else {\n            funcs.splice(i, 1);\n          }\n\n          // intervals get rescheduled when executed, so there's never more\n          // than a single scheduled function with a given timeoutKey\n          break;\n        }\n      }\n    };\n\n    return self;\n\n    function indexOfFirstToPass(array, testFn) {\n      var index = -1;\n\n      for (var i = 0; i < array.length; ++i) {\n        if (testFn(array[i])) {\n          index = i;\n          break;\n        }\n      }\n\n      return index;\n    }\n\n    function deleteFromLookup(key) {\n      var value = Number(key);\n      var i = indexOfFirstToPass(scheduledLookup, function (millis) {\n        return millis === value;\n      });\n\n      if (i > -1) {\n        scheduledLookup.splice(i, 1);\n      }\n    }\n\n    function reschedule(scheduledFn) {\n      self.scheduleFunction(scheduledFn.funcToCall,\n        scheduledFn.millis,\n        scheduledFn.params,\n        true,\n        scheduledFn.timeoutKey,\n        scheduledFn.runAtMillis + scheduledFn.millis);\n    }\n\n    function forEachFunction(funcsToRun, callback) {\n      for (var i = 0; i < funcsToRun.length; ++i) {\n        callback(funcsToRun[i]);\n      }\n    }\n\n    function runScheduledFunctions(endTime) {\n      if (scheduledLookup.length === 0 || scheduledLookup[0] > endTime) {\n        return;\n      }\n\n      do {\n        currentTime = scheduledLookup.shift();\n\n        var funcsToRun = scheduledFunctions[currentTime];\n        delete scheduledFunctions[currentTime];\n\n        forEachFunction(funcsToRun, function(funcToRun) {\n          if (funcToRun.recurring) {\n            reschedule(funcToRun);\n          }\n        });\n\n        forEachFunction(funcsToRun, function(funcToRun) {\n          funcToRun.funcToCall.apply(null, funcToRun.params || []);\n        });\n      } while (scheduledLookup.length > 0 &&\n              // checking first if we're out of time prevents setTimeout(0)\n              // scheduled in a funcToRun from forcing an extra iteration\n                 currentTime !== endTime  &&\n                 scheduledLookup[0] <= endTime);\n    }\n  }\n\n  return DelayedFunctionScheduler;\n};\n\ngetJasmineRequireObj().ExceptionFormatter = function() {\n  function ExceptionFormatter() {\n    this.message = function(error) {\n      var message = '';\n\n      if (error.name && error.message) {\n        message += error.name + ': ' + error.message;\n      } else {\n        message += error.toString() + ' thrown';\n      }\n\n      if (error.fileName || error.sourceURL) {\n        message += ' in ' + (error.fileName || error.sourceURL);\n      }\n\n      if (error.line || error.lineNumber) {\n        message += ' (line ' + (error.line || error.lineNumber) + ')';\n      }\n\n      return message;\n    };\n\n    this.stack = function(error) {\n      return error ? error.stack : null;\n    };\n  }\n\n  return ExceptionFormatter;\n};\n\ngetJasmineRequireObj().Expectation = function() {\n\n  function Expectation(options) {\n    this.util = options.util || { buildFailureMessage: function() {} };\n    this.customEqualityTesters = options.customEqualityTesters || [];\n    this.actual = options.actual;\n    this.addExpectationResult = options.addExpectationResult || function(){};\n    this.isNot = options.isNot;\n\n    var customMatchers = options.customMatchers || {};\n    for (var matcherName in customMatchers) {\n      this[matcherName] = Expectation.prototype.wrapCompare(matcherName, customMatchers[matcherName]);\n    }\n  }\n\n  Expectation.prototype.wrapCompare = function(name, matcherFactory) {\n    return function() {\n      var args = Array.prototype.slice.call(arguments, 0),\n        expected = args.slice(0),\n        message = '';\n\n      args.unshift(this.actual);\n\n      var matcher = matcherFactory(this.util, this.customEqualityTesters),\n          matcherCompare = matcher.compare;\n\n      function defaultNegativeCompare() {\n        var result = matcher.compare.apply(null, args);\n        result.pass = !result.pass;\n        return result;\n      }\n\n      if (this.isNot) {\n        matcherCompare = matcher.negativeCompare || defaultNegativeCompare;\n      }\n\n      var result = matcherCompare.apply(null, args);\n\n      if (!result.pass) {\n        if (!result.message) {\n          args.unshift(this.isNot);\n          args.unshift(name);\n          message = this.util.buildFailureMessage.apply(null, args);\n        } else {\n          if (Object.prototype.toString.apply(result.message) === '[object Function]') {\n            message = result.message();\n          } else {\n            message = result.message;\n          }\n        }\n      }\n\n      if (expected.length == 1) {\n        expected = expected[0];\n      }\n\n      // TODO: how many of these params are needed?\n      this.addExpectationResult(\n        result.pass,\n        {\n          matcherName: name,\n          passed: result.pass,\n          message: message,\n          actual: this.actual,\n          expected: expected // TODO: this may need to be arrayified/sliced\n        }\n      );\n    };\n  };\n\n  Expectation.addCoreMatchers = function(matchers) {\n    var prototype = Expectation.prototype;\n    for (var matcherName in matchers) {\n      var matcher = matchers[matcherName];\n      prototype[matcherName] = prototype.wrapCompare(matcherName, matcher);\n    }\n  };\n\n  Expectation.Factory = function(options) {\n    options = options || {};\n\n    var expect = new Expectation(options);\n\n    // TODO: this would be nice as its own Object - NegativeExpectation\n    // TODO: copy instead of mutate options\n    options.isNot = true;\n    expect.not = new Expectation(options);\n\n    return expect;\n  };\n\n  return Expectation;\n};\n\n//TODO: expectation result may make more sense as a presentation of an expectation.\ngetJasmineRequireObj().buildExpectationResult = function() {\n  function buildExpectationResult(options) {\n    var messageFormatter = options.messageFormatter || function() {},\n      stackFormatter = options.stackFormatter || function() {};\n\n    var result = {\n      matcherName: options.matcherName,\n      message: message(),\n      stack: stack(),\n      passed: options.passed\n    };\n\n    if(!result.passed) {\n      result.expected = options.expected;\n      result.actual = options.actual;\n    }\n\n    return result;\n\n    function message() {\n      if (options.passed) {\n        return 'Passed.';\n      } else if (options.message) {\n        return options.message;\n      } else if (options.error) {\n        return messageFormatter(options.error);\n      }\n      return '';\n    }\n\n    function stack() {\n      if (options.passed) {\n        return '';\n      }\n\n      var error = options.error;\n      if (!error) {\n        try {\n          throw new Error(message());\n        } catch (e) {\n          error = e;\n        }\n      }\n      return stackFormatter(error);\n    }\n  }\n\n  return buildExpectationResult;\n};\n\ngetJasmineRequireObj().MockDate = function() {\n  function MockDate(global) {\n    var self = this;\n    var currentTime = 0;\n\n    if (!global || !global.Date) {\n      self.install = function() {};\n      self.tick = function() {};\n      self.uninstall = function() {};\n      return self;\n    }\n\n    var GlobalDate = global.Date;\n\n    self.install = function(mockDate) {\n      if (mockDate instanceof GlobalDate) {\n        currentTime = mockDate.getTime();\n      } else {\n        currentTime = new GlobalDate().getTime();\n      }\n\n      global.Date = FakeDate;\n    };\n\n    self.tick = function(millis) {\n      millis = millis || 0;\n      currentTime = currentTime + millis;\n    };\n\n    self.uninstall = function() {\n      currentTime = 0;\n      global.Date = GlobalDate;\n    };\n\n    createDateProperties();\n\n    return self;\n\n    function FakeDate() {\n      switch(arguments.length) {\n        case 0:\n          return new GlobalDate(currentTime);\n        case 1:\n          return new GlobalDate(arguments[0]);\n        case 2:\n          return new GlobalDate(arguments[0], arguments[1]);\n        case 3:\n          return new GlobalDate(arguments[0], arguments[1], arguments[2]);\n        case 4:\n          return new GlobalDate(arguments[0], arguments[1], arguments[2], arguments[3]);\n        case 5:\n          return new GlobalDate(arguments[0], arguments[1], arguments[2], arguments[3],\n                                arguments[4]);\n        case 6:\n          return new GlobalDate(arguments[0], arguments[1], arguments[2], arguments[3],\n                                arguments[4], arguments[5]);\n        default:\n          return new GlobalDate(arguments[0], arguments[1], arguments[2], arguments[3],\n                                arguments[4], arguments[5], arguments[6]);\n      }\n    }\n\n    function createDateProperties() {\n      FakeDate.prototype = GlobalDate.prototype;\n\n      FakeDate.now = function() {\n        if (GlobalDate.now) {\n          return currentTime;\n        } else {\n          throw new Error('Browser does not support Date.now()');\n        }\n      };\n\n      FakeDate.toSource = GlobalDate.toSource;\n      FakeDate.toString = GlobalDate.toString;\n      FakeDate.parse = GlobalDate.parse;\n      FakeDate.UTC = GlobalDate.UTC;\n    }\n\t}\n\n  return MockDate;\n};\n\ngetJasmineRequireObj().pp = function(j$) {\n\n  function PrettyPrinter() {\n    this.ppNestLevel_ = 0;\n    this.seen = [];\n  }\n\n  PrettyPrinter.prototype.format = function(value) {\n    this.ppNestLevel_++;\n    try {\n      if (j$.util.isUndefined(value)) {\n        this.emitScalar('undefined');\n      } else if (value === null) {\n        this.emitScalar('null');\n      } else if (value === 0 && 1/value === -Infinity) {\n        this.emitScalar('-0');\n      } else if (value === j$.getGlobal()) {\n        this.emitScalar('<global>');\n      } else if (value.jasmineToString) {\n        this.emitScalar(value.jasmineToString());\n      } else if (typeof value === 'string') {\n        this.emitString(value);\n      } else if (j$.isSpy(value)) {\n        this.emitScalar('spy on ' + value.and.identity());\n      } else if (value instanceof RegExp) {\n        this.emitScalar(value.toString());\n      } else if (typeof value === 'function') {\n        this.emitScalar('Function');\n      } else if (typeof value.nodeType === 'number') {\n        this.emitScalar('HTMLNode');\n      } else if (value instanceof Date) {\n        this.emitScalar('Date(' + value + ')');\n      } else if (value.toString && typeof value === 'object' && !(value instanceof Array) && value.toString !== Object.prototype.toString) {\n        this.emitScalar(value.toString());\n      } else if (j$.util.arrayContains(this.seen, value)) {\n        this.emitScalar('<circular reference: ' + (j$.isArray_(value) ? 'Array' : 'Object') + '>');\n      } else if (j$.isArray_(value) || j$.isA_('Object', value)) {\n        this.seen.push(value);\n        if (j$.isArray_(value)) {\n          this.emitArray(value);\n        } else {\n          this.emitObject(value);\n        }\n        this.seen.pop();\n      } else {\n        this.emitScalar(value.toString());\n      }\n    } finally {\n      this.ppNestLevel_--;\n    }\n  };\n\n  PrettyPrinter.prototype.iterateObject = function(obj, fn) {\n    for (var property in obj) {\n      if (!Object.prototype.hasOwnProperty.call(obj, property)) { continue; }\n      fn(property, obj.__lookupGetter__ ? (!j$.util.isUndefined(obj.__lookupGetter__(property)) &&\n          obj.__lookupGetter__(property) !== null) : false);\n    }\n  };\n\n  PrettyPrinter.prototype.emitArray = j$.unimplementedMethod_;\n  PrettyPrinter.prototype.emitObject = j$.unimplementedMethod_;\n  PrettyPrinter.prototype.emitScalar = j$.unimplementedMethod_;\n  PrettyPrinter.prototype.emitString = j$.unimplementedMethod_;\n\n  function StringPrettyPrinter() {\n    PrettyPrinter.call(this);\n\n    this.string = '';\n  }\n\n  j$.util.inherit(StringPrettyPrinter, PrettyPrinter);\n\n  StringPrettyPrinter.prototype.emitScalar = function(value) {\n    this.append(value);\n  };\n\n  StringPrettyPrinter.prototype.emitString = function(value) {\n    this.append('\\'' + value + '\\'');\n  };\n\n  StringPrettyPrinter.prototype.emitArray = function(array) {\n    if (this.ppNestLevel_ > j$.MAX_PRETTY_PRINT_DEPTH) {\n      this.append('Array');\n      return;\n    }\n    var length = Math.min(array.length, j$.MAX_PRETTY_PRINT_ARRAY_LENGTH);\n    this.append('[ ');\n    for (var i = 0; i < length; i++) {\n      if (i > 0) {\n        this.append(', ');\n      }\n      this.format(array[i]);\n    }\n    if(array.length > length){\n      this.append(', ...');\n    }\n\n    var self = this;\n    var first = array.length === 0;\n    this.iterateObject(array, function(property, isGetter) {\n      if (property.match(/^\\d+$/)) {\n        return;\n      }\n\n      if (first) {\n        first = false;\n      } else {\n        self.append(', ');\n      }\n\n      self.formatProperty(array, property, isGetter);\n    });\n\n    this.append(' ]');\n  };\n\n  StringPrettyPrinter.prototype.emitObject = function(obj) {\n    var constructorName = obj.constructor ? j$.fnNameFor(obj.constructor) : 'null';\n    this.append(constructorName);\n\n    if (this.ppNestLevel_ > j$.MAX_PRETTY_PRINT_DEPTH) {\n      return;\n    }\n\n    var self = this;\n    this.append('({ ');\n    var first = true;\n\n    this.iterateObject(obj, function(property, isGetter) {\n      if (first) {\n        first = false;\n      } else {\n        self.append(', ');\n      }\n\n      self.formatProperty(obj, property, isGetter);\n    });\n\n    this.append(' })');\n  };\n\n  StringPrettyPrinter.prototype.formatProperty = function(obj, property, isGetter) {\n      this.append(property);\n      this.append(': ');\n      if (isGetter) {\n        this.append('<getter>');\n      } else {\n        this.format(obj[property]);\n      }\n  };\n\n  StringPrettyPrinter.prototype.append = function(value) {\n    this.string += value;\n  };\n\n  return function(value) {\n    var stringPrettyPrinter = new StringPrettyPrinter();\n    stringPrettyPrinter.format(value);\n    return stringPrettyPrinter.string;\n  };\n};\n\ngetJasmineRequireObj().QueueRunner = function(j$) {\n\n  function once(fn) {\n    var called = false;\n    return function() {\n      if (!called) {\n        called = true;\n        fn();\n      }\n    };\n  }\n\n  function QueueRunner(attrs) {\n    this.queueableFns = attrs.queueableFns || [];\n    this.onComplete = attrs.onComplete || function() {};\n    this.clearStack = attrs.clearStack || function(fn) {fn();};\n    this.onException = attrs.onException || function() {};\n    this.catchException = attrs.catchException || function() { return true; };\n    this.userContext = attrs.userContext || {};\n    this.timeout = attrs.timeout || {setTimeout: setTimeout, clearTimeout: clearTimeout};\n    this.fail = attrs.fail || function() {};\n  }\n\n  QueueRunner.prototype.execute = function() {\n    this.run(this.queueableFns, 0);\n  };\n\n  QueueRunner.prototype.run = function(queueableFns, recursiveIndex) {\n    var length = queueableFns.length,\n      self = this,\n      iterativeIndex;\n\n\n    for(iterativeIndex = recursiveIndex; iterativeIndex < length; iterativeIndex++) {\n      var queueableFn = queueableFns[iterativeIndex];\n      if (queueableFn.fn.length > 0) {\n        attemptAsync(queueableFn);\n        return;\n      } else {\n        attemptSync(queueableFn);\n      }\n    }\n\n    var runnerDone = iterativeIndex >= length;\n\n    if (runnerDone) {\n      this.clearStack(this.onComplete);\n    }\n\n    function attemptSync(queueableFn) {\n      try {\n        queueableFn.fn.call(self.userContext);\n      } catch (e) {\n        handleException(e, queueableFn);\n      }\n    }\n\n    function attemptAsync(queueableFn) {\n      var clearTimeout = function () {\n          Function.prototype.apply.apply(self.timeout.clearTimeout, [j$.getGlobal(), [timeoutId]]);\n        },\n        next = once(function () {\n          clearTimeout(timeoutId);\n          self.run(queueableFns, iterativeIndex + 1);\n        }),\n        timeoutId;\n\n      next.fail = function() {\n        self.fail.apply(null, arguments);\n        next();\n      };\n\n      if (queueableFn.timeout) {\n        timeoutId = Function.prototype.apply.apply(self.timeout.setTimeout, [j$.getGlobal(), [function() {\n          var error = new Error('Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL.');\n          onException(error);\n          next();\n        }, queueableFn.timeout()]]);\n      }\n\n      try {\n        queueableFn.fn.call(self.userContext, next);\n      } catch (e) {\n        handleException(e, queueableFn);\n        next();\n      }\n    }\n\n    function onException(e) {\n      self.onException(e);\n    }\n\n    function handleException(e, queueableFn) {\n      onException(e);\n      if (!self.catchException(e)) {\n        //TODO: set a var when we catch an exception and\n        //use a finally block to close the loop in a nice way..\n        throw e;\n      }\n    }\n  };\n\n  return QueueRunner;\n};\n\ngetJasmineRequireObj().ReportDispatcher = function() {\n  function ReportDispatcher(methods) {\n\n    var dispatchedMethods = methods || [];\n\n    for (var i = 0; i < dispatchedMethods.length; i++) {\n      var method = dispatchedMethods[i];\n      this[method] = (function(m) {\n        return function() {\n          dispatch(m, arguments);\n        };\n      }(method));\n    }\n\n    var reporters = [];\n\n    this.addReporter = function(reporter) {\n      reporters.push(reporter);\n    };\n\n    return this;\n\n    function dispatch(method, args) {\n      for (var i = 0; i < reporters.length; i++) {\n        var reporter = reporters[i];\n        if (reporter[method]) {\n          reporter[method].apply(reporter, args);\n        }\n      }\n    }\n  }\n\n  return ReportDispatcher;\n};\n\n\ngetJasmineRequireObj().SpyRegistry = function(j$) {\n\n  function SpyRegistry(options) {\n    options = options || {};\n    var currentSpies = options.currentSpies || function() { return []; };\n\n    this.spyOn = function(obj, methodName) {\n      if (j$.util.isUndefined(obj)) {\n        throw new Error('spyOn could not find an object to spy upon for ' + methodName + '()');\n      }\n\n      if (j$.util.isUndefined(methodName)) {\n        throw new Error('No method name supplied');\n      }\n\n      if (j$.util.isUndefined(obj[methodName])) {\n        throw new Error(methodName + '() method does not exist');\n      }\n\n      if (obj[methodName] && j$.isSpy(obj[methodName])) {\n        //TODO?: should this return the current spy? Downside: may cause user confusion about spy state\n        throw new Error(methodName + ' has already been spied upon');\n      }\n\n      var descriptor;\n      try {\n        descriptor = Object.getOwnPropertyDescriptor(obj, methodName);\n      } catch(e) {\n        // IE 8 doesn't support `definePropery` on non-DOM nodes\n      }\n\n      if (descriptor && !(descriptor.writable || descriptor.set)) {\n        throw new Error(methodName + ' is not declared writable or has no setter');\n      }\n\n      var spy = j$.createSpy(methodName, obj[methodName]);\n\n      currentSpies().push({\n        spy: spy,\n        baseObj: obj,\n        methodName: methodName,\n        originalValue: obj[methodName]\n      });\n\n      obj[methodName] = spy;\n\n      return spy;\n    };\n\n    this.clearSpies = function() {\n      var spies = currentSpies();\n      for (var i = 0; i < spies.length; i++) {\n        var spyEntry = spies[i];\n        spyEntry.baseObj[spyEntry.methodName] = spyEntry.originalValue;\n      }\n    };\n  }\n\n  return SpyRegistry;\n};\n\ngetJasmineRequireObj().SpyStrategy = function() {\n\n  function SpyStrategy(options) {\n    options = options || {};\n\n    var identity = options.name || 'unknown',\n        originalFn = options.fn || function() {},\n        getSpy = options.getSpy || function() {},\n        plan = function() {};\n\n    this.identity = function() {\n      return identity;\n    };\n\n    this.exec = function() {\n      return plan.apply(this, arguments);\n    };\n\n    this.callThrough = function() {\n      plan = originalFn;\n      return getSpy();\n    };\n\n    this.returnValue = function(value) {\n      plan = function() {\n        return value;\n      };\n      return getSpy();\n    };\n\n    this.returnValues = function() {\n      var values = Array.prototype.slice.call(arguments);\n      plan = function () {\n        return values.shift();\n      };\n      return getSpy();\n    };\n\n    this.throwError = function(something) {\n      var error = (something instanceof Error) ? something : new Error(something);\n      plan = function() {\n        throw error;\n      };\n      return getSpy();\n    };\n\n    this.callFake = function(fn) {\n      plan = fn;\n      return getSpy();\n    };\n\n    this.stub = function(fn) {\n      plan = function() {};\n      return getSpy();\n    };\n  }\n\n  return SpyStrategy;\n};\n\ngetJasmineRequireObj().Suite = function(j$) {\n  function Suite(attrs) {\n    this.env = attrs.env;\n    this.id = attrs.id;\n    this.parentSuite = attrs.parentSuite;\n    this.description = attrs.description;\n    this.expectationFactory = attrs.expectationFactory;\n    this.expectationResultFactory = attrs.expectationResultFactory;\n    this.throwOnExpectationFailure = !!attrs.throwOnExpectationFailure;\n\n    this.beforeFns = [];\n    this.afterFns = [];\n    this.beforeAllFns = [];\n    this.afterAllFns = [];\n    this.disabled = false;\n\n    this.children = [];\n\n    this.result = {\n      id: this.id,\n      description: this.description,\n      fullName: this.getFullName(),\n      failedExpectations: []\n    };\n  }\n\n  Suite.prototype.expect = function(actual) {\n    return this.expectationFactory(actual, this);\n  };\n\n  Suite.prototype.getFullName = function() {\n    var fullName = this.description;\n    for (var parentSuite = this.parentSuite; parentSuite; parentSuite = parentSuite.parentSuite) {\n      if (parentSuite.parentSuite) {\n        fullName = parentSuite.description + ' ' + fullName;\n      }\n    }\n    return fullName;\n  };\n\n  Suite.prototype.disable = function() {\n    this.disabled = true;\n  };\n\n  Suite.prototype.pend = function(message) {\n    this.markedPending = true;\n  };\n\n  Suite.prototype.beforeEach = function(fn) {\n    this.beforeFns.unshift(fn);\n  };\n\n  Suite.prototype.beforeAll = function(fn) {\n    this.beforeAllFns.push(fn);\n  };\n\n  Suite.prototype.afterEach = function(fn) {\n    this.afterFns.unshift(fn);\n  };\n\n  Suite.prototype.afterAll = function(fn) {\n    this.afterAllFns.push(fn);\n  };\n\n  Suite.prototype.addChild = function(child) {\n    this.children.push(child);\n  };\n\n  Suite.prototype.status = function() {\n    if (this.disabled) {\n      return 'disabled';\n    }\n\n    if (this.markedPending) {\n      return 'pending';\n    }\n\n    if (this.result.failedExpectations.length > 0) {\n      return 'failed';\n    } else {\n      return 'finished';\n    }\n  };\n\n  Suite.prototype.isExecutable = function() {\n    return !this.disabled;\n  };\n\n  Suite.prototype.canBeReentered = function() {\n    return this.beforeAllFns.length === 0 && this.afterAllFns.length === 0;\n  };\n\n  Suite.prototype.getResult = function() {\n    this.result.status = this.status();\n    return this.result;\n  };\n\n  Suite.prototype.sharedUserContext = function() {\n    if (!this.sharedContext) {\n      this.sharedContext = this.parentSuite ? clone(this.parentSuite.sharedUserContext()) : {};\n    }\n\n    return this.sharedContext;\n  };\n\n  Suite.prototype.clonedSharedUserContext = function() {\n    return clone(this.sharedUserContext());\n  };\n\n  Suite.prototype.onException = function() {\n    if (arguments[0] instanceof j$.errors.ExpectationFailed) {\n      return;\n    }\n\n    if(isAfterAll(this.children)) {\n      var data = {\n        matcherName: '',\n        passed: false,\n        expected: '',\n        actual: '',\n        error: arguments[0]\n      };\n      this.result.failedExpectations.push(this.expectationResultFactory(data));\n    } else {\n      for (var i = 0; i < this.children.length; i++) {\n        var child = this.children[i];\n        child.onException.apply(child, arguments);\n      }\n    }\n  };\n\n  Suite.prototype.addExpectationResult = function () {\n    if(isAfterAll(this.children) && isFailure(arguments)){\n      var data = arguments[1];\n      this.result.failedExpectations.push(this.expectationResultFactory(data));\n      if(this.throwOnExpectationFailure) {\n        throw new j$.errors.ExpectationFailed();\n      }\n    } else {\n      for (var i = 0; i < this.children.length; i++) {\n        var child = this.children[i];\n        try {\n          child.addExpectationResult.apply(child, arguments);\n        } catch(e) {\n          // keep going\n        }\n      }\n    }\n  };\n\n  function isAfterAll(children) {\n    return children && children[0].result.status;\n  }\n\n  function isFailure(args) {\n    return !args[0];\n  }\n\n  function clone(obj) {\n    var clonedObj = {};\n    for (var prop in obj) {\n      if (obj.hasOwnProperty(prop)) {\n        clonedObj[prop] = obj[prop];\n      }\n    }\n\n    return clonedObj;\n  }\n\n  return Suite;\n};\n\nif (typeof window == void 0 && typeof exports == 'object') {\n  exports.Suite = jasmineRequire.Suite;\n}\n\ngetJasmineRequireObj().Timer = function() {\n  var defaultNow = (function(Date) {\n    return function() { return new Date().getTime(); };\n  })(Date);\n\n  function Timer(options) {\n    options = options || {};\n\n    var now = options.now || defaultNow,\n      startTime;\n\n    this.start = function() {\n      startTime = now();\n    };\n\n    this.elapsed = function() {\n      return now() - startTime;\n    };\n  }\n\n  return Timer;\n};\n\ngetJasmineRequireObj().TreeProcessor = function() {\n  function TreeProcessor(attrs) {\n    var tree = attrs.tree,\n        runnableIds = attrs.runnableIds,\n        queueRunnerFactory = attrs.queueRunnerFactory,\n        nodeStart = attrs.nodeStart || function() {},\n        nodeComplete = attrs.nodeComplete || function() {},\n        orderChildren = attrs.orderChildren || function(node) { return node.children; },\n        stats = { valid: true },\n        processed = false,\n        defaultMin = Infinity,\n        defaultMax = 1 - Infinity;\n\n    this.processTree = function() {\n      processNode(tree, false);\n      processed = true;\n      return stats;\n    };\n\n    this.execute = function(done) {\n      if (!processed) {\n        this.processTree();\n      }\n\n      if (!stats.valid) {\n        throw 'invalid order';\n      }\n\n      var childFns = wrapChildren(tree, 0);\n\n      queueRunnerFactory({\n        queueableFns: childFns,\n        userContext: tree.sharedUserContext(),\n        onException: function() {\n          tree.onException.apply(tree, arguments);\n        },\n        onComplete: done\n      });\n    };\n\n    function runnableIndex(id) {\n      for (var i = 0; i < runnableIds.length; i++) {\n        if (runnableIds[i] === id) {\n          return i;\n        }\n      }\n    }\n\n    function processNode(node, parentEnabled) {\n      var executableIndex = runnableIndex(node.id);\n\n      if (executableIndex !== undefined) {\n        parentEnabled = true;\n      }\n\n      parentEnabled = parentEnabled && node.isExecutable();\n\n      if (!node.children) {\n        stats[node.id] = {\n          executable: parentEnabled && node.isExecutable(),\n          segments: [{\n            index: 0,\n            owner: node,\n            nodes: [node],\n            min: startingMin(executableIndex),\n            max: startingMax(executableIndex)\n          }]\n        };\n      } else {\n        var hasExecutableChild = false;\n\n        var orderedChildren = orderChildren(node);\n\n        for (var i = 0; i < orderedChildren.length; i++) {\n          var child = orderedChildren[i];\n\n          processNode(child, parentEnabled);\n\n          if (!stats.valid) {\n            return;\n          }\n\n          var childStats = stats[child.id];\n\n          hasExecutableChild = hasExecutableChild || childStats.executable;\n        }\n\n        stats[node.id] = {\n          executable: hasExecutableChild\n        };\n\n        segmentChildren(node, orderedChildren, stats[node.id], executableIndex);\n\n        if (!node.canBeReentered() && stats[node.id].segments.length > 1) {\n          stats = { valid: false };\n        }\n      }\n    }\n\n    function startingMin(executableIndex) {\n      return executableIndex === undefined ? defaultMin : executableIndex;\n    }\n\n    function startingMax(executableIndex) {\n      return executableIndex === undefined ? defaultMax : executableIndex;\n    }\n\n    function segmentChildren(node, orderedChildren, nodeStats, executableIndex) {\n      var currentSegment = { index: 0, owner: node, nodes: [], min: startingMin(executableIndex), max: startingMax(executableIndex) },\n          result = [currentSegment],\n          lastMax = defaultMax,\n          orderedChildSegments = orderChildSegments(orderedChildren);\n\n      function isSegmentBoundary(minIndex) {\n        return lastMax !== defaultMax && minIndex !== defaultMin && lastMax < minIndex - 1;\n      }\n\n      for (var i = 0; i < orderedChildSegments.length; i++) {\n        var childSegment = orderedChildSegments[i],\n          maxIndex = childSegment.max,\n          minIndex = childSegment.min;\n\n        if (isSegmentBoundary(minIndex)) {\n          currentSegment = {index: result.length, owner: node, nodes: [], min: defaultMin, max: defaultMax};\n          result.push(currentSegment);\n        }\n\n        currentSegment.nodes.push(childSegment);\n        currentSegment.min = Math.min(currentSegment.min, minIndex);\n        currentSegment.max = Math.max(currentSegment.max, maxIndex);\n        lastMax = maxIndex;\n      }\n\n      nodeStats.segments = result;\n    }\n\n    function orderChildSegments(children) {\n      var specifiedOrder = [],\n          unspecifiedOrder = [];\n\n      for (var i = 0; i < children.length; i++) {\n        var child = children[i],\n            segments = stats[child.id].segments;\n\n        for (var j = 0; j < segments.length; j++) {\n          var seg = segments[j];\n\n          if (seg.min === defaultMin) {\n            unspecifiedOrder.push(seg);\n          } else {\n            specifiedOrder.push(seg);\n          }\n        }\n      }\n\n      specifiedOrder.sort(function(a, b) {\n        return a.min - b.min;\n      });\n\n      return specifiedOrder.concat(unspecifiedOrder);\n    }\n\n    function executeNode(node, segmentNumber) {\n      if (node.children) {\n        return {\n          fn: function(done) {\n            nodeStart(node);\n\n            queueRunnerFactory({\n              onComplete: function() {\n                nodeComplete(node, node.getResult());\n                done();\n              },\n              queueableFns: wrapChildren(node, segmentNumber),\n              userContext: node.sharedUserContext(),\n              onException: function() {\n                node.onException.apply(node, arguments);\n              }\n            });\n          }\n        };\n      } else {\n        return {\n          fn: function(done) { node.execute(done, stats[node.id].executable); }\n        };\n      }\n    }\n\n    function wrapChildren(node, segmentNumber) {\n      var result = [],\n          segmentChildren = stats[node.id].segments[segmentNumber].nodes;\n\n      for (var i = 0; i < segmentChildren.length; i++) {\n        result.push(executeNode(segmentChildren[i].owner, segmentChildren[i].index));\n      }\n\n      if (!stats[node.id].executable) {\n        return result;\n      }\n\n      return node.beforeAllFns.concat(result).concat(node.afterAllFns);\n    }\n  }\n\n  return TreeProcessor;\n};\n\ngetJasmineRequireObj().Any = function(j$) {\n\n  function Any(expectedObject) {\n    if (typeof expectedObject === 'undefined') {\n      throw new TypeError(\n        'jasmine.any() expects to be passed a constructor function. ' +\n        'Please pass one or use jasmine.anything() to match any object.'\n      );\n    }\n    this.expectedObject = expectedObject;\n  }\n\n  Any.prototype.asymmetricMatch = function(other) {\n    if (this.expectedObject == String) {\n      return typeof other == 'string' || other instanceof String;\n    }\n\n    if (this.expectedObject == Number) {\n      return typeof other == 'number' || other instanceof Number;\n    }\n\n    if (this.expectedObject == Function) {\n      return typeof other == 'function' || other instanceof Function;\n    }\n\n    if (this.expectedObject == Object) {\n      return typeof other == 'object';\n    }\n\n    if (this.expectedObject == Boolean) {\n      return typeof other == 'boolean';\n    }\n\n    return other instanceof this.expectedObject;\n  };\n\n  Any.prototype.jasmineToString = function() {\n    return '<jasmine.any(' + j$.fnNameFor(this.expectedObject) + ')>';\n  };\n\n  return Any;\n};\n\ngetJasmineRequireObj().Anything = function(j$) {\n\n  function Anything() {}\n\n  Anything.prototype.asymmetricMatch = function(other) {\n    return !j$.util.isUndefined(other) && other !== null;\n  };\n\n  Anything.prototype.jasmineToString = function() {\n    return '<jasmine.anything>';\n  };\n\n  return Anything;\n};\n\ngetJasmineRequireObj().ArrayContaining = function(j$) {\n  function ArrayContaining(sample) {\n    this.sample = sample;\n  }\n\n  ArrayContaining.prototype.asymmetricMatch = function(other) {\n    var className = Object.prototype.toString.call(this.sample);\n    if (className !== '[object Array]') { throw new Error('You must provide an array to arrayContaining, not \\'' + this.sample + '\\'.'); }\n\n    for (var i = 0; i < this.sample.length; i++) {\n      var item = this.sample[i];\n      if (!j$.matchersUtil.contains(other, item)) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  ArrayContaining.prototype.jasmineToString = function () {\n    return '<jasmine.arrayContaining(' + jasmine.pp(this.sample) +')>';\n  };\n\n  return ArrayContaining;\n};\n\ngetJasmineRequireObj().ObjectContaining = function(j$) {\n\n  function ObjectContaining(sample) {\n    this.sample = sample;\n  }\n\n  function getPrototype(obj) {\n    if (Object.getPrototypeOf) {\n      return Object.getPrototypeOf(obj);\n    }\n\n    if (obj.constructor.prototype == obj) {\n      return null;\n    }\n\n    return obj.constructor.prototype;\n  }\n\n  function hasProperty(obj, property) {\n    if (!obj) {\n      return false;\n    }\n\n    if (Object.prototype.hasOwnProperty.call(obj, property)) {\n      return true;\n    }\n\n    return hasProperty(getPrototype(obj), property);\n  }\n\n  ObjectContaining.prototype.asymmetricMatch = function(other) {\n    if (typeof(this.sample) !== 'object') { throw new Error('You must provide an object to objectContaining, not \\''+this.sample+'\\'.'); }\n\n    for (var property in this.sample) {\n      if (!hasProperty(other, property) ||\n          !j$.matchersUtil.equals(this.sample[property], other[property])) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  ObjectContaining.prototype.jasmineToString = function() {\n    return '<jasmine.objectContaining(' + j$.pp(this.sample) + ')>';\n  };\n\n  return ObjectContaining;\n};\n\ngetJasmineRequireObj().StringMatching = function(j$) {\n\n  function StringMatching(expected) {\n    if (!j$.isString_(expected) && !j$.isA_('RegExp', expected)) {\n      throw new Error('Expected is not a String or a RegExp');\n    }\n\n    this.regexp = new RegExp(expected);\n  }\n\n  StringMatching.prototype.asymmetricMatch = function(other) {\n    return this.regexp.test(other);\n  };\n\n  StringMatching.prototype.jasmineToString = function() {\n    return '<jasmine.stringMatching(' + this.regexp + ')>';\n  };\n\n  return StringMatching;\n};\n\ngetJasmineRequireObj().errors = function() {\n  function ExpectationFailed() {}\n\n  ExpectationFailed.prototype = new Error();\n  ExpectationFailed.prototype.constructor = ExpectationFailed;\n\n  return {\n    ExpectationFailed: ExpectationFailed\n  };\n};\ngetJasmineRequireObj().matchersUtil = function(j$) {\n  // TODO: what to do about jasmine.pp not being inject? move to JSON.stringify? gut PrettyPrinter?\n\n  return {\n    equals: function(a, b, customTesters) {\n      customTesters = customTesters || [];\n\n      return eq(a, b, [], [], customTesters);\n    },\n\n    contains: function(haystack, needle, customTesters) {\n      customTesters = customTesters || [];\n\n      if ((Object.prototype.toString.apply(haystack) === '[object Array]') ||\n        (!!haystack && !haystack.indexOf))\n      {\n        for (var i = 0; i < haystack.length; i++) {\n          if (eq(haystack[i], needle, [], [], customTesters)) {\n            return true;\n          }\n        }\n        return false;\n      }\n\n      return !!haystack && haystack.indexOf(needle) >= 0;\n    },\n\n    buildFailureMessage: function() {\n      var args = Array.prototype.slice.call(arguments, 0),\n        matcherName = args[0],\n        isNot = args[1],\n        actual = args[2],\n        expected = args.slice(3),\n        englishyPredicate = matcherName.replace(/[A-Z]/g, function(s) { return ' ' + s.toLowerCase(); });\n\n      var message = 'Expected ' +\n        j$.pp(actual) +\n        (isNot ? ' not ' : ' ') +\n        englishyPredicate;\n\n      if (expected.length > 0) {\n        for (var i = 0; i < expected.length; i++) {\n          if (i > 0) {\n            message += ',';\n          }\n          message += ' ' + j$.pp(expected[i]);\n        }\n      }\n\n      return message + '.';\n    }\n  };\n\n  function isAsymmetric(obj) {\n    return obj && j$.isA_('Function', obj.asymmetricMatch);\n  }\n\n  function asymmetricMatch(a, b) {\n    var asymmetricA = isAsymmetric(a),\n        asymmetricB = isAsymmetric(b);\n\n    if (asymmetricA && asymmetricB) {\n      return undefined;\n    }\n\n    if (asymmetricA) {\n      return a.asymmetricMatch(b);\n    }\n\n    if (asymmetricB) {\n      return b.asymmetricMatch(a);\n    }\n  }\n\n  // Equality function lovingly adapted from isEqual in\n  //   [Underscore](http://underscorejs.org)\n  function eq(a, b, aStack, bStack, customTesters) {\n    var result = true;\n\n    var asymmetricResult = asymmetricMatch(a, b);\n    if (!j$.util.isUndefined(asymmetricResult)) {\n      return asymmetricResult;\n    }\n\n    for (var i = 0; i < customTesters.length; i++) {\n      var customTesterResult = customTesters[i](a, b);\n      if (!j$.util.isUndefined(customTesterResult)) {\n        return customTesterResult;\n      }\n    }\n\n    if (a instanceof Error && b instanceof Error) {\n      return a.message == b.message;\n    }\n\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\n    if (a === b) { return a !== 0 || 1 / a == 1 / b; }\n    // A strict comparison is necessary because `null == undefined`.\n    if (a === null || b === null) { return a === b; }\n    var className = Object.prototype.toString.call(a);\n    if (className != Object.prototype.toString.call(b)) { return false; }\n    switch (className) {\n      // Strings, numbers, dates, and booleans are compared by value.\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return a == String(b);\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\n        // other numeric values.\n        return a != +a ? b != +b : (a === 0 ? 1 / a == 1 / b : a == +b);\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a == +b;\n      // RegExps are compared by their source patterns and flags.\n      case '[object RegExp]':\n        return a.source == b.source &&\n          a.global == b.global &&\n          a.multiline == b.multiline &&\n          a.ignoreCase == b.ignoreCase;\n    }\n    if (typeof a != 'object' || typeof b != 'object') { return false; }\n\n    var aIsDomNode = j$.isDomNode(a);\n    var bIsDomNode = j$.isDomNode(b);\n    if (aIsDomNode && bIsDomNode) {\n      // At first try to use DOM3 method isEqualNode\n      if (a.isEqualNode) {\n        return a.isEqualNode(b);\n      }\n      // IE8 doesn't support isEqualNode, try to use outerHTML && innerText\n      var aIsElement = a instanceof Element;\n      var bIsElement = b instanceof Element;\n      if (aIsElement && bIsElement) {\n        return a.outerHTML == b.outerHTML;\n      }\n      if (aIsElement || bIsElement) {\n        return false;\n      }\n      return a.innerText == b.innerText && a.textContent == b.textContent;\n    }\n    if (aIsDomNode || bIsDomNode) {\n      return false;\n    }\n\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n    var length = aStack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (aStack[length] == a) { return bStack[length] == b; }\n    }\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n    var size = 0;\n    // Recursively compare objects and arrays.\n    // Compare array lengths to determine if a deep comparison is necessary.\n    if (className == '[object Array]' && a.length !== b.length) {\n      result = false;\n    }\n\n    if (result) {\n      // Objects with different constructors are not equivalent, but `Object`s\n      // or `Array`s from different frames are.\n      if (className !== '[object Array]') {\n        var aCtor = a.constructor, bCtor = b.constructor;\n        if (aCtor !== bCtor && !(isFunction(aCtor) && aCtor instanceof aCtor &&\n               isFunction(bCtor) && bCtor instanceof bCtor)) {\n          return false;\n        }\n      }\n      // Deep compare objects.\n      for (var key in a) {\n        if (has(a, key)) {\n          // Count the expected number of properties.\n          size++;\n          // Deep compare each member.\n          if (!(result = has(b, key) && eq(a[key], b[key], aStack, bStack, customTesters))) { break; }\n        }\n      }\n      // Ensure that both objects contain the same number of properties.\n      if (result) {\n        for (key in b) {\n          if (has(b, key) && !(size--)) { break; }\n        }\n        result = !size;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n\n    return result;\n\n    function has(obj, key) {\n      return Object.prototype.hasOwnProperty.call(obj, key);\n    }\n\n    function isFunction(obj) {\n      return typeof obj === 'function';\n    }\n  }\n};\n\ngetJasmineRequireObj().toBe = function() {\n  function toBe() {\n    return {\n      compare: function(actual, expected) {\n        return {\n          pass: actual === expected\n        };\n      }\n    };\n  }\n\n  return toBe;\n};\n\ngetJasmineRequireObj().toBeCloseTo = function() {\n\n  function toBeCloseTo() {\n    return {\n      compare: function(actual, expected, precision) {\n        if (precision !== 0) {\n          precision = precision || 2;\n        }\n\n        return {\n          pass: Math.abs(expected - actual) < (Math.pow(10, -precision) / 2)\n        };\n      }\n    };\n  }\n\n  return toBeCloseTo;\n};\n\ngetJasmineRequireObj().toBeDefined = function() {\n  function toBeDefined() {\n    return {\n      compare: function(actual) {\n        return {\n          pass: (void 0 !== actual)\n        };\n      }\n    };\n  }\n\n  return toBeDefined;\n};\n\ngetJasmineRequireObj().toBeFalsy = function() {\n  function toBeFalsy() {\n    return {\n      compare: function(actual) {\n        return {\n          pass: !!!actual\n        };\n      }\n    };\n  }\n\n  return toBeFalsy;\n};\n\ngetJasmineRequireObj().toBeGreaterThan = function() {\n\n  function toBeGreaterThan() {\n    return {\n      compare: function(actual, expected) {\n        return {\n          pass: actual > expected\n        };\n      }\n    };\n  }\n\n  return toBeGreaterThan;\n};\n\n\ngetJasmineRequireObj().toBeLessThan = function() {\n  function toBeLessThan() {\n    return {\n\n      compare: function(actual, expected) {\n        return {\n          pass: actual < expected\n        };\n      }\n    };\n  }\n\n  return toBeLessThan;\n};\ngetJasmineRequireObj().toBeNaN = function(j$) {\n\n  function toBeNaN() {\n    return {\n      compare: function(actual) {\n        var result = {\n          pass: (actual !== actual)\n        };\n\n        if (result.pass) {\n          result.message = 'Expected actual not to be NaN.';\n        } else {\n          result.message = function() { return 'Expected ' + j$.pp(actual) + ' to be NaN.'; };\n        }\n\n        return result;\n      }\n    };\n  }\n\n  return toBeNaN;\n};\n\ngetJasmineRequireObj().toBeNull = function() {\n\n  function toBeNull() {\n    return {\n      compare: function(actual) {\n        return {\n          pass: actual === null\n        };\n      }\n    };\n  }\n\n  return toBeNull;\n};\n\ngetJasmineRequireObj().toBeTruthy = function() {\n\n  function toBeTruthy() {\n    return {\n      compare: function(actual) {\n        return {\n          pass: !!actual\n        };\n      }\n    };\n  }\n\n  return toBeTruthy;\n};\n\ngetJasmineRequireObj().toBeUndefined = function() {\n\n  function toBeUndefined() {\n    return {\n      compare: function(actual) {\n        return {\n          pass: void 0 === actual\n        };\n      }\n    };\n  }\n\n  return toBeUndefined;\n};\n\ngetJasmineRequireObj().toContain = function() {\n  function toContain(util, customEqualityTesters) {\n    customEqualityTesters = customEqualityTesters || [];\n\n    return {\n      compare: function(actual, expected) {\n\n        return {\n          pass: util.contains(actual, expected, customEqualityTesters)\n        };\n      }\n    };\n  }\n\n  return toContain;\n};\n\ngetJasmineRequireObj().toEqual = function() {\n\n  function toEqual(util, customEqualityTesters) {\n    customEqualityTesters = customEqualityTesters || [];\n\n    return {\n      compare: function(actual, expected) {\n        var result = {\n          pass: false\n        };\n\n        result.pass = util.equals(actual, expected, customEqualityTesters);\n\n        return result;\n      }\n    };\n  }\n\n  return toEqual;\n};\n\ngetJasmineRequireObj().toHaveBeenCalled = function(j$) {\n\n  function toHaveBeenCalled() {\n    return {\n      compare: function(actual) {\n        var result = {};\n\n        if (!j$.isSpy(actual)) {\n          throw new Error('Expected a spy, but got ' + j$.pp(actual) + '.');\n        }\n\n        if (arguments.length > 1) {\n          throw new Error('toHaveBeenCalled does not take arguments, use toHaveBeenCalledWith');\n        }\n\n        result.pass = actual.calls.any();\n\n        result.message = result.pass ?\n          'Expected spy ' + actual.and.identity() + ' not to have been called.' :\n          'Expected spy ' + actual.and.identity() + ' to have been called.';\n\n        return result;\n      }\n    };\n  }\n\n  return toHaveBeenCalled;\n};\n\ngetJasmineRequireObj().toHaveBeenCalledTimes = function(j$) {\n\n  function toHaveBeenCalledTimes() {\n    return {\n      compare: function(actual, expected) {\n        if (!j$.isSpy(actual)) {\n          throw new Error('Expected a spy, but got ' + j$.pp(actual) + '.');\n        }\n\n        var args = Array.prototype.slice.call(arguments, 0),\n          result = { pass: false };\n\n        if(!expected){\n          throw new Error('Expected times failed is required as an argument.');\n        }\n\n        actual = args[0];\n        var calls = actual.calls.count();\n        var timesMessage = expected === 1 ? 'once' : expected + ' times';\n        result.pass = calls === expected;\n        result.message = result.pass ?\n          'Expected spy ' + actual.and.identity() + ' not to have been called ' + timesMessage + '. It was called ' +  calls + ' times.' :\n          'Expected spy ' + actual.and.identity() + ' to have been called ' + timesMessage + '. It was called ' +  calls + ' times.';\n        return result;\n      }\n    };\n  }\n\n  return toHaveBeenCalledTimes;\n};\n\ngetJasmineRequireObj().toHaveBeenCalledWith = function(j$) {\n\n  function toHaveBeenCalledWith(util, customEqualityTesters) {\n    return {\n      compare: function() {\n        var args = Array.prototype.slice.call(arguments, 0),\n          actual = args[0],\n          expectedArgs = args.slice(1),\n          result = { pass: false };\n\n        if (!j$.isSpy(actual)) {\n          throw new Error('Expected a spy, but got ' + j$.pp(actual) + '.');\n        }\n\n        if (!actual.calls.any()) {\n          result.message = function() { return 'Expected spy ' + actual.and.identity() + ' to have been called with ' + j$.pp(expectedArgs) + ' but it was never called.'; };\n          return result;\n        }\n\n        if (util.contains(actual.calls.allArgs(), expectedArgs, customEqualityTesters)) {\n          result.pass = true;\n          result.message = function() { return 'Expected spy ' + actual.and.identity() + ' not to have been called with ' + j$.pp(expectedArgs) + ' but it was.'; };\n        } else {\n          result.message = function() { return 'Expected spy ' + actual.and.identity() + ' to have been called with ' + j$.pp(expectedArgs) + ' but actual calls were ' + j$.pp(actual.calls.allArgs()).replace(/^\\[ | \\]$/g, '') + '.'; };\n        }\n\n        return result;\n      }\n    };\n  }\n\n  return toHaveBeenCalledWith;\n};\n\ngetJasmineRequireObj().toMatch = function(j$) {\n\n  function toMatch() {\n    return {\n      compare: function(actual, expected) {\n        if (!j$.isString_(expected) && !j$.isA_('RegExp', expected)) {\n          throw new Error('Expected is not a String or a RegExp');\n        }\n\n        var regexp = new RegExp(expected);\n\n        return {\n          pass: regexp.test(actual)\n        };\n      }\n    };\n  }\n\n  return toMatch;\n};\n\ngetJasmineRequireObj().toThrow = function(j$) {\n\n  function toThrow(util) {\n    return {\n      compare: function(actual, expected) {\n        var result = { pass: false },\n          threw = false,\n          thrown;\n\n        if (typeof actual != 'function') {\n          throw new Error('Actual is not a Function');\n        }\n\n        try {\n          actual();\n        } catch (e) {\n          threw = true;\n          thrown = e;\n        }\n\n        if (!threw) {\n          result.message = 'Expected function to throw an exception.';\n          return result;\n        }\n\n        if (arguments.length == 1) {\n          result.pass = true;\n          result.message = function() { return 'Expected function not to throw, but it threw ' + j$.pp(thrown) + '.'; };\n\n          return result;\n        }\n\n        if (util.equals(thrown, expected)) {\n          result.pass = true;\n          result.message = function() { return 'Expected function not to throw ' + j$.pp(expected) + '.'; };\n        } else {\n          result.message = function() { return 'Expected function to throw ' + j$.pp(expected) + ', but it threw ' +  j$.pp(thrown) + '.'; };\n        }\n\n        return result;\n      }\n    };\n  }\n\n  return toThrow;\n};\n\ngetJasmineRequireObj().toThrowError = function(j$) {\n  function toThrowError () {\n    return {\n      compare: function(actual) {\n        var threw = false,\n          pass = {pass: true},\n          fail = {pass: false},\n          thrown;\n\n        if (typeof actual != 'function') {\n          throw new Error('Actual is not a Function');\n        }\n\n        var errorMatcher = getMatcher.apply(null, arguments);\n\n        try {\n          actual();\n        } catch (e) {\n          threw = true;\n          thrown = e;\n        }\n\n        if (!threw) {\n          fail.message = 'Expected function to throw an Error.';\n          return fail;\n        }\n\n        if (!(thrown instanceof Error)) {\n          fail.message = function() { return 'Expected function to throw an Error, but it threw ' + j$.pp(thrown) + '.'; };\n          return fail;\n        }\n\n        if (errorMatcher.hasNoSpecifics()) {\n          pass.message = 'Expected function not to throw an Error, but it threw ' + j$.fnNameFor(thrown) + '.';\n          return pass;\n        }\n\n        if (errorMatcher.matches(thrown)) {\n          pass.message = function() {\n            return 'Expected function not to throw ' + errorMatcher.errorTypeDescription + errorMatcher.messageDescription() + '.';\n          };\n          return pass;\n        } else {\n          fail.message = function() {\n            return 'Expected function to throw ' + errorMatcher.errorTypeDescription + errorMatcher.messageDescription() +\n              ', but it threw ' + errorMatcher.thrownDescription(thrown) + '.';\n          };\n          return fail;\n        }\n      }\n    };\n\n    function getMatcher() {\n      var expected = null,\n          errorType = null;\n\n      if (arguments.length == 2) {\n        expected = arguments[1];\n        if (isAnErrorType(expected)) {\n          errorType = expected;\n          expected = null;\n        }\n      } else if (arguments.length > 2) {\n        errorType = arguments[1];\n        expected = arguments[2];\n        if (!isAnErrorType(errorType)) {\n          throw new Error('Expected error type is not an Error.');\n        }\n      }\n\n      if (expected && !isStringOrRegExp(expected)) {\n        if (errorType) {\n          throw new Error('Expected error message is not a string or RegExp.');\n        } else {\n          throw new Error('Expected is not an Error, string, or RegExp.');\n        }\n      }\n\n      function messageMatch(message) {\n        if (typeof expected == 'string') {\n          return expected == message;\n        } else {\n          return expected.test(message);\n        }\n      }\n\n      return {\n        errorTypeDescription: errorType ? j$.fnNameFor(errorType) : 'an exception',\n        thrownDescription: function(thrown) {\n          var thrownName = errorType ? j$.fnNameFor(thrown.constructor) : 'an exception',\n              thrownMessage = '';\n\n          if (expected) {\n            thrownMessage = ' with message ' + j$.pp(thrown.message);\n          }\n\n          return thrownName + thrownMessage;\n        },\n        messageDescription: function() {\n          if (expected === null) {\n            return '';\n          } else if (expected instanceof RegExp) {\n            return ' with a message matching ' + j$.pp(expected);\n          } else {\n            return ' with message ' + j$.pp(expected);\n          }\n        },\n        hasNoSpecifics: function() {\n          return expected === null && errorType === null;\n        },\n        matches: function(error) {\n          return (errorType === null || error instanceof errorType) &&\n            (expected === null || messageMatch(error.message));\n        }\n      };\n    }\n\n    function isStringOrRegExp(potential) {\n      return potential instanceof RegExp || (typeof potential == 'string');\n    }\n\n    function isAnErrorType(type) {\n      if (typeof type !== 'function') {\n        return false;\n      }\n\n      var Surrogate = function() {};\n      Surrogate.prototype = type.prototype;\n      return (new Surrogate()) instanceof Error;\n    }\n  }\n\n  return toThrowError;\n};\n\ngetJasmineRequireObj().interface = function(jasmine, env) {\n  var jasmineInterface = {\n    describe: function(description, specDefinitions) {\n      return env.describe(description, specDefinitions);\n    },\n\n    xdescribe: function(description, specDefinitions) {\n      return env.xdescribe(description, specDefinitions);\n    },\n\n    fdescribe: function(description, specDefinitions) {\n      return env.fdescribe(description, specDefinitions);\n    },\n\n    it: function() {\n      return env.it.apply(env, arguments);\n    },\n\n    xit: function() {\n      return env.xit.apply(env, arguments);\n    },\n\n    fit: function() {\n      return env.fit.apply(env, arguments);\n    },\n\n    beforeEach: function() {\n      return env.beforeEach.apply(env, arguments);\n    },\n\n    afterEach: function() {\n      return env.afterEach.apply(env, arguments);\n    },\n\n    beforeAll: function() {\n      return env.beforeAll.apply(env, arguments);\n    },\n\n    afterAll: function() {\n      return env.afterAll.apply(env, arguments);\n    },\n\n    expect: function(actual) {\n      return env.expect(actual);\n    },\n\n    pending: function() {\n      return env.pending.apply(env, arguments);\n    },\n\n    fail: function() {\n      return env.fail.apply(env, arguments);\n    },\n\n    spyOn: function(obj, methodName) {\n      return env.spyOn(obj, methodName);\n    },\n\n    jsApiReporter: new jasmine.JsApiReporter({\n      timer: new jasmine.Timer()\n    }),\n\n    jasmine: jasmine\n  };\n\n  jasmine.addCustomEqualityTester = function(tester) {\n    env.addCustomEqualityTester(tester);\n  };\n\n  jasmine.addMatchers = function(matchers) {\n    return env.addMatchers(matchers);\n  };\n\n  jasmine.clock = function() {\n    return env.clock;\n  };\n\n  return jasmineInterface;\n};\n\ngetJasmineRequireObj().version = function() {\n  return '2.4.1';\n};\n";

/***/ },
/* 8 */
/***/ function(module, exports) {

	"use strict";
	
	module.exports = "/*\nCopyright (c) 2008-2015 Pivotal Labs\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\njasmineRequire.html = function(j$) {\n  j$.ResultsNode = jasmineRequire.ResultsNode();\n  j$.HtmlReporter = jasmineRequire.HtmlReporter(j$);\n  j$.QueryString = jasmineRequire.QueryString();\n  j$.HtmlSpecFilter = jasmineRequire.HtmlSpecFilter();\n};\n\njasmineRequire.HtmlReporter = function(j$) {\n\n  var noopTimer = {\n    start: function() {},\n    elapsed: function() { return 0; }\n  };\n\n  function HtmlReporter(options) {\n    var env = options.env || {},\n      getContainer = options.getContainer,\n      createElement = options.createElement,\n      createTextNode = options.createTextNode,\n      onRaiseExceptionsClick = options.onRaiseExceptionsClick || function() {},\n      onThrowExpectationsClick = options.onThrowExpectationsClick || function() {},\n      onRandomClick = options.onRandomClick || function() {},\n      addToExistingQueryString = options.addToExistingQueryString || defaultQueryString,\n      timer = options.timer || noopTimer,\n      results = [],\n      specsExecuted = 0,\n      failureCount = 0,\n      pendingSpecCount = 0,\n      htmlReporterMain,\n      symbols,\n      failedSuites = [];\n\n    this.initialize = function() {\n      clearPrior();\n      htmlReporterMain = createDom('div', {className: 'jasmine_html-reporter'},\n        createDom('div', {className: 'jasmine-banner'},\n          createDom('a', {className: 'jasmine-title', href: 'http://jasmine.github.io/', target: '_blank'}),\n          createDom('span', {className: 'jasmine-version'}, j$.version)\n        ),\n        createDom('ul', {className: 'jasmine-symbol-summary'}),\n        createDom('div', {className: 'jasmine-alert'}),\n        createDom('div', {className: 'jasmine-results'},\n          createDom('div', {className: 'jasmine-failures'})\n        )\n      );\n      getContainer().appendChild(htmlReporterMain);\n    };\n\n    var totalSpecsDefined;\n    this.jasmineStarted = function(options) {\n      totalSpecsDefined = options.totalSpecsDefined || 0;\n      timer.start();\n    };\n\n    var summary = createDom('div', {className: 'jasmine-summary'});\n\n    var topResults = new j$.ResultsNode({}, '', null),\n      currentParent = topResults;\n\n    this.suiteStarted = function(result) {\n      currentParent.addChild(result, 'suite');\n      currentParent = currentParent.last();\n    };\n\n    this.suiteDone = function(result) {\n      if (result.status == 'failed') {\n        failedSuites.push(result);\n      }\n\n      if (currentParent == topResults) {\n        return;\n      }\n\n      currentParent = currentParent.parent;\n    };\n\n    this.specStarted = function(result) {\n      currentParent.addChild(result, 'spec');\n    };\n\n    var failures = [];\n    this.specDone = function(result) {\n      if(noExpectations(result) && typeof console !== 'undefined' && typeof console.error !== 'undefined') {\n        console.error('Spec \\'' + result.fullName + '\\' has no expectations.');\n      }\n\n      if (result.status != 'disabled') {\n        specsExecuted++;\n      }\n\n      if (!symbols){\n        symbols = find('.jasmine-symbol-summary');\n      }\n\n      symbols.appendChild(createDom('li', {\n          className: noExpectations(result) ? 'jasmine-empty' : 'jasmine-' + result.status,\n          id: 'spec_' + result.id,\n          title: result.fullName\n        }\n      ));\n\n      if (result.status == 'failed') {\n        failureCount++;\n\n        var failure =\n          createDom('div', {className: 'jasmine-spec-detail jasmine-failed'},\n            createDom('div', {className: 'jasmine-description'},\n              createDom('a', {title: result.fullName, href: specHref(result)}, result.fullName)\n            ),\n            createDom('div', {className: 'jasmine-messages'})\n          );\n        var messages = failure.childNodes[1];\n\n        for (var i = 0; i < result.failedExpectations.length; i++) {\n          var expectation = result.failedExpectations[i];\n          messages.appendChild(createDom('div', {className: 'jasmine-result-message'}, expectation.message));\n          messages.appendChild(createDom('div', {className: 'jasmine-stack-trace'}, expectation.stack));\n        }\n\n        failures.push(failure);\n      }\n\n      if (result.status == 'pending') {\n        pendingSpecCount++;\n      }\n    };\n\n    this.jasmineDone = function(doneResult) {\n      var banner = find('.jasmine-banner');\n      var alert = find('.jasmine-alert');\n      var order = doneResult && doneResult.order;\n      alert.appendChild(createDom('span', {className: 'jasmine-duration'}, 'finished in ' + timer.elapsed() / 1000 + 's'));\n\n      banner.appendChild(\n        createDom('div', { className: 'jasmine-run-options' },\n          createDom('span', { className: 'jasmine-trigger' }, 'Options'),\n          createDom('div', { className: 'jasmine-payload' },\n            createDom('div', { className: 'jasmine-exceptions' },\n              createDom('input', {\n                className: 'jasmine-raise',\n                id: 'jasmine-raise-exceptions',\n                type: 'checkbox'\n              }),\n              createDom('label', { className: 'jasmine-label', 'for': 'jasmine-raise-exceptions' }, 'raise exceptions')),\n            createDom('div', { className: 'jasmine-throw-failures' },\n              createDom('input', {\n                className: 'jasmine-throw',\n                id: 'jasmine-throw-failures',\n                type: 'checkbox'\n              }),\n              createDom('label', { className: 'jasmine-label', 'for': 'jasmine-throw-failures' }, 'stop spec on expectation failure')),\n            createDom('div', { className: 'jasmine-random-order' },\n              createDom('input', {\n                className: 'jasmine-random',\n                id: 'jasmine-random-order',\n                type: 'checkbox'\n              }),\n              createDom('label', { className: 'jasmine-label', 'for': 'jasmine-random-order' }, 'run tests in random order'))\n          )\n        ));\n\n      var raiseCheckbox = find('#jasmine-raise-exceptions');\n\n      raiseCheckbox.checked = !env.catchingExceptions();\n      raiseCheckbox.onclick = onRaiseExceptionsClick;\n\n      var throwCheckbox = find('#jasmine-throw-failures');\n      throwCheckbox.checked = env.throwingExpectationFailures();\n      throwCheckbox.onclick = onThrowExpectationsClick;\n\n      var randomCheckbox = find('#jasmine-random-order');\n      randomCheckbox.checked = env.randomTests();\n      randomCheckbox.onclick = onRandomClick;\n\n      var optionsMenu = find('.jasmine-run-options'),\n          optionsTrigger = optionsMenu.querySelector('.jasmine-trigger'),\n          optionsPayload = optionsMenu.querySelector('.jasmine-payload'),\n          isOpen = /\\bjasmine-open\\b/;\n\n      optionsTrigger.onclick = function() {\n        if (isOpen.test(optionsPayload.className)) {\n          optionsPayload.className = optionsPayload.className.replace(isOpen, '');\n        } else {\n          optionsPayload.className += ' jasmine-open';\n        }\n      };\n\n      if (specsExecuted < totalSpecsDefined) {\n        var skippedMessage = 'Ran ' + specsExecuted + ' of ' + totalSpecsDefined + ' specs - run all';\n        alert.appendChild(\n          createDom('span', {className: 'jasmine-bar jasmine-skipped'},\n            createDom('a', {href: '?', title: 'Run all specs'}, skippedMessage)\n          )\n        );\n      }\n      var statusBarMessage = '';\n      var statusBarClassName = 'jasmine-bar ';\n\n      if (totalSpecsDefined > 0) {\n        statusBarMessage += pluralize('spec', specsExecuted) + ', ' + pluralize('failure', failureCount);\n        if (pendingSpecCount) { statusBarMessage += ', ' + pluralize('pending spec', pendingSpecCount); }\n        statusBarClassName += (failureCount > 0) ? 'jasmine-failed' : 'jasmine-passed';\n      } else {\n        statusBarClassName += 'jasmine-skipped';\n        statusBarMessage += 'No specs found';\n      }\n\n      var seedBar;\n      if (order && order.random) {\n        seedBar = createDom('span', {className: 'jasmine-seed-bar'},\n          ', randomized with seed ',\n          createDom('a', {title: 'randomized with seed ' + order.seed, href: seedHref(order.seed)}, order.seed)\n        );\n      }\n\n      alert.appendChild(createDom('span', {className: statusBarClassName}, statusBarMessage, seedBar));\n\n      for(i = 0; i < failedSuites.length; i++) {\n        var failedSuite = failedSuites[i];\n        for(var j = 0; j < failedSuite.failedExpectations.length; j++) {\n          var errorBarMessage = 'AfterAll ' + failedSuite.failedExpectations[j].message;\n          var errorBarClassName = 'jasmine-bar jasmine-errored';\n          alert.appendChild(createDom('span', {className: errorBarClassName}, errorBarMessage));\n        }\n      }\n\n      var results = find('.jasmine-results');\n      results.appendChild(summary);\n\n      summaryList(topResults, summary);\n\n      function summaryList(resultsTree, domParent) {\n        var specListNode;\n        for (var i = 0; i < resultsTree.children.length; i++) {\n          var resultNode = resultsTree.children[i];\n          if (resultNode.type == 'suite') {\n            var suiteListNode = createDom('ul', {className: 'jasmine-suite', id: 'suite-' + resultNode.result.id},\n              createDom('li', {className: 'jasmine-suite-detail'},\n                createDom('a', {href: specHref(resultNode.result)}, resultNode.result.description)\n              )\n            );\n\n            summaryList(resultNode, suiteListNode);\n            domParent.appendChild(suiteListNode);\n          }\n          if (resultNode.type == 'spec') {\n            if (domParent.getAttribute('class') != 'jasmine-specs') {\n              specListNode = createDom('ul', {className: 'jasmine-specs'});\n              domParent.appendChild(specListNode);\n            }\n            var specDescription = resultNode.result.description;\n            if(noExpectations(resultNode.result)) {\n              specDescription = 'SPEC HAS NO EXPECTATIONS ' + specDescription;\n            }\n            if(resultNode.result.status === 'pending' && resultNode.result.pendingReason !== '') {\n              specDescription = specDescription + ' PENDING WITH MESSAGE: ' + resultNode.result.pendingReason;\n            }\n            specListNode.appendChild(\n              createDom('li', {\n                  className: 'jasmine-' + resultNode.result.status,\n                  id: 'spec-' + resultNode.result.id\n                },\n                createDom('a', {href: specHref(resultNode.result)}, specDescription)\n              )\n            );\n          }\n        }\n      }\n\n      if (failures.length) {\n        alert.appendChild(\n          createDom('span', {className: 'jasmine-menu jasmine-bar jasmine-spec-list'},\n            createDom('span', {}, 'Spec List | '),\n            createDom('a', {className: 'jasmine-failures-menu', href: '#'}, 'Failures')));\n        alert.appendChild(\n          createDom('span', {className: 'jasmine-menu jasmine-bar jasmine-failure-list'},\n            createDom('a', {className: 'jasmine-spec-list-menu', href: '#'}, 'Spec List'),\n            createDom('span', {}, ' | Failures ')));\n\n        find('.jasmine-failures-menu').onclick = function() {\n          setMenuModeTo('jasmine-failure-list');\n        };\n        find('.jasmine-spec-list-menu').onclick = function() {\n          setMenuModeTo('jasmine-spec-list');\n        };\n\n        setMenuModeTo('jasmine-failure-list');\n\n        var failureNode = find('.jasmine-failures');\n        for (var i = 0; i < failures.length; i++) {\n          failureNode.appendChild(failures[i]);\n        }\n      }\n    };\n\n    return this;\n\n    function find(selector) {\n      return getContainer().querySelector('.jasmine_html-reporter ' + selector);\n    }\n\n    function clearPrior() {\n      // return the reporter\n      var oldReporter = find('');\n\n      if(oldReporter) {\n        getContainer().removeChild(oldReporter);\n      }\n    }\n\n    function createDom(type, attrs, childrenVarArgs) {\n      var el = createElement(type);\n\n      for (var i = 2; i < arguments.length; i++) {\n        var child = arguments[i];\n\n        if (typeof child === 'string') {\n          el.appendChild(createTextNode(child));\n        } else {\n          if (child) {\n            el.appendChild(child);\n          }\n        }\n      }\n\n      for (var attr in attrs) {\n        if (attr == 'className') {\n          el[attr] = attrs[attr];\n        } else {\n          el.setAttribute(attr, attrs[attr]);\n        }\n      }\n\n      return el;\n    }\n\n    function pluralize(singular, count) {\n      var word = (count == 1 ? singular : singular + 's');\n\n      return '' + count + ' ' + word;\n    }\n\n    function specHref(result) {\n      return addToExistingQueryString('spec', result.fullName);\n    }\n\n    function seedHref(seed) {\n      return addToExistingQueryString('seed', seed);\n    }\n\n    function defaultQueryString(key, value) {\n      return '?' + key + '=' + value;\n    }\n\n    function setMenuModeTo(mode) {\n      htmlReporterMain.setAttribute('class', 'jasmine_html-reporter ' + mode);\n    }\n\n    function noExpectations(result) {\n      return (result.failedExpectations.length + result.passedExpectations.length) === 0 &&\n        result.status === 'passed';\n    }\n  }\n\n  return HtmlReporter;\n};\n\njasmineRequire.HtmlSpecFilter = function() {\n  function HtmlSpecFilter(options) {\n    var filterString = options && options.filterString() && options.filterString().replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n    var filterPattern = new RegExp(filterString);\n\n    this.matches = function(specName) {\n      return filterPattern.test(specName);\n    };\n  }\n\n  return HtmlSpecFilter;\n};\n\njasmineRequire.ResultsNode = function() {\n  function ResultsNode(result, type, parent) {\n    this.result = result;\n    this.type = type;\n    this.parent = parent;\n\n    this.children = [];\n\n    this.addChild = function(result, type) {\n      this.children.push(new ResultsNode(result, type, this));\n    };\n\n    this.last = function() {\n      return this.children[this.children.length - 1];\n    };\n  }\n\n  return ResultsNode;\n};\n\njasmineRequire.QueryString = function() {\n  function QueryString(options) {\n\n    this.navigateWithNewParam = function(key, value) {\n      options.getWindowLocation().search = this.fullStringWithNewParam(key, value);\n    };\n\n    this.fullStringWithNewParam = function(key, value) {\n      var paramMap = queryStringToParamMap();\n      paramMap[key] = value;\n      return toQueryString(paramMap);\n    };\n\n    this.getParam = function(key) {\n      return queryStringToParamMap()[key];\n    };\n\n    return this;\n\n    function toQueryString(paramMap) {\n      var qStrPairs = [];\n      for (var prop in paramMap) {\n        qStrPairs.push(encodeURIComponent(prop) + '=' + encodeURIComponent(paramMap[prop]));\n      }\n      return '?' + qStrPairs.join('&');\n    }\n\n    function queryStringToParamMap() {\n      var paramStr = options.getWindowLocation().search.substring(1),\n        params = [],\n        paramMap = {};\n\n      if (paramStr.length > 0) {\n        params = paramStr.split('&');\n        for (var i = 0; i < params.length; i++) {\n          var p = params[i].split('=');\n          var value = decodeURIComponent(p[1]);\n          if (value === 'true' || value === 'false') {\n            value = JSON.parse(value);\n          }\n          paramMap[decodeURIComponent(p[0])] = value;\n        }\n      }\n\n      return paramMap;\n    }\n\n  }\n\n  return QueryString;\n};\n";

/***/ },
/* 9 */
/***/ function(module, exports) {

	"use strict";
	
	module.exports = "/**\n Starting with version 2.0, this file \"boots\" Jasmine, performing all of the necessary initialization before executing the loaded environment and all of a project's specs. This file should be loaded after `jasmine.js` and `jasmine_html.js`, but before any project source files or spec files are loaded. Thus this file can also be used to customize Jasmine for a project.\n\n If a project is using Jasmine via the standalone distribution, this file can be customized directly. If a project is using Jasmine via the [Ruby gem][jasmine-gem], this file can be copied into the support directory via `jasmine copy_boot_js`. Other environments (e.g., Python) will have different mechanisms.\n\n The location of `boot.js` can be specified and/or overridden in `jasmine.yml`.\n\n [jasmine-gem]: http://github.com/pivotal/jasmine-gem\n */\n\n(function() {\n\n  /**\n   * ## Require &amp; Instantiate\n   *\n   * Require Jasmine's core files. Specifically, this requires and attaches all of Jasmine's code to the `jasmine` reference.\n   */\n  window.jasmine = jasmineRequire.core(jasmineRequire);\n\n  /**\n   * Since this is being run in a browser and the results should populate to an HTML page, require the HTML-specific Jasmine code, injecting the same reference.\n   */\n  jasmineRequire.html(jasmine);\n\n  /**\n   * Create the Jasmine environment. This is used to run all specs in a project.\n   */\n  var env = jasmine.getEnv();\n\n  /**\n   * ## The Global Interface\n   *\n   * Build up the functions that will be exposed as the Jasmine public interface. A project can customize, rename or alias any of these functions as desired, provided the implementation remains unchanged.\n   */\n  var jasmineInterface = jasmineRequire.interface(jasmine, env);\n\n  /**\n   * Add all of the Jasmine global/public interface to the global scope, so a project can use the public interface directly. For example, calling `describe` in specs instead of `jasmine.getEnv().describe`.\n   */\n  extend(window, jasmineInterface);\n\n  /**\n   * ## Runner Parameters\n   *\n   * More browser specific code - wrap the query string in an object and to allow for getting/setting parameters from the runner user interface.\n   */\n\n  var queryString = new jasmine.QueryString({\n    getWindowLocation: function() { return window.location; }\n  });\n\n  var catchingExceptions = queryString.getParam(\"catch\");\n  env.catchExceptions(typeof catchingExceptions === \"undefined\" ? true : catchingExceptions);\n\n  var throwingExpectationFailures = queryString.getParam(\"throwFailures\");\n  env.throwOnExpectationFailure(throwingExpectationFailures);\n\n  var random = queryString.getParam(\"random\");\n  env.randomizeTests(random);\n\n  var seed = queryString.getParam(\"seed\");\n  if (seed) {\n    env.seed(seed);\n  }\n\n  /**\n   * ## Reporters\n   * The `HtmlReporter` builds all of the HTML UI for the runner page. This reporter paints the dots, stars, and x's for specs, as well as all spec names and all failures (if any).\n   */\n  var htmlReporter = new jasmine.HtmlReporter({\n    env: env,\n    onRaiseExceptionsClick: function() { queryString.navigateWithNewParam(\"catch\", !env.catchingExceptions()); },\n    onThrowExpectationsClick: function() { queryString.navigateWithNewParam(\"throwFailures\", !env.throwingExpectationFailures()); },\n    onRandomClick: function() { queryString.navigateWithNewParam(\"random\", !env.randomTests()); },\n    addToExistingQueryString: function(key, value) { return queryString.fullStringWithNewParam(key, value); },\n    getContainer: function() { return document.body; },\n    createElement: function() { return document.createElement.apply(document, arguments); },\n    createTextNode: function() { return document.createTextNode.apply(document, arguments); },\n    timer: new jasmine.Timer()\n  });\n\n  /**\n   * The `jsApiReporter` also receives spec results, and is used by any environment that needs to extract the results  from JavaScript.\n   */\n  env.addReporter(jasmineInterface.jsApiReporter);\n  env.addReporter(htmlReporter);\n\n  /**\n   * Filter which specs will be run by matching the start of the full name against the `spec` query param.\n   */\n  var specFilter = new jasmine.HtmlSpecFilter({\n    filterString: function() { return queryString.getParam(\"spec\"); }\n  });\n\n  env.specFilter = function(spec) {\n    return specFilter.matches(spec.getFullName());\n  };\n\n  /**\n   * Setting up timing functions to be able to be overridden. Certain browsers (Safari, IE 8, phantomjs) require this hack.\n   */\n  window.setTimeout = window.setTimeout;\n  window.setInterval = window.setInterval;\n  window.clearTimeout = window.clearTimeout;\n  window.clearInterval = window.clearInterval;\n\n  /**\n   * ## Execution\n   *\n   * Replace the browser window's `onload`, ensure it's called, and then run all of the loaded specs. This includes initializing the `HtmlReporter` instance and then executing the loaded Jasmine environment. All of this will happen after all of the specs are loaded.\n   */\n  var currentWindowOnload = window.onload;\n\n  window.onload = function() {\n    if (currentWindowOnload) {\n      currentWindowOnload();\n    }\n    htmlReporter.initialize();\n    env.execute();\n  };\n\n  /**\n   * Helper function for readability above.\n   */\n  function extend(destination, source) {\n    for (var property in source) destination[property] = source[property];\n    return destination;\n  }\n\n}());\n";

/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgYjg4NDUxNTg0YzYyNjEwMjJjYWYiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Jyb3dzZXItamFzbWluZS10ZXN0aW5nLmpzIiwid2VicGFjazovLy8uL3NyYy9saWIvamFzbWluZS0yLjQuMS9qYXNtaW5lLmNzcz8wZTA1Iiwid2VicGFjazovLy8uL3NyYy9saWIvamFzbWluZS0yLjQuMS9qYXNtaW5lLmNzcyIsIndlYnBhY2s6Ly8vLi9+L2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzIiwid2VicGFjazovLy8uL34vc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2VzNS1zaGltL2VzNS1zaGltLmpzIiwid2VicGFjazovLy8uL34vc291cmNlLW1hcC1zdXBwb3J0L2Jyb3dzZXItc291cmNlLW1hcC1zdXBwb3J0LmpzIiwid2VicGFjazovLy8uL3NyYy9saWIvamFzbWluZS0yLjQuMS9qYXNtaW5lLmpzIiwid2VicGFjazovLy8uL3NyYy9saWIvamFzbWluZS0yLjQuMS9qYXNtaW5lLWh0bWwuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi9qYXNtaW5lLTIuNC4xL2Jvb3QuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7OztBQ3RDQSxhQUFZLEVBQUUsQ0FBQzs7QUFFZixvQkFBTyxDQUFDLENBQWlDLENBQUMsQ0FBQztBQUMzQyxvQkFBTyxDQUFDLENBQVUsQ0FBQyxDQUFDO0FBQ3BCLEtBQUksT0FBTyxHQUFHLENBQ1YsbUJBQU8sQ0FBQyxDQUFrRCxDQUFDLEVBQzNELG1CQUFPLENBQUMsQ0FBZ0MsQ0FBQyxFQUN6QyxtQkFBTyxDQUFDLENBQXFDLENBQUMsRUFDOUMsbUJBQU8sQ0FBQyxDQUE2QixDQUFDLENBQ3pDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDOztBQUdaLEtBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0FBQzNCLGlCQUFnQixDQUFDLE9BQU8sRUFBRTs7O0FBRzFCLFVBQVMsWUFBWSxHQUFHO0FBQ3BCLFNBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRTtBQUMxQixpQkFBUSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEdBQUcsVUFBUyxLQUFLLEVBQUU7QUFDdEMsaUJBQUksT0FBTyxJQUFJLEtBQUssVUFBVSxFQUFFOzs7QUFHNUIsdUJBQU0sSUFBSSxTQUFTLENBQUMsc0VBQXNFLENBQUMsQ0FBQztjQUMvRjs7QUFFRCxpQkFBSSxLQUFLLEdBQUssS0FBSyxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDLENBQUM7aUJBQ2xELE9BQU8sR0FBRyxJQUFJO2lCQUNkLElBQUksR0FBTSxTQUFWLElBQUksR0FBaUIsRUFBRTtpQkFDdkIsTUFBTSxHQUFJLFNBQVYsTUFBTSxHQUFlO0FBQ2pCLHdCQUFPLE9BQU8sQ0FBQyxLQUFLLENBQUMsSUFBSSxZQUFZLElBQUksR0FDL0IsSUFBSSxHQUNKLEtBQUssRUFDWCxLQUFLLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7Y0FDNUQsQ0FBQzs7QUFFTixpQkFBSSxJQUFJLENBQUMsU0FBUyxFQUFFOztBQUVoQixxQkFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDO2NBQ25DO0FBQ0QsbUJBQU0sQ0FBQyxTQUFTLEdBQUcsSUFBSSxJQUFJLEVBQUUsQ0FBQzs7QUFFOUIsb0JBQU8sTUFBTSxDQUFDO1VBQ2pCLENBQUM7TUFDTDs7Ozs7Ozs7QUMzQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBc0Y7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxpQ0FBZ0MsVUFBVSxFQUFFO0FBQzVDLEU7Ozs7OztBQ3BCQTtBQUNBOzs7QUFHQTtBQUNBLGlDQUFnQyxvQkFBb0IsRUFBRSw0QkFBNEIsd0JBQXdCLGNBQWMsY0FBYyxpQkFBaUIsb0RBQW9ELG1CQUFtQixhQUFhLEVBQUUsNEJBQTRCLHVCQUF1QixFQUFFLGtDQUFrQyw0QkFBNEIsRUFBRSw4TEFBOEwsV0FBVyxtQkFBbUIsRUFBRSxpWkFBaVosbUJBQW1CLG9CQUFvQixFQUFFLDBDQUEwQyxvQkFBb0IsRUFBRSx5REFBeUQsaUNBQWlDLG93RUFBb3dFLHFDQUFxQyw4aFhBQThoWCw0QkFBNEIsMEJBQTBCLCtCQUErQix1QkFBdUIsZ0JBQWdCLGFBQWEsYUFBYSxjQUFjLEVBQUUsMkRBQTJELG1CQUFtQixvQkFBb0IsVUFBVSxFQUFFLDJDQUEyQyxpQkFBaUIsYUFBYSxFQUFFLDJDQUEyQyxhQUFhLEVBQUUsMENBQTBDLGtCQUFrQixFQUFFLDRDQUE0QyxhQUFhLGNBQWMsbUJBQW1CLG9CQUFvQixFQUFFLGtEQUFrRCxrQkFBa0IsVUFBVSxnQkFBZ0IsRUFBRSxxREFBcUQsdUJBQXVCLGNBQWMsYUFBYSxpQkFBaUIsRUFBRSxvRUFBb0UsaUJBQWlCLEVBQUUsMkVBQTJFLGdCQUFnQixxQkFBcUIsRUFBRSxvRUFBb0Usa0JBQWtCLEVBQUUsMkVBQTJFLGdCQUFnQixtQkFBbUIsbUJBQW1CLG1CQUFtQixFQUFFLHNFQUFzRSxpQkFBaUIsRUFBRSw2RUFBNkUsZ0JBQWdCLHFCQUFxQixFQUFFLHFFQUFxRSxtQkFBbUIsRUFBRSw0RUFBNEUsZ0JBQWdCLGdCQUFnQixFQUFFLG1FQUFtRSxpQkFBaUIsRUFBRSwwRUFBMEUsZ0JBQWdCLHFCQUFxQixFQUFFLCtDQUErQyxjQUFjLG1CQUFtQiwyQkFBMkIsZ0JBQWdCLG9CQUFvQixtQkFBbUIsRUFBRSxnRUFBZ0UsaUJBQWlCLG1CQUFtQixFQUFFLGdFQUFnRSxvQkFBb0IsZUFBZSxhQUFhLDJCQUEyQix3QkFBd0IscUJBQXFCLGtCQUFrQixFQUFFLDZFQUE2RSxnQkFBZ0IsRUFBRSx1Q0FBdUMsbUJBQW1CLGlCQUFpQixnQkFBZ0IsYUFBYSxFQUFFLHNEQUFzRCwyQkFBMkIsRUFBRSxzREFBc0QsMkJBQTJCLEVBQUUsdURBQXVELDJCQUEyQixFQUFFLHVEQUF1RCwyQkFBMkIsRUFBRSxvREFBb0Qsd0JBQXdCLGFBQWEsRUFBRSxzREFBc0QsYUFBYSxFQUFFLHlDQUF5QyxjQUFjLEVBQUUsd0tBQXdLLGVBQWUsRUFBRSx5SkFBeUosZUFBZSxFQUFFLDJDQUEyQyxrQkFBa0IsRUFBRSwyQ0FBMkMsa0JBQWtCLEVBQUUsOENBQThDLHVCQUF1QixtQkFBbUIsZ0JBQWdCLGlCQUFpQixFQUFFLDREQUE0RCxpQkFBaUIsb0JBQW9CLEVBQUUsK0RBQStELGdCQUFnQixFQUFFLCtEQUErRCxnQkFBZ0IsRUFBRSw4REFBOEQsZ0JBQWdCLEVBQUUsZ0VBQWdFLGdCQUFnQixFQUFFLGlFQUFpRSxnQkFBZ0IsRUFBRSxnRUFBZ0UsZUFBZSxFQUFFLHlDQUF5QyxrQkFBa0IsRUFBRSwyQ0FBMkMsYUFBYSxFQUFFLGlFQUFpRSxxQkFBcUIsRUFBRSxzRkFBc0YsMkJBQTJCLEVBQUUsd0ZBQXdGLGNBQWMsRUFBRSxrREFBa0QsbUJBQW1CLGFBQWEsa0JBQWtCLEVBQUUsc0VBQXNFLGdCQUFnQixFQUFFLCtDQUErQyxtQkFBbUIsbUJBQW1CLGdCQUFnQixtQkFBbUIsYUFBYSx3QkFBd0IsbUJBQW1CLGtCQUFrQixFQUFFOztBQUV4Nm5COzs7Ozs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0EseUNBQXdDLGdCQUFnQjtBQUN4RCxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCLHNCQUFzQjtBQUN0QztBQUNBO0FBQ0EsbUJBQWtCLDJCQUEyQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZSxtQkFBbUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUIsMkJBQTJCO0FBQzVDO0FBQ0E7QUFDQSxTQUFRLHVCQUF1QjtBQUMvQjtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0Esa0JBQWlCLHVCQUF1QjtBQUN4QztBQUNBO0FBQ0EsNEJBQTJCO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBLGlDQUFnQyxzQkFBc0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3REFBdUQ7QUFDdkQ7O0FBRUEsOEJBQTZCLG1CQUFtQjs7QUFFaEQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7O0FDdlBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZSxvSkFBb0osTUFBTSxxQkFBcUIsYUFBYSxFQUFFLFlBQVksY0FBYyxFQUFFLEVBQUUseUVBQXlFLDBDQUEwQyxtQ0FBbUMsY0FBYyxFQUFFLHNCQUFzQixpQ0FBaUMsRUFBRSxzQ0FBc0Msc0RBQXNEO0FBQ3RpQixhQUFZLG1JQUFtSSxNQUFNLHVCQUF1QixhQUFhLEVBQUUsWUFBWSxjQUFjLEVBQUUsRUFBRSxpQ0FBaUMsb0NBQW9DLGlDQUFpQyxjQUFjLEVBQUUsb0ZBQW9GO0FBQ25hLGNBQWEsNElBQTRJLE1BQU0sc0JBQXNCLGFBQWEsRUFBRSxZQUFZLGNBQWMsRUFBRSxFQUFFLGtDQUFrQyxzQ0FBc0MsaUNBQWlDLGFBQWEsRUFBRSxpQ0FBaUMsY0FBYyxFQUFFLHdGQUF3Rjs7QUFFbmU7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMEMsZ0NBQWdDO0FBQzFFLDZCQUE0QixjQUFjO0FBQzFDO0FBQ0EsTUFBSyxZQUFZO0FBQ2pCO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWlELFFBQVE7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBLElBQUc7QUFDSDtBQUNBLGtEQUFpRCxRQUFRO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtEQUFpRCxnQkFBZ0I7O0FBRWpFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxnQ0FBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLGlCQUFpQjtBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFrRixzQ0FBc0MsRUFBRTs7QUFFMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0RBQXFEO0FBQ3JELHNFQUFxRTtBQUNyRTtBQUNBO0FBQ0EseURBQXdEO0FBQ3hELCtFQUE4RTtBQUM5RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSwyQkFBMEIsbUJBQW1COztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBOEMsZ0NBQWdDO0FBQzlFLFVBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF1QixZQUFZO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXVCLFlBQVk7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXVCLFlBQVk7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXVCLFlBQVk7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQWtHLGFBQWEsRUFBRTtBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjs7QUFFQSxlQUFjLFlBQVk7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZHQUE0RyxhQUFhLEVBQUU7QUFDM0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBYyxZQUFZO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQSxzQ0FBcUMsV0FBVztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLGtCQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0QsbUNBQWtDLGlCQUFpQjs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsdUJBQXNCO0FBQ3RCO0FBQ0EsTUFBSyxZQUFZO0FBQ2pCO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLLFlBQVk7QUFDakI7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUssWUFBWTtBQUNqQjtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHlCQUF3QixtQkFBbUI7QUFDM0MscUNBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBLHNFQUFxRSwyQ0FBMkM7QUFDaEg7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTJCLG1CQUFtQjtBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUEyQixxQkFBcUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBd0M7QUFDeEMsMkNBQTBDLGFBQWE7QUFDdkQsY0FBYTtBQUNiLE1BQUs7QUFDTDtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdFQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUFzQyx3QkFBd0I7QUFDOUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBa0IsRUFBRSxTQUFTLEVBQUU7QUFDL0I7QUFDQSx1QkFBc0IsRUFBRTtBQUN4Qix1QkFBc0IsRUFBRTtBQUN4QjtBQUNBLHdCQUF1QixFQUFFO0FBQ3pCLHdCQUF1QixFQUFFO0FBQ3pCO0FBQ0EsNEJBQTJCLEVBQUU7QUFDN0IsaUNBQWdDLEdBQUc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEwQixFQUFFO0FBQzVCLDRCQUEyQixFQUFFO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBb0MsbUJBQW1COztBQUV2RDtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUE4QjtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBbUMsdUJBQXVCOztBQUUxRDtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTRFO0FBQzVFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTJDLDBCQUEwQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBLCtEQUE4RCxXQUFXO0FBQ3pFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUM7Ozs7Ozs7QUN0eURELDRKQUEySiwwQkFBMEIsNkNBQTZDLG1CQUFtQixnQkFBZ0IsVUFBVSxVQUFVLDRDQUE0Qyx3QkFBd0Isb0JBQW9CLCtDQUErQyxRQUFRLFlBQVksbUNBQW1DLGlCQUFpQixnQkFBZ0Isc0JBQXNCLG9CQUFvQixvREFBb0QsV0FBVyxZQUFZLFNBQVMsR0FBRyxxQkFBcUIsOEJBQThCLEVBQUUsNEJBQTRCLHFCQUFxQixlQUFlLHdCQUF3QixnQkFBZ0IsTUFBTSw4QkFBOEIsaUJBQWlCLHdCQUF3QixxQ0FBcUMsUUFBUSxLQUFLLDJDQUEyQyxzRkFBc0YsV0FBVyxnQkFBZ0IsU0FBUyxjQUFjLG1CQUFtQixlQUFlLGNBQWMsY0FBYyxPQUFPLDJCQUEyQiw2REFBNkQsU0FBUyxrQkFBa0IsVUFBVSxjQUFjLElBQUkscUJBQXFCLGNBQWMsS0FBSywyRkFBMkYsS0FBSyxZQUFZLElBQUksZ0JBQWdCLHdCQUF3QixZQUFZLEdBQUcsaURBQWlELDhDQUE4QyxrQkFBa0IsOEVBQThFLHFDQUFxQyw0Q0FBNEMsd0JBQXdCLFFBQVEsS0FBSyx3QkFBd0Isb0JBQW9CLGdCQUFnQiw2Q0FBNkMsb0JBQW9CLG9CQUFvQixFQUFFLHlCQUF5QixnQkFBZ0IsRUFBRSxvQkFBb0IsMERBQTBELFVBQVUsZ0JBQWdCLHFDQUFxQyxzQkFBc0IsMkJBQTJCLGFBQWEsU0FBUyxxQ0FBcUMsNEJBQTRCLDJCQUEyQixtQ0FBbUMsdUNBQXVDLGlCQUFpQix3Q0FBd0MsbUJBQW1CLDRCQUE0QixlQUFlLHlDQUF5QyxpQ0FBaUMsRUFBRSxhQUFhLHNCQUFzQixvQkFBb0Isd0NBQXdDLFNBQVMsVUFBVSw2RkFBNkYsRUFBRSw2Q0FBNkMscUJBQXFCLGFBQWEsY0FBYyxrQkFBa0IsNEJBQTRCLDRCQUE0QixpQkFBaUIsdUJBQXVCLG9CQUFvQix3QkFBd0IseURBQXlELDBCQUEwQixjQUFjLFNBQVMsY0FBYyxnRkFBZ0YsV0FBVyxzREFBc0Qsd0JBQXdCLDBCQUEwQixRQUFRLFFBQVEsSUFBSSxpSUFBaUksb0pBQW9KLFVBQVUsNEJBQTRCLDhCQUE4QixJQUFJLGlCQUFpQixJQUFJLGlZQUFpWSxVQUFVLHVCQUF1QixxRkFBcUYsMEZBQTBGLFVBQVUsTUFBTSx5VEFBeVQsVUFBVSwyQ0FBMkMsSUFBSSxHQUFHLHNCQUFzQixHQUFHLHFCQUFxQixrQkFBa0IsNENBQTRDLGVBQWUseUZBQXlGLGVBQWUsVUFBVSxNQUFNLHlCQUF5QiwyQ0FBMkMscUNBQXFDLDRFQUE0RSxNQUFNLHFGQUFxRixpRUFBaUUsS0FBSyxRQUFRLHlGQUF5RixJQUFJLGdEQUFnRCxzQ0FBc0MsdURBQXVELElBQUksV0FBVyxTQUFTLGtCQUFrQixXQUFXLDJCQUEyQixJQUFJLGlDQUFpQyxTQUFTLG9CQUFvQixnS0FBZ0ssV0FBVyxzRkFBc0Ysb0JBQW9CLGdLQUFnSyxXQUFXLFlBQVksTUFBTSxvS0FBb0ssVUFBVSxvQkFBb0Isa0tBQWtLLGdFQUFnRSxvQkFBb0IsZ0tBQWdLLDBFQUEwRSxvQkFBb0IscUhBQXFILDRCQUE0QixvQkFBb0IscUhBQXFILDBCQUEwQixzQkFBc0Isc05BQXNOLGVBQWUscUNBQXFDLElBQUksZ0RBQWdELHNCQUFzQiwyTkFBMk4sZUFBZSxxQ0FBcUMsSUFBSSwrQkFBK0Isc0JBQXNCLCtOQUErTixzREFBc0Qsc0JBQXNCLHVPQUF1TywyREFBMkQsc0JBQXNCLCtQQUErUCxtQ0FBbUMsc0JBQXNCLCtQQUErUCxxQ0FBcUMsa0JBQWtCLGtDQUFrQyxNQUFNLGlCQUFpQixpQkFBaUIsS0FBSyxnQkFBZ0IsY0FBYyxrQkFBa0IsZUFBZSxjQUFjLGtDQUFrQyw2REFBNkQsS0FBSyxjQUFjLGdEQUFnRCxjQUFjLGlCQUFpQixXQUFXLEtBQUssc0JBQXNCLGtDQUFrQyxLQUFLLFFBQVEsd0JBQXdCLDhEQUE4RCxRQUFRLFdBQVcsK0JBQStCLFNBQVMsY0FBYyxpQkFBaUIsV0FBVyxnQ0FBZ0MsU0FBUyxvQkFBb0IsWUFBWSxtQ0FBbUMsZ0JBQWdCLFNBQVMsY0FBYyxJQUFJLDZCQUE2QixTQUFTLG1DQUFtQyxnQkFBZ0IsbUVBQW1FLHFFQUFxRSwwREFBMEQsMERBQTBELGtCQUFrQixtRUFBbUUsb0RBQW9ELHFEQUFxRCwwREFBMEQsa0JBQWtCLG1FQUFtRSxvREFBb0QscURBQXFELGtCQUFrQiw0Q0FBNEMsd0NBQXdDLFdBQVcsZUFBZSx1QkFBdUIsZ0JBQWdCLDZCQUE2QixJQUFJLDZDQUE2QyxpQkFBaUIsV0FBVyxzREFBc0QsU0FBUyxVQUFVLEdBQUcseUJBQXlCLGdDQUFnQywrS0FBK0sscUJBQXFCLHVCQUF1Qiw2Q0FBNkMsMkJBQTJCLE1BQU0sUUFBUSxvQkFBb0IsMEJBQTBCLE1BQU0sMkNBQTJDLE1BQU0sdURBQXVELE1BQU0sMENBQTBDLE1BQU0sNkVBQTZFLE1BQU0sMkNBQTJDLFVBQVUsdUJBQXVCLGlGQUFpRixrQ0FBa0MsNEJBQTRCLE1BQU0sbUNBQW1DLFdBQVcsbUJBQW1CLG1CQUFtQixRQUFRLFdBQVcsS0FBSyxXQUFXLFlBQVksWUFBWSxVQUFVLG9DQUFvQywyQ0FBMkMsS0FBSyxRQUFRLElBQUksSUFBSSxJQUFJLGVBQWUsZ0JBQWdCLCtCQUErQixvQ0FBb0MsVUFBVSw0QkFBNEIsZ0JBQWdCLCtCQUErQixhQUFhLGtDQUFrQyxlQUFlLFFBQVEsSUFBSSxtRkFBbUYsb0JBQW9CLElBQUksTUFBTSxnRUFBZ0UsTUFBTSxrREFBa0QsTUFBTSxtREFBbUQsTUFBTSwrREFBK0QsTUFBTSxtRkFBbUYsV0FBVywwREFBMEQsZ0NBQWdDLE1BQU0sMkNBQTJDLFVBQVUscUNBQXFDLG9DQUFvQyxlQUFlLHFDQUFxQyxvQkFBb0IsVUFBVSwyQkFBMkIsZUFBZSxvQkFBb0IsV0FBVyxJQUFJLGtCQUFrQixJQUFJLE1BQU0sMENBQTBDLDhCQUE4QixJQUFJLCtGQUErRixTQUFTLE1BQU0sNkJBQTZCLE1BQU0sOEJBQThCLE1BQU0sZ0dBQWdHLE1BQU0sa0ZBQWtGLE9BQU8sUUFBUSxXQUFXLDZDQUE2QyxJQUFJLE1BQU0sMkNBQTJDLFVBQVUsOEJBQThCLE9BQU8sdUVBQXVFLG1DQUFtQyxTQUFTLDBCQUEwQixTQUFTLHFWQUFxVixJQUFJLHFCQUFxQixxQ0FBcUMsa0NBQWtDLGtCQUFrQixXQUFXLFdBQVcsMkRBQTJELHVDQUF1QyxJQUFJLG1CQUFtQixVQUFVLDRCQUE0QiwyRUFBMkUsMEJBQTBCLDhCQUE4QiwyRUFBMkUsNkJBQTZCLG9DQUFvQywyR0FBMkcscUNBQXFDLHVDQUF1Qyx1QkFBdUIsdUNBQXVDLHVCQUF1Qix1Q0FBdUMsdUJBQXVCLHVDQUF1Qyx1QkFBdUIsbUNBQW1DLHlHQUF5RyxzRUFBc0Usc0NBQXNDLHVCQUF1QixzQ0FBc0MsdUJBQXVCLHNDQUFzQyx1QkFBdUIsc0NBQXNDLHVCQUF1QixzQ0FBc0MsdUJBQXVCLHNDQUFzQyx1QkFBdUIsdUNBQXVDLHVCQUF1Qix5Q0FBeUMsdUJBQXVCLHVDQUF1Qyw2SkFBNkosNkJBQTZCLDBDQUEwQyxrQkFBa0IsMENBQTBDLGtCQUFrQiwwQ0FBMEMsa0JBQWtCLDBDQUEwQyxrQkFBa0Isd0NBQXdDLGtLQUFrSyw0RUFBNEUseUNBQXlDLGtCQUFrQix5Q0FBeUMsa0JBQWtCLHlDQUF5QyxrQkFBa0IseUNBQXlDLGtCQUFrQiwyQ0FBMkMsa0JBQWtCLHlDQUF5QyxrQkFBa0IsMENBQTBDLGtCQUFrQiwwQ0FBMEMsa0JBQWtCLGlDQUFpQyxTQUFTLFNBQVMsbUJBQW1CLDJDQUEyQyw4REFBOEQsd0JBQXdCLDZIQUE2SCxJQUFJLGVBQWUsK0JBQStCLCtCQUErQixJQUFJLGdEQUFnRCxlQUFlLE1BQU0sd0NBQXdDLHFDQUFxQyxzQ0FBc0MsZ0RBQWdELHFEQUFxRCxJQUFJLGtCQUFrQixnQkFBZ0Isc0VBQXNFLGtCQUFrQix5QkFBeUIsZUFBZSxhQUFhLGFBQWEsWUFBWSxZQUFZLGdCQUFnQixzQkFBc0IsNEJBQTRCLGtCQUFrQixjQUFjLGdCQUFnQix3QkFBd0IsOEJBQThCLDhCQUE4Qiw4QkFBOEIsOEJBQThCLHNCQUFzQiw0QkFBNEIsNEJBQTRCLDRCQUE0Qiw0QkFBNEIsNEJBQTRCLDhCQUE4Qiw4QkFBOEIsOEJBQThCLDBCQUEwQixnQ0FBZ0MsZ0NBQWdDLGdDQUFnQyxnQ0FBZ0Msd0JBQXdCLDhCQUE4Qiw4QkFBOEIsOEJBQThCLDhCQUE4Qiw4QkFBOEIsOEJBQThCLGdDQUFnQyxnQ0FBZ0MsZ0JBQWdCLG9CQUFvQixnQ0FBZ0MsVUFBVSxFQUFFLDBCQUEwQixxQkFBcUIsMkJBQTJCLE1BQU0sVUFBVSwyQkFBMkIsVUFBVSxzQkFBc0IsS0FBSyxjQUFjLE9BQU8sU0FBUyxJQUFJLDBCQUEwQixjQUFjLE9BQU8sU0FBUyxJQUFJLDBCQUEwQixlQUFlLEtBQUssd0NBQXdDLGlCQUFpQixLQUFLLGtDQUFrQyw4QkFBOEIsK0VBQStFLFVBQVUscUNBQXFDLGNBQWMseVFBQXlRLEtBQUssS0FBSywrQkFBK0IsU0FBUyxTQUFTLElBQUksK0JBQStCLG1CQUFtQixHQUFHLHFCQUFxQixhQUFhLGdCQUFnQix5QkFBeUIsS0FBSyxLQUFLLFdBQVcsOEVBQThFLFVBQVUsSUFBSSxvQkFBb0IsU0FBUyxnQkFBZ0IsK0JBQStCLGlCQUFpQixXQUFXLDhCQUE4QixTQUFTLG1DQUFtQyxJQUFJLHVDQUF1QyxxQkFBcUIseUNBQXlDLFVBQVUsS0FBSyxrQ0FBa0MsNEZBQTRGLHVDQUF1QyxpQ0FBaUMsVUFBVSxrQkFBa0IsK0JBQStCLHdCQUF3Qix3Q0FBd0Msa0NBQWtDLFVBQVUsaUNBQWlDLGlCQUFpQix3QkFBd0IseUJBQXlCLDJCQUEyQixrQkFBa0IsOENBQThDLHVDQUF1Qyx5RkFBeUYsU0FBUyxnQkFBZ0IseUJBQXlCLGNBQWMsWUFBWSx3QkFBd0IsS0FBSyxxQkFBcUIsa0JBQWtCLEtBQUssK0JBQStCLHlCQUF5Qix5QkFBeUIsc0ZBQXNGLElBQUksb0JBQW9CLElBQUksTUFBTSxLQUFLLFFBQVEsV0FBVyxtQkFBbUIsdUJBQXVCLHdCQUF3QixZQUFZLGtCQUFrQixzQkFBc0IseUJBQXlCLE9BQU8sT0FBTyxzQkFBc0IsOEJBQThCLFlBQVkseUJBQXlCLDRCQUE0QixnRUFBZ0UsVUFBVSxzQkFBc0IsOEJBQThCLGdEQUFnRCxxQkFBcUIsaUJBQWlCLG9CQUFvQixzQkFBc0Isb0RBQW9ELElBQUksc0NBQXNDLHFCQUFxQixjQUFjLGVBQWUsc0JBQXNCLHlFQUF5RSwrQkFBK0IsK0VBQStFLFNBQVMsZ0RBQWdELGVBQWUsK0ZBQStGLEtBQUssbUJBQW1CLFVBQVUsOENBQThDLG1CQUFtQixpQkFBaUIsR0FBRyxvQkFBb0IsYUFBYSxTQUFTLFVBQVUsT0FBTyxTQUFTLFFBQVEsU0FBUyxzQkFBc0Isb0RBQW9ELGlCQUFpQixhQUFhLG9CQUFvQixrREFBa0QsR0FBRyxxQkFBcUIsaUZBQWlGLDhFQUE4RSx3REFBd0QsSUFBSSxpSEFBaUgsc0JBQXNCLHNEQUFzRCxrQkFBa0IsYUFBYSxlQUFlLGFBQWEsb0JBQW9CLDBCQUEwQiwrQkFBK0IsSUFBSSxrQkFBa0IsVUFBVSw4QkFBOEIsdUNBQXVDLDJCQUEyQixvQ0FBb0MsNEJBQTRCLDJFQUEyRSxnQ0FBZ0Msa0RBQWtELDhDQUE4QywyQkFBMkIsb0RBQW9ELDRDQUE0QywrQkFBK0IsNEJBQTRCLGFBQWEsRUFBRSxFQUFFLHlCQUF5QixzQkFBc0Isc0RBQXNELGtCQUFrQixzQkFBc0IscUJBQXFCLHNDQUFzQyw2Q0FBNkMsV0FBVyxVQUFVLHFCQUFxQiwrQkFBK0IsR0FBRyxvRUFBb0UsMEJBQTBCLFdBQVcsTUFBTSxRQUFRLEtBQUssU0FBUyxPQUFPLE9BQU8sdUNBQXVDLEVBQUUsRUFBRSwyQkFBMkIsc0JBQXNCLHNEQUFzRCxrQkFBa0IsUUFBUSxNQUFNLHlHQUF5RyxPQUFPLE9BQU8sRUFBRSxxQkFBcUIsc0JBQXNCLHdEQUF3RCxxQkFBcUIsc0JBQXNCLHlEQUF5RCxFQUFFLEVBQUUsV0FBVyxzQkFBc0Isc0RBQXNELGtCQUFrQixzQkFBc0IsMkNBQTJDLCtFQUErRSx5QkFBeUIsK0NBQStDLEVBQUUsRUFBRSxXQUFXLHNCQUFzQixzREFBc0Qsa0JBQWtCLGNBQWMsUUFBUSwwREFBMEQsV0FBVywwQkFBMEIsd0xBQXdMLDZEQUE2RCw4QkFBOEIsa0NBQWtDLGtCQUFrQixzQkFBc0IsaUJBQWlCLFlBQVksaUdBQWlHLDRCQUE0QixpQ0FBaUMsNENBQTRDLGdEQUFnRCwyQkFBMkIsOEVBQThFLGVBQWUsOEVBQThFLDhFQUE4RSxVQUFVLHVCQUF1QiwrQ0FBK0MsZUFBZSwrQ0FBK0MsbURBQW1ELFFBQVEsRUFBRSxxQ0FBcUMsMERBQTBELGVBQWUseUlBQXlJLGlDQUFpQyxFQUFFLG9DQUFvQyx5REFBeUQsZUFBZSxzSUFBc0ksZ0NBQWdDLEVBQUUseUNBQXlDLHVDQUF1QyxTQUFTLFdBQVcsT0FBTyxzQ0FBc0MseUNBQXlDLE9BQU8sS0FBSyxrQkFBa0IsY0FBYyw0QkFBNEIsb0JBQW9CLFNBQVMscUNBQXFDLGNBQWMscUNBQXFDLFdBQVcsU0FBUyw2RkFBNkYsY0FBYyx5QkFBeUIsaUJBQWlCLGtCQUFrQixTQUFTLDZGQUE2RixjQUFjLDZCQUE2QixtQkFBbUIsU0FBUyx1R0FBdUcsaUNBQWlDLG9FQUFvRSw2REFBNkQsNERBQTRELDZDQUE2Qyx1RkFBdUYsMEZBQTBGLHdCQUF3Qiw0Q0FBNEMsR0FBRywyRUFBMkUsdUhBQXVILGtDQUFrQyxrREFBa0QsT0FBTywySEFBMkgsT0FBTyxnREFBZ0QseUNBQXlDLG9DQUFvQyxtREFBbUQsNkVBQTZFLE1BQU0scURBQXFELHFDQUFxQyxpR0FBaUcscUhBQXFILG9EQUFvRCw2Q0FBNkMsR0FBRyx1R0FBdUcsaUVBQWlFLHdIQUF3SCxvRkFBb0YsRUFBRSx3QkFBd0Isc0JBQXNCLG1CQUFtQix3Q0FBd0MsVUFBVSw2QkFBNkIsaURBQWlELE1BQU0sK0NBQStDLE1BQU0sc0RBQXNELHNCQUFzQixrQkFBa0IsZUFBZSxzQkFBc0IsT0FBTyxrSkFBa0osa0JBQWtCLHNCQUFzQixFQUFFLEVBQUUsdUZBQXVGLHNCQUFzQixzREFBc0Qsa0JBQWtCLGNBQWMsZ0NBQWdDLGlEQUFpRCxvQkFBb0Isa0JBQWtCLGtCQUFrQiwyQkFBMkIsd0VBQXdFLHVCQUF1Qiw0QkFBNEIsOEJBQThCLHlCQUF5QixFQUFFLDBCQUEwQixPQUFPLFdBQVcsZ0RBQWdELDhFQUE4RSw0Q0FBNEMsMEJBQTBCLGdCQUFnQixFQUFFLDhCQUE4Qiw0QkFBNEIsMkJBQTJCLEVBQUUsVUFBVSxtQ0FBbUMsZ0dBQWdHLDRCQUE0QiwrQkFBK0IsK0NBQStDLDJDQUEyQyxxQkFBcUIsNEhBQTRILEdBQUcsMkNBQTJDLFFBQVEscURBQXFELDBEQUEwRCw2S0FBNksseUNBQXlDLGNBQWMsdUJBQXVCLHVCQUF1QixvQkFBb0IsbUNBQW1DLGlDQUFpQyw2QkFBNkIsNENBQTRDLEVBQUUsOEpBQThKLGtDQUFrQyxnQ0FBZ0MsT0FBTyxnQkFBZ0IsY0FBYyw4QkFBOEIsNEJBQTRCLHVEQUF1RCxRQUFRLCtDQUErQyxnUEFBZ1AsdUNBQXVDLEtBQUssMENBQTBDLHFDQUFxQyxtREFBbUQsb0NBQW9DLElBQUksS0FBSyxvQkFBb0IsK0JBQStCLG9CQUFvQixPQUFPLE9BQU8sYUFBYSxrRUFBa0UsU0FBUyxpQ0FBaUMsb0JBQW9CLHdSQUF3UixVQUFVLGtEQUFrRCx5QkFBeUIsc0NBQXNDLHVCQUF1QixtQkFBbUIsbUdBQW1HLFFBQVEsZ0NBQWdDLE9BQU8sc0lBQXNJLGtEQUFrRCwrRkFBK0YsVUFBVSxnQ0FBZ0MsNkJBQTZCLHVCQUF1QixFQUFFLEVBQUUsZ0VBQWdFLHNCQUFzQix3REFBd0Qsa0JBQWtCLHNCQUFzQixpQkFBaUIsdUJBQXVCLDRCQUE0Qiw4QkFBOEIsOEJBQThCLDRCQUE0QixxQkFBcUIsdUVBQXVFLHdDQUF3QyxnQkFBZ0IscUdBQXFHLDhDQUE4Qyw0QkFBNEIsYUFBYSxLQUFLLGtCQUFrQiw4QkFBOEIsd0JBQXdCLFdBQVcscUNBQXFDLGlDQUFpQyxxQkFBcUIsS0FBSyxzQkFBc0IsV0FBVyxnQ0FBZ0MseUJBQXlCLG9IQUFvSCx1R0FBdUcsT0FBTyxJQUFJLE9BQU8scUJBQXFCLDhCQUE4Qiw0QkFBNEIsMkJBQTJCLEVBQUUsVUFBVSw0QkFBNEIsMENBQTBDLFlBQVksT0FBTyx1RUFBdUUsNEdBQTRHLGFBQWEsZ0NBQWdDLDJDQUEyQyxLQUFLLHVCQUF1Qix1RUFBdUUsNEdBQTRHLGFBQWEsNkJBQTZCLHFDQUFxQyxJQUFJLCtEQUErRCxvRUFBb0UsR0FBRyw2QkFBNkIsK0JBQStCLFFBQVEsS0FBSyxRQUFRLFFBQVEsdUNBQXVDLHlCQUF5QixnQkFBZ0IsYUFBYSx1Q0FBdUMsNENBQTRDLG9KQUFvSixhQUFhLDJDQUEyQyx5Q0FBeUMsMkNBQTJDLG1DQUFtQyxNQUFNLHlFQUF5RSwwREFBMEQsSUFBSSx3REFBd0QsZ0NBQWdDLFdBQVcsc0JBQXNCLEtBQUssRUFBRSxVQUFVLDhDQUE4QywrREFBK0Qsd0JBQXdCLEtBQUsscUhBQXFILDBCQUEwQiw0QkFBNEIsWUFBWSxnQkFBZ0IsYUFBYSxrRUFBa0UsV0FBVyxpQkFBaUIsZUFBZSxrQ0FBa0MsMEJBQTBCLEVBQUUsRUFBRSxzQ0FBc0Msd0JBQXdCLEVBQUUsT0FBTyxlQUFlLGVBQWUsRUFBRSxFQUFFLHVEQUF1RCxzQkFBc0Isd0RBQXdELGtCQUFrQixjQUFjLHNCQUFzQixvREFBb0QsTUFBTSxjQUFjLHVCQUF1QiwwQkFBMEIsb0JBQW9CLDBCQUEwQixvQkFBb0IsU0FBUyxnQkFBZ0Isd0JBQXdCLGtCQUFrQix5QkFBeUIsc0JBQXNCLGlDQUFpQyxtREFBbUQseUZBQXlGLGVBQWUsZ0JBQWdCLHFCQUFxQixNQUFNLDhHQUE4RywwQkFBMEIsZUFBZSw0QkFBNEIsb0JBQW9CLHlCQUF5Qix5QkFBeUIsV0FBVyxxR0FBcUcsNkNBQTZDLE1BQU0saU5BQWlOLDhDQUE4QyxNQUFNLCtNQUErTSxFQUFFLEVBQUUsV0FBVyxzQkFBc0IsZUFBZSxhQUFhLCtHQUErRyxjQUFjLFdBQVcsc0JBQXNCLElBQUksUUFBUSx5QkFBeUIscUJBQXFCLGFBQWEsV0FBVyxxREFBcUQsa0NBQWtDLFNBQVMsT0FBTyxjQUFjLGdCQUFnQixlQUFlLGlFQUFpRSx3Q0FBd0MsY0FBYyxNQUFNLEdBQUcsTUFBTSwrSUFBK0ksSUFBSSxRQUFRLE9BQU8sc0pBQXNKLFlBQVksS0FBSyxjQUFjLGtCQUFrQixzR0FBc0csVUFBVSxZQUFZLE1BQU0sY0FBYyxrQkFBa0IsT0FBTyxrQkFBa0Isa0JBQWtCLDZCQUE2QiwyREFBMkQsOEJBQThCLE1BQU0saUJBQWlCLFFBQVEsa0JBQWtCLG1CQUFtQixtR0FBbUcsY0FBYywyREFBMkQsZUFBZSxvQ0FBb0MsaUtBQWlLLGFBQWEsYUFBYSx1T0FBdU8sT0FBTyx5REFBeUQsOEVBQThFLEtBQUssZ0RBQWdELCtJQUErSSx1QkFBdUIsU0FBUyxjQUFjLFNBQVMseUVBQXlFLHNDQUFzQyxvQkFBb0IsTUFBTSxFQUFFLGFBQWEsU0FBUyxjQUFjLG9EQUFvRCxNQUFNLGdEQUFnRCxnQ0FBZ0MsU0FBUyx5QkFBeUIsRUFBRSxPQUFPLHlCQUF5QixpQkFBaUIsNkJBQTZCLGVBQWUsNkJBQTZCLG1CQUFtQixzQ0FBc0MsaUJBQWlCLFNBQVMsb0NBQW9DLDZDQUE2QyxTQUFTLEVBQUUsU0FBUyxnQkFBZ0IsUUFBUSxLQUFLLEVBQUUsMkJBQTJCLDBCQUEwQixhQUFhLGNBQWMsK0RBQStELE1BQU0sT0FBTywyQkFBMkIsb0RBQW9ELDZHQUE2RyxZQUFZLGFBQWEsYUFBYSxtQkFBbUIsOEJBQThCLG9FQUFvRSxVQUFVLGVBQWUsMkNBQTJDLHVCQUF1QixVQUFVLFFBQVEsZ0NBQWdDLDZGQUE2RixLQUFLLDBDQUEwQyxtQkFBbUIsbUJBQW1CLHNCQUFzQixzQkFBc0Isc0JBQXNCLE9BQU8sS0FBSywwQkFBMEIsUUFBUSxxRUFBcUUsdUVBQXVFLDBKQUEwSixvQkFBb0IsSUFBSSxtQ0FBbUMsK0NBQStDLHNFQUFzRSx5RUFBeUUsRUFBRSw0RUFBNEUsRUFBRSxHQUFHLE1BQU0sU0FBUyxFQUFFLEc7Ozs7Ozs7O0FDQW5rM0MsT0FBTSxDQUFDLE9BQU8sR0FBRywwMDZGQUEwMDZGLEM7Ozs7Ozs7O0FDQTMxNkYsT0FBTSxDQUFDLE9BQU8sR0FBRyxvOGdCQUFvOGdCLEM7Ozs7Ozs7O0FDQXI5Z0IsT0FBTSxDQUFDLE9BQU8sR0FBRyw4MktBQTgySyxDIiwiZmlsZSI6ImJyb3dzZXItamFzbWluZS10ZXN0aW5nLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGV4cG9ydHM6IHt9LFxuIFx0XHRcdGlkOiBtb2R1bGVJZCxcbiBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiB3ZWJwYWNrL2Jvb3RzdHJhcCBiODg0NTE1ODRjNjI2MTAyMmNhZlxuICoqLyIsImJpbmRQb2x5ZmlsbCgpO1xuXG5yZXF1aXJlKCcuL2xpYi9qYXNtaW5lLTIuNC4xL2phc21pbmUuY3NzJyk7XG5yZXF1aXJlKCdlczUtc2hpbScpO1xudmFyIHNjcmlwdHMgPSBbXG4gICAgcmVxdWlyZSgnc291cmNlLW1hcC1zdXBwb3J0L2Jyb3dzZXItc291cmNlLW1hcC1zdXBwb3J0LmpzJyksXG4gICAgcmVxdWlyZSgnLi9saWIvamFzbWluZS0yLjQuMS9qYXNtaW5lLmpzJyksXG4gICAgcmVxdWlyZSgnLi9saWIvamFzbWluZS0yLjQuMS9qYXNtaW5lLWh0bWwuanMnKSxcbiAgICByZXF1aXJlKCcuL2xpYi9qYXNtaW5lLTIuNC4xL2Jvb3QuanMnKSxcbl0uam9pbignOycpO1xuXG5cbmV2YWwuY2FsbChnbG9iYWwsIHNjcmlwdHMpO1xuc291cmNlTWFwU3VwcG9ydC5pbnN0YWxsKCk7XG5cbi8vIE5lZWRlZCBmb3IgcGhhbnRvbUpTIHdoaWNoIGRvZXMgbm90IGluY2x1ZGUgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQoKVxuZnVuY3Rpb24gYmluZFBvbHlmaWxsKCkge1xuICAgIGlmICghRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQpIHtcbiAgICAgICAgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbihvVGhpcykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgLy8gY2xvc2VzdCB0aGluZyBwb3NzaWJsZSB0byB0aGUgRUNNQVNjcmlwdCA1XG4gICAgICAgICAgICAgICAgLy8gaW50ZXJuYWwgSXNDYWxsYWJsZSBmdW5jdGlvblxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kIC0gd2hhdCBpcyB0cnlpbmcgdG8gYmUgYm91bmQgaXMgbm90IGNhbGxhYmxlJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBhQXJncyAgID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSxcbiAgICAgICAgICAgICAgICBmVG9CaW5kID0gdGhpcyxcbiAgICAgICAgICAgICAgICBmTk9QICAgID0gZnVuY3Rpb24oKSB7fSxcbiAgICAgICAgICAgICAgICBmQm91bmQgID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmVG9CaW5kLmFwcGx5KHRoaXMgaW5zdGFuY2VvZiBmTk9QXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBvVGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFBcmdzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKHRoaXMucHJvdG90eXBlKSB7XG4gICAgICAgICAgICAgICAgLy8gbmF0aXZlIGZ1bmN0aW9ucyBkb24ndCBoYXZlIGEgcHJvdG90eXBlXG4gICAgICAgICAgICAgICAgZk5PUC5wcm90b3R5cGUgPSB0aGlzLnByb3RvdHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZCb3VuZC5wcm90b3R5cGUgPSBuZXcgZk5PUCgpO1xuXG4gICAgICAgICAgICByZXR1cm4gZkJvdW5kO1xuICAgICAgICB9O1xuICAgIH1cbn1cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9icm93c2VyLWphc21pbmUtdGVzdGluZy5qc1xuICoqLyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vamFzbWluZS5jc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vamFzbWluZS5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9qYXNtaW5lLmNzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9saWIvamFzbWluZS0yLjQuMS9qYXNtaW5lLmNzc1xuICoqIG1vZHVsZSBpZCA9IDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiYm9keSB7IG92ZXJmbG93LXk6IHNjcm9sbDsgfVxcblxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgeyBiYWNrZ3JvdW5kLWNvbG9yOiAjZWVlOyBwYWRkaW5nOiA1cHg7IG1hcmdpbjogLThweDsgZm9udC1zaXplOiAxMXB4OyBmb250LWZhbWlseTogTW9uYWNvLCBcXFwiTHVjaWRhIENvbnNvbGVcXFwiLCBtb25vc3BhY2U7IGxpbmUtaGVpZ2h0OiAxNHB4OyBjb2xvcjogIzMzMzsgfVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgYSB7IHRleHQtZGVjb3JhdGlvbjogbm9uZTsgfVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgYTpob3ZlciB7IHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lOyB9XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciBwLCAuamFzbWluZV9odG1sLXJlcG9ydGVyIGgxLCAuamFzbWluZV9odG1sLXJlcG9ydGVyIGgyLCAuamFzbWluZV9odG1sLXJlcG9ydGVyIGgzLCAuamFzbWluZV9odG1sLXJlcG9ydGVyIGg0LCAuamFzbWluZV9odG1sLXJlcG9ydGVyIGg1LCAuamFzbWluZV9odG1sLXJlcG9ydGVyIGg2IHsgbWFyZ2luOiAwOyBsaW5lLWhlaWdodDogMTRweDsgfVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtYmFubmVyLCAuamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN5bWJvbC1zdW1tYXJ5LCAuamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN1bW1hcnksIC5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtcmVzdWx0LW1lc3NhZ2UsIC5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3BlYyAuamFzbWluZS1kZXNjcmlwdGlvbiwgLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zcGVjLWRldGFpbCAuamFzbWluZS1kZXNjcmlwdGlvbiwgLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1hbGVydCAuamFzbWluZS1iYXIsIC5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3RhY2stdHJhY2UgeyBwYWRkaW5nLWxlZnQ6IDlweDsgcGFkZGluZy1yaWdodDogOXB4OyB9XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1iYW5uZXIgeyBwb3NpdGlvbjogcmVsYXRpdmU7IH1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWJhbm5lciAuamFzbWluZS10aXRsZSB7IGJhY2tncm91bmQ6IHVybCgnZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFGb0FBQUFaQ0FNQUFBQ0d1c255QUFBQ2RsQk1WRVgvLy8vL0FQK0FnSUNxVmFxQVFJQ1pNNW1BVllDU1NaS0FRSUNPT1k2QVRZQ0xSb3VBUUlDSk80bVNTWUNJUklpUFFJQ0hQSWVPUjRDR1E0YU1RSUNHUFlhTFJvQ0ZRNFdLUUlDUFBZV0pSWUNPUW9TSlFJQ05Qb1NJUklDTVFvU0hRSUNIUklDS1FvT0hRSUNLUG9PSk80T0pRWU9NUUlDTVE0Q0lRWUtMUUlDSVBvS0xRNENLUUlDTlBvS0pRSVNNUTRLSlFvU0xRWUtKUUlTTFE0S0lRb1NLUVlLSVFJQ0lRSVNNUW9TS1FZS0xRSU9MUW9PSlFZR0xRSU9LUUlPTVFvR0tRWU9MUVlHS1FJT0xRb0dKUVlPSlFJT0tRWUdKUUlPS1FvR0tRSUdMUUlLTFE0S0tRb0dMUVlLSlFJR0tRWUtKUUlHS1FJS0pRb0dLUVlLTFFJR0tRWUtMUUlPSlFvS0tRb09KUVlLS1FJT0pRb0tLUW9PS1FJT0xRb0tLUVlPTFFZS0pRSU9LUW9LS1FZS0tRb0tKUVlPS1FZS0xRSU9LUW9LTFFZT0tRWUtMUUlPSlFvR0tRWUtKUVlHSlFvR0tRWUtMUW9HTFFZR0tRb0dKUVlLS1FZR0pRSUtLUW9HSlFZS0xRSUtLUVlHTFFZS0tRWUdLUVlHS1FZS0pRWU9LUW9LSlFZT0tRWUtMUVlPTFFZT0tRWUtMUVlPS1FvS0tRWUtLUVlPS1FZT0pRWUtLUVlLTFFZS0tRSUtLUW9LS1FZS0tRWUtLUW9LSlFJS0tRWUtMUVlLS1FZS0tRSUtLUVlLS1FZS0tRWUtLUUlLS1FZS0pRWUdMUVlHS1FZS0tRWUtLUVlHS1FJS0tRWUdLUVlPSlFvS0tRWU9MUVlLS1FZT0tRb0tLUVlLS1FvS0tRWUtLUVlLSlFZS0xRWUtLUVlLS1FZS0tRWUtLUVlLS1FZS0tRWUtLUVlLS1FZS0pRWUtLUVlLS1FZS0tRWUtLUVlLS1FZS0tRWUtLUVlLS1FZS0tRWUtLUVlLS1FZS0xRWUtLUVlLS1FZS0tRWUtLUVlLS1FZS0tRWUtLUVlLS1FZS0tRWUtLUVlLS1FZS0tRWUttSURwRUFBQUEwWFJTVGxNQUFRSURCQVVHQndnSkNnc01EUTRQRUJFU0V4UVZGaGNZR1JvYkhCMGVIeUFpSXlRbEp5Y29LaXNzTFM0d01UUTFOamM0T1RvN1BEdytQMEJDUTBSSVNVcExURTFPVUZOVVZWZFlXRmxhVzE1ZllHRmlZMlpuYUdscWEyeHRiM0J4Y25OMGRuaDVlbnQ4Zlg1L2dJR0NoSVdJaW95TmpvK1FrWk9VbFphWW1acWJuSjJlb0tHaW82V21xS21zcmE2dnNMR3p0cmU0dWJxN3ZMMit3TUhEeE1qSnlzdk56cy9RMGRMVTF0ZlkyZHZjM3QvZzRlTGo1ZWJuNk9ucTYrenQ3dS93OHZQMDlmYjMrUG42Ky96OS92a1ZRWEFBQUFNYVNVUkJWSGhlNWRYeFYxTjFHTWZ4ejJBQmJEZ0lBbTVWREpPeVZESUpMVU1hVnBCV1VaVWFHYm1xb0dwWlJTaUdpUldwNktvWjVBQjBaWTUwUkltWlFJbGFoS2tNWVh2L1I5MGRCdkVUL3JKZk9yM091Yzh2OTl6UGVjNTl6dmY1NmordllLbFZpU2Y3MjUwWDRNcjNPMjlUZ3EwOEJkR0I0RGhjZWtFSjVZa1FLRnNnV1pkdGo5SnBWK0k4eFBqTEZxa3JzRUlxTzhQSFNwaXMzNmpXYXpjcWpFc2ZKamt2UnNzVlUzN1NkSU91NFhDZjV2RUpQc253SnBuUk5VOUpteGhNazhsMWdlaElycTdoVEZqek9EK1ZmODg2MjlxS01KVk5sdEluRmVSZXhSUXlKbE5lcWQxaUdEbFN6cklVSXlYYnlGZm0zUllwcmNRUmU3bHF0V3lHWWJmYzZkVDBSMnZtZE9Pa1gzdTU1QzFyUDM3ZnRpSCt0RGJ5NHIvUkJUMHc4VHlFa3IrZXBCOVhnUERtU1lZV2JyaEN1RllhSXl3M2ZEUUFYVG5Ta2grQU5vZmlIbVdmOWwrRlkxSTkwRmRRVGV0c3RPMDBvMjNub3Z6VnNKN3VCMy9DNVRrYmpSd1o1SmVyd1Y0aVJXcTlIRmJGTWFLL2QwVFlxYXlSaVFQdUl4eFMzQnU4SldVOTAvNjB0S2k3dmtoYXpuZXowYS9UYlZPS2o1Q2FPWmg2ZldHNi9MeXY5Qi9aTFIxZ3cvUy9mcGJlVkQzTUNXMWxpNlN2V0RPbjY1dHI5OS91dld0QlMwWERtNHMxdCtzT0hwRzBrcEJLeC9sNzd3T1NueExwY3g2VFhtWExUUFFPS1lPZjlRMWRmcjgvU0oybUZkQ3ZsMVlsOTNEaUhVWnZYZUxKYkdTell1NWdWSjJzbGJTYWtPUjhkeENxNWFkUTJvRkxxc0U5RXgzTDRxUU8wZU9QZVU1eDU2YnlwWHA0b25TRWI1T2tJQ1g2bERhdDU1VGVvenROS1FjSmFha3J6OUtDYjk1b0Q2OUlLcSt5S1c0WFBqa25hUzUyVjBUWnFFMmNUdFhqY0hTQ1JtVU84OGUrODVoajNFUDc0aTlwOHB5bHc3bHhnTUR5eWw2T1Y3WmVqbmpOTWZhdHU4N0x4UmJIMElTMzVndDJhNFpqbUdwVkJkS0szV3I2SU5rOGpXV1NHcWJBNTVDS2dqQlJDNkU5dzc4eWRUZzNBQlMzQUZWMVFOMFk0QWEycGdFalduUVVSajlMMGF5SzZSMnlzRXF4SFVLelluTHZ2eVUraTlLTTJKSEp6RTR2eVpPeURjT3dPc3lTYWplTFBjOHNOdlBKa0ZseUpkMjB3cHFBelplQWZaM29XeWJ4ZCtQLzNqK1NHM3VTQmRmMlZRQUFBQUJKUlU1RXJrSmdnZz09Jykgbm8tcmVwZWF0OyBiYWNrZ3JvdW5kOiB1cmwoJ2RhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEQ5NGJXd2dkbVZ5YzJsdmJqMGlNUzR3SWlCbGJtTnZaR2x1WnowaVZWUkdMVGdpSUhOMFlXNWtZV3h2Ym1VOUltNXZJajgrQ2p3aExTMGdRM0psWVhSbFpDQjNhWFJvSUVsdWEzTmpZWEJsSUNob2RIUndPaTh2ZDNkM0xtbHVhM05qWVhCbExtOXlaeThwSUMwdFBnb0tQSE4yWndvZ0lDQjRiV3h1Y3pwa1l6MGlhSFIwY0RvdkwzQjFjbXd1YjNKbkwyUmpMMlZzWlcxbGJuUnpMekV1TVM4aUNpQWdJSGh0Ykc1ek9tTmpQU0pvZEhSd09pOHZZM0psWVhScGRtVmpiMjF0YjI1ekxtOXlaeTl1Y3lNaUNpQWdJSGh0Ykc1ek9uSmtaajBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TVRrNU9TOHdNaTh5TWkxeVpHWXRjM2x1ZEdGNExXNXpJeUlLSUNBZ2VHMXNibk02YzNablBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHlNREF3TDNOMlp5SUtJQ0FnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JZ29nSUNCNGJXeHVjenBwYm10elkyRndaVDBpYUhSMGNEb3ZMM2QzZHk1cGJtdHpZMkZ3WlM1dmNtY3ZibUZ0WlhOd1lXTmxjeTlwYm10elkyRndaU0lLSUNBZ2RtVnljMmx2YmowaU1TNHhJZ29nSUNCM2FXUjBhRDBpTmpneExqazJNalV5SWdvZ0lDQm9aV2xuYUhROUlqRTROeTQxSWdvZ0lDQnBaRDBpYzNabk1pSUtJQ0FnZUcxc09uTndZV05sUFNKd2NtVnpaWEoyWlNJK1BHMWxkR0ZrWVhSaENpQWdJQ0FnYVdROUltMWxkR0ZrWVhSaE9DSStQSEprWmpwU1JFWStQR05qT2xkdmNtc0tJQ0FnSUNBZ0lDQWdjbVJtT21GaWIzVjBQU0lpUGp4a1l6cG1iM0p0WVhRK2FXMWhaMlV2YzNabkszaHRiRHd2WkdNNlptOXliV0YwUGp4a1l6cDBlWEJsQ2lBZ0lDQWdJQ0FnSUNBZ2NtUm1PbkpsYzI5MWNtTmxQU0pvZEhSd09pOHZjSFZ5YkM1dmNtY3ZaR012WkdOdGFYUjVjR1V2VTNScGJHeEpiV0ZuWlNJZ0x6NDhMMk5qT2xkdmNtcytQQzl5WkdZNlVrUkdQand2YldWMFlXUmhkR0UrUEdSbFpuTUtJQ0FnSUNCcFpEMGlaR1ZtY3pZaVBqeGpiR2x3VUdGMGFBb2dJQ0FnSUNBZ2FXUTlJbU5zYVhCUVlYUm9NVGdpUGp4d1lYUm9DaUFnSUNBZ0lDQWdJR1E5SWswZ01Dd3hOVEF3SURBc01DQnNJRFUwTlRVdU56UXNNQ0F3TERFMU1EQWdUQ0F3TERFMU1EQWdlaUlLSUNBZ0lDQWdJQ0FnYVc1cmMyTmhjR1U2WTI5dWJtVmpkRzl5TFdOMWNuWmhkSFZ5WlQwaU1DSUtJQ0FnSUNBZ0lDQWdhV1E5SW5CaGRHZ3lNQ0lnTHo0OEwyTnNhWEJRWVhSb1Bqd3ZaR1ZtY3o0OFp3b2dJQ0FnSUhSeVlXNXpabTl5YlQwaWJXRjBjbWw0S0RFdU1qVXNNQ3d3TEMweExqSTFMREFzTVRnM0xqVXBJZ29nSUNBZ0lHbGtQU0puTVRBaVBqeG5DaUFnSUNBZ0lDQjBjbUZ1YzJadmNtMDlJbk5qWVd4bEtEQXVNU3d3TGpFcElnb2dJQ0FnSUNBZ2FXUTlJbWN4TWlJK1BHY0tJQ0FnSUNBZ0lDQWdhV1E5SW1jeE5DSStQR2NLSUNBZ0lDQWdJQ0FnSUNCamJHbHdMWEJoZEdnOUluVnliQ2dqWTJ4cGNGQmhkR2d4T0NraUNpQWdJQ0FnSUNBZ0lDQWdhV1E5SW1jeE5pSStQSEJoZEdnS0lDQWdJQ0FnSUNBZ0lDQWdJR1E5SW0wZ01UVTBOQ3cxT1RrdU5ETTBJR01nTUM0NU1pd3ROREF1TXpVeUlESTFMalk0TEMwNE1TNDJNRElnTnpFdU5UTXNMVGd4TGpZd01pQXlOeTQxTVN3d0lEUTNMalk0TERFeUxqZ3pNaUEyTVM0ME5Dd3pOUzQzTlRRZ01USXVPRE1zTWpJdU9UTWdNVEl1T0RNc05UWXVPRFV5SURFeUxqZ3pMRGd5TGpVeU55QnNJREFzTXpJNUxqRTROQ0F0TnpFdU5USXNNQ0F3TERFd05DNDFORE1nTWpZMkxqZ3pMREFnTUN3dE1UQTBMalUwTXlBdE56QXVOaXd3SURBc0xUTTBOQzQzTnlCaklEQXNMVFU0TGpZNU1TQXRNeTQyT0N3dE1UQTBMalV6TVNBdE5EUXVPVE1zTFRFMU1pNHlNVGdnTFRNMkxqWTRMQzAwTWk0eE9DQXRPVFl1TWpnc0xUWTJMakF5SUMweE5UTXVNVFFzTFRZMkxqQXlJQzB4TVRjdU16Y3NNQ0F0TWpBM0xqSTBMRGMzTGprME1TQXRNakF5TGpZMExERTVOeTR4TkRVZ2JDQXhNekF1TWl3d0lnb2dJQ0FnSUNBZ0lDQWdJQ0FnYVc1cmMyTmhjR1U2WTI5dWJtVmpkRzl5TFdOMWNuWmhkSFZ5WlQwaU1DSUtJQ0FnSUNBZ0lDQWdJQ0FnSUdsa1BTSndZWFJvTWpJaUNpQWdJQ0FnSUNBZ0lDQWdJQ0J6ZEhsc1pUMGlabWxzYkRvak9HRTBNVGd5TzJacGJHd3RiM0JoWTJsMGVUb3hPMlpwYkd3dGNuVnNaVHB1YjI1NlpYSnZPM04wY205clpUcHViMjVsSWlBdlBqeHdZWFJvQ2lBZ0lDQWdJQ0FnSUNBZ0lDQmtQU0p0SURJek1ERXVOQ3cyTmpJdU5qazFJR01nTUN3NE1DNDNNRE1nTFRZMkxqazBMREUwTlM0NE1UTWdMVEUwTnk0Mk15d3hORFV1T0RFeklDMDRNeTQwTkN3d0lDMHhORGN1TmpNc0xUWTRMamM0TVNBdE1UUTNMall6TEMweE5URXVNekF4SURBc0xUYzVMamM0TlNBMk5pNDVOQ3d0TVRRMUxqZ3dNU0F4TkRVdU9Dd3RNVFExTGpnd01TQTROQzR6TlN3d0lERTBPUzQwTml3Mk55NDROVElnTVRRNUxqUTJMREUxTVM0eU9Ea2dlaUJ0SUMweExqZ3pMQzB4T0RFdU5UUTNJR01nTFRNMUxqYzNMQzAxTkM0d09UY2dMVGt6TGpVekxDMDNPQzQ0TlRrZ0xURTFOeTQzTWl3dE56Z3VPRFU1SUMweE5EQXVNeXd3SUMweU5URXVNalFzTVRFMkxqUTBPU0F0TWpVeExqSTBMREkxTkM0NU1UZ2dNQ3d4TkRJdU1USTVJREV4TXk0M0xESTJNQzQwTVNBeU5UWXVOelFzTWpZd0xqUXhJRFl6TGpJM0xEQWdNVEU0TGpJNUxDMHlPUzR6TXpZZ01UVXlMakl5TEMwNE1pNDFNak1nYkNBd0xEWTVMalk0TnlBeE56VXVNVFFzTUNBd0xDMHhNRFF1TlRJM0lDMDJNUzQwTkN3d0lEQXNMVEk0TUM0MU9UZ2dOakV1TkRRc01DQXdMQzB4TURRdU5USTNJQzB4TnpVdU1UUXNNQ0F3TERZMkxqQXhPU0lLSUNBZ0lDQWdJQ0FnSUNBZ0lHbHVhM05qWVhCbE9tTnZibTVsWTNSdmNpMWpkWEoyWVhSMWNtVTlJakFpQ2lBZ0lDQWdJQ0FnSUNBZ0lDQnBaRDBpY0dGMGFESTBJZ29nSUNBZ0lDQWdJQ0FnSUNBZ2MzUjViR1U5SW1acGJHdzZJemhoTkRFNE1qdG1hV3hzTFc5d1lXTnBkSGs2TVR0bWFXeHNMWEoxYkdVNmJtOXVlbVZ5Ynp0emRISnZhMlU2Ym05dVpTSWdMejQ4Y0dGMGFBb2dJQ0FnSUNBZ0lDQWdJQ0FnWkQwaWJTQXlOakl5TGpNekxEVTFOeTR5TlRnZ1l5QXpMalkzTEMwME5DNHdNVFlnTXpNdU1ERXNMVGN6TGpNME9DQTNPQzQ0Tml3dE56TXVNelE0SURNekxqa3pMREFnTmpZdU9UTXNNak11T0RJMElEWTJMamt6TERZd0xqVXdOQ0F3TERRNExqWXdOaUF0TkRVdU9EUXNOVFl1T0RVMklDMDRNeTQwTkN3Mk5pNDVOREVnTFRnMUxqSTRMREl5TGpBd05DQXRNVGM0TGpneExEUTRMall3TmlBdE1UYzRMamd4TERFMU5TNDROemtnTUN3NU15NDFNellnTnpndU9EWXNNVFEzTGpZek15QXhOalV1T1Rnc01UUTNMall6TXlBME5Dd3dJRGd6TGpRekxDMDVMakUzTmlBeE1UQXVPVFFzTFRRMExqQXdPQ0JzSURBc016TXVPVEl5SURneUxqVXpMREFnTUN3dE1UTXlMamsyTlNBdE1UQTRMakl4TERBZ1l5QXRNUzQ0TXl3ek5DNDROVFlnTFRJNExqUXlMRFUzTGpjM05DQXROak11TWpZc05UY3VOemMwSUMwek1DNHlOaXd3SUMwMk1pNHpOU3d0TVRjdU5ESXlJQzAyTWk0ek5Td3ROVEV1TXpRNElEQXNMVFExTGpnME55QTBOQzQ1TXl3dE5UVXVPVE1nT0RBdU5qa3NMVFkwTGpFNElEZzRMakF5TEMweU1DNHhOelVnTVRneUxqUTNMQzAwTnk0Mk9UVWdNVGd5TGpRM0xDMHhOVGN1TnpNMElEQXNMVGs1TGpBeU55QXRPRE11TkRRc0xURTFOQzR3TXprZ0xURTNOUzR4TXl3dE1UVTBMakF6T1NBdE5Ea3VOVE1zTUNBdE9UUXVORFlzTVRVdU5UZ3lJQzB4TWpZdU5UVXNOVE11TVRnZ2JDQXdMQzAwTUM0ek5DQXRPRFV1TWpjc01DQXdMREUwTWk0eE1qa2dNVEUwTGpZeUxEQWlDaUFnSUNBZ0lDQWdJQ0FnSUNCcGJtdHpZMkZ3WlRwamIyNXVaV04wYjNJdFkzVnlkbUYwZFhKbFBTSXdJZ29nSUNBZ0lDQWdJQ0FnSUNBZ2FXUTlJbkJoZEdneU5pSUtJQ0FnSUNBZ0lDQWdJQ0FnSUhOMGVXeGxQU0ptYVd4c09pTTRZVFF4T0RJN1ptbHNiQzF2Y0dGamFYUjVPakU3Wm1sc2JDMXlkV3hsT201dmJucGxjbTg3YzNSeWIydGxPbTV2Ym1VaUlDOCtQSEJoZEdnS0lDQWdJQ0FnSUNBZ0lDQWdJR1E5SW0wZ01qazRPQzR4T0N3NE1EQXVNalUwSUMwMk15NHlOaXd3SURBc01UQTBMalV5TnlBeE5qVXVNRFVzTUNBd0xDMDNNeTR6TlRVZ1l5QXpNUzR4T0N3MU1TNHpORGNnTnpndU9EWXNPRFV1TWpjM0lERTBNUzR5TVN3NE5TNHlOemNnTmpjdU9EVXNNQ0F4TWpRdU56RXNMVFF4TGpJMU9DQXhOVEl1TWpFc0xURXdNaTQyT1RrZ01qWXVOaXcyTWk0ek5URWdPVEl1TmpJc01UQXlMalk1T1NBeE5qQXVORGNzTVRBeUxqWTVPU0ExTXk0eE9Td3dJREV3TlM0ME5pd3RNaklnTVRReExqSXhMQzAyTWk0ek5URWdNemd1TlRJc0xUUTBMamt6T0NBek9DNDFNaXd0T1RNdU5UTXlJRE00TGpVeUxDMHhORGt1TkRVM0lHd2dNQ3d0TVRnMUxqSXpPU0EyTXk0eU55d3dJREFzTFRFd05DNDFNamNnTFRJek9DNDBNaXd3SURBc01UQTBMalV5TnlBMk15NHlPQ3d3SURBc01UVTNMamN4TlNCaklEQXNNekl1TVRBeUlEQXNOakF1TlRJM0lDMHhOQzQyTnl3NE9DNDVOVGNnTFRFNExqTTBMREkyTGpVNE1pQXRORGd1TmpFc05EQXVNelEwSUMwM09TNDNOeXcwTUM0ek5EUWdMVE13TGpJMkxEQWdMVFl6TGpJNExDMHhNaTQ0TkRRZ0xUZ3lMalV6TEMwek5pNDJOeklnTFRJeUxqa3pMQzB5T1M0ek5UVWdMVEl5TGprekxDMDFOaTQ0TmpNZ0xUSXlMamt6TEMwNU1pNDJNamtnYkNBd0xDMHhOVGN1TnpFMUlEWXpMakkzTERBZ01Dd3RNVEEwTGpVeU55QXRNak00TGpReExEQWdNQ3d4TURRdU5USTNJRFl6TGpJNExEQWdNQ3d4TlRBdU16Z3pJR01nTUN3eU9TNHpORGdnTUN3Mk5pNHdNak1nTFRFMExqWTNMRGt4TGpZNU9TQXRNVFV1TlRrc01qa3VNek0ySUMwME55NDJPU3cwTkM0NU16UWdMVGd3TGpjc05EUXVPVE0wSUMwek1TNHhPQ3d3SUMwMU55NDNOeXd0TVRFdU1EQTRJQzAzTnk0NU5Dd3RNelV1TnpjMElDMHlOQzQzTnl3dE16QXVNalV6SUMweU5pNDJMQzAyTWk0ek5ETWdMVEkyTGpZc0xUazVMamswTVNCc0lEQXNMVEUxTVM0ek1ERWdOak11TWpjc01DQXdMQzB4TURRdU5USTNJQzB5TXpndU5Dd3dJREFzTVRBMExqVXlOeUEyTXk0eU5pd3dJREFzTWpnd0xqVTVPQ0lLSUNBZ0lDQWdJQ0FnSUNBZ0lHbHVhM05qWVhCbE9tTnZibTVsWTNSdmNpMWpkWEoyWVhSMWNtVTlJakFpQ2lBZ0lDQWdJQ0FnSUNBZ0lDQnBaRDBpY0dGMGFESTRJZ29nSUNBZ0lDQWdJQ0FnSUNBZ2MzUjViR1U5SW1acGJHdzZJemhoTkRFNE1qdG1hV3hzTFc5d1lXTnBkSGs2TVR0bWFXeHNMWEoxYkdVNmJtOXVlbVZ5Ynp0emRISnZhMlU2Ym05dVpTSWdMejQ4Y0dGMGFBb2dJQ0FnSUNBZ0lDQWdJQ0FnWkQwaWJTQXpPVGs0TGpZMkxEazFNUzQxTkRjZ0xURXhNUzQ0Tnl3d0lEQXNNVEU0TGpJNU15QXhNVEV1T0Rjc01DQXdMQzB4TVRndU1qa3pJSG9nYlNBd0xDMDBNekV1T0RreElEWXpMakkzTERBZ01Dd3RNVEEwTGpVeU55QXRNak01TGpNekxEQWdNQ3d4TURRdU5USTNJRFkwTGpFNUxEQWdNQ3d5T0RBdU5UazRJQzAyTXk0eU55d3dJREFzTVRBMExqVXlOeUF4TnpVdU1UUXNNQ0F3TEMwek9EVXVNVEkxSWdvZ0lDQWdJQ0FnSUNBZ0lDQWdhVzVyYzJOaGNHVTZZMjl1Ym1WamRHOXlMV04xY25aaGRIVnlaVDBpTUNJS0lDQWdJQ0FnSUNBZ0lDQWdJR2xrUFNKd1lYUm9NekFpQ2lBZ0lDQWdJQ0FnSUNBZ0lDQnpkSGxzWlQwaVptbHNiRG9qT0dFME1UZ3lPMlpwYkd3dGIzQmhZMmwwZVRveE8yWnBiR3d0Y25Wc1pUcHViMjU2WlhKdk8zTjBjbTlyWlRwdWIyNWxJaUF2UGp4d1lYUm9DaUFnSUNBZ0lDQWdJQ0FnSUNCa1BTSnRJRFF4TlRrdU1USXNPREF3TGpJMU5DQXROak11TWpjc01DQXdMREV3TkM0MU1qY2dNVGMxTGpFMExEQWdNQ3d0TmprdU5qZzNJR01nTWprdU16VXNOVFF1TVRBeElEZzBMak0yTERnd0xqWTVPU0F4TkRRdU9EY3NPREF1TmprNUlEVXpMakU1TERBZ01UQTFMalExTEMweU1pNHdNVFlnTVRReExqSXlMQzAyTUM0MU1qY2dOREF1TXpRc0xUUTBMamt6TkNBME1TNHlOaXd0T0RndU1ETXlJRFF4TGpJMkxDMHhORE11T1RVM0lHd2dNQ3d0TVRreExqWTFNeUEyTXk0eU55d3dJREFzTFRFd05DNDFNamNnTFRJek9DNDBMREFnTUN3eE1EUXVOVEkzSURZekxqSTJMREFnTUN3eE5UZ3VOak0zSUdNZ01Dd3pNQzR5TmpJZ01DdzJNUzQwTXpRZ0xURTVMakkyTERnNExqQXpOU0F0TWpBdU1UY3NNall1TlRneUlDMDFNeTR4T0N3ek9TNDBNVFFnTFRnMkxqRTVMRE01TGpReE5DQXRNek11T1RNc01DQXROamd1Tnpjc0xURXpMamMxSUMwNE9DNDVOQ3d0TkRFdU1qVWdMVEl4TGpBNUxDMHlOeTQxSUMweU1TNHdPU3d0TmprdU5qZzNJQzB5TVM0d09Td3RNVEF5TGpjd055QnNJREFzTFRFME1pNHhNamtnTmpNdU1qWXNNQ0F3TEMweE1EUXVOVEkzSUMweU16Z3VOQ3d3SURBc01UQTBMalV5TnlBMk15NHlOeXd3SURBc01qZ3dMalU1T0NJS0lDQWdJQ0FnSUNBZ0lDQWdJR2x1YTNOallYQmxPbU52Ym01bFkzUnZjaTFqZFhKMllYUjFjbVU5SWpBaUNpQWdJQ0FnSUNBZ0lDQWdJQ0JwWkQwaWNHRjBhRE15SWdvZ0lDQWdJQ0FnSUNBZ0lDQWdjM1I1YkdVOUltWnBiR3c2SXpoaE5ERTRNanRtYVd4c0xXOXdZV05wZEhrNk1UdG1hV3hzTFhKMWJHVTZibTl1ZW1WeWJ6dHpkSEp2YTJVNmJtOXVaU0lnTHo0OGNHRjBhQW9nSUNBZ0lDQWdJQ0FnSUNBZ1pEMGliU0ExTURneUxqUTRMRGN3TXk0NU5qVWdZeUF0TVRrdU1qUXNOekF1TmpBMUlDMDRNUzQyTERFeE5TNDFORGNnTFRFMU5DNHdOQ3d4TVRVdU5UUTNJQzAyTmk0d05Dd3dJQzB4TWprdU15d3ROVEV1TXpRNElDMHhORE11TURVc0xURXhOUzQxTkRjZ2JDQXlPVGN1TURrc01DQjZJRzBnT0RVdU1qY3NMVEUwTkM0NE9ETWdZeUF0TXpndU5URXNMVGt6TGpVeU15QXRNVEk1TGpJM0xDMHhOVFl1TnpreklDMHlNekV1TURVc0xURTFOaTQzT1RNZ0xURTBNeTR3Tnl3d0lDMHlOVGN1Tmpnc01URXhMamczTVNBdE1qVTNMalk0TERJMU5TNDRNellnTUN3eE5EUXVPRGd6SURFd09TNHhNaXd5TmpFdU16STRJREkxTkM0NU1Td3lOakV1TXpJNElEWTNMamczTERBZ01UTTFMamN5TEMwek1DNHlOVGdnTVRnekxqTTVMQzAzT0M0NE5qTWdORGd1TmpJc0xUVXhMak0wTkNBMk9DNDNPU3d0TVRFekxqWTVOU0EyT0M0M09Td3RNVGd6TGpNNE15QnNJQzB6TGpZM0xDMHpPUzQwTXpRZ0xUTTVOaTR4TXl3d0lHTWdNVFF1Tmpjc0xUWTNMamcyTXlBM055NHdNeXd0TVRFM0xqTTJNeUF4TkRZdU56SXNMVEV4Tnk0ek5qTWdORGd1TlRrc01DQTVNQzQzTml3eE9DNHpNamdnTVRFNExqSTRMRFU0TGpZM01pQnNJREV4Tmk0ME5Dd3dJZ29nSUNBZ0lDQWdJQ0FnSUNBZ2FXNXJjMk5oY0dVNlkyOXVibVZqZEc5eUxXTjFjblpoZEhWeVpUMGlNQ0lLSUNBZ0lDQWdJQ0FnSUNBZ0lHbGtQU0p3WVhSb016UWlDaUFnSUNBZ0lDQWdJQ0FnSUNCemRIbHNaVDBpWm1sc2JEb2pPR0UwTVRneU8yWnBiR3d0YjNCaFkybDBlVG94TzJacGJHd3RjblZzWlRwdWIyNTZaWEp2TzNOMGNtOXJaVHB1YjI1bElpQXZQanh3WVhSb0NpQWdJQ0FnSUNBZ0lDQWdJQ0JrUFNKdElEWTVNQzQ0T1RVc09EVXdMamN3TXlBNU1DNDNOU3d3SURJeUxqVTBNeXd6TVM0d016VWdNQ3d5TkRNdU1USXlJQzB4TXpVdU9ESTVMREFnTUN3dE1qUXpMakUwTVNBeU1pNDFNellzTFRNeExqQXhOaUlLSUNBZ0lDQWdJQ0FnSUNBZ0lHbHVhM05qWVhCbE9tTnZibTVsWTNSdmNpMWpkWEoyWVhSMWNtVTlJakFpQ2lBZ0lDQWdJQ0FnSUNBZ0lDQnBaRDBpY0dGMGFETTJJZ29nSUNBZ0lDQWdJQ0FnSUNBZ2MzUjViR1U5SW1acGJHdzZJemhoTkRFNE1qdG1hV3hzTFc5d1lXTnBkSGs2TVR0bWFXeHNMWEoxYkdVNmJtOXVlbVZ5Ynp0emRISnZhMlU2Ym05dVpTSWdMejQ4Y0dGMGFBb2dJQ0FnSUNBZ0lDQWdJQ0FnWkQwaWJTQTJNekl1TXprMUxEYzBNaTR5TlRnZ01qZ3VNRE01TERnMkxqTXdOQ0F0TWpJdU5UVXhMRE14TGpBMElDMHlNekV1TWpJekxEYzFMakV5T0NBdE5ERXVPVGMyTEMweE1qa3VNVGd6SURJek1TNHlOVGNzTFRjMUxqRXpOeUF6Tmk0ME5UUXNNVEV1T0RRNElnb2dJQ0FnSUNBZ0lDQWdJQ0FnYVc1cmMyTmhjR1U2WTI5dWJtVmpkRzl5TFdOMWNuWmhkSFZ5WlQwaU1DSUtJQ0FnSUNBZ0lDQWdJQ0FnSUdsa1BTSndZWFJvTXpnaUNpQWdJQ0FnSUNBZ0lDQWdJQ0J6ZEhsc1pUMGlabWxzYkRvak9HRTBNVGd5TzJacGJHd3RiM0JoWTJsMGVUb3hPMlpwYkd3dGNuVnNaVHB1YjI1NlpYSnZPM04wY205clpUcHViMjVsSWlBdlBqeHdZWFJvQ2lBZ0lDQWdJQ0FnSUNBZ0lDQmtQU0p0SURjeE55NDBORGtzTmpVekxqRXdOU0F0TnpNdU5ERXNOVE11TXpZZ0xUTTJMalE0T0N3dE1URXVPRGMxSUMweE5ESXVPVEF6TEMweE9UWXVOamt5SURFd09TNDRPRE1zTFRjNUxqZ3lPQ0F4TkRJdU9URTRMREU1Tmk0M01ETWdNQ3d6T0M0ek16SWlDaUFnSUNBZ0lDQWdJQ0FnSUNCcGJtdHpZMkZ3WlRwamIyNXVaV04wYjNJdFkzVnlkbUYwZFhKbFBTSXdJZ29nSUNBZ0lDQWdJQ0FnSUNBZ2FXUTlJbkJoZEdnME1DSUtJQ0FnSUNBZ0lDQWdJQ0FnSUhOMGVXeGxQU0ptYVd4c09pTTRZVFF4T0RJN1ptbHNiQzF2Y0dGamFYUjVPakU3Wm1sc2JDMXlkV3hsT201dmJucGxjbTg3YzNSeWIydGxPbTV2Ym1VaUlDOCtQSEJoZEdnS0lDQWdJQ0FnSUNBZ0lDQWdJR1E5SW0wZ09ESTRMalV5TERjd05pNDBOalVnTFRjekxqUXlOaXd0TlRNdU16UWdNQzR3TVRFc0xUTTRMak0xT1NCTUlEZzVPQzR3TURRc05ERTRMakEzSURFd01EY3VPU3cwT1RjdU9EazRJRGcyTkM0NU56TXNOamswTGpZd09TQTRNamd1TlRJc056QTJMalEyTlNJS0lDQWdJQ0FnSUNBZ0lDQWdJR2x1YTNOallYQmxPbU52Ym01bFkzUnZjaTFqZFhKMllYUjFjbVU5SWpBaUNpQWdJQ0FnSUNBZ0lDQWdJQ0JwWkQwaWNHRjBhRFF5SWdvZ0lDQWdJQ0FnSUNBZ0lDQWdjM1I1YkdVOUltWnBiR3c2SXpoaE5ERTRNanRtYVd4c0xXOXdZV05wZEhrNk1UdG1hV3hzTFhKMWJHVTZibTl1ZW1WeWJ6dHpkSEp2YTJVNmJtOXVaU0lnTHo0OGNHRjBhQW9nSUNBZ0lDQWdJQ0FnSUNBZ1pEMGliU0E0TVRJdU1EZzJMRGd5T0M0MU9EWWdNamd1TURVMUxDMDROaTR6TWlBek5pNDBPRFFzTFRFeExqZ3pOaUF5TXpFdU1qSTFMRGMxTGpFeE55QXROREV1T1Rjc01USTVMakU0TXlBdE1qTXhMakl6T1N3dE56VXVNVFFnTFRJeUxqVTFOU3d0TXpFdU1EQTBJZ29nSUNBZ0lDQWdJQ0FnSUNBZ2FXNXJjMk5oY0dVNlkyOXVibVZqZEc5eUxXTjFjblpoZEhWeVpUMGlNQ0lLSUNBZ0lDQWdJQ0FnSUNBZ0lHbGtQU0p3WVhSb05EUWlDaUFnSUNBZ0lDQWdJQ0FnSUNCemRIbHNaVDBpWm1sc2JEb2pPR0UwTVRneU8yWnBiR3d0YjNCaFkybDBlVG94TzJacGJHd3RjblZzWlRwdWIyNTZaWEp2TzNOMGNtOXJaVHB1YjI1bElpQXZQanh3WVhSb0NpQWdJQ0FnSUNBZ0lDQWdJQ0JrUFNKdElEY3pOaTR6TURFc01UTXpOUzQ0T0NCaklDMHpNak11TURRM0xEQWdMVFU0TlM0NE56VXNMVEkyTWk0M09DQXROVGcxTGpnM05Td3ROVGcxTGpjNE1pQXdMQzB6TWpNdU1URTRJREkyTWk0NE1qZ3NMVFU0TlM0NU56Y2dOVGcxTGpnM05Td3ROVGcxTGprM055QXpNak11TURFNUxEQWdOVGcxTGpnd09Td3lOakl1T0RVNUlEVTROUzQ0TURrc05UZzFMamszTnlBd0xETXlNeTR3TURJZ0xUSTJNaTQzT1N3MU9EVXVOemd5SUMwMU9EVXVPREE1TERVNE5TNDNPRElnYkNBd0xEQWdlaUJ0SURBc0xURXhPQzQyTVNCaklESTFOeTQ1TnpJc01DQTBOamN1TVRnNUxDMHlNRGt1TVRNZ05EWTNMakU0T1N3dE5EWTNMakUzTWlBd0xDMHlOVGd1TVRJNUlDMHlNRGt1TWpFM0xDMDBOamN1TXpRNElDMDBOamN1TVRnNUxDMDBOamN1TXpRNElDMHlOVGd1TURjMExEQWdMVFEyTnk0eU5UUXNNakE1TGpJeE9TQXRORFkzTGpJMU5DdzBOamN1TXpRNElEQXNNalU0TGpBME1pQXlNRGt1TVRnc05EWTNMakUzTWlBME5qY3VNalUwTERRMk55NHhOeklpQ2lBZ0lDQWdJQ0FnSUNBZ0lDQnBibXR6WTJGd1pUcGpiMjV1WldOMGIzSXRZM1Z5ZG1GMGRYSmxQU0l3SWdvZ0lDQWdJQ0FnSUNBZ0lDQWdhV1E5SW5CaGRHZzBOaUlLSUNBZ0lDQWdJQ0FnSUNBZ0lITjBlV3hsUFNKbWFXeHNPaU00WVRReE9ESTdabWxzYkMxdmNHRmphWFI1T2pFN1ptbHNiQzF5ZFd4bE9tNXZibnBsY204N2MzUnliMnRsT201dmJtVWlJQzgrUEhCaGRHZ0tJQ0FnSUNBZ0lDQWdJQ0FnSUdROUltMGdNVEE1TVM0eE15dzJNVGt1T0RneklDMHhOelV1TnpjeExEVTNMakV5TVNBeE1TNDJNamtzTXpVdU9EQTRJREUzTlM0M05qSXNMVFUzTGpFeU1TQXRNVEV1TmpJc0xUTTFMamd3T0NJS0lDQWdJQ0FnSUNBZ0lDQWdJR2x1YTNOallYQmxPbU52Ym01bFkzUnZjaTFqZFhKMllYUjFjbVU5SWpBaUNpQWdJQ0FnSUNBZ0lDQWdJQ0JwWkQwaWNHRjBhRFE0SWdvZ0lDQWdJQ0FnSUNBZ0lDQWdjM1I1YkdVOUltWnBiR3c2SXpoaE5ERTRNanRtYVd4c0xXOXdZV05wZEhrNk1UdG1hV3hzTFhKMWJHVTZibTl1ZW1WeWJ6dHpkSEp2YTJVNmJtOXVaU0lnTHo0OGNHRjBhQW9nSUNBZ0lDQWdJQ0FnSUNBZ1pEMGlUU0E0TmpZdU9UVTNMRGt3TWk0d056UWdPRE0yTGpVc09USTBMakU1T1NBNU5EVXVNVEl4TERFd056TXVOek1nT1RjMUxqVTROaXd4TURVeExqWXhJRGcyTmk0NU5UY3NPVEF5TGpBM05DSUtJQ0FnSUNBZ0lDQWdJQ0FnSUdsdWEzTmpZWEJsT21OdmJtNWxZM1J2Y2kxamRYSjJZWFIxY21VOUlqQWlDaUFnSUNBZ0lDQWdJQ0FnSUNCcFpEMGljR0YwYURVd0lnb2dJQ0FnSUNBZ0lDQWdJQ0FnYzNSNWJHVTlJbVpwYkd3Nkl6aGhOREU0TWp0bWFXeHNMVzl3WVdOcGRIazZNVHRtYVd4c0xYSjFiR1U2Ym05dWVtVnlienR6ZEhKdmEyVTZibTl1WlNJZ0x6NDhjR0YwYUFvZ0lDQWdJQ0FnSUNBZ0lDQWdaRDBpVFNBMk1EY3VORFkxTERrd015NDBORFVnTkRrNExqZzFOU3d4TURVeUxqazNJRFV5T1M0ek1pd3hNRGMxTGpFZ05qTTNMamt6TERreU5TNDFOallnTmpBM0xqUTJOU3c1TURNdU5EUTFJZ29nSUNBZ0lDQWdJQ0FnSUNBZ2FXNXJjMk5oY0dVNlkyOXVibVZqZEc5eUxXTjFjblpoZEhWeVpUMGlNQ0lLSUNBZ0lDQWdJQ0FnSUNBZ0lHbGtQU0p3WVhSb05USWlDaUFnSUNBZ0lDQWdJQ0FnSUNCemRIbHNaVDBpWm1sc2JEb2pPR0UwTVRneU8yWnBiR3d0YjNCaFkybDBlVG94TzJacGJHd3RjblZzWlRwdWIyNTZaWEp2TzNOMGNtOXJaVHB1YjI1bElpQXZQanh3WVhSb0NpQWdJQ0FnSUNBZ0lDQWdJQ0JrUFNKdElETTRNQzQyT0Rnc05qSXlMakV5T1NBdE1URXVOakkyTERNMUxqZ3dNU0F4TnpVdU56VTRMRFUzTGpBNUlERXhMall5TVN3dE16VXVPREF4SUMweE56VXVOelV6TEMwMU55NHdPU0lLSUNBZ0lDQWdJQ0FnSUNBZ0lHbHVhM05qWVhCbE9tTnZibTVsWTNSdmNpMWpkWEoyWVhSMWNtVTlJakFpQ2lBZ0lDQWdJQ0FnSUNBZ0lDQnBaRDBpY0dGMGFEVTBJZ29nSUNBZ0lDQWdJQ0FnSUNBZ2MzUjViR1U5SW1acGJHdzZJemhoTkRFNE1qdG1hV3hzTFc5d1lXTnBkSGs2TVR0bWFXeHNMWEoxYkdVNmJtOXVlbVZ5Ynp0emRISnZhMlU2Ym05dVpTSWdMejQ4Y0dGMGFBb2dJQ0FnSUNBZ0lDQWdJQ0FnWkQwaWJTQTNNVFl1TWpnNUxETTNOaTQxT1NBek55NDJOREEyTERBZ01Dd3hPRFF1T0RFMklDMHpOeTQyTkRBMkxEQWdNQ3d0TVRnMExqZ3hOaUI2SWdvZ0lDQWdJQ0FnSUNBZ0lDQWdhVzVyYzJOaGNHVTZZMjl1Ym1WamRHOXlMV04xY25aaGRIVnlaVDBpTUNJS0lDQWdJQ0FnSUNBZ0lDQWdJR2xrUFNKd1lYUm9OVFlpQ2lBZ0lDQWdJQ0FnSUNBZ0lDQnpkSGxzWlQwaVptbHNiRG9qT0dFME1UZ3lPMlpwYkd3dGIzQmhZMmwwZVRveE8yWnBiR3d0Y25Wc1pUcHViMjU2WlhKdk8zTjBjbTlyWlRwdWIyNWxJaUF2UGp3dlp6NDhMMmMrUEM5blBqd3ZaejQ4TDNOMlp6ND0nKSBuby1yZXBlYXQsIG5vbmU7IC1tb3otYmFja2dyb3VuZC1zaXplOiAxMDAlOyAtby1iYWNrZ3JvdW5kLXNpemU6IDEwMCU7IC13ZWJraXQtYmFja2dyb3VuZC1zaXplOiAxMDAlOyBiYWNrZ3JvdW5kLXNpemU6IDEwMCU7IGRpc3BsYXk6IGJsb2NrOyBmbG9hdDogbGVmdDsgd2lkdGg6IDkwcHg7IGhlaWdodDogMjVweDsgfVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtYmFubmVyIC5qYXNtaW5lLXZlcnNpb24geyBtYXJnaW4tbGVmdDogMTRweDsgcG9zaXRpb246IHJlbGF0aXZlOyB0b3A6IDZweDsgfVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgI2phc21pbmVfY29udGVudCB7IHBvc2l0aW9uOiBmaXhlZDsgcmlnaHQ6IDEwMCU7IH1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXZlcnNpb24geyBjb2xvcjogI2FhYTsgfVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtYmFubmVyIHsgbWFyZ2luLXRvcDogMTRweDsgfVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtZHVyYXRpb24geyBjb2xvcjogI2ZmZjsgZmxvYXQ6IHJpZ2h0OyBsaW5lLWhlaWdodDogMjhweDsgcGFkZGluZy1yaWdodDogOXB4OyB9XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zeW1ib2wtc3VtbWFyeSB7IG92ZXJmbG93OiBoaWRkZW47ICp6b29tOiAxOyBtYXJnaW46IDE0cHggMDsgfVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3ltYm9sLXN1bW1hcnkgbGkgeyBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IGhlaWdodDogMTBweDsgd2lkdGg6IDE0cHg7IGZvbnQtc2l6ZTogMTZweDsgfVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3ltYm9sLXN1bW1hcnkgbGkuamFzbWluZS1wYXNzZWQgeyBmb250LXNpemU6IDE0cHg7IH1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN5bWJvbC1zdW1tYXJ5IGxpLmphc21pbmUtcGFzc2VkOmJlZm9yZSB7IGNvbG9yOiAjMDA3MDY5OyBjb250ZW50OiBcXFwiXFxcXDIwMjJcXFwiOyB9XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zeW1ib2wtc3VtbWFyeSBsaS5qYXNtaW5lLWZhaWxlZCB7IGxpbmUtaGVpZ2h0OiA5cHg7IH1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN5bWJvbC1zdW1tYXJ5IGxpLmphc21pbmUtZmFpbGVkOmJlZm9yZSB7IGNvbG9yOiAjY2EzYTExOyBjb250ZW50OiBcXFwiXFxcXEQ3XFxcIjsgZm9udC13ZWlnaHQ6IGJvbGQ7IG1hcmdpbi1sZWZ0OiAtMXB4OyB9XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zeW1ib2wtc3VtbWFyeSBsaS5qYXNtaW5lLWRpc2FibGVkIHsgZm9udC1zaXplOiAxNHB4OyB9XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zeW1ib2wtc3VtbWFyeSBsaS5qYXNtaW5lLWRpc2FibGVkOmJlZm9yZSB7IGNvbG9yOiAjYmFiYWJhOyBjb250ZW50OiBcXFwiXFxcXDIwMjJcXFwiOyB9XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zeW1ib2wtc3VtbWFyeSBsaS5qYXNtaW5lLXBlbmRpbmcgeyBsaW5lLWhlaWdodDogMTdweDsgfVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3ltYm9sLXN1bW1hcnkgbGkuamFzbWluZS1wZW5kaW5nOmJlZm9yZSB7IGNvbG9yOiAjYmE5ZDM3OyBjb250ZW50OiBcXFwiKlxcXCI7IH1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN5bWJvbC1zdW1tYXJ5IGxpLmphc21pbmUtZW1wdHkgeyBmb250LXNpemU6IDE0cHg7IH1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN5bWJvbC1zdW1tYXJ5IGxpLmphc21pbmUtZW1wdHk6YmVmb3JlIHsgY29sb3I6ICNiYTlkMzc7IGNvbnRlbnQ6IFxcXCJcXFxcMjAyMlxcXCI7IH1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXJ1bi1vcHRpb25zIHsgZmxvYXQ6IHJpZ2h0OyBtYXJnaW4tcmlnaHQ6IDVweDsgYm9yZGVyOiAxcHggc29saWQgIzhhNDE4MjsgY29sb3I6ICM4YTQxODI7IHBvc2l0aW9uOiByZWxhdGl2ZTsgbGluZS1oZWlnaHQ6IDIwcHg7IH1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXJ1bi1vcHRpb25zIC5qYXNtaW5lLXRyaWdnZXIgeyBjdXJzb3I6IHBvaW50ZXI7IHBhZGRpbmc6IDhweCAxNnB4OyB9XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1ydW4tb3B0aW9ucyAuamFzbWluZS1wYXlsb2FkIHsgcG9zaXRpb246IGFic29sdXRlOyBkaXNwbGF5OiBub25lOyByaWdodDogLTFweDsgYm9yZGVyOiAxcHggc29saWQgIzhhNDE4MjsgYmFja2dyb3VuZC1jb2xvcjogI2VlZTsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgcGFkZGluZzogNHB4IDhweDsgfVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtcnVuLW9wdGlvbnMgLmphc21pbmUtcGF5bG9hZC5qYXNtaW5lLW9wZW4geyBkaXNwbGF5OiBibG9jazsgfVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtYmFyIHsgbGluZS1oZWlnaHQ6IDI4cHg7IGZvbnQtc2l6ZTogMTRweDsgZGlzcGxheTogYmxvY2s7IGNvbG9yOiAjZWVlOyB9XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1iYXIuamFzbWluZS1mYWlsZWQgeyBiYWNrZ3JvdW5kLWNvbG9yOiAjY2EzYTExOyB9XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1iYXIuamFzbWluZS1wYXNzZWQgeyBiYWNrZ3JvdW5kLWNvbG9yOiAjMDA3MDY5OyB9XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1iYXIuamFzbWluZS1za2lwcGVkIHsgYmFja2dyb3VuZC1jb2xvcjogI2JhYmFiYTsgfVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtYmFyLmphc21pbmUtZXJyb3JlZCB7IGJhY2tncm91bmQtY29sb3I6ICNjYTNhMTE7IH1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWJhci5qYXNtaW5lLW1lbnUgeyBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmOyBjb2xvcjogI2FhYTsgfVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtYmFyLmphc21pbmUtbWVudSBhIHsgY29sb3I6ICMzMzM7IH1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWJhciBhIHsgY29sb3I6IHdoaXRlOyB9XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlci5qYXNtaW5lLXNwZWMtbGlzdCAuamFzbWluZS1iYXIuamFzbWluZS1tZW51Lmphc21pbmUtZmFpbHVyZS1saXN0LCAuamFzbWluZV9odG1sLXJlcG9ydGVyLmphc21pbmUtc3BlYy1saXN0IC5qYXNtaW5lLXJlc3VsdHMgLmphc21pbmUtZmFpbHVyZXMgeyBkaXNwbGF5OiBub25lOyB9XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlci5qYXNtaW5lLWZhaWx1cmUtbGlzdCAuamFzbWluZS1iYXIuamFzbWluZS1tZW51Lmphc21pbmUtc3BlYy1saXN0LCAuamFzbWluZV9odG1sLXJlcG9ydGVyLmphc21pbmUtZmFpbHVyZS1saXN0IC5qYXNtaW5lLXN1bW1hcnkgeyBkaXNwbGF5OiBub25lOyB9XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1yZXN1bHRzIHsgbWFyZ2luLXRvcDogMTRweDsgfVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3VtbWFyeSB7IG1hcmdpbi10b3A6IDE0cHg7IH1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN1bW1hcnkgdWwgeyBsaXN0LXN0eWxlLXR5cGU6IG5vbmU7IG1hcmdpbi1sZWZ0OiAxNHB4OyBwYWRkaW5nLXRvcDogMDsgcGFkZGluZy1sZWZ0OiAwOyB9XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zdW1tYXJ5IHVsLmphc21pbmUtc3VpdGUgeyBtYXJnaW4tdG9wOiA3cHg7IG1hcmdpbi1ib3R0b206IDdweDsgfVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3VtbWFyeSBsaS5qYXNtaW5lLXBhc3NlZCBhIHsgY29sb3I6ICMwMDcwNjk7IH1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN1bW1hcnkgbGkuamFzbWluZS1mYWlsZWQgYSB7IGNvbG9yOiAjY2EzYTExOyB9XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zdW1tYXJ5IGxpLmphc21pbmUtZW1wdHkgYSB7IGNvbG9yOiAjYmE5ZDM3OyB9XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zdW1tYXJ5IGxpLmphc21pbmUtcGVuZGluZyBhIHsgY29sb3I6ICNiYTlkMzc7IH1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN1bW1hcnkgbGkuamFzbWluZS1kaXNhYmxlZCBhIHsgY29sb3I6ICNiYWJhYmE7IH1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWRlc2NyaXB0aW9uICsgLmphc21pbmUtc3VpdGUgeyBtYXJnaW4tdG9wOiAwOyB9XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zdWl0ZSB7IG1hcmdpbi10b3A6IDE0cHg7IH1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN1aXRlIGEgeyBjb2xvcjogIzMzMzsgfVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtZmFpbHVyZXMgLmphc21pbmUtc3BlYy1kZXRhaWwgeyBtYXJnaW4tYm90dG9tOiAyOHB4OyB9XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1mYWlsdXJlcyAuamFzbWluZS1zcGVjLWRldGFpbCAuamFzbWluZS1kZXNjcmlwdGlvbiB7IGJhY2tncm91bmQtY29sb3I6ICNjYTNhMTE7IH1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWZhaWx1cmVzIC5qYXNtaW5lLXNwZWMtZGV0YWlsIC5qYXNtaW5lLWRlc2NyaXB0aW9uIGEgeyBjb2xvcjogd2hpdGU7IH1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXJlc3VsdC1tZXNzYWdlIHsgcGFkZGluZy10b3A6IDE0cHg7IGNvbG9yOiAjMzMzOyB3aGl0ZS1zcGFjZTogcHJlOyB9XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1yZXN1bHQtbWVzc2FnZSBzcGFuLmphc21pbmUtcmVzdWx0IHsgZGlzcGxheTogYmxvY2s7IH1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN0YWNrLXRyYWNlIHsgbWFyZ2luOiA1cHggMCAwIDA7IG1heC1oZWlnaHQ6IDIyNHB4OyBvdmVyZmxvdzogYXV0bzsgbGluZS1oZWlnaHQ6IDE4cHg7IGNvbG9yOiAjNjY2OyBib3JkZXI6IDFweCBzb2xpZCAjZGRkOyBiYWNrZ3JvdW5kOiB3aGl0ZTsgd2hpdGUtc3BhY2U6IHByZTsgfVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2Nzcy1sb2FkZXIhLi9zcmMvbGliL2phc21pbmUtMi40LjEvamFzbWluZS5jc3NcbiAqKiBtb2R1bGUgaWQgPSAyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBsaXN0ID0gW107XHJcblxyXG5cdC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcclxuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XHJcblx0XHR2YXIgcmVzdWx0ID0gW107XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaXRlbSA9IHRoaXNbaV07XHJcblx0XHRcdGlmKGl0ZW1bMl0pIHtcclxuXHRcdFx0XHRyZXN1bHQucHVzaChcIkBtZWRpYSBcIiArIGl0ZW1bMl0gKyBcIntcIiArIGl0ZW1bMV0gKyBcIn1cIik7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cmVzdWx0LnB1c2goaXRlbVsxXSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiByZXN1bHQuam9pbihcIlwiKTtcclxuXHR9O1xyXG5cclxuXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxyXG5cdGxpc3QuaSA9IGZ1bmN0aW9uKG1vZHVsZXMsIG1lZGlhUXVlcnkpIHtcclxuXHRcdGlmKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKVxyXG5cdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XHJcblx0XHR2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcclxuXHRcdFx0aWYodHlwZW9mIGlkID09PSBcIm51bWJlclwiKVxyXG5cdFx0XHRcdGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcclxuXHRcdH1cclxuXHRcdGZvcihpID0gMDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGl0ZW0gPSBtb2R1bGVzW2ldO1xyXG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXHJcblx0XHRcdC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgbm90IDEwMCUgcGVyZmVjdCBmb3Igd2VpcmQgbWVkaWEgcXVlcnkgY29tYmluYXRpb25zXHJcblx0XHRcdC8vICB3aGVuIGEgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG1lZGlhIHF1ZXJpZXMuXHJcblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXHJcblx0XHRcdGlmKHR5cGVvZiBpdGVtWzBdICE9PSBcIm51bWJlclwiIHx8ICFhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XHJcblx0XHRcdFx0aWYobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xyXG5cdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XHJcblx0XHRcdFx0fSBlbHNlIGlmKG1lZGlhUXVlcnkpIHtcclxuXHRcdFx0XHRcdGl0ZW1bMl0gPSBcIihcIiArIGl0ZW1bMl0gKyBcIikgYW5kIChcIiArIG1lZGlhUXVlcnkgKyBcIilcIjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0bGlzdC5wdXNoKGl0ZW0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fTtcclxuXHRyZXR1cm4gbGlzdDtcclxufTtcclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcbiAqKiBtb2R1bGUgaWQgPSAzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgc3R5bGVzSW5Eb20gPSB7fSxcclxuXHRtZW1vaXplID0gZnVuY3Rpb24oZm4pIHtcclxuXHRcdHZhciBtZW1vO1xyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0aWYgKHR5cGVvZiBtZW1vID09PSBcInVuZGVmaW5lZFwiKSBtZW1vID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHRcdFx0cmV0dXJuIG1lbW87XHJcblx0XHR9O1xyXG5cdH0sXHJcblx0aXNPbGRJRSA9IG1lbW9pemUoZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gL21zaWUgWzYtOV1cXGIvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSk7XHJcblx0fSksXHJcblx0Z2V0SGVhZEVsZW1lbnQgPSBtZW1vaXplKGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXTtcclxuXHR9KSxcclxuXHRzaW5nbGV0b25FbGVtZW50ID0gbnVsbCxcclxuXHRzaW5nbGV0b25Db3VudGVyID0gMCxcclxuXHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcCA9IFtdO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsaXN0LCBvcHRpb25zKSB7XHJcblx0aWYodHlwZW9mIERFQlVHICE9PSBcInVuZGVmaW5lZFwiICYmIERFQlVHKSB7XHJcblx0XHRpZih0eXBlb2YgZG9jdW1lbnQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudFwiKTtcclxuXHR9XHJcblxyXG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cdC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxyXG5cdC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2VcclxuXHRpZiAodHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uID09PSBcInVuZGVmaW5lZFwiKSBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcclxuXHJcblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgYm90dG9tIG9mIDxoZWFkPi5cclxuXHRpZiAodHlwZW9mIG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidW5kZWZpbmVkXCIpIG9wdGlvbnMuaW5zZXJ0QXQgPSBcImJvdHRvbVwiO1xyXG5cclxuXHR2YXIgc3R5bGVzID0gbGlzdFRvU3R5bGVzKGxpc3QpO1xyXG5cdGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucyk7XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkge1xyXG5cdFx0dmFyIG1heVJlbW92ZSA9IFtdO1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcclxuXHRcdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XHJcblx0XHRcdGRvbVN0eWxlLnJlZnMtLTtcclxuXHRcdFx0bWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpO1xyXG5cdFx0fVxyXG5cdFx0aWYobmV3TGlzdCkge1xyXG5cdFx0XHR2YXIgbmV3U3R5bGVzID0gbGlzdFRvU3R5bGVzKG5ld0xpc3QpO1xyXG5cdFx0XHRhZGRTdHlsZXNUb0RvbShuZXdTdHlsZXMsIG9wdGlvbnMpO1xyXG5cdFx0fVxyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV07XHJcblx0XHRcdGlmKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcclxuXHRcdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspXHJcblx0XHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXSgpO1xyXG5cdFx0XHRcdGRlbGV0ZSBzdHlsZXNJbkRvbVtkb21TdHlsZS5pZF07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpIHtcclxuXHRmb3IodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcclxuXHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xyXG5cdFx0aWYoZG9tU3R5bGUpIHtcclxuXHRcdFx0ZG9tU3R5bGUucmVmcysrO1xyXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRmb3IoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR2YXIgcGFydHMgPSBbXTtcclxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0XHRwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRzdHlsZXNJbkRvbVtpdGVtLmlkXSA9IHtpZDogaXRlbS5pZCwgcmVmczogMSwgcGFydHM6IHBhcnRzfTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyhsaXN0KSB7XHJcblx0dmFyIHN0eWxlcyA9IFtdO1xyXG5cdHZhciBuZXdTdHlsZXMgPSB7fTtcclxuXHRmb3IodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xyXG5cdFx0dmFyIGl0ZW0gPSBsaXN0W2ldO1xyXG5cdFx0dmFyIGlkID0gaXRlbVswXTtcclxuXHRcdHZhciBjc3MgPSBpdGVtWzFdO1xyXG5cdFx0dmFyIG1lZGlhID0gaXRlbVsyXTtcclxuXHRcdHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdO1xyXG5cdFx0dmFyIHBhcnQgPSB7Y3NzOiBjc3MsIG1lZGlhOiBtZWRpYSwgc291cmNlTWFwOiBzb3VyY2VNYXB9O1xyXG5cdFx0aWYoIW5ld1N0eWxlc1tpZF0pXHJcblx0XHRcdHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7aWQ6IGlkLCBwYXJ0czogW3BhcnRdfSk7XHJcblx0XHRlbHNlXHJcblx0XHRcdG5ld1N0eWxlc1tpZF0ucGFydHMucHVzaChwYXJ0KTtcclxuXHR9XHJcblx0cmV0dXJuIHN0eWxlcztcclxufVxyXG5cclxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlRWxlbWVudCkge1xyXG5cdHZhciBoZWFkID0gZ2V0SGVhZEVsZW1lbnQoKTtcclxuXHR2YXIgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AgPSBzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcFtzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5sZW5ndGggLSAxXTtcclxuXHRpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJ0b3BcIikge1xyXG5cdFx0aWYoIWxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wKSB7XHJcblx0XHRcdGhlYWQuaW5zZXJ0QmVmb3JlKHN0eWxlRWxlbWVudCwgaGVhZC5maXJzdENoaWxkKTtcclxuXHRcdH0gZWxzZSBpZihsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZykge1xyXG5cdFx0XHRoZWFkLmluc2VydEJlZm9yZShzdHlsZUVsZW1lbnQsIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KTtcclxuXHRcdH1cclxuXHRcdHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLnB1c2goc3R5bGVFbGVtZW50KTtcclxuXHR9IGVsc2UgaWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwiYm90dG9tXCIpIHtcclxuXHRcdGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyICdpbnNlcnRBdCcuIE11c3QgYmUgJ3RvcCcgb3IgJ2JvdHRvbScuXCIpO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCkge1xyXG5cdHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudCk7XHJcblx0dmFyIGlkeCA9IHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLmluZGV4T2Yoc3R5bGVFbGVtZW50KTtcclxuXHRpZihpZHggPj0gMCkge1xyXG5cdFx0c3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3Auc3BsaWNlKGlkeCwgMSk7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykge1xyXG5cdHZhciBzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XHJcblx0c3R5bGVFbGVtZW50LnR5cGUgPSBcInRleHQvY3NzXCI7XHJcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlRWxlbWVudCk7XHJcblx0cmV0dXJuIHN0eWxlRWxlbWVudDtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlTGlua0VsZW1lbnQob3B0aW9ucykge1xyXG5cdHZhciBsaW5rRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xyXG5cdGxpbmtFbGVtZW50LnJlbCA9IFwic3R5bGVzaGVldFwiO1xyXG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBsaW5rRWxlbWVudCk7XHJcblx0cmV0dXJuIGxpbmtFbGVtZW50O1xyXG59XHJcblxyXG5mdW5jdGlvbiBhZGRTdHlsZShvYmosIG9wdGlvbnMpIHtcclxuXHR2YXIgc3R5bGVFbGVtZW50LCB1cGRhdGUsIHJlbW92ZTtcclxuXHJcblx0aWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XHJcblx0XHR2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcclxuXHRcdHN0eWxlRWxlbWVudCA9IHNpbmdsZXRvbkVsZW1lbnQgfHwgKHNpbmdsZXRvbkVsZW1lbnQgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xyXG5cdFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgZmFsc2UpO1xyXG5cdFx0cmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgdHJ1ZSk7XHJcblx0fSBlbHNlIGlmKG9iai5zb3VyY2VNYXAgJiZcclxuXHRcdHR5cGVvZiBVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxyXG5cdFx0dHlwZW9mIFVSTC5jcmVhdGVPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxyXG5cdFx0dHlwZW9mIFVSTC5yZXZva2VPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxyXG5cdFx0dHlwZW9mIEJsb2IgPT09IFwiZnVuY3Rpb25cIiAmJlxyXG5cdFx0dHlwZW9mIGJ0b2EgPT09IFwiZnVuY3Rpb25cIikge1xyXG5cdFx0c3R5bGVFbGVtZW50ID0gY3JlYXRlTGlua0VsZW1lbnQob3B0aW9ucyk7XHJcblx0XHR1cGRhdGUgPSB1cGRhdGVMaW5rLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50KTtcclxuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KTtcclxuXHRcdFx0aWYoc3R5bGVFbGVtZW50LmhyZWYpXHJcblx0XHRcdFx0VVJMLnJldm9rZU9iamVjdFVSTChzdHlsZUVsZW1lbnQuaHJlZik7XHJcblx0XHR9O1xyXG5cdH0gZWxzZSB7XHJcblx0XHRzdHlsZUVsZW1lbnQgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucyk7XHJcblx0XHR1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50KTtcclxuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KTtcclxuXHRcdH07XHJcblx0fVxyXG5cclxuXHR1cGRhdGUob2JqKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKG5ld09iaikge1xyXG5cdFx0aWYobmV3T2JqKSB7XHJcblx0XHRcdGlmKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiYgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiYgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcClcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdHVwZGF0ZShvYmogPSBuZXdPYmopO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmVtb3ZlKCk7XHJcblx0XHR9XHJcblx0fTtcclxufVxyXG5cclxudmFyIHJlcGxhY2VUZXh0ID0gKGZ1bmN0aW9uICgpIHtcclxuXHR2YXIgdGV4dFN0b3JlID0gW107XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2VtZW50KSB7XHJcblx0XHR0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XHJcblx0XHRyZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcclxuXHR9O1xyXG59KSgpO1xyXG5cclxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyhzdHlsZUVsZW1lbnQsIGluZGV4LCByZW1vdmUsIG9iaikge1xyXG5cdHZhciBjc3MgPSByZW1vdmUgPyBcIlwiIDogb2JqLmNzcztcclxuXHJcblx0aWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XHJcblx0XHRzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcclxuXHRcdHZhciBjaGlsZE5vZGVzID0gc3R5bGVFbGVtZW50LmNoaWxkTm9kZXM7XHJcblx0XHRpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7XHJcblx0XHRpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcclxuXHRcdFx0c3R5bGVFbGVtZW50Lmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBhcHBseVRvVGFnKHN0eWxlRWxlbWVudCwgb2JqKSB7XHJcblx0dmFyIGNzcyA9IG9iai5jc3M7XHJcblx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xyXG5cdHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xyXG5cclxuXHRpZihtZWRpYSkge1xyXG5cdFx0c3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsIG1lZGlhKVxyXG5cdH1cclxuXHJcblx0aWYoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcclxuXHRcdHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XHJcblx0fSBlbHNlIHtcclxuXHRcdHdoaWxlKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKSB7XHJcblx0XHRcdHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCk7XHJcblx0XHR9XHJcblx0XHRzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiB1cGRhdGVMaW5rKGxpbmtFbGVtZW50LCBvYmopIHtcclxuXHR2YXIgY3NzID0gb2JqLmNzcztcclxuXHR2YXIgbWVkaWEgPSBvYmoubWVkaWE7XHJcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XHJcblxyXG5cdGlmKHNvdXJjZU1hcCkge1xyXG5cdFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcclxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcclxuXHR9XHJcblxyXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xyXG5cclxuXHR2YXIgb2xkU3JjID0gbGlua0VsZW1lbnQuaHJlZjtcclxuXHJcblx0bGlua0VsZW1lbnQuaHJlZiA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XHJcblxyXG5cdGlmKG9sZFNyYylcclxuXHRcdFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcclxufVxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXG4gKiogbW9kdWxlIGlkID0gNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyohXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW1cbiAqIEBsaWNlbnNlIGVzNS1zaGltIENvcHlyaWdodCAyMDA5LTIwMTUgYnkgY29udHJpYnV0b3JzLCBNSVQgTGljZW5zZVxuICogc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbS9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKi9cblxuLy8gdmltOiB0cz00IHN0cz00IHN3PTQgZXhwYW5kdGFiXG5cbi8vIEFkZCBzZW1pY29sb24gdG8gcHJldmVudCBJSUZFIGZyb20gYmVpbmcgcGFzc2VkIGFzIGFyZ3VtZW50IHRvIGNvbmNhdGVuYXRlZCBjb2RlLlxuO1xuXG4vLyBVTUQgKFVuaXZlcnNhbCBNb2R1bGUgRGVmaW5pdGlvbilcbi8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vdW1kanMvdW1kL2Jsb2IvbWFzdGVyL3RlbXBsYXRlcy9yZXR1cm5FeHBvcnRzLmpzXG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvKiBnbG9iYWwgZGVmaW5lLCBleHBvcnRzLCBtb2R1bGUgKi9cbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cbiAgICAgICAgZGVmaW5lKGZhY3RvcnkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIE5vZGUuIERvZXMgbm90IHdvcmsgd2l0aCBzdHJpY3QgQ29tbW9uSlMsIGJ1dFxuICAgICAgICAvLyBvbmx5IENvbW1vbkpTLWxpa2UgZW52aXJvbWVudHMgdGhhdCBzdXBwb3J0IG1vZHVsZS5leHBvcnRzLFxuICAgICAgICAvLyBsaWtlIE5vZGUuXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEJyb3dzZXIgZ2xvYmFscyAocm9vdCBpcyB3aW5kb3cpXG4gICAgICAgIHJvb3QucmV0dXJuRXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcblxuLyoqXG4gKiBCcmluZ3MgYW4gZW52aXJvbm1lbnQgYXMgY2xvc2UgdG8gRUNNQVNjcmlwdCA1IGNvbXBsaWFuY2VcbiAqIGFzIGlzIHBvc3NpYmxlIHdpdGggdGhlIGZhY2lsaXRpZXMgb2YgZXJzdHdoaWxlIGVuZ2luZXMuXG4gKlxuICogQW5ub3RhdGVkIEVTNTogaHR0cDovL2VzNS5naXRodWIuY29tLyAoc3BlY2lmaWMgbGlua3MgYmVsb3cpXG4gKiBFUzUgU3BlYzogaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL3B1YmxpY2F0aW9ucy9maWxlcy9FQ01BLVNUL0VjbWEtMjYyLnBkZlxuICogUmVxdWlyZWQgcmVhZGluZzogaHR0cDovL2phdmFzY3JpcHR3ZWJsb2cud29yZHByZXNzLmNvbS8yMDExLzEyLzA1L2V4dGVuZGluZy1qYXZhc2NyaXB0LW5hdGl2ZXMvXG4gKi9cblxuLy8gU2hvcnRjdXQgdG8gYW4gb2Z0ZW4gYWNjZXNzZWQgcHJvcGVydGllcywgaW4gb3JkZXIgdG8gYXZvaWQgbXVsdGlwbGVcbi8vIGRlcmVmZXJlbmNlIHRoYXQgY29zdHMgdW5pdmVyc2FsbHkuIFRoaXMgYWxzbyBob2xkcyBhIHJlZmVyZW5jZSB0byBrbm93bi1nb29kXG4vLyBmdW5jdGlvbnMuXG52YXIgJEFycmF5ID0gQXJyYXk7XG52YXIgQXJyYXlQcm90b3R5cGUgPSAkQXJyYXkucHJvdG90eXBlO1xudmFyICRPYmplY3QgPSBPYmplY3Q7XG52YXIgT2JqZWN0UHJvdG90eXBlID0gJE9iamVjdC5wcm90b3R5cGU7XG52YXIgRnVuY3Rpb25Qcm90b3R5cGUgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG52YXIgJFN0cmluZyA9IFN0cmluZztcbnZhciBTdHJpbmdQcm90b3R5cGUgPSAkU3RyaW5nLnByb3RvdHlwZTtcbnZhciAkTnVtYmVyID0gTnVtYmVyO1xudmFyIE51bWJlclByb3RvdHlwZSA9ICROdW1iZXIucHJvdG90eXBlO1xudmFyIGFycmF5X3NsaWNlID0gQXJyYXlQcm90b3R5cGUuc2xpY2U7XG52YXIgYXJyYXlfc3BsaWNlID0gQXJyYXlQcm90b3R5cGUuc3BsaWNlO1xudmFyIGFycmF5X3B1c2ggPSBBcnJheVByb3RvdHlwZS5wdXNoO1xudmFyIGFycmF5X3Vuc2hpZnQgPSBBcnJheVByb3RvdHlwZS51bnNoaWZ0O1xudmFyIGFycmF5X2NvbmNhdCA9IEFycmF5UHJvdG90eXBlLmNvbmNhdDtcbnZhciBjYWxsID0gRnVuY3Rpb25Qcm90b3R5cGUuY2FsbDtcbnZhciBhcHBseSA9IEZ1bmN0aW9uUHJvdG90eXBlLmFwcGx5O1xudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IE1hdGgubWluO1xuXG4vLyBIYXZpbmcgYSB0b1N0cmluZyBsb2NhbCB2YXJpYWJsZSBuYW1lIGJyZWFrcyBpbiBPcGVyYSBzbyB1c2UgdG9fc3RyaW5nLlxudmFyIHRvX3N0cmluZyA9IE9iamVjdFByb3RvdHlwZS50b1N0cmluZztcblxudmFyIGhhc1RvU3RyaW5nVGFnID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJztcbnZhciBpc0NhbGxhYmxlOyAvKiBpbmxpbmVkIGZyb20gaHR0cHM6Ly9ucG1qcy5jb20vaXMtY2FsbGFibGUgKi8gdmFyIGZuVG9TdHIgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmcsIHRyeUZ1bmN0aW9uT2JqZWN0ID0gZnVuY3Rpb24gdHJ5RnVuY3Rpb25PYmplY3QodmFsdWUpIHsgdHJ5IHsgZm5Ub1N0ci5jYWxsKHZhbHVlKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH0sIGZuQ2xhc3MgPSAnW29iamVjdCBGdW5jdGlvbl0nLCBnZW5DbGFzcyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXSc7IGlzQ2FsbGFibGUgPSBmdW5jdGlvbiBpc0NhbGxhYmxlKHZhbHVlKSB7IGlmICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9IGlmIChoYXNUb1N0cmluZ1RhZykgeyByZXR1cm4gdHJ5RnVuY3Rpb25PYmplY3QodmFsdWUpOyB9IHZhciBzdHJDbGFzcyA9IHRvX3N0cmluZy5jYWxsKHZhbHVlKTsgcmV0dXJuIHN0ckNsYXNzID09PSBmbkNsYXNzIHx8IHN0ckNsYXNzID09PSBnZW5DbGFzczsgfTtcbnZhciBpc1JlZ2V4OyAvKiBpbmxpbmVkIGZyb20gaHR0cHM6Ly9ucG1qcy5jb20vaXMtcmVnZXggKi8gdmFyIHJlZ2V4RXhlYyA9IFJlZ0V4cC5wcm90b3R5cGUuZXhlYywgdHJ5UmVnZXhFeGVjID0gZnVuY3Rpb24gdHJ5UmVnZXhFeGVjKHZhbHVlKSB7IHRyeSB7IHJlZ2V4RXhlYy5jYWxsKHZhbHVlKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH0sIHJlZ2V4Q2xhc3MgPSAnW29iamVjdCBSZWdFeHBdJzsgaXNSZWdleCA9IGZ1bmN0aW9uIGlzUmVnZXgodmFsdWUpIHsgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHsgcmV0dXJuIGZhbHNlOyB9IHJldHVybiBoYXNUb1N0cmluZ1RhZyA/IHRyeVJlZ2V4RXhlYyh2YWx1ZSkgOiB0b19zdHJpbmcuY2FsbCh2YWx1ZSkgPT09IHJlZ2V4Q2xhc3M7IH07XG52YXIgaXNTdHJpbmc7IC8qIGlubGluZWQgZnJvbSBodHRwczovL25wbWpzLmNvbS9pcy1zdHJpbmcgKi8gdmFyIHN0clZhbHVlID0gU3RyaW5nLnByb3RvdHlwZS52YWx1ZU9mLCB0cnlTdHJpbmdPYmplY3QgPSBmdW5jdGlvbiB0cnlTdHJpbmdPYmplY3QodmFsdWUpIHsgdHJ5IHsgc3RyVmFsdWUuY2FsbCh2YWx1ZSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9LCBzdHJpbmdDbGFzcyA9ICdbb2JqZWN0IFN0cmluZ10nOyBpc1N0cmluZyA9IGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7IGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7IHJldHVybiB0cnVlOyB9IGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7IHJldHVybiBmYWxzZTsgfSByZXR1cm4gaGFzVG9TdHJpbmdUYWcgPyB0cnlTdHJpbmdPYmplY3QodmFsdWUpIDogdG9fc3RyaW5nLmNhbGwodmFsdWUpID09PSBzdHJpbmdDbGFzczsgfTtcblxuLyogaW5saW5lZCBmcm9tIGh0dHA6Ly9ucG1qcy5jb20vZGVmaW5lLXByb3BlcnRpZXMgKi9cbnZhciBzdXBwb3J0c0Rlc2NyaXB0b3JzID0gJE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiAoZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBvYmogPSB7fTtcbiAgICAgICAgJE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosICd4JywgeyBlbnVtZXJhYmxlOiBmYWxzZSwgdmFsdWU6IG9iaiB9KTtcbiAgICAgICAgZm9yICh2YXIgXyBpbiBvYmopIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgIHJldHVybiBvYmoueCA9PT0gb2JqO1xuICAgIH0gY2F0Y2ggKGUpIHsgLyogdGhpcyBpcyBFUzMgKi9cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn0oKSk7XG52YXIgZGVmaW5lUHJvcGVydGllcyA9IChmdW5jdGlvbiAoaGFzKSB7XG4gIC8vIERlZmluZSBjb25maWd1cmFibGUsIHdyaXRhYmxlLCBhbmQgbm9uLWVudW1lcmFibGUgcHJvcHNcbiAgLy8gaWYgdGhleSBkb24ndCBleGlzdC5cbiAgdmFyIGRlZmluZVByb3BlcnR5O1xuICBpZiAoc3VwcG9ydHNEZXNjcmlwdG9ycykge1xuICAgICAgZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lLCBtZXRob2QsIGZvcmNlQXNzaWduKSB7XG4gICAgICAgICAgaWYgKCFmb3JjZUFzc2lnbiAmJiAobmFtZSBpbiBvYmplY3QpKSB7IHJldHVybjsgfVxuICAgICAgICAgICRPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCB7XG4gICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICB2YWx1ZTogbWV0aG9kXG4gICAgICAgICAgfSk7XG4gICAgICB9O1xuICB9IGVsc2Uge1xuICAgICAgZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lLCBtZXRob2QsIGZvcmNlQXNzaWduKSB7XG4gICAgICAgICAgaWYgKCFmb3JjZUFzc2lnbiAmJiAobmFtZSBpbiBvYmplY3QpKSB7IHJldHVybjsgfVxuICAgICAgICAgIG9iamVjdFtuYW1lXSA9IG1ldGhvZDtcbiAgICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMob2JqZWN0LCBtYXAsIGZvcmNlQXNzaWduKSB7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIG1hcCkge1xuICAgICAgICAgIGlmIChoYXMuY2FsbChtYXAsIG5hbWUpKSB7XG4gICAgICAgICAgICBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIG5hbWUsIG1hcFtuYW1lXSwgZm9yY2VBc3NpZ24pO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgfTtcbn0oT2JqZWN0UHJvdG90eXBlLmhhc093blByb3BlcnR5KSk7XG5cbi8vXG4vLyBVdGlsXG4vLyA9PT09PT1cbi8vXG5cbi8qIHJlcGxhY2VhYmxlIHdpdGggaHR0cHM6Ly9ucG1qcy5jb20vcGFja2FnZS9lcy1hYnN0cmFjdCAvaGVscGVycy9pc1ByaW1pdGl2ZSAqL1xudmFyIGlzUHJpbWl0aXZlID0gZnVuY3Rpb24gaXNQcmltaXRpdmUoaW5wdXQpIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiBpbnB1dDtcbiAgICByZXR1cm4gaW5wdXQgPT09IG51bGwgfHwgKHR5cGUgIT09ICdvYmplY3QnICYmIHR5cGUgIT09ICdmdW5jdGlvbicpO1xufTtcblxudmFyIGlzQWN0dWFsTmFOID0gJE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiAoeCkgeyByZXR1cm4geCAhPT0geDsgfTtcblxudmFyIEVTID0ge1xuICAgIC8vIEVTNSA5LjRcbiAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3g5LjRcbiAgICAvLyBodHRwOi8vanNwZXJmLmNvbS90by1pbnRlZ2VyXG4gICAgLyogcmVwbGFjZWFibGUgd2l0aCBodHRwczovL25wbWpzLmNvbS9wYWNrYWdlL2VzLWFic3RyYWN0IEVTNS5Ub0ludGVnZXIgKi9cbiAgICBUb0ludGVnZXI6IGZ1bmN0aW9uIFRvSW50ZWdlcihudW0pIHtcbiAgICAgICAgdmFyIG4gPSArbnVtO1xuICAgICAgICBpZiAoaXNBY3R1YWxOYU4obikpIHtcbiAgICAgICAgICAgIG4gPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKG4gIT09IDAgJiYgbiAhPT0gKDEgLyAwKSAmJiBuICE9PSAtKDEgLyAwKSkge1xuICAgICAgICAgICAgbiA9IChuID4gMCB8fCAtMSkgKiBNYXRoLmZsb29yKE1hdGguYWJzKG4pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbjtcbiAgICB9LFxuXG4gICAgLyogcmVwbGFjZWFibGUgd2l0aCBodHRwczovL25wbWpzLmNvbS9wYWNrYWdlL2VzLWFic3RyYWN0IEVTNS5Ub1ByaW1pdGl2ZSAqL1xuICAgIFRvUHJpbWl0aXZlOiBmdW5jdGlvbiBUb1ByaW1pdGl2ZShpbnB1dCkge1xuICAgICAgICB2YXIgdmFsLCB2YWx1ZU9mLCB0b1N0cjtcbiAgICAgICAgaWYgKGlzUHJpbWl0aXZlKGlucHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlT2YgPSBpbnB1dC52YWx1ZU9mO1xuICAgICAgICBpZiAoaXNDYWxsYWJsZSh2YWx1ZU9mKSkge1xuICAgICAgICAgICAgdmFsID0gdmFsdWVPZi5jYWxsKGlucHV0KTtcbiAgICAgICAgICAgIGlmIChpc1ByaW1pdGl2ZSh2YWwpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0b1N0ciA9IGlucHV0LnRvU3RyaW5nO1xuICAgICAgICBpZiAoaXNDYWxsYWJsZSh0b1N0cikpIHtcbiAgICAgICAgICAgIHZhbCA9IHRvU3RyLmNhbGwoaW5wdXQpO1xuICAgICAgICAgICAgaWYgKGlzUHJpbWl0aXZlKHZhbCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICB9LFxuXG4gICAgLy8gRVM1IDkuOVxuICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDkuOVxuICAgIC8qIHJlcGxhY2VhYmxlIHdpdGggaHR0cHM6Ly9ucG1qcy5jb20vcGFja2FnZS9lcy1hYnN0cmFjdCBFUzUuVG9PYmplY3QgKi9cbiAgICBUb09iamVjdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgaWYgKG8gPT0gbnVsbCkgeyAvLyB0aGlzIG1hdGNoZXMgYm90aCBudWxsIGFuZCB1bmRlZmluZWRcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjYW4ndCBjb252ZXJ0IFwiICsgbyArICcgdG8gb2JqZWN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICRPYmplY3Qobyk7XG4gICAgfSxcblxuICAgIC8qIHJlcGxhY2VhYmxlIHdpdGggaHR0cHM6Ly9ucG1qcy5jb20vcGFja2FnZS9lcy1hYnN0cmFjdCBFUzUuVG9VaW50MzIgKi9cbiAgICBUb1VpbnQzMjogZnVuY3Rpb24gVG9VaW50MzIoeCkge1xuICAgICAgICByZXR1cm4geCA+Pj4gMDtcbiAgICB9XG59O1xuXG4vL1xuLy8gRnVuY3Rpb25cbi8vID09PT09PT09XG4vL1xuXG4vLyBFUy01IDE1LjMuNC41XG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS4zLjQuNVxuXG52YXIgRW1wdHkgPSBmdW5jdGlvbiBFbXB0eSgpIHt9O1xuXG5kZWZpbmVQcm9wZXJ0aWVzKEZ1bmN0aW9uUHJvdG90eXBlLCB7XG4gICAgYmluZDogZnVuY3Rpb24gYmluZCh0aGF0KSB7IC8vIC5sZW5ndGggaXMgMVxuICAgICAgICAvLyAxLiBMZXQgVGFyZ2V0IGJlIHRoZSB0aGlzIHZhbHVlLlxuICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcztcbiAgICAgICAgLy8gMi4gSWYgSXNDYWxsYWJsZShUYXJnZXQpIGlzIGZhbHNlLCB0aHJvdyBhIFR5cGVFcnJvciBleGNlcHRpb24uXG4gICAgICAgIGlmICghaXNDYWxsYWJsZSh0YXJnZXQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGdW5jdGlvbi5wcm90b3R5cGUuYmluZCBjYWxsZWQgb24gaW5jb21wYXRpYmxlICcgKyB0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIDMuIExldCBBIGJlIGEgbmV3IChwb3NzaWJseSBlbXB0eSkgaW50ZXJuYWwgbGlzdCBvZiBhbGwgb2YgdGhlXG4gICAgICAgIC8vICAgYXJndW1lbnQgdmFsdWVzIHByb3ZpZGVkIGFmdGVyIHRoaXNBcmcgKGFyZzEsIGFyZzIgZXRjKSwgaW4gb3JkZXIuXG4gICAgICAgIC8vIFhYWCBzbGljZWRBcmdzIHdpbGwgc3RhbmQgaW4gZm9yIFwiQVwiIGlmIHVzZWRcbiAgICAgICAgdmFyIGFyZ3MgPSBhcnJheV9zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7IC8vIGZvciBub3JtYWwgY2FsbFxuICAgICAgICAvLyA0LiBMZXQgRiBiZSBhIG5ldyBuYXRpdmUgRUNNQVNjcmlwdCBvYmplY3QuXG4gICAgICAgIC8vIDExLiBTZXQgdGhlIFtbUHJvdG90eXBlXV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgRiB0byB0aGUgc3RhbmRhcmRcbiAgICAgICAgLy8gICBidWlsdC1pbiBGdW5jdGlvbiBwcm90b3R5cGUgb2JqZWN0IGFzIHNwZWNpZmllZCBpbiAxNS4zLjMuMS5cbiAgICAgICAgLy8gMTIuIFNldCB0aGUgW1tDYWxsXV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgRiBhcyBkZXNjcmliZWQgaW5cbiAgICAgICAgLy8gICAxNS4zLjQuNS4xLlxuICAgICAgICAvLyAxMy4gU2V0IHRoZSBbW0NvbnN0cnVjdF1dIGludGVybmFsIHByb3BlcnR5IG9mIEYgYXMgZGVzY3JpYmVkIGluXG4gICAgICAgIC8vICAgMTUuMy40LjUuMi5cbiAgICAgICAgLy8gMTQuIFNldCB0aGUgW1tIYXNJbnN0YW5jZV1dIGludGVybmFsIHByb3BlcnR5IG9mIEYgYXMgZGVzY3JpYmVkIGluXG4gICAgICAgIC8vICAgMTUuMy40LjUuMy5cbiAgICAgICAgdmFyIGJvdW5kO1xuICAgICAgICB2YXIgYmluZGVyID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSB7XG4gICAgICAgICAgICAgICAgLy8gMTUuMy40LjUuMiBbW0NvbnN0cnVjdF1dXG4gICAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgW1tDb25zdHJ1Y3RdXSBpbnRlcm5hbCBtZXRob2Qgb2YgYSBmdW5jdGlvbiBvYmplY3QsXG4gICAgICAgICAgICAgICAgLy8gRiB0aGF0IHdhcyBjcmVhdGVkIHVzaW5nIHRoZSBiaW5kIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIGFcbiAgICAgICAgICAgICAgICAvLyBsaXN0IG9mIGFyZ3VtZW50cyBFeHRyYUFyZ3MsIHRoZSBmb2xsb3dpbmcgc3RlcHMgYXJlIHRha2VuOlxuICAgICAgICAgICAgICAgIC8vIDEuIExldCB0YXJnZXQgYmUgdGhlIHZhbHVlIG9mIEYncyBbW1RhcmdldEZ1bmN0aW9uXV1cbiAgICAgICAgICAgICAgICAvLyAgIGludGVybmFsIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIC8vIDIuIElmIHRhcmdldCBoYXMgbm8gW1tDb25zdHJ1Y3RdXSBpbnRlcm5hbCBtZXRob2QsIGFcbiAgICAgICAgICAgICAgICAvLyAgIFR5cGVFcnJvciBleGNlcHRpb24gaXMgdGhyb3duLlxuICAgICAgICAgICAgICAgIC8vIDMuIExldCBib3VuZEFyZ3MgYmUgdGhlIHZhbHVlIG9mIEYncyBbW0JvdW5kQXJnc11dIGludGVybmFsXG4gICAgICAgICAgICAgICAgLy8gICBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAvLyA0LiBMZXQgYXJncyBiZSBhIG5ldyBsaXN0IGNvbnRhaW5pbmcgdGhlIHNhbWUgdmFsdWVzIGFzIHRoZVxuICAgICAgICAgICAgICAgIC8vICAgbGlzdCBib3VuZEFyZ3MgaW4gdGhlIHNhbWUgb3JkZXIgZm9sbG93ZWQgYnkgdGhlIHNhbWVcbiAgICAgICAgICAgICAgICAvLyAgIHZhbHVlcyBhcyB0aGUgbGlzdCBFeHRyYUFyZ3MgaW4gdGhlIHNhbWUgb3JkZXIuXG4gICAgICAgICAgICAgICAgLy8gNS4gUmV0dXJuIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgW1tDb25zdHJ1Y3RdXSBpbnRlcm5hbFxuICAgICAgICAgICAgICAgIC8vICAgbWV0aG9kIG9mIHRhcmdldCBwcm92aWRpbmcgYXJncyBhcyB0aGUgYXJndW1lbnRzLlxuXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRhcmdldC5hcHBseShcbiAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlfY29uY2F0LmNhbGwoYXJncywgYXJyYXlfc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKCRPYmplY3QocmVzdWx0KSA9PT0gcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIDE1LjMuNC41LjEgW1tDYWxsXV1cbiAgICAgICAgICAgICAgICAvLyBXaGVuIHRoZSBbW0NhbGxdXSBpbnRlcm5hbCBtZXRob2Qgb2YgYSBmdW5jdGlvbiBvYmplY3QsIEYsXG4gICAgICAgICAgICAgICAgLy8gd2hpY2ggd2FzIGNyZWF0ZWQgdXNpbmcgdGhlIGJpbmQgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggYVxuICAgICAgICAgICAgICAgIC8vIHRoaXMgdmFsdWUgYW5kIGEgbGlzdCBvZiBhcmd1bWVudHMgRXh0cmFBcmdzLCB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgICAgICAgLy8gc3RlcHMgYXJlIHRha2VuOlxuICAgICAgICAgICAgICAgIC8vIDEuIExldCBib3VuZEFyZ3MgYmUgdGhlIHZhbHVlIG9mIEYncyBbW0JvdW5kQXJnc11dIGludGVybmFsXG4gICAgICAgICAgICAgICAgLy8gICBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAvLyAyLiBMZXQgYm91bmRUaGlzIGJlIHRoZSB2YWx1ZSBvZiBGJ3MgW1tCb3VuZFRoaXNdXSBpbnRlcm5hbFxuICAgICAgICAgICAgICAgIC8vICAgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgLy8gMy4gTGV0IHRhcmdldCBiZSB0aGUgdmFsdWUgb2YgRidzIFtbVGFyZ2V0RnVuY3Rpb25dXSBpbnRlcm5hbFxuICAgICAgICAgICAgICAgIC8vICAgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgLy8gNC4gTGV0IGFyZ3MgYmUgYSBuZXcgbGlzdCBjb250YWluaW5nIHRoZSBzYW1lIHZhbHVlcyBhcyB0aGVcbiAgICAgICAgICAgICAgICAvLyAgIGxpc3QgYm91bmRBcmdzIGluIHRoZSBzYW1lIG9yZGVyIGZvbGxvd2VkIGJ5IHRoZSBzYW1lXG4gICAgICAgICAgICAgICAgLy8gICB2YWx1ZXMgYXMgdGhlIGxpc3QgRXh0cmFBcmdzIGluIHRoZSBzYW1lIG9yZGVyLlxuICAgICAgICAgICAgICAgIC8vIDUuIFJldHVybiB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhlIFtbQ2FsbF1dIGludGVybmFsIG1ldGhvZFxuICAgICAgICAgICAgICAgIC8vICAgb2YgdGFyZ2V0IHByb3ZpZGluZyBib3VuZFRoaXMgYXMgdGhlIHRoaXMgdmFsdWUgYW5kXG4gICAgICAgICAgICAgICAgLy8gICBwcm92aWRpbmcgYXJncyBhcyB0aGUgYXJndW1lbnRzLlxuXG4gICAgICAgICAgICAgICAgLy8gZXF1aXY6IHRhcmdldC5jYWxsKHRoaXMsIC4uLmJvdW5kQXJncywgLi4uYXJncylcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KFxuICAgICAgICAgICAgICAgICAgICB0aGF0LFxuICAgICAgICAgICAgICAgICAgICBhcnJheV9jb25jYXQuY2FsbChhcmdzLCBhcnJheV9zbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gMTUuIElmIHRoZSBbW0NsYXNzXV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgVGFyZ2V0IGlzIFwiRnVuY3Rpb25cIiwgdGhlblxuICAgICAgICAvLyAgICAgYS4gTGV0IEwgYmUgdGhlIGxlbmd0aCBwcm9wZXJ0eSBvZiBUYXJnZXQgbWludXMgdGhlIGxlbmd0aCBvZiBBLlxuICAgICAgICAvLyAgICAgYi4gU2V0IHRoZSBsZW5ndGggb3duIHByb3BlcnR5IG9mIEYgdG8gZWl0aGVyIDAgb3IgTCwgd2hpY2hldmVyIGlzXG4gICAgICAgIC8vICAgICAgIGxhcmdlci5cbiAgICAgICAgLy8gMTYuIEVsc2Ugc2V0IHRoZSBsZW5ndGggb3duIHByb3BlcnR5IG9mIEYgdG8gMC5cblxuICAgICAgICB2YXIgYm91bmRMZW5ndGggPSBtYXgoMCwgdGFyZ2V0Lmxlbmd0aCAtIGFyZ3MubGVuZ3RoKTtcblxuICAgICAgICAvLyAxNy4gU2V0IHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBsZW5ndGggb3duIHByb3BlcnR5IG9mIEYgdG8gdGhlIHZhbHVlc1xuICAgICAgICAvLyAgIHNwZWNpZmllZCBpbiAxNS4zLjUuMS5cbiAgICAgICAgdmFyIGJvdW5kQXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvdW5kTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFycmF5X3B1c2guY2FsbChib3VuZEFyZ3MsICckJyArIGkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gWFhYIEJ1aWxkIGEgZHluYW1pYyBmdW5jdGlvbiB3aXRoIGRlc2lyZWQgYW1vdW50IG9mIGFyZ3VtZW50cyBpcyB0aGUgb25seVxuICAgICAgICAvLyB3YXkgdG8gc2V0IHRoZSBsZW5ndGggcHJvcGVydHkgb2YgYSBmdW5jdGlvbi5cbiAgICAgICAgLy8gSW4gZW52aXJvbm1lbnRzIHdoZXJlIENvbnRlbnQgU2VjdXJpdHkgUG9saWNpZXMgZW5hYmxlZCAoQ2hyb21lIGV4dGVuc2lvbnMsXG4gICAgICAgIC8vIGZvciBleC4pIGFsbCB1c2Ugb2YgZXZhbCBvciBGdW5jdGlvbiBjb3N0cnVjdG9yIHRocm93cyBhbiBleGNlcHRpb24uXG4gICAgICAgIC8vIEhvd2V2ZXIgaW4gYWxsIG9mIHRoZXNlIGVudmlyb25tZW50cyBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCBleGlzdHNcbiAgICAgICAgLy8gYW5kIHNvIHRoaXMgY29kZSB3aWxsIG5ldmVyIGJlIGV4ZWN1dGVkLlxuICAgICAgICBib3VuZCA9IEZ1bmN0aW9uKCdiaW5kZXInLCAncmV0dXJuIGZ1bmN0aW9uICgnICsgYm91bmRBcmdzLmpvaW4oJywnKSArICcpeyByZXR1cm4gYmluZGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0nKShiaW5kZXIpO1xuXG4gICAgICAgIGlmICh0YXJnZXQucHJvdG90eXBlKSB7XG4gICAgICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSB0YXJnZXQucHJvdG90eXBlO1xuICAgICAgICAgICAgYm91bmQucHJvdG90eXBlID0gbmV3IEVtcHR5KCk7XG4gICAgICAgICAgICAvLyBDbGVhbiB1cCBkYW5nbGluZyByZWZlcmVuY2VzLlxuICAgICAgICAgICAgRW1wdHkucHJvdG90eXBlID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgLy8gMTguIFNldCB0aGUgW1tFeHRlbnNpYmxlXV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgRiB0byB0cnVlLlxuXG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgLy8gMTkuIExldCB0aHJvd2VyIGJlIHRoZSBbW1Rocm93VHlwZUVycm9yXV0gZnVuY3Rpb24gT2JqZWN0ICgxMy4yLjMpLlxuICAgICAgICAvLyAyMC4gQ2FsbCB0aGUgW1tEZWZpbmVPd25Qcm9wZXJ0eV1dIGludGVybmFsIG1ldGhvZCBvZiBGIHdpdGhcbiAgICAgICAgLy8gICBhcmd1bWVudHMgXCJjYWxsZXJcIiwgUHJvcGVydHlEZXNjcmlwdG9yIHtbW0dldF1dOiB0aHJvd2VyLCBbW1NldF1dOlxuICAgICAgICAvLyAgIHRocm93ZXIsIFtbRW51bWVyYWJsZV1dOiBmYWxzZSwgW1tDb25maWd1cmFibGVdXTogZmFsc2V9LCBhbmRcbiAgICAgICAgLy8gICBmYWxzZS5cbiAgICAgICAgLy8gMjEuIENhbGwgdGhlIFtbRGVmaW5lT3duUHJvcGVydHldXSBpbnRlcm5hbCBtZXRob2Qgb2YgRiB3aXRoXG4gICAgICAgIC8vICAgYXJndW1lbnRzIFwiYXJndW1lbnRzXCIsIFByb3BlcnR5RGVzY3JpcHRvciB7W1tHZXRdXTogdGhyb3dlcixcbiAgICAgICAgLy8gICBbW1NldF1dOiB0aHJvd2VyLCBbW0VudW1lcmFibGVdXTogZmFsc2UsIFtbQ29uZmlndXJhYmxlXV06IGZhbHNlfSxcbiAgICAgICAgLy8gICBhbmQgZmFsc2UuXG5cbiAgICAgICAgLy8gVE9ET1xuICAgICAgICAvLyBOT1RFIEZ1bmN0aW9uIG9iamVjdHMgY3JlYXRlZCB1c2luZyBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCBkbyBub3RcbiAgICAgICAgLy8gaGF2ZSBhIHByb3RvdHlwZSBwcm9wZXJ0eSBvciB0aGUgW1tDb2RlXV0sIFtbRm9ybWFsUGFyYW1ldGVyc11dLCBhbmRcbiAgICAgICAgLy8gW1tTY29wZV1dIGludGVybmFsIHByb3BlcnRpZXMuXG4gICAgICAgIC8vIFhYWCBjYW4ndCBkZWxldGUgcHJvdG90eXBlIGluIHB1cmUtanMuXG5cbiAgICAgICAgLy8gMjIuIFJldHVybiBGLlxuICAgICAgICByZXR1cm4gYm91bmQ7XG4gICAgfVxufSk7XG5cbi8vIF9QbGVhc2Ugbm90ZTogU2hvcnRjdXRzIGFyZSBkZWZpbmVkIGFmdGVyIGBGdW5jdGlvbi5wcm90b3R5cGUuYmluZGAgYXMgd2Vcbi8vIHVzZSBpdCBpbiBkZWZpbmluZyBzaG9ydGN1dHMuXG52YXIgb3ducyA9IGNhbGwuYmluZChPYmplY3RQcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xudmFyIHRvU3RyID0gY2FsbC5iaW5kKE9iamVjdFByb3RvdHlwZS50b1N0cmluZyk7XG52YXIgYXJyYXlTbGljZSA9IGNhbGwuYmluZChhcnJheV9zbGljZSk7XG52YXIgYXJyYXlTbGljZUFwcGx5ID0gYXBwbHkuYmluZChhcnJheV9zbGljZSk7XG52YXIgc3RyU2xpY2UgPSBjYWxsLmJpbmQoU3RyaW5nUHJvdG90eXBlLnNsaWNlKTtcbnZhciBzdHJTcGxpdCA9IGNhbGwuYmluZChTdHJpbmdQcm90b3R5cGUuc3BsaXQpO1xudmFyIHN0ckluZGV4T2YgPSBjYWxsLmJpbmQoU3RyaW5nUHJvdG90eXBlLmluZGV4T2YpO1xudmFyIHB1c2ggPSBjYWxsLmJpbmQoYXJyYXlfcHVzaCk7XG52YXIgaXNFbnVtID0gY2FsbC5iaW5kKE9iamVjdFByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZSk7XG52YXIgYXJyYXlTb3J0ID0gY2FsbC5iaW5kKEFycmF5UHJvdG90eXBlLnNvcnQpO1xuXG4vL1xuLy8gQXJyYXlcbi8vID09PT09XG4vL1xuXG52YXIgaXNBcnJheSA9ICRBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIGlzQXJyYXkob2JqKSB7XG4gICAgcmV0dXJuIHRvU3RyKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG4vLyBFUzUgMTUuNC40LjEyXG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjQuMTNcbi8vIFJldHVybiBsZW4rYXJnQ291bnQuXG4vLyBbYnVnZml4LCBpZWx0OF1cbi8vIElFIDwgOCBidWc6IFtdLnVuc2hpZnQoMCkgPT09IHVuZGVmaW5lZCBidXQgc2hvdWxkIGJlIFwiMVwiXG52YXIgaGFzVW5zaGlmdFJldHVyblZhbHVlQnVnID0gW10udW5zaGlmdCgwKSAhPT0gMTtcbmRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICB1bnNoaWZ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGFycmF5X3Vuc2hpZnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoO1xuICAgIH1cbn0sIGhhc1Vuc2hpZnRSZXR1cm5WYWx1ZUJ1Zyk7XG5cbi8vIEVTNSAxNS40LjMuMlxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNC4zLjJcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2lzQXJyYXlcbmRlZmluZVByb3BlcnRpZXMoJEFycmF5LCB7IGlzQXJyYXk6IGlzQXJyYXkgfSk7XG5cbi8vIFRoZSBJc0NhbGxhYmxlKCkgY2hlY2sgaW4gdGhlIEFycmF5IGZ1bmN0aW9uc1xuLy8gaGFzIGJlZW4gcmVwbGFjZWQgd2l0aCBhIHN0cmljdCBjaGVjayBvbiB0aGVcbi8vIGludGVybmFsIGNsYXNzIG9mIHRoZSBvYmplY3QgdG8gdHJhcCBjYXNlcyB3aGVyZVxuLy8gdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIHdhcyBhY3R1YWxseSBhIHJlZ3VsYXJcbi8vIGV4cHJlc3Npb24gbGl0ZXJhbCwgd2hpY2ggaW4gVjggYW5kXG4vLyBKYXZhU2NyaXB0Q29yZSBpcyBhIHR5cGVvZiBcImZ1bmN0aW9uXCIuICBPbmx5IGluXG4vLyBWOCBhcmUgcmVndWxhciBleHByZXNzaW9uIGxpdGVyYWxzIHBlcm1pdHRlZCBhc1xuLy8gcmVkdWNlIHBhcmFtZXRlcnMsIHNvIGl0IGlzIGRlc2lyYWJsZSBpbiB0aGVcbi8vIGdlbmVyYWwgY2FzZSBmb3IgdGhlIHNoaW0gdG8gbWF0Y2ggdGhlIG1vcmVcbi8vIHN0cmljdCBhbmQgY29tbW9uIGJlaGF2aW9yIG9mIHJlamVjdGluZyByZWd1bGFyXG4vLyBleHByZXNzaW9ucy5cblxuLy8gRVM1IDE1LjQuNC4xOFxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNC40LjE4XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9hcnJheS9mb3JFYWNoXG5cbi8vIENoZWNrIGZhaWx1cmUgb2YgYnktaW5kZXggYWNjZXNzIG9mIHN0cmluZyBjaGFyYWN0ZXJzIChJRSA8IDkpXG4vLyBhbmQgZmFpbHVyZSBvZiBgMCBpbiBib3hlZFN0cmluZ2AgKFJoaW5vKVxudmFyIGJveGVkU3RyaW5nID0gJE9iamVjdCgnYScpO1xudmFyIHNwbGl0U3RyaW5nID0gYm94ZWRTdHJpbmdbMF0gIT09ICdhJyB8fCAhKDAgaW4gYm94ZWRTdHJpbmcpO1xuXG52YXIgcHJvcGVybHlCb3hlc0NvbnRleHQgPSBmdW5jdGlvbiBwcm9wZXJseUJveGVkKG1ldGhvZCkge1xuICAgIC8vIENoZWNrIG5vZGUgMC42LjIxIGJ1ZyB3aGVyZSB0aGlyZCBwYXJhbWV0ZXIgaXMgbm90IGJveGVkXG4gICAgdmFyIHByb3Blcmx5Qm94ZXNOb25TdHJpY3QgPSB0cnVlO1xuICAgIHZhciBwcm9wZXJseUJveGVzU3RyaWN0ID0gdHJ1ZTtcbiAgICBpZiAobWV0aG9kKSB7XG4gICAgICAgIG1ldGhvZC5jYWxsKCdmb28nLCBmdW5jdGlvbiAoXywgX18sIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGV4dCAhPT0gJ29iamVjdCcpIHsgcHJvcGVybHlCb3hlc05vblN0cmljdCA9IGZhbHNlOyB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1ldGhvZC5jYWxsKFsxXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgICAgICBwcm9wZXJseUJveGVzU3RyaWN0ID0gdHlwZW9mIHRoaXMgPT09ICdzdHJpbmcnO1xuICAgICAgICB9LCAneCcpO1xuICAgIH1cbiAgICByZXR1cm4gISFtZXRob2QgJiYgcHJvcGVybHlCb3hlc05vblN0cmljdCAmJiBwcm9wZXJseUJveGVzU3RyaWN0O1xufTtcblxuZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmbi8qLCB0aGlzQXJnKi8pIHtcbiAgICAgICAgdmFyIG9iamVjdCA9IEVTLlRvT2JqZWN0KHRoaXMpO1xuICAgICAgICB2YXIgc2VsZiA9IHNwbGl0U3RyaW5nICYmIGlzU3RyaW5nKHRoaXMpID8gc3RyU3BsaXQodGhpcywgJycpIDogb2JqZWN0O1xuICAgICAgICB2YXIgaSA9IC0xO1xuICAgICAgICB2YXIgbGVuZ3RoID0gRVMuVG9VaW50MzIoc2VsZi5sZW5ndGgpO1xuICAgICAgICB2YXIgVDtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgVCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIG5vIGNhbGxiYWNrIGZ1bmN0aW9uIG9yIGlmIGNhbGxiYWNrIGlzIG5vdCBhIGNhbGxhYmxlIGZ1bmN0aW9uXG4gICAgICAgIGlmICghaXNDYWxsYWJsZShjYWxsYmFja2ZuKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkucHJvdG90eXBlLmZvckVhY2ggY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoKytpIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaSBpbiBzZWxmKSB7XG4gICAgICAgICAgICAgICAgLy8gSW52b2tlIHRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aXRoIGNhbGwsIHBhc3NpbmcgYXJndW1lbnRzOlxuICAgICAgICAgICAgICAgIC8vIGNvbnRleHQsIHByb3BlcnR5IHZhbHVlLCBwcm9wZXJ0eSBrZXksIHRoaXNBcmcgb2JqZWN0XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBUID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja2ZuKHNlbGZbaV0sIGksIG9iamVjdCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tmbi5jYWxsKFQsIHNlbGZbaV0sIGksIG9iamVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSwgIXByb3Blcmx5Qm94ZXNDb250ZXh0KEFycmF5UHJvdG90eXBlLmZvckVhY2gpKTtcblxuLy8gRVM1IDE1LjQuNC4xOVxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNC40LjE5XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9Db3JlX0phdmFTY3JpcHRfMS41X1JlZmVyZW5jZS9PYmplY3RzL0FycmF5L21hcFxuZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgIG1hcDogZnVuY3Rpb24gbWFwKGNhbGxiYWNrZm4vKiwgdGhpc0FyZyovKSB7XG4gICAgICAgIHZhciBvYmplY3QgPSBFUy5Ub09iamVjdCh0aGlzKTtcbiAgICAgICAgdmFyIHNlbGYgPSBzcGxpdFN0cmluZyAmJiBpc1N0cmluZyh0aGlzKSA/IHN0clNwbGl0KHRoaXMsICcnKSA6IG9iamVjdDtcbiAgICAgICAgdmFyIGxlbmd0aCA9IEVTLlRvVWludDMyKHNlbGYubGVuZ3RoKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICRBcnJheShsZW5ndGgpO1xuICAgICAgICB2YXIgVDtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBUID0gYXJndW1lbnRzWzFdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgbm8gY2FsbGJhY2sgZnVuY3Rpb24gb3IgaWYgY2FsbGJhY2sgaXMgbm90IGEgY2FsbGFibGUgZnVuY3Rpb25cbiAgICAgICAgaWYgKCFpc0NhbGxhYmxlKGNhbGxiYWNrZm4pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheS5wcm90b3R5cGUubWFwIGNhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgaW4gc2VsZikge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgVCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gY2FsbGJhY2tmbihzZWxmW2ldLCBpLCBvYmplY3QpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IGNhbGxiYWNrZm4uY2FsbChULCBzZWxmW2ldLCBpLCBvYmplY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn0sICFwcm9wZXJseUJveGVzQ29udGV4dChBcnJheVByb3RvdHlwZS5tYXApKTtcblxuLy8gRVM1IDE1LjQuNC4yMFxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNC40LjIwXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9Db3JlX0phdmFTY3JpcHRfMS41X1JlZmVyZW5jZS9PYmplY3RzL0FycmF5L2ZpbHRlclxuZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKGNhbGxiYWNrZm4vKiwgdGhpc0FyZyovKSB7XG4gICAgICAgIHZhciBvYmplY3QgPSBFUy5Ub09iamVjdCh0aGlzKTtcbiAgICAgICAgdmFyIHNlbGYgPSBzcGxpdFN0cmluZyAmJiBpc1N0cmluZyh0aGlzKSA/IHN0clNwbGl0KHRoaXMsICcnKSA6IG9iamVjdDtcbiAgICAgICAgdmFyIGxlbmd0aCA9IEVTLlRvVWludDMyKHNlbGYubGVuZ3RoKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgIHZhciBUO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIFQgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBubyBjYWxsYmFjayBmdW5jdGlvbiBvciBpZiBjYWxsYmFjayBpcyBub3QgYSBjYWxsYWJsZSBmdW5jdGlvblxuICAgICAgICBpZiAoIWlzQ2FsbGFibGUoY2FsbGJhY2tmbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5LnByb3RvdHlwZS5maWx0ZXIgY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSBpbiBzZWxmKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBzZWxmW2ldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgVCA9PT0gJ3VuZGVmaW5lZCcgPyBjYWxsYmFja2ZuKHZhbHVlLCBpLCBvYmplY3QpIDogY2FsbGJhY2tmbi5jYWxsKFQsIHZhbHVlLCBpLCBvYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIHB1c2gocmVzdWx0LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufSwgIXByb3Blcmx5Qm94ZXNDb250ZXh0KEFycmF5UHJvdG90eXBlLmZpbHRlcikpO1xuXG4vLyBFUzUgMTUuNC40LjE2XG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjQuMTZcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2V2ZXJ5XG5kZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgZXZlcnk6IGZ1bmN0aW9uIGV2ZXJ5KGNhbGxiYWNrZm4vKiwgdGhpc0FyZyovKSB7XG4gICAgICAgIHZhciBvYmplY3QgPSBFUy5Ub09iamVjdCh0aGlzKTtcbiAgICAgICAgdmFyIHNlbGYgPSBzcGxpdFN0cmluZyAmJiBpc1N0cmluZyh0aGlzKSA/IHN0clNwbGl0KHRoaXMsICcnKSA6IG9iamVjdDtcbiAgICAgICAgdmFyIGxlbmd0aCA9IEVTLlRvVWludDMyKHNlbGYubGVuZ3RoKTtcbiAgICAgICAgdmFyIFQ7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgVCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIG5vIGNhbGxiYWNrIGZ1bmN0aW9uIG9yIGlmIGNhbGxiYWNrIGlzIG5vdCBhIGNhbGxhYmxlIGZ1bmN0aW9uXG4gICAgICAgIGlmICghaXNDYWxsYWJsZShjYWxsYmFja2ZuKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkucHJvdG90eXBlLmV2ZXJ5IGNhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgaW4gc2VsZiAmJiAhKHR5cGVvZiBUID09PSAndW5kZWZpbmVkJyA/IGNhbGxiYWNrZm4oc2VsZltpXSwgaSwgb2JqZWN0KSA6IGNhbGxiYWNrZm4uY2FsbChULCBzZWxmW2ldLCBpLCBvYmplY3QpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59LCAhcHJvcGVybHlCb3hlc0NvbnRleHQoQXJyYXlQcm90b3R5cGUuZXZlcnkpKTtcblxuLy8gRVM1IDE1LjQuNC4xN1xuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNC40LjE3XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9zb21lXG5kZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgc29tZTogZnVuY3Rpb24gc29tZShjYWxsYmFja2ZuLyosIHRoaXNBcmcgKi8pIHtcbiAgICAgICAgdmFyIG9iamVjdCA9IEVTLlRvT2JqZWN0KHRoaXMpO1xuICAgICAgICB2YXIgc2VsZiA9IHNwbGl0U3RyaW5nICYmIGlzU3RyaW5nKHRoaXMpID8gc3RyU3BsaXQodGhpcywgJycpIDogb2JqZWN0O1xuICAgICAgICB2YXIgbGVuZ3RoID0gRVMuVG9VaW50MzIoc2VsZi5sZW5ndGgpO1xuICAgICAgICB2YXIgVDtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBUID0gYXJndW1lbnRzWzFdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgbm8gY2FsbGJhY2sgZnVuY3Rpb24gb3IgaWYgY2FsbGJhY2sgaXMgbm90IGEgY2FsbGFibGUgZnVuY3Rpb25cbiAgICAgICAgaWYgKCFpc0NhbGxhYmxlKGNhbGxiYWNrZm4pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheS5wcm90b3R5cGUuc29tZSBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpIGluIHNlbGYgJiYgKHR5cGVvZiBUID09PSAndW5kZWZpbmVkJyA/IGNhbGxiYWNrZm4oc2VsZltpXSwgaSwgb2JqZWN0KSA6IGNhbGxiYWNrZm4uY2FsbChULCBzZWxmW2ldLCBpLCBvYmplY3QpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59LCAhcHJvcGVybHlCb3hlc0NvbnRleHQoQXJyYXlQcm90b3R5cGUuc29tZSkpO1xuXG4vLyBFUzUgMTUuNC40LjIxXG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjQuMjFcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0NvcmVfSmF2YVNjcmlwdF8xLjVfUmVmZXJlbmNlL09iamVjdHMvQXJyYXkvcmVkdWNlXG52YXIgcmVkdWNlQ29lcmNlc1RvT2JqZWN0ID0gZmFsc2U7XG5pZiAoQXJyYXlQcm90b3R5cGUucmVkdWNlKSB7XG4gICAgcmVkdWNlQ29lcmNlc1RvT2JqZWN0ID0gdHlwZW9mIEFycmF5UHJvdG90eXBlLnJlZHVjZS5jYWxsKCdlczUnLCBmdW5jdGlvbiAoXywgX18sIF9fXywgbGlzdCkgeyByZXR1cm4gbGlzdDsgfSkgPT09ICdvYmplY3QnO1xufVxuZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgIHJlZHVjZTogZnVuY3Rpb24gcmVkdWNlKGNhbGxiYWNrZm4vKiwgaW5pdGlhbFZhbHVlKi8pIHtcbiAgICAgICAgdmFyIG9iamVjdCA9IEVTLlRvT2JqZWN0KHRoaXMpO1xuICAgICAgICB2YXIgc2VsZiA9IHNwbGl0U3RyaW5nICYmIGlzU3RyaW5nKHRoaXMpID8gc3RyU3BsaXQodGhpcywgJycpIDogb2JqZWN0O1xuICAgICAgICB2YXIgbGVuZ3RoID0gRVMuVG9VaW50MzIoc2VsZi5sZW5ndGgpO1xuXG4gICAgICAgIC8vIElmIG5vIGNhbGxiYWNrIGZ1bmN0aW9uIG9yIGlmIGNhbGxiYWNrIGlzIG5vdCBhIGNhbGxhYmxlIGZ1bmN0aW9uXG4gICAgICAgIGlmICghaXNDYWxsYWJsZShjYWxsYmFja2ZuKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkucHJvdG90eXBlLnJlZHVjZSBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5vIHZhbHVlIHRvIHJldHVybiBpZiBubyBpbml0aWFsIHZhbHVlIGFuZCBhbiBlbXB0eSBhcnJheVxuICAgICAgICBpZiAobGVuZ3RoID09PSAwICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3JlZHVjZSBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgcmVzdWx0ID0gYXJndW1lbnRzWzFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGlmIChpIGluIHNlbGYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gc2VsZltpKytdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBpZiBhcnJheSBjb250YWlucyBubyB2YWx1ZXMsIG5vIGluaXRpYWwgdmFsdWUgdG8gcmV0dXJuXG4gICAgICAgICAgICAgICAgaWYgKCsraSA+PSBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncmVkdWNlIG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgaW4gc2VsZikge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGNhbGxiYWNrZm4ocmVzdWx0LCBzZWxmW2ldLCBpLCBvYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59LCAhcmVkdWNlQ29lcmNlc1RvT2JqZWN0KTtcblxuLy8gRVM1IDE1LjQuNC4yMlxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNC40LjIyXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9Db3JlX0phdmFTY3JpcHRfMS41X1JlZmVyZW5jZS9PYmplY3RzL0FycmF5L3JlZHVjZVJpZ2h0XG52YXIgcmVkdWNlUmlnaHRDb2VyY2VzVG9PYmplY3QgPSBmYWxzZTtcbmlmIChBcnJheVByb3RvdHlwZS5yZWR1Y2VSaWdodCkge1xuICAgIHJlZHVjZVJpZ2h0Q29lcmNlc1RvT2JqZWN0ID0gdHlwZW9mIEFycmF5UHJvdG90eXBlLnJlZHVjZVJpZ2h0LmNhbGwoJ2VzNScsIGZ1bmN0aW9uIChfLCBfXywgX19fLCBsaXN0KSB7IHJldHVybiBsaXN0OyB9KSA9PT0gJ29iamVjdCc7XG59XG5kZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgcmVkdWNlUmlnaHQ6IGZ1bmN0aW9uIHJlZHVjZVJpZ2h0KGNhbGxiYWNrZm4vKiwgaW5pdGlhbCovKSB7XG4gICAgICAgIHZhciBvYmplY3QgPSBFUy5Ub09iamVjdCh0aGlzKTtcbiAgICAgICAgdmFyIHNlbGYgPSBzcGxpdFN0cmluZyAmJiBpc1N0cmluZyh0aGlzKSA/IHN0clNwbGl0KHRoaXMsICcnKSA6IG9iamVjdDtcbiAgICAgICAgdmFyIGxlbmd0aCA9IEVTLlRvVWludDMyKHNlbGYubGVuZ3RoKTtcblxuICAgICAgICAvLyBJZiBubyBjYWxsYmFjayBmdW5jdGlvbiBvciBpZiBjYWxsYmFjayBpcyBub3QgYSBjYWxsYWJsZSBmdW5jdGlvblxuICAgICAgICBpZiAoIWlzQ2FsbGFibGUoY2FsbGJhY2tmbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5LnByb3RvdHlwZS5yZWR1Y2VSaWdodCBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5vIHZhbHVlIHRvIHJldHVybiBpZiBubyBpbml0aWFsIHZhbHVlLCBlbXB0eSBhcnJheVxuICAgICAgICBpZiAobGVuZ3RoID09PSAwICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3JlZHVjZVJpZ2h0IG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdmFyIGkgPSBsZW5ndGggLSAxO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgaWYgKGkgaW4gc2VsZikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBzZWxmW2ktLV07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGlmIGFycmF5IGNvbnRhaW5zIG5vIHZhbHVlcywgbm8gaW5pdGlhbCB2YWx1ZSB0byByZXR1cm5cbiAgICAgICAgICAgICAgICBpZiAoLS1pIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdyZWR1Y2VSaWdodCBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlICh0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmIChpIGluIHNlbGYpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBjYWxsYmFja2ZuKHJlc3VsdCwgc2VsZltpXSwgaSwgb2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoaS0tKTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn0sICFyZWR1Y2VSaWdodENvZXJjZXNUb09iamVjdCk7XG5cbi8vIEVTNSAxNS40LjQuMTRcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjQuNC4xNFxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvaW5kZXhPZlxudmFyIGhhc0ZpcmVmb3gySW5kZXhPZkJ1ZyA9IEFycmF5UHJvdG90eXBlLmluZGV4T2YgJiYgWzAsIDFdLmluZGV4T2YoMSwgMikgIT09IC0xO1xuZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgIGluZGV4T2Y6IGZ1bmN0aW9uIGluZGV4T2Yoc2VhcmNoRWxlbWVudC8qLCBmcm9tSW5kZXggKi8pIHtcbiAgICAgICAgdmFyIHNlbGYgPSBzcGxpdFN0cmluZyAmJiBpc1N0cmluZyh0aGlzKSA/IHN0clNwbGl0KHRoaXMsICcnKSA6IEVTLlRvT2JqZWN0KHRoaXMpO1xuICAgICAgICB2YXIgbGVuZ3RoID0gRVMuVG9VaW50MzIoc2VsZi5sZW5ndGgpO1xuXG4gICAgICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBpID0gRVMuVG9JbnRlZ2VyKGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBoYW5kbGUgbmVnYXRpdmUgaW5kaWNlc1xuICAgICAgICBpID0gaSA+PSAwID8gaSA6IG1heCgwLCBsZW5ndGggKyBpKTtcbiAgICAgICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgaW4gc2VsZiAmJiBzZWxmW2ldID09PSBzZWFyY2hFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbn0sIGhhc0ZpcmVmb3gySW5kZXhPZkJ1Zyk7XG5cbi8vIEVTNSAxNS40LjQuMTVcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjQuNC4xNVxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvbGFzdEluZGV4T2ZcbnZhciBoYXNGaXJlZm94Mkxhc3RJbmRleE9mQnVnID0gQXJyYXlQcm90b3R5cGUubGFzdEluZGV4T2YgJiYgWzAsIDFdLmxhc3RJbmRleE9mKDAsIC0zKSAhPT0gLTE7XG5kZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgbGFzdEluZGV4T2Y6IGZ1bmN0aW9uIGxhc3RJbmRleE9mKHNlYXJjaEVsZW1lbnQvKiwgZnJvbUluZGV4ICovKSB7XG4gICAgICAgIHZhciBzZWxmID0gc3BsaXRTdHJpbmcgJiYgaXNTdHJpbmcodGhpcykgPyBzdHJTcGxpdCh0aGlzLCAnJykgOiBFUy5Ub09iamVjdCh0aGlzKTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IEVTLlRvVWludDMyKHNlbGYubGVuZ3RoKTtcblxuICAgICAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGkgPSBsZW5ndGggLSAxO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGkgPSBtaW4oaSwgRVMuVG9JbnRlZ2VyKGFyZ3VtZW50c1sxXSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGhhbmRsZSBuZWdhdGl2ZSBpbmRpY2VzXG4gICAgICAgIGkgPSBpID49IDAgPyBpIDogbGVuZ3RoIC0gTWF0aC5hYnMoaSk7XG4gICAgICAgIGZvciAoOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKGkgaW4gc2VsZiAmJiBzZWFyY2hFbGVtZW50ID09PSBzZWxmW2ldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbn0sIGhhc0ZpcmVmb3gyTGFzdEluZGV4T2ZCdWcpO1xuXG4vLyBFUzUgMTUuNC40LjEyXG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjQuMTJcbnZhciBzcGxpY2VOb29wUmV0dXJuc0VtcHR5QXJyYXkgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBhID0gWzEsIDJdO1xuICAgIHZhciByZXN1bHQgPSBhLnNwbGljZSgpO1xuICAgIHJldHVybiBhLmxlbmd0aCA9PT0gMiAmJiBpc0FycmF5KHJlc3VsdCkgJiYgcmVzdWx0Lmxlbmd0aCA9PT0gMDtcbn0oKSk7XG5kZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgLy8gU2FmYXJpIDUuMCBidWcgd2hlcmUgLnNwbGljZSgpIHJldHVybnMgdW5kZWZpbmVkXG4gICAgc3BsaWNlOiBmdW5jdGlvbiBzcGxpY2Uoc3RhcnQsIGRlbGV0ZUNvdW50KSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyYXlfc3BsaWNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICB9XG59LCAhc3BsaWNlTm9vcFJldHVybnNFbXB0eUFycmF5KTtcblxudmFyIHNwbGljZVdvcmtzV2l0aEVtcHR5T2JqZWN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2JqID0ge307XG4gICAgQXJyYXlQcm90b3R5cGUuc3BsaWNlLmNhbGwob2JqLCAwLCAwLCAxKTtcbiAgICByZXR1cm4gb2JqLmxlbmd0aCA9PT0gMTtcbn0oKSk7XG5kZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgc3BsaWNlOiBmdW5jdGlvbiBzcGxpY2Uoc3RhcnQsIGRlbGV0ZUNvdW50KSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7IHJldHVybiBbXTsgfVxuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgdGhpcy5sZW5ndGggPSBtYXgoRVMuVG9JbnRlZ2VyKHRoaXMubGVuZ3RoKSwgMCk7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCAmJiB0eXBlb2YgZGVsZXRlQ291bnQgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBhcmdzID0gYXJyYXlTbGljZShhcmd1bWVudHMpO1xuICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgICAgIHB1c2goYXJncywgdGhpcy5sZW5ndGggLSBzdGFydCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFyZ3NbMV0gPSBFUy5Ub0ludGVnZXIoZGVsZXRlQ291bnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnJheV9zcGxpY2UuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxufSwgIXNwbGljZVdvcmtzV2l0aEVtcHR5T2JqZWN0KTtcbnZhciBzcGxpY2VXb3Jrc1dpdGhMYXJnZVNwYXJzZUFycmF5cyA9IChmdW5jdGlvbiAoKSB7XG4gICAgLy8gUGVyIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbS9pc3N1ZXMvMjk1XG4gICAgLy8gU2FmYXJpIDcvOCBicmVha3Mgd2l0aCBzcGFyc2UgYXJyYXlzIG9mIHNpemUgMWU1IG9yIGdyZWF0ZXJcbiAgICB2YXIgYXJyID0gbmV3ICRBcnJheSgxZTUpO1xuICAgIC8vIG5vdGU6IHRoZSBpbmRleCBNVVNUIGJlIDggb3IgbGFyZ2VyIG9yIHRoZSB0ZXN0IHdpbGwgZmFsc2UgcGFzc1xuICAgIGFycls4XSA9ICd4JztcbiAgICBhcnIuc3BsaWNlKDEsIDEpO1xuICAgIC8vIG5vdGU6IHRoaXMgdGVzdCBtdXN0IGJlIGRlZmluZWQgKmFmdGVyKiB0aGUgaW5kZXhPZiBzaGltXG4gICAgLy8gcGVyIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbS9pc3N1ZXMvMzEzXG4gICAgcmV0dXJuIGFyci5pbmRleE9mKCd4JykgPT09IDc7XG59KCkpO1xudmFyIHNwbGljZVdvcmtzV2l0aFNtYWxsU3BhcnNlQXJyYXlzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBQZXIgaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltL2lzc3Vlcy8yOTVcbiAgICAvLyBPcGVyYSAxMi4xNSBicmVha3Mgb24gdGhpcywgbm8gaWRlYSB3aHkuXG4gICAgdmFyIG4gPSAyNTY7XG4gICAgdmFyIGFyciA9IFtdO1xuICAgIGFycltuXSA9ICdhJztcbiAgICBhcnIuc3BsaWNlKG4gKyAxLCAwLCAnYicpO1xuICAgIHJldHVybiBhcnJbbl0gPT09ICdhJztcbn0oKSk7XG5kZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgc3BsaWNlOiBmdW5jdGlvbiBzcGxpY2Uoc3RhcnQsIGRlbGV0ZUNvdW50KSB7XG4gICAgICAgIHZhciBPID0gRVMuVG9PYmplY3QodGhpcyk7XG4gICAgICAgIHZhciBBID0gW107XG4gICAgICAgIHZhciBsZW4gPSBFUy5Ub1VpbnQzMihPLmxlbmd0aCk7XG4gICAgICAgIHZhciByZWxhdGl2ZVN0YXJ0ID0gRVMuVG9JbnRlZ2VyKHN0YXJ0KTtcbiAgICAgICAgdmFyIGFjdHVhbFN0YXJ0ID0gcmVsYXRpdmVTdGFydCA8IDAgPyBtYXgoKGxlbiArIHJlbGF0aXZlU3RhcnQpLCAwKSA6IG1pbihyZWxhdGl2ZVN0YXJ0LCBsZW4pO1xuICAgICAgICB2YXIgYWN0dWFsRGVsZXRlQ291bnQgPSBtaW4obWF4KEVTLlRvSW50ZWdlcihkZWxldGVDb3VudCksIDApLCBsZW4gLSBhY3R1YWxTdGFydCk7XG5cbiAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICB2YXIgZnJvbTtcbiAgICAgICAgd2hpbGUgKGsgPCBhY3R1YWxEZWxldGVDb3VudCkge1xuICAgICAgICAgICAgZnJvbSA9ICRTdHJpbmcoYWN0dWFsU3RhcnQgKyBrKTtcbiAgICAgICAgICAgIGlmIChvd25zKE8sIGZyb20pKSB7XG4gICAgICAgICAgICAgICAgQVtrXSA9IE9bZnJvbV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBrICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXRlbXMgPSBhcnJheVNsaWNlKGFyZ3VtZW50cywgMik7XG4gICAgICAgIHZhciBpdGVtQ291bnQgPSBpdGVtcy5sZW5ndGg7XG4gICAgICAgIHZhciB0bztcbiAgICAgICAgaWYgKGl0ZW1Db3VudCA8IGFjdHVhbERlbGV0ZUNvdW50KSB7XG4gICAgICAgICAgICBrID0gYWN0dWFsU3RhcnQ7XG4gICAgICAgICAgICB3aGlsZSAoayA8IChsZW4gLSBhY3R1YWxEZWxldGVDb3VudCkpIHtcbiAgICAgICAgICAgICAgICBmcm9tID0gJFN0cmluZyhrICsgYWN0dWFsRGVsZXRlQ291bnQpO1xuICAgICAgICAgICAgICAgIHRvID0gJFN0cmluZyhrICsgaXRlbUNvdW50KTtcbiAgICAgICAgICAgICAgICBpZiAob3ducyhPLCBmcm9tKSkge1xuICAgICAgICAgICAgICAgICAgICBPW3RvXSA9IE9bZnJvbV07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIE9bdG9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBrICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBrID0gbGVuO1xuICAgICAgICAgICAgd2hpbGUgKGsgPiAobGVuIC0gYWN0dWFsRGVsZXRlQ291bnQgKyBpdGVtQ291bnQpKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIE9bayAtIDFdO1xuICAgICAgICAgICAgICAgIGsgLT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpdGVtQ291bnQgPiBhY3R1YWxEZWxldGVDb3VudCkge1xuICAgICAgICAgICAgayA9IGxlbiAtIGFjdHVhbERlbGV0ZUNvdW50O1xuICAgICAgICAgICAgd2hpbGUgKGsgPiBhY3R1YWxTdGFydCkge1xuICAgICAgICAgICAgICAgIGZyb20gPSAkU3RyaW5nKGsgKyBhY3R1YWxEZWxldGVDb3VudCAtIDEpO1xuICAgICAgICAgICAgICAgIHRvID0gJFN0cmluZyhrICsgaXRlbUNvdW50IC0gMSk7XG4gICAgICAgICAgICAgICAgaWYgKG93bnMoTywgZnJvbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgT1t0b10gPSBPW2Zyb21dO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBPW3RvXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgayAtPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGsgPSBhY3R1YWxTdGFydDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgT1trXSA9IGl0ZW1zW2ldO1xuICAgICAgICAgICAgayArPSAxO1xuICAgICAgICB9XG4gICAgICAgIE8ubGVuZ3RoID0gbGVuIC0gYWN0dWFsRGVsZXRlQ291bnQgKyBpdGVtQ291bnQ7XG5cbiAgICAgICAgcmV0dXJuIEE7XG4gICAgfVxufSwgIXNwbGljZVdvcmtzV2l0aExhcmdlU3BhcnNlQXJyYXlzIHx8ICFzcGxpY2VXb3Jrc1dpdGhTbWFsbFNwYXJzZUFycmF5cyk7XG5cbnZhciBvcmlnaW5hbEpvaW4gPSBBcnJheVByb3RvdHlwZS5qb2luO1xudmFyIGhhc1N0cmluZ0pvaW5CdWc7XG50cnkge1xuICAgIGhhc1N0cmluZ0pvaW5CdWcgPSBBcnJheS5wcm90b3R5cGUuam9pbi5jYWxsKCcxMjMnLCAnLCcpICE9PSAnMSwyLDMnO1xufSBjYXRjaCAoZSkge1xuICAgIGhhc1N0cmluZ0pvaW5CdWcgPSB0cnVlO1xufVxuaWYgKGhhc1N0cmluZ0pvaW5CdWcpIHtcbiAgICBkZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgICAgIGpvaW46IGZ1bmN0aW9uIGpvaW4oc2VwYXJhdG9yKSB7XG4gICAgICAgICAgICB2YXIgc2VwID0gdHlwZW9mIHNlcGFyYXRvciA9PT0gJ3VuZGVmaW5lZCcgPyAnLCcgOiBzZXBhcmF0b3I7XG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxKb2luLmNhbGwoaXNTdHJpbmcodGhpcykgPyBzdHJTcGxpdCh0aGlzLCAnJykgOiB0aGlzLCBzZXApO1xuICAgICAgICB9XG4gICAgfSwgaGFzU3RyaW5nSm9pbkJ1Zyk7XG59XG5cbnZhciBoYXNKb2luVW5kZWZpbmVkQnVnID0gWzEsIDJdLmpvaW4odW5kZWZpbmVkKSAhPT0gJzEsMic7XG5pZiAoaGFzSm9pblVuZGVmaW5lZEJ1Zykge1xuICAgIGRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICAgICAgam9pbjogZnVuY3Rpb24gam9pbihzZXBhcmF0b3IpIHtcbiAgICAgICAgICAgIHZhciBzZXAgPSB0eXBlb2Ygc2VwYXJhdG9yID09PSAndW5kZWZpbmVkJyA/ICcsJyA6IHNlcGFyYXRvcjtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbEpvaW4uY2FsbCh0aGlzLCBzZXApO1xuICAgICAgICB9XG4gICAgfSwgaGFzSm9pblVuZGVmaW5lZEJ1Zyk7XG59XG5cbnZhciBwdXNoU2hpbSA9IGZ1bmN0aW9uIHB1c2goaXRlbSkge1xuICAgIHZhciBPID0gRVMuVG9PYmplY3QodGhpcyk7XG4gICAgdmFyIG4gPSBFUy5Ub1VpbnQzMihPLmxlbmd0aCk7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBPW24gKyBpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgaSArPSAxO1xuICAgIH1cbiAgICBPLmxlbmd0aCA9IG4gKyBpO1xuICAgIHJldHVybiBuICsgaTtcbn07XG5cbnZhciBwdXNoSXNOb3RHZW5lcmljID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2JqID0ge307XG4gICAgdmFyIHJlc3VsdCA9IEFycmF5LnByb3RvdHlwZS5wdXNoLmNhbGwob2JqLCB1bmRlZmluZWQpO1xuICAgIHJldHVybiByZXN1bHQgIT09IDEgfHwgb2JqLmxlbmd0aCAhPT0gMSB8fCB0eXBlb2Ygb2JqWzBdICE9PSAndW5kZWZpbmVkJyB8fCAhb3ducyhvYmosIDApO1xufSgpKTtcbmRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICBwdXNoOiBmdW5jdGlvbiBwdXNoKGl0ZW0pIHtcbiAgICAgICAgaWYgKGlzQXJyYXkodGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnJheV9wdXNoLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHB1c2hTaGltLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxufSwgcHVzaElzTm90R2VuZXJpYyk7XG5cbi8vIFRoaXMgZml4ZXMgYSB2ZXJ5IHdlaXJkIGJ1ZyBpbiBPcGVyYSAxMC42IHdoZW4gcHVzaGluZyBgdW5kZWZpbmVkXG52YXIgcHVzaFVuZGVmaW5lZElzV2VpcmQgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcnIgPSBbXTtcbiAgICB2YXIgcmVzdWx0ID0gYXJyLnB1c2godW5kZWZpbmVkKTtcbiAgICByZXR1cm4gcmVzdWx0ICE9PSAxIHx8IGFyci5sZW5ndGggIT09IDEgfHwgdHlwZW9mIGFyclswXSAhPT0gJ3VuZGVmaW5lZCcgfHwgIW93bnMoYXJyLCAwKTtcbn0oKSk7XG5kZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7IHB1c2g6IHB1c2hTaGltIH0sIHB1c2hVbmRlZmluZWRJc1dlaXJkKTtcblxuLy8gRVM1IDE1LjIuMy4xNFxuLy8gaHR0cDovL2VzNS5naXRodWIuaW8vI3gxNS40LjQuMTBcbi8vIEZpeCBib3hlZCBzdHJpbmcgYnVnXG5kZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgc2xpY2U6IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgICAgIHZhciBhcnIgPSBpc1N0cmluZyh0aGlzKSA/IHN0clNwbGl0KHRoaXMsICcnKSA6IHRoaXM7XG4gICAgICAgIHJldHVybiBhcnJheVNsaWNlQXBwbHkoYXJyLCBhcmd1bWVudHMpO1xuICAgIH1cbn0sIHNwbGl0U3RyaW5nKTtcblxudmFyIHNvcnRJZ25vcmVzTm9uRnVuY3Rpb25zID0gKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBbMSwgMl0uc29ydChudWxsKTtcbiAgICAgICAgWzEsIDJdLnNvcnQoe30pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7IC8qKi8gfVxuICAgIHJldHVybiBmYWxzZTtcbn0oKSk7XG52YXIgc29ydFRocm93c09uUmVnZXggPSAoZnVuY3Rpb24gKCkge1xuICAgIC8vIHRoaXMgaXMgYSBwcm9ibGVtIGluIEZpcmVmb3ggNCwgaW4gd2hpY2ggYHR5cGVvZiAvYS8gPT09ICdmdW5jdGlvbidgXG4gICAgdHJ5IHtcbiAgICAgICAgWzEsIDJdLnNvcnQoL2EvKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gY2F0Y2ggKGUpIHsgLyoqLyB9XG4gICAgcmV0dXJuIHRydWU7XG59KCkpO1xudmFyIHNvcnRJZ25vcmVzVW5kZWZpbmVkID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBhcHBsaWVzIGluIElFIDgsIGZvciBvbmUuXG4gICAgdHJ5IHtcbiAgICAgICAgWzEsIDJdLnNvcnQodW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkgeyAvKiovIH1cbiAgICByZXR1cm4gZmFsc2U7XG59KCkpO1xuZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgIHNvcnQ6IGZ1bmN0aW9uIHNvcnQoY29tcGFyZUZuKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY29tcGFyZUZuID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIGFycmF5U29ydCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzQ2FsbGFibGUoY29tcGFyZUZuKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkucHJvdG90eXBlLnNvcnQgY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5U29ydCh0aGlzLCBjb21wYXJlRm4pO1xuICAgIH1cbn0sIHNvcnRJZ25vcmVzTm9uRnVuY3Rpb25zIHx8ICFzb3J0SWdub3Jlc1VuZGVmaW5lZCB8fCAhc29ydFRocm93c09uUmVnZXgpO1xuXG4vL1xuLy8gT2JqZWN0XG4vLyA9PT09PT1cbi8vXG5cbi8vIEVTNSAxNS4yLjMuMTRcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjIuMy4xNFxuXG4vLyBodHRwOi8vd2hhdHRoZWhlYWRzYWlkLmNvbS8yMDEwLzEwL2Etc2FmZXItb2JqZWN0LWtleXMtY29tcGF0aWJpbGl0eS1pbXBsZW1lbnRhdGlvblxudmFyIGhhc0RvbnRFbnVtQnVnID0gISh7ICd0b1N0cmluZyc6IG51bGwgfSkucHJvcGVydHlJc0VudW1lcmFibGUoJ3RvU3RyaW5nJyk7XG52YXIgaGFzUHJvdG9FbnVtQnVnID0gZnVuY3Rpb24gKCkge30ucHJvcGVydHlJc0VudW1lcmFibGUoJ3Byb3RvdHlwZScpO1xudmFyIGhhc1N0cmluZ0VudW1CdWcgPSAhb3ducygneCcsICcwJyk7XG52YXIgZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUgPSBmdW5jdGlvbiAobykge1xuICAgIHZhciBjdG9yID0gby5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvciAmJiBjdG9yLnByb3RvdHlwZSA9PT0gbztcbn07XG52YXIgYmxhY2tsaXN0ZWRLZXlzID0ge1xuICAgICR3aW5kb3c6IHRydWUsXG4gICAgJGNvbnNvbGU6IHRydWUsXG4gICAgJHBhcmVudDogdHJ1ZSxcbiAgICAkc2VsZjogdHJ1ZSxcbiAgICAkZnJhbWU6IHRydWUsXG4gICAgJGZyYW1lczogdHJ1ZSxcbiAgICAkZnJhbWVFbGVtZW50OiB0cnVlLFxuICAgICR3ZWJraXRJbmRleGVkREI6IHRydWUsXG4gICAgJHdlYmtpdFN0b3JhZ2VJbmZvOiB0cnVlLFxuICAgICRleHRlcm5hbDogdHJ1ZVxufTtcbnZhciBoYXNBdXRvbWF0aW9uRXF1YWxpdHlCdWcgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qIGdsb2JhbHMgd2luZG93ICovXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGZvciAodmFyIGsgaW4gd2luZG93KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIWJsYWNrbGlzdGVkS2V5c1snJCcgKyBrXSAmJiBvd25zKHdpbmRvdywgaykgJiYgd2luZG93W2tdICE9PSBudWxsICYmIHR5cGVvZiB3aW5kb3dba10gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUod2luZG93W2tdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufSgpKTtcbnZhciBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZUlmTm90QnVnZ3kgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICFoYXNBdXRvbWF0aW9uRXF1YWxpdHlCdWcpIHsgcmV0dXJuIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlKG9iamVjdCk7IH1cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUob2JqZWN0KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xudmFyIGRvbnRFbnVtcyA9IFtcbiAgICAndG9TdHJpbmcnLFxuICAgICd0b0xvY2FsZVN0cmluZycsXG4gICAgJ3ZhbHVlT2YnLFxuICAgICdoYXNPd25Qcm9wZXJ0eScsXG4gICAgJ2lzUHJvdG90eXBlT2YnLFxuICAgICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsXG4gICAgJ2NvbnN0cnVjdG9yJ1xuXTtcbnZhciBkb250RW51bXNMZW5ndGggPSBkb250RW51bXMubGVuZ3RoO1xuXG4vLyB0YWtlbiBkaXJlY3RseSBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9samhhcmIvaXMtYXJndW1lbnRzL2Jsb2IvbWFzdGVyL2luZGV4LmpzXG4vLyBjYW4gYmUgcmVwbGFjZWQgd2l0aCByZXF1aXJlKCdpcy1hcmd1bWVudHMnKSBpZiB3ZSBldmVyIHVzZSBhIGJ1aWxkIHByb2Nlc3MgaW5zdGVhZFxudmFyIGlzU3RhbmRhcmRBcmd1bWVudHMgPSBmdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuICAgIHJldHVybiB0b1N0cih2YWx1ZSkgPT09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xufTtcbnZhciBpc0xlZ2FjeUFyZ3VtZW50cyA9IGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmXG4gICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlLmxlbmd0aCA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgdmFsdWUubGVuZ3RoID49IDAgJiZcbiAgICAgICAgIWlzQXJyYXkodmFsdWUpICYmXG4gICAgICAgIGlzQ2FsbGFibGUodmFsdWUuY2FsbGVlKTtcbn07XG52YXIgaXNBcmd1bWVudHMgPSBpc1N0YW5kYXJkQXJndW1lbnRzKGFyZ3VtZW50cykgPyBpc1N0YW5kYXJkQXJndW1lbnRzIDogaXNMZWdhY3lBcmd1bWVudHM7XG5cbmRlZmluZVByb3BlcnRpZXMoJE9iamVjdCwge1xuICAgIGtleXM6IGZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gICAgICAgIHZhciBpc0ZuID0gaXNDYWxsYWJsZShvYmplY3QpO1xuICAgICAgICB2YXIgaXNBcmdzID0gaXNBcmd1bWVudHMob2JqZWN0KTtcbiAgICAgICAgdmFyIGlzT2JqZWN0ID0gb2JqZWN0ICE9PSBudWxsICYmIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnO1xuICAgICAgICB2YXIgaXNTdHIgPSBpc09iamVjdCAmJiBpc1N0cmluZyhvYmplY3QpO1xuXG4gICAgICAgIGlmICghaXNPYmplY3QgJiYgIWlzRm4gJiYgIWlzQXJncykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmtleXMgY2FsbGVkIG9uIGEgbm9uLW9iamVjdCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRoZUtleXMgPSBbXTtcbiAgICAgICAgdmFyIHNraXBQcm90byA9IGhhc1Byb3RvRW51bUJ1ZyAmJiBpc0ZuO1xuICAgICAgICBpZiAoKGlzU3RyICYmIGhhc1N0cmluZ0VudW1CdWcpIHx8IGlzQXJncykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBwdXNoKHRoZUtleXMsICRTdHJpbmcoaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc0FyZ3MpIHtcbiAgICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoc2tpcFByb3RvICYmIG5hbWUgPT09ICdwcm90b3R5cGUnKSAmJiBvd25zKG9iamVjdCwgbmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcHVzaCh0aGVLZXlzLCAkU3RyaW5nKG5hbWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzRG9udEVudW1CdWcpIHtcbiAgICAgICAgICAgIHZhciBza2lwQ29uc3RydWN0b3IgPSBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZUlmTm90QnVnZ3kob2JqZWN0KTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZG9udEVudW1zTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZG9udEVudW0gPSBkb250RW51bXNbal07XG4gICAgICAgICAgICAgICAgaWYgKCEoc2tpcENvbnN0cnVjdG9yICYmIGRvbnRFbnVtID09PSAnY29uc3RydWN0b3InKSAmJiBvd25zKG9iamVjdCwgZG9udEVudW0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHB1c2godGhlS2V5cywgZG9udEVudW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhlS2V5cztcbiAgICB9XG59KTtcblxudmFyIGtleXNXb3Jrc1dpdGhBcmd1bWVudHMgPSAkT2JqZWN0LmtleXMgJiYgKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBTYWZhcmkgNS4wIGJ1Z1xuICAgIHJldHVybiAkT2JqZWN0LmtleXMoYXJndW1lbnRzKS5sZW5ndGggPT09IDI7XG59KDEsIDIpKTtcbnZhciBrZXlzSGFzQXJndW1lbnRzTGVuZ3RoQnVnID0gJE9iamVjdC5rZXlzICYmIChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ0tleXMgPSAkT2JqZWN0LmtleXMoYXJndW1lbnRzKTtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCAhPT0gMSB8fCBhcmdLZXlzLmxlbmd0aCAhPT0gMSB8fCBhcmdLZXlzWzBdICE9PSAxO1xufSgxKSk7XG52YXIgb3JpZ2luYWxLZXlzID0gJE9iamVjdC5rZXlzO1xuZGVmaW5lUHJvcGVydGllcygkT2JqZWN0LCB7XG4gICAga2V5czogZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgICAgICAgaWYgKGlzQXJndW1lbnRzKG9iamVjdCkpIHtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbEtleXMoYXJyYXlTbGljZShvYmplY3QpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbEtleXMob2JqZWN0KTtcbiAgICAgICAgfVxuICAgIH1cbn0sICFrZXlzV29ya3NXaXRoQXJndW1lbnRzIHx8IGtleXNIYXNBcmd1bWVudHNMZW5ndGhCdWcpO1xuXG4vL1xuLy8gRGF0ZVxuLy8gPT09PVxuLy9cblxuLy8gRVM1IDE1LjkuNS40M1xuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuOS41LjQzXG4vLyBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYSBTdHJpbmcgdmFsdWUgcmVwcmVzZW50IHRoZSBpbnN0YW5jZSBpbiB0aW1lXG4vLyByZXByZXNlbnRlZCBieSB0aGlzIERhdGUgb2JqZWN0LiBUaGUgZm9ybWF0IG9mIHRoZSBTdHJpbmcgaXMgdGhlIERhdGUgVGltZVxuLy8gc3RyaW5nIGZvcm1hdCBkZWZpbmVkIGluIDE1LjkuMS4xNS4gQWxsIGZpZWxkcyBhcmUgcHJlc2VudCBpbiB0aGUgU3RyaW5nLlxuLy8gVGhlIHRpbWUgem9uZSBpcyBhbHdheXMgVVRDLCBkZW5vdGVkIGJ5IHRoZSBzdWZmaXggWi4gSWYgdGhlIHRpbWUgdmFsdWUgb2Zcbi8vIHRoaXMgb2JqZWN0IGlzIG5vdCBhIGZpbml0ZSBOdW1iZXIgYSBSYW5nZUVycm9yIGV4Y2VwdGlvbiBpcyB0aHJvd24uXG52YXIgbmVnYXRpdmVEYXRlID0gLTYyMTk4NzU1MjAwMDAwO1xudmFyIG5lZ2F0aXZlWWVhclN0cmluZyA9ICctMDAwMDAxJztcbnZhciBoYXNOZWdhdGl2ZURhdGVCdWcgPSBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZyAmJiBuZXcgRGF0ZShuZWdhdGl2ZURhdGUpLnRvSVNPU3RyaW5nKCkuaW5kZXhPZihuZWdhdGl2ZVllYXJTdHJpbmcpID09PSAtMTtcbnZhciBoYXNTYWZhcmk1MURhdGVCdWcgPSBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZyAmJiBuZXcgRGF0ZSgtMSkudG9JU09TdHJpbmcoKSAhPT0gJzE5NjktMTItMzFUMjM6NTk6NTkuOTk5Wic7XG5cbmRlZmluZVByb3BlcnRpZXMoRGF0ZS5wcm90b3R5cGUsIHtcbiAgICB0b0lTT1N0cmluZzogZnVuY3Rpb24gdG9JU09TdHJpbmcoKSB7XG4gICAgICAgIHZhciByZXN1bHQsIGxlbmd0aCwgdmFsdWUsIHllYXIsIG1vbnRoO1xuICAgICAgICBpZiAoIWlzRmluaXRlKHRoaXMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcgY2FsbGVkIG9uIG5vbi1maW5pdGUgdmFsdWUuJyk7XG4gICAgICAgIH1cblxuICAgICAgICB5ZWFyID0gdGhpcy5nZXRVVENGdWxsWWVhcigpO1xuXG4gICAgICAgIG1vbnRoID0gdGhpcy5nZXRVVENNb250aCgpO1xuICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltL2lzc3Vlcy8xMTFcbiAgICAgICAgeWVhciArPSBNYXRoLmZsb29yKG1vbnRoIC8gMTIpO1xuICAgICAgICBtb250aCA9IChtb250aCAlIDEyICsgMTIpICUgMTI7XG5cbiAgICAgICAgLy8gdGhlIGRhdGUgdGltZSBzdHJpbmcgZm9ybWF0IGlzIHNwZWNpZmllZCBpbiAxNS45LjEuMTUuXG4gICAgICAgIHJlc3VsdCA9IFttb250aCArIDEsIHRoaXMuZ2V0VVRDRGF0ZSgpLCB0aGlzLmdldFVUQ0hvdXJzKCksIHRoaXMuZ2V0VVRDTWludXRlcygpLCB0aGlzLmdldFVUQ1NlY29uZHMoKV07XG4gICAgICAgIHllYXIgPSAoXG4gICAgICAgICAgICAoeWVhciA8IDAgPyAnLScgOiAoeWVhciA+IDk5OTkgPyAnKycgOiAnJykpICtcbiAgICAgICAgICAgIHN0clNsaWNlKCcwMDAwMCcgKyBNYXRoLmFicyh5ZWFyKSwgKDAgPD0geWVhciAmJiB5ZWFyIDw9IDk5OTkpID8gLTQgOiAtNilcbiAgICAgICAgKTtcblxuICAgICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICAgIHZhbHVlID0gcmVzdWx0W2xlbmd0aF07XG4gICAgICAgICAgICAvLyBwYWQgbW9udGhzLCBkYXlzLCBob3VycywgbWludXRlcywgYW5kIHNlY29uZHMgdG8gaGF2ZSB0d29cbiAgICAgICAgICAgIC8vIGRpZ2l0cy5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA8IDEwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2xlbmd0aF0gPSAnMCcgKyB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBwYWQgbWlsbGlzZWNvbmRzIHRvIGhhdmUgdGhyZWUgZGlnaXRzLlxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgeWVhciArICctJyArIGFycmF5U2xpY2UocmVzdWx0LCAwLCAyKS5qb2luKCctJykgK1xuICAgICAgICAgICAgJ1QnICsgYXJyYXlTbGljZShyZXN1bHQsIDIpLmpvaW4oJzonKSArICcuJyArXG4gICAgICAgICAgICBzdHJTbGljZSgnMDAwJyArIHRoaXMuZ2V0VVRDTWlsbGlzZWNvbmRzKCksIC0zKSArICdaJ1xuICAgICAgICApO1xuICAgIH1cbn0sIGhhc05lZ2F0aXZlRGF0ZUJ1ZyB8fCBoYXNTYWZhcmk1MURhdGVCdWcpO1xuXG4vLyBFUzUgMTUuOS41LjQ0XG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS45LjUuNDRcbi8vIFRoaXMgZnVuY3Rpb24gcHJvdmlkZXMgYSBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBEYXRlIG9iamVjdCBmb3IgdXNlIGJ5XG4vLyBKU09OLnN0cmluZ2lmeSAoMTUuMTIuMykuXG52YXIgZGF0ZVRvSlNPTklzU3VwcG9ydGVkID0gKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gRGF0ZS5wcm90b3R5cGUudG9KU09OICYmXG4gICAgICAgICAgICBuZXcgRGF0ZShOYU4pLnRvSlNPTigpID09PSBudWxsICYmXG4gICAgICAgICAgICBuZXcgRGF0ZShuZWdhdGl2ZURhdGUpLnRvSlNPTigpLmluZGV4T2YobmVnYXRpdmVZZWFyU3RyaW5nKSAhPT0gLTEgJiZcbiAgICAgICAgICAgIERhdGUucHJvdG90eXBlLnRvSlNPTi5jYWxsKHsgLy8gZ2VuZXJpY1xuICAgICAgICAgICAgICAgIHRvSVNPU3RyaW5nOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9XG4gICAgICAgICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59KCkpO1xuaWYgKCFkYXRlVG9KU09OSXNTdXBwb3J0ZWQpIHtcbiAgICBEYXRlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oa2V5KSB7XG4gICAgICAgIC8vIFdoZW4gdGhlIHRvSlNPTiBtZXRob2QgaXMgY2FsbGVkIHdpdGggYXJndW1lbnQga2V5LCB0aGUgZm9sbG93aW5nXG4gICAgICAgIC8vIHN0ZXBzIGFyZSB0YWtlbjpcblxuICAgICAgICAvLyAxLiAgTGV0IE8gYmUgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIFRvT2JqZWN0LCBnaXZpbmcgaXQgdGhlIHRoaXNcbiAgICAgICAgLy8gdmFsdWUgYXMgaXRzIGFyZ3VtZW50LlxuICAgICAgICAvLyAyLiBMZXQgdHYgYmUgRVMuVG9QcmltaXRpdmUoTywgaGludCBOdW1iZXIpLlxuICAgICAgICB2YXIgTyA9ICRPYmplY3QodGhpcyk7XG4gICAgICAgIHZhciB0diA9IEVTLlRvUHJpbWl0aXZlKE8pO1xuICAgICAgICAvLyAzLiBJZiB0diBpcyBhIE51bWJlciBhbmQgaXMgbm90IGZpbml0ZSwgcmV0dXJuIG51bGwuXG4gICAgICAgIGlmICh0eXBlb2YgdHYgPT09ICdudW1iZXInICYmICFpc0Zpbml0ZSh0dikpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIDQuIExldCB0b0lTTyBiZSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhlIFtbR2V0XV0gaW50ZXJuYWwgbWV0aG9kIG9mXG4gICAgICAgIC8vIE8gd2l0aCBhcmd1bWVudCBcInRvSVNPU3RyaW5nXCIuXG4gICAgICAgIHZhciB0b0lTTyA9IE8udG9JU09TdHJpbmc7XG4gICAgICAgIC8vIDUuIElmIElzQ2FsbGFibGUodG9JU08pIGlzIGZhbHNlLCB0aHJvdyBhIFR5cGVFcnJvciBleGNlcHRpb24uXG4gICAgICAgIGlmICghaXNDYWxsYWJsZSh0b0lTTykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3RvSVNPU3RyaW5nIHByb3BlcnR5IGlzIG5vdCBjYWxsYWJsZScpO1xuICAgICAgICB9XG4gICAgICAgIC8vIDYuIFJldHVybiB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhlIFtbQ2FsbF1dIGludGVybmFsIG1ldGhvZCBvZlxuICAgICAgICAvLyAgdG9JU08gd2l0aCBPIGFzIHRoZSB0aGlzIHZhbHVlIGFuZCBhbiBlbXB0eSBhcmd1bWVudCBsaXN0LlxuICAgICAgICByZXR1cm4gdG9JU08uY2FsbChPKTtcblxuICAgICAgICAvLyBOT1RFIDEgVGhlIGFyZ3VtZW50IGlzIGlnbm9yZWQuXG5cbiAgICAgICAgLy8gTk9URSAyIFRoZSB0b0pTT04gZnVuY3Rpb24gaXMgaW50ZW50aW9uYWxseSBnZW5lcmljOyBpdCBkb2VzIG5vdFxuICAgICAgICAvLyByZXF1aXJlIHRoYXQgaXRzIHRoaXMgdmFsdWUgYmUgYSBEYXRlIG9iamVjdC4gVGhlcmVmb3JlLCBpdCBjYW4gYmVcbiAgICAgICAgLy8gdHJhbnNmZXJyZWQgdG8gb3RoZXIga2luZHMgb2Ygb2JqZWN0cyBmb3IgdXNlIGFzIGEgbWV0aG9kLiBIb3dldmVyLFxuICAgICAgICAvLyBpdCBkb2VzIHJlcXVpcmUgdGhhdCBhbnkgc3VjaCBvYmplY3QgaGF2ZSBhIHRvSVNPU3RyaW5nIG1ldGhvZC4gQW5cbiAgICAgICAgLy8gb2JqZWN0IGlzIGZyZWUgdG8gdXNlIHRoZSBhcmd1bWVudCBrZXkgdG8gZmlsdGVyIGl0c1xuICAgICAgICAvLyBzdHJpbmdpZmljYXRpb24uXG4gICAgfTtcbn1cblxuLy8gRVM1IDE1LjkuNC4yXG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS45LjQuMlxuLy8gYmFzZWQgb24gd29yayBzaGFyZWQgYnkgRGFuaWVsIEZyaWVzZW4gKGRhbnRtYW4pXG4vLyBodHRwOi8vZ2lzdC5naXRodWIuY29tLzMwMzI0OVxudmFyIHN1cHBvcnRzRXh0ZW5kZWRZZWFycyA9IERhdGUucGFyc2UoJyswMzM2NTgtMDktMjdUMDE6NDY6NDAuMDAwWicpID09PSAxZTE1O1xudmFyIGFjY2VwdHNJbnZhbGlkRGF0ZXMgPSAhaXNOYU4oRGF0ZS5wYXJzZSgnMjAxMi0wNC0wNFQyNDowMDowMC41MDBaJykpIHx8ICFpc05hTihEYXRlLnBhcnNlKCcyMDEyLTExLTMxVDIzOjU5OjU5LjAwMFonKSkgfHwgIWlzTmFOKERhdGUucGFyc2UoJzIwMTItMTItMzFUMjM6NTk6NjAuMDAwWicpKTtcbnZhciBkb2VzTm90UGFyc2VZMktOZXdZZWFyID0gaXNOYU4oRGF0ZS5wYXJzZSgnMjAwMC0wMS0wMVQwMDowMDowMC4wMDBaJykpO1xuaWYgKGRvZXNOb3RQYXJzZVkyS05ld1llYXIgfHwgYWNjZXB0c0ludmFsaWREYXRlcyB8fCAhc3VwcG9ydHNFeHRlbmRlZFllYXJzKSB7XG4gICAgLy8gWFhYIGdsb2JhbCBhc3NpZ25tZW50IHdvbid0IHdvcmsgaW4gZW1iZWRkaW5ncyB0aGF0IHVzZVxuICAgIC8vIGFuIGFsdGVybmF0ZSBvYmplY3QgZm9yIHRoZSBjb250ZXh0LlxuICAgIC8qIGdsb2JhbCBEYXRlOiB0cnVlICovXG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWYgKi9cbiAgICB2YXIgbWF4U2FmZVVuc2lnbmVkMzJCaXQgPSBNYXRoLnBvdygyLCAzMSkgLSAxO1xuICAgIHZhciBoYXNTYWZhcmlTaWduZWRJbnRCdWcgPSBpc0FjdHVhbE5hTihuZXcgRGF0ZSgxOTcwLCAwLCAxLCAwLCAwLCAwLCBtYXhTYWZlVW5zaWduZWQzMkJpdCArIDEpLmdldFRpbWUoKSk7XG4gICAgRGF0ZSA9IChmdW5jdGlvbiAoTmF0aXZlRGF0ZSkge1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW5kZWYgKi9cbiAgICAgICAgLy8gRGF0ZS5sZW5ndGggPT09IDdcbiAgICAgICAgdmFyIERhdGVTaGltID0gZnVuY3Rpb24gRGF0ZShZLCBNLCBELCBoLCBtLCBzLCBtcykge1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgZGF0ZTtcbiAgICAgICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgTmF0aXZlRGF0ZSkge1xuICAgICAgICAgICAgICAgIHZhciBzZWNvbmRzID0gcztcbiAgICAgICAgICAgICAgICB2YXIgbWlsbGlzID0gbXM7XG4gICAgICAgICAgICAgICAgaWYgKGhhc1NhZmFyaVNpZ25lZEludEJ1ZyAmJiBsZW5ndGggPj0gNyAmJiBtcyA+IG1heFNhZmVVbnNpZ25lZDMyQml0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdvcmsgYXJvdW5kIGEgU2FmYXJpIDgvOSBidWcgd2hlcmUgaXQgdHJlYXRzIHRoZSBzZWNvbmRzIGFzIHNpZ25lZFxuICAgICAgICAgICAgICAgICAgICB2YXIgbXNUb1NoaWZ0ID0gTWF0aC5mbG9vcihtcyAvIG1heFNhZmVVbnNpZ25lZDMyQml0KSAqIG1heFNhZmVVbnNpZ25lZDMyQml0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgc1RvU2hpZnQgPSBNYXRoLmZsb29yKG1zVG9TaGlmdCAvIDFlMyk7XG4gICAgICAgICAgICAgICAgICAgIHNlY29uZHMgKz0gc1RvU2hpZnQ7XG4gICAgICAgICAgICAgICAgICAgIG1pbGxpcyAtPSBzVG9TaGlmdCAqIDFlMztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGF0ZSA9IGxlbmd0aCA9PT0gMSAmJiAkU3RyaW5nKFkpID09PSBZID8gLy8gaXNTdHJpbmcoWSlcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgZXhwbGljaXRseSBwYXNzIGl0IHRocm91Z2ggcGFyc2U6XG4gICAgICAgICAgICAgICAgICAgIG5ldyBOYXRpdmVEYXRlKERhdGVTaGltLnBhcnNlKFkpKSA6XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgdG8gbWFudWFsbHkgbWFrZSBjYWxscyBkZXBlbmRpbmcgb24gYXJndW1lbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gbGVuZ3RoIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID49IDcgPyBuZXcgTmF0aXZlRGF0ZShZLCBNLCBELCBoLCBtLCBzZWNvbmRzLCBtaWxsaXMpIDpcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID49IDYgPyBuZXcgTmF0aXZlRGF0ZShZLCBNLCBELCBoLCBtLCBzZWNvbmRzKSA6XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA+PSA1ID8gbmV3IE5hdGl2ZURhdGUoWSwgTSwgRCwgaCwgbSkgOlxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPj0gNCA/IG5ldyBOYXRpdmVEYXRlKFksIE0sIEQsIGgpIDpcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID49IDMgPyBuZXcgTmF0aXZlRGF0ZShZLCBNLCBEKSA6XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA+PSAyID8gbmV3IE5hdGl2ZURhdGUoWSwgTSkgOlxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPj0gMSA/IG5ldyBOYXRpdmVEYXRlKFkpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgTmF0aXZlRGF0ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRlID0gTmF0aXZlRGF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc1ByaW1pdGl2ZShkYXRlKSkge1xuICAgICAgICAgICAgICAvLyBQcmV2ZW50IG1peHVwcyB3aXRoIHVuZml4ZWQgRGF0ZSBvYmplY3RcbiAgICAgICAgICAgICAgZGVmaW5lUHJvcGVydGllcyhkYXRlLCB7IGNvbnN0cnVjdG9yOiBEYXRlU2hpbSB9LCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkYXRlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIDE1LjkuMS4xNSBEYXRlIFRpbWUgU3RyaW5nIEZvcm1hdC5cbiAgICAgICAgdmFyIGlzb0RhdGVFeHByZXNzaW9uID0gbmV3IFJlZ0V4cCgnXicgK1xuICAgICAgICAgICAgJyhcXFxcZHs0fXxbKy1dXFxcXGR7Nn0pJyArIC8vIGZvdXItZGlnaXQgeWVhciBjYXB0dXJlIG9yIHNpZ24gK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA2LWRpZ2l0IGV4dGVuZGVkIHllYXJcbiAgICAgICAgICAgICcoPzotKFxcXFxkezJ9KScgKyAvLyBvcHRpb25hbCBtb250aCBjYXB0dXJlXG4gICAgICAgICAgICAnKD86LShcXFxcZHsyfSknICsgLy8gb3B0aW9uYWwgZGF5IGNhcHR1cmVcbiAgICAgICAgICAgICcoPzonICsgLy8gY2FwdHVyZSBob3VyczptaW51dGVzOnNlY29uZHMubWlsbGlzZWNvbmRzXG4gICAgICAgICAgICAgICAgJ1QoXFxcXGR7Mn0pJyArIC8vIGhvdXJzIGNhcHR1cmVcbiAgICAgICAgICAgICAgICAnOihcXFxcZHsyfSknICsgLy8gbWludXRlcyBjYXB0dXJlXG4gICAgICAgICAgICAgICAgJyg/OicgKyAvLyBvcHRpb25hbCA6c2Vjb25kcy5taWxsaXNlY29uZHNcbiAgICAgICAgICAgICAgICAgICAgJzooXFxcXGR7Mn0pJyArIC8vIHNlY29uZHMgY2FwdHVyZVxuICAgICAgICAgICAgICAgICAgICAnKD86KFxcXFwuXFxcXGR7MSx9KSk/JyArIC8vIG1pbGxpc2Vjb25kcyBjYXB0dXJlXG4gICAgICAgICAgICAgICAgJyk/JyArXG4gICAgICAgICAgICAnKCcgKyAvLyBjYXB0dXJlIFVUQyBvZmZzZXQgY29tcG9uZW50XG4gICAgICAgICAgICAgICAgJ1p8JyArIC8vIFVUQyBjYXB0dXJlXG4gICAgICAgICAgICAgICAgJyg/OicgKyAvLyBvZmZzZXQgc3BlY2lmaWVyICsvLWhvdXJzOm1pbnV0ZXNcbiAgICAgICAgICAgICAgICAgICAgJyhbLStdKScgKyAvLyBzaWduIGNhcHR1cmVcbiAgICAgICAgICAgICAgICAgICAgJyhcXFxcZHsyfSknICsgLy8gaG91cnMgb2Zmc2V0IGNhcHR1cmVcbiAgICAgICAgICAgICAgICAgICAgJzooXFxcXGR7Mn0pJyArIC8vIG1pbnV0ZXMgb2Zmc2V0IGNhcHR1cmVcbiAgICAgICAgICAgICAgICAnKScgK1xuICAgICAgICAgICAgJyk/KT8pPyk/JyArXG4gICAgICAgICckJyk7XG5cbiAgICAgICAgdmFyIG1vbnRocyA9IFswLCAzMSwgNTksIDkwLCAxMjAsIDE1MSwgMTgxLCAyMTIsIDI0MywgMjczLCAzMDQsIDMzNCwgMzY1XTtcblxuICAgICAgICB2YXIgZGF5RnJvbU1vbnRoID0gZnVuY3Rpb24gZGF5RnJvbU1vbnRoKHllYXIsIG1vbnRoKSB7XG4gICAgICAgICAgICB2YXIgdCA9IG1vbnRoID4gMSA/IDEgOiAwO1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICBtb250aHNbbW9udGhdICtcbiAgICAgICAgICAgICAgICBNYXRoLmZsb29yKCh5ZWFyIC0gMTk2OSArIHQpIC8gNCkgLVxuICAgICAgICAgICAgICAgIE1hdGguZmxvb3IoKHllYXIgLSAxOTAxICsgdCkgLyAxMDApICtcbiAgICAgICAgICAgICAgICBNYXRoLmZsb29yKCh5ZWFyIC0gMTYwMSArIHQpIC8gNDAwKSArXG4gICAgICAgICAgICAgICAgMzY1ICogKHllYXIgLSAxOTcwKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgdG9VVEMgPSBmdW5jdGlvbiB0b1VUQyh0KSB7XG4gICAgICAgICAgICB2YXIgcyA9IDA7XG4gICAgICAgICAgICB2YXIgbXMgPSB0O1xuICAgICAgICAgICAgaWYgKGhhc1NhZmFyaVNpZ25lZEludEJ1ZyAmJiBtcyA+IG1heFNhZmVVbnNpZ25lZDMyQml0KSB7XG4gICAgICAgICAgICAgICAgLy8gd29yayBhcm91bmQgYSBTYWZhcmkgOC85IGJ1ZyB3aGVyZSBpdCB0cmVhdHMgdGhlIHNlY29uZHMgYXMgc2lnbmVkXG4gICAgICAgICAgICAgICAgdmFyIG1zVG9TaGlmdCA9IE1hdGguZmxvb3IobXMgLyBtYXhTYWZlVW5zaWduZWQzMkJpdCkgKiBtYXhTYWZlVW5zaWduZWQzMkJpdDtcbiAgICAgICAgICAgICAgICB2YXIgc1RvU2hpZnQgPSBNYXRoLmZsb29yKG1zVG9TaGlmdCAvIDFlMyk7XG4gICAgICAgICAgICAgICAgcyArPSBzVG9TaGlmdDtcbiAgICAgICAgICAgICAgICBtcyAtPSBzVG9TaGlmdCAqIDFlMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAkTnVtYmVyKG5ldyBOYXRpdmVEYXRlKDE5NzAsIDAsIDEsIDAsIDAsIHMsIG1zKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQ29weSBhbnkgY3VzdG9tIG1ldGhvZHMgYSAzcmQgcGFydHkgbGlicmFyeSBtYXkgaGF2ZSBhZGRlZFxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gTmF0aXZlRGF0ZSkge1xuICAgICAgICAgICAgaWYgKG93bnMoTmF0aXZlRGF0ZSwga2V5KSkge1xuICAgICAgICAgICAgICAgIERhdGVTaGltW2tleV0gPSBOYXRpdmVEYXRlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb3B5IFwibmF0aXZlXCIgbWV0aG9kcyBleHBsaWNpdGx5OyB0aGV5IG1heSBiZSBub24tZW51bWVyYWJsZVxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKERhdGVTaGltLCB7XG4gICAgICAgICAgICBub3c6IE5hdGl2ZURhdGUubm93LFxuICAgICAgICAgICAgVVRDOiBOYXRpdmVEYXRlLlVUQ1xuICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgRGF0ZVNoaW0ucHJvdG90eXBlID0gTmF0aXZlRGF0ZS5wcm90b3R5cGU7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXMoRGF0ZVNoaW0ucHJvdG90eXBlLCB7XG4gICAgICAgICAgICBjb25zdHJ1Y3RvcjogRGF0ZVNoaW1cbiAgICAgICAgfSwgdHJ1ZSk7XG5cbiAgICAgICAgLy8gVXBncmFkZSBEYXRlLnBhcnNlIHRvIGhhbmRsZSBzaW1wbGlmaWVkIElTTyA4NjAxIHN0cmluZ3NcbiAgICAgICAgdmFyIHBhcnNlU2hpbSA9IGZ1bmN0aW9uIHBhcnNlKHN0cmluZykge1xuICAgICAgICAgICAgdmFyIG1hdGNoID0gaXNvRGF0ZUV4cHJlc3Npb24uZXhlYyhzdHJpbmcpO1xuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgLy8gcGFyc2UgbW9udGhzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgYW5kIG1pbGxpc2Vjb25kc1xuICAgICAgICAgICAgICAgIC8vIHByb3ZpZGUgZGVmYXVsdCB2YWx1ZXMgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgICAgICAgLy8gcGFyc2UgdGhlIFVUQyBvZmZzZXQgY29tcG9uZW50XG4gICAgICAgICAgICAgICAgdmFyIHllYXIgPSAkTnVtYmVyKG1hdGNoWzFdKSxcbiAgICAgICAgICAgICAgICAgICAgbW9udGggPSAkTnVtYmVyKG1hdGNoWzJdIHx8IDEpIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgZGF5ID0gJE51bWJlcihtYXRjaFszXSB8fCAxKSAtIDEsXG4gICAgICAgICAgICAgICAgICAgIGhvdXIgPSAkTnVtYmVyKG1hdGNoWzRdIHx8IDApLFxuICAgICAgICAgICAgICAgICAgICBtaW51dGUgPSAkTnVtYmVyKG1hdGNoWzVdIHx8IDApLFxuICAgICAgICAgICAgICAgICAgICBzZWNvbmQgPSAkTnVtYmVyKG1hdGNoWzZdIHx8IDApLFxuICAgICAgICAgICAgICAgICAgICBtaWxsaXNlY29uZCA9IE1hdGguZmxvb3IoJE51bWJlcihtYXRjaFs3XSB8fCAwKSAqIDEwMDApLFxuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHRpbWUgem9uZSBpcyBtaXNzZWQsIGxvY2FsIG9mZnNldCBzaG91bGQgYmUgdXNlZFxuICAgICAgICAgICAgICAgICAgICAvLyAoRVMgNS4xIGJ1ZylcbiAgICAgICAgICAgICAgICAgICAgLy8gc2VlIGh0dHBzOi8vYnVncy5lY21hc2NyaXB0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTEyXG4gICAgICAgICAgICAgICAgICAgIGlzTG9jYWxUaW1lID0gQm9vbGVhbihtYXRjaFs0XSAmJiAhbWF0Y2hbOF0pLFxuICAgICAgICAgICAgICAgICAgICBzaWduT2Zmc2V0ID0gbWF0Y2hbOV0gPT09ICctJyA/IDEgOiAtMSxcbiAgICAgICAgICAgICAgICAgICAgaG91ck9mZnNldCA9ICROdW1iZXIobWF0Y2hbMTBdIHx8IDApLFxuICAgICAgICAgICAgICAgICAgICBtaW51dGVPZmZzZXQgPSAkTnVtYmVyKG1hdGNoWzExXSB8fCAwKSxcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0O1xuICAgICAgICAgICAgICAgIHZhciBoYXNNaW51dGVzT3JTZWNvbmRzT3JNaWxsaXNlY29uZHMgPSBtaW51dGUgPiAwIHx8IHNlY29uZCA+IDAgfHwgbWlsbGlzZWNvbmQgPiAwO1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgaG91ciA8IChoYXNNaW51dGVzT3JTZWNvbmRzT3JNaWxsaXNlY29uZHMgPyAyNCA6IDI1KSAmJlxuICAgICAgICAgICAgICAgICAgICBtaW51dGUgPCA2MCAmJiBzZWNvbmQgPCA2MCAmJiBtaWxsaXNlY29uZCA8IDEwMDAgJiZcbiAgICAgICAgICAgICAgICAgICAgbW9udGggPiAtMSAmJiBtb250aCA8IDEyICYmIGhvdXJPZmZzZXQgPCAyNCAmJlxuICAgICAgICAgICAgICAgICAgICBtaW51dGVPZmZzZXQgPCA2MCAmJiAvLyBkZXRlY3QgaW52YWxpZCBvZmZzZXRzXG4gICAgICAgICAgICAgICAgICAgIGRheSA+IC0xICYmXG4gICAgICAgICAgICAgICAgICAgIGRheSA8IChkYXlGcm9tTW9udGgoeWVhciwgbW9udGggKyAxKSAtIGRheUZyb21Nb250aCh5ZWFyLCBtb250aCkpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IChcbiAgICAgICAgICAgICAgICAgICAgICAgIChkYXlGcm9tTW9udGgoeWVhciwgbW9udGgpICsgZGF5KSAqIDI0ICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvdXIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgaG91ck9mZnNldCAqIHNpZ25PZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgKSAqIDYwO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSAoXG4gICAgICAgICAgICAgICAgICAgICAgICAocmVzdWx0ICsgbWludXRlICsgbWludXRlT2Zmc2V0ICogc2lnbk9mZnNldCkgKiA2MCArXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWNvbmRcbiAgICAgICAgICAgICAgICAgICAgKSAqIDEwMDAgKyBtaWxsaXNlY29uZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTG9jYWxUaW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0b1VUQyhyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICgtOC42NGUxNSA8PSByZXN1bHQgJiYgcmVzdWx0IDw9IDguNjRlMTUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBOYXRpdmVEYXRlLnBhcnNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXMoRGF0ZVNoaW0sIHsgcGFyc2U6IHBhcnNlU2hpbSB9KTtcblxuICAgICAgICByZXR1cm4gRGF0ZVNoaW07XG4gICAgfShEYXRlKSk7XG4gICAgLyogZ2xvYmFsIERhdGU6IGZhbHNlICovXG59XG5cbi8vIEVTNSAxNS45LjQuNFxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuOS40LjRcbmlmICghRGF0ZS5ub3cpIHtcbiAgICBEYXRlLm5vdyA9IGZ1bmN0aW9uIG5vdygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIH07XG59XG5cbi8vXG4vLyBOdW1iZXJcbi8vID09PT09PVxuLy9cblxuLy8gRVM1LjEgMTUuNy40LjVcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjcuNC41XG52YXIgaGFzVG9GaXhlZEJ1Z3MgPSBOdW1iZXJQcm90b3R5cGUudG9GaXhlZCAmJiAoXG4gICgwLjAwMDA4KS50b0ZpeGVkKDMpICE9PSAnMC4wMDAnIHx8XG4gICgwLjkpLnRvRml4ZWQoMCkgIT09ICcxJyB8fFxuICAoMS4yNTUpLnRvRml4ZWQoMikgIT09ICcxLjI1JyB8fFxuICAoMTAwMDAwMDAwMDAwMDAwMDEyOCkudG9GaXhlZCgwKSAhPT0gJzEwMDAwMDAwMDAwMDAwMDAxMjgnXG4pO1xuXG52YXIgdG9GaXhlZEhlbHBlcnMgPSB7XG4gIGJhc2U6IDFlNyxcbiAgc2l6ZTogNixcbiAgZGF0YTogWzAsIDAsIDAsIDAsIDAsIDBdLFxuICBtdWx0aXBseTogZnVuY3Rpb24gbXVsdGlwbHkobiwgYykge1xuICAgICAgdmFyIGkgPSAtMTtcbiAgICAgIHZhciBjMiA9IGM7XG4gICAgICB3aGlsZSAoKytpIDwgdG9GaXhlZEhlbHBlcnMuc2l6ZSkge1xuICAgICAgICAgIGMyICs9IG4gKiB0b0ZpeGVkSGVscGVycy5kYXRhW2ldO1xuICAgICAgICAgIHRvRml4ZWRIZWxwZXJzLmRhdGFbaV0gPSBjMiAlIHRvRml4ZWRIZWxwZXJzLmJhc2U7XG4gICAgICAgICAgYzIgPSBNYXRoLmZsb29yKGMyIC8gdG9GaXhlZEhlbHBlcnMuYmFzZSk7XG4gICAgICB9XG4gIH0sXG4gIGRpdmlkZTogZnVuY3Rpb24gZGl2aWRlKG4pIHtcbiAgICAgIHZhciBpID0gdG9GaXhlZEhlbHBlcnMuc2l6ZSwgYyA9IDA7XG4gICAgICB3aGlsZSAoLS1pID49IDApIHtcbiAgICAgICAgICBjICs9IHRvRml4ZWRIZWxwZXJzLmRhdGFbaV07XG4gICAgICAgICAgdG9GaXhlZEhlbHBlcnMuZGF0YVtpXSA9IE1hdGguZmxvb3IoYyAvIG4pO1xuICAgICAgICAgIGMgPSAoYyAlIG4pICogdG9GaXhlZEhlbHBlcnMuYmFzZTtcbiAgICAgIH1cbiAgfSxcbiAgbnVtVG9TdHJpbmc6IGZ1bmN0aW9uIG51bVRvU3RyaW5nKCkge1xuICAgICAgdmFyIGkgPSB0b0ZpeGVkSGVscGVycy5zaXplO1xuICAgICAgdmFyIHMgPSAnJztcbiAgICAgIHdoaWxlICgtLWkgPj0gMCkge1xuICAgICAgICAgIGlmIChzICE9PSAnJyB8fCBpID09PSAwIHx8IHRvRml4ZWRIZWxwZXJzLmRhdGFbaV0gIT09IDApIHtcbiAgICAgICAgICAgICAgdmFyIHQgPSAkU3RyaW5nKHRvRml4ZWRIZWxwZXJzLmRhdGFbaV0pO1xuICAgICAgICAgICAgICBpZiAocyA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgIHMgPSB0O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcyArPSBzdHJTbGljZSgnMDAwMDAwMCcsIDAsIDcgLSB0Lmxlbmd0aCkgKyB0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHM7XG4gIH0sXG4gIHBvdzogZnVuY3Rpb24gcG93KHgsIG4sIGFjYykge1xuICAgICAgcmV0dXJuIChuID09PSAwID8gYWNjIDogKG4gJSAyID09PSAxID8gcG93KHgsIG4gLSAxLCBhY2MgKiB4KSA6IHBvdyh4ICogeCwgbiAvIDIsIGFjYykpKTtcbiAgfSxcbiAgbG9nOiBmdW5jdGlvbiBsb2coeCkge1xuICAgICAgdmFyIG4gPSAwO1xuICAgICAgdmFyIHgyID0geDtcbiAgICAgIHdoaWxlICh4MiA+PSA0MDk2KSB7XG4gICAgICAgICAgbiArPSAxMjtcbiAgICAgICAgICB4MiAvPSA0MDk2O1xuICAgICAgfVxuICAgICAgd2hpbGUgKHgyID49IDIpIHtcbiAgICAgICAgICBuICs9IDE7XG4gICAgICAgICAgeDIgLz0gMjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuO1xuICB9XG59O1xuXG52YXIgdG9GaXhlZFNoaW0gPSBmdW5jdGlvbiB0b0ZpeGVkKGZyYWN0aW9uRGlnaXRzKSB7XG4gICAgdmFyIGYsIHgsIHMsIG0sIGUsIHosIGosIGs7XG5cbiAgICAvLyBUZXN0IGZvciBOYU4gYW5kIHJvdW5kIGZyYWN0aW9uRGlnaXRzIGRvd25cbiAgICBmID0gJE51bWJlcihmcmFjdGlvbkRpZ2l0cyk7XG4gICAgZiA9IGlzQWN0dWFsTmFOKGYpID8gMCA6IE1hdGguZmxvb3IoZik7XG5cbiAgICBpZiAoZiA8IDAgfHwgZiA+IDIwKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdOdW1iZXIudG9GaXhlZCBjYWxsZWQgd2l0aCBpbnZhbGlkIG51bWJlciBvZiBkZWNpbWFscycpO1xuICAgIH1cblxuICAgIHggPSAkTnVtYmVyKHRoaXMpO1xuXG4gICAgaWYgKGlzQWN0dWFsTmFOKHgpKSB7XG4gICAgICAgIHJldHVybiAnTmFOJztcbiAgICB9XG5cbiAgICAvLyBJZiBpdCBpcyB0b28gYmlnIG9yIHNtYWxsLCByZXR1cm4gdGhlIHN0cmluZyB2YWx1ZSBvZiB0aGUgbnVtYmVyXG4gICAgaWYgKHggPD0gLTFlMjEgfHwgeCA+PSAxZTIxKSB7XG4gICAgICAgIHJldHVybiAkU3RyaW5nKHgpO1xuICAgIH1cblxuICAgIHMgPSAnJztcblxuICAgIGlmICh4IDwgMCkge1xuICAgICAgICBzID0gJy0nO1xuICAgICAgICB4ID0gLXg7XG4gICAgfVxuXG4gICAgbSA9ICcwJztcblxuICAgIGlmICh4ID4gMWUtMjEpIHtcbiAgICAgICAgLy8gMWUtMjEgPCB4IDwgMWUyMVxuICAgICAgICAvLyAtNzAgPCBsb2cyKHgpIDwgNzBcbiAgICAgICAgZSA9IHRvRml4ZWRIZWxwZXJzLmxvZyh4ICogdG9GaXhlZEhlbHBlcnMucG93KDIsIDY5LCAxKSkgLSA2OTtcbiAgICAgICAgeiA9IChlIDwgMCA/IHggKiB0b0ZpeGVkSGVscGVycy5wb3coMiwgLWUsIDEpIDogeCAvIHRvRml4ZWRIZWxwZXJzLnBvdygyLCBlLCAxKSk7XG4gICAgICAgIHogKj0gMHgxMDAwMDAwMDAwMDAwMDsgLy8gTWF0aC5wb3coMiwgNTIpO1xuICAgICAgICBlID0gNTIgLSBlO1xuXG4gICAgICAgIC8vIC0xOCA8IGUgPCAxMjJcbiAgICAgICAgLy8geCA9IHogLyAyIF4gZVxuICAgICAgICBpZiAoZSA+IDApIHtcbiAgICAgICAgICAgIHRvRml4ZWRIZWxwZXJzLm11bHRpcGx5KDAsIHopO1xuICAgICAgICAgICAgaiA9IGY7XG5cbiAgICAgICAgICAgIHdoaWxlIChqID49IDcpIHtcbiAgICAgICAgICAgICAgICB0b0ZpeGVkSGVscGVycy5tdWx0aXBseSgxZTcsIDApO1xuICAgICAgICAgICAgICAgIGogLT0gNztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdG9GaXhlZEhlbHBlcnMubXVsdGlwbHkodG9GaXhlZEhlbHBlcnMucG93KDEwLCBqLCAxKSwgMCk7XG4gICAgICAgICAgICBqID0gZSAtIDE7XG5cbiAgICAgICAgICAgIHdoaWxlIChqID49IDIzKSB7XG4gICAgICAgICAgICAgICAgdG9GaXhlZEhlbHBlcnMuZGl2aWRlKDEgPDwgMjMpO1xuICAgICAgICAgICAgICAgIGogLT0gMjM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRvRml4ZWRIZWxwZXJzLmRpdmlkZSgxIDw8IGopO1xuICAgICAgICAgICAgdG9GaXhlZEhlbHBlcnMubXVsdGlwbHkoMSwgMSk7XG4gICAgICAgICAgICB0b0ZpeGVkSGVscGVycy5kaXZpZGUoMik7XG4gICAgICAgICAgICBtID0gdG9GaXhlZEhlbHBlcnMubnVtVG9TdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRvRml4ZWRIZWxwZXJzLm11bHRpcGx5KDAsIHopO1xuICAgICAgICAgICAgdG9GaXhlZEhlbHBlcnMubXVsdGlwbHkoMSA8PCAoLWUpLCAwKTtcbiAgICAgICAgICAgIG0gPSB0b0ZpeGVkSGVscGVycy5udW1Ub1N0cmluZygpICsgc3RyU2xpY2UoJzAuMDAwMDAwMDAwMDAwMDAwMDAwMDAnLCAyLCAyICsgZik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZiA+IDApIHtcbiAgICAgICAgayA9IG0ubGVuZ3RoO1xuXG4gICAgICAgIGlmIChrIDw9IGYpIHtcbiAgICAgICAgICAgIG0gPSBzICsgc3RyU2xpY2UoJzAuMDAwMDAwMDAwMDAwMDAwMDAwMCcsIDAsIGYgLSBrICsgMikgKyBtO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbSA9IHMgKyBzdHJTbGljZShtLCAwLCBrIC0gZikgKyAnLicgKyBzdHJTbGljZShtLCBrIC0gZik7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBtID0gcyArIG07XG4gICAgfVxuXG4gICAgcmV0dXJuIG07XG59O1xuZGVmaW5lUHJvcGVydGllcyhOdW1iZXJQcm90b3R5cGUsIHsgdG9GaXhlZDogdG9GaXhlZFNoaW0gfSwgaGFzVG9GaXhlZEJ1Z3MpO1xuXG52YXIgaGFzVG9QcmVjaXNpb25VbmRlZmluZWRCdWcgPSAoZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiAxLjAudG9QcmVjaXNpb24odW5kZWZpbmVkKSA9PT0gJzEnO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufSgpKTtcbnZhciBvcmlnaW5hbFRvUHJlY2lzaW9uID0gTnVtYmVyUHJvdG90eXBlLnRvUHJlY2lzaW9uO1xuZGVmaW5lUHJvcGVydGllcyhOdW1iZXJQcm90b3R5cGUsIHtcbiAgICB0b1ByZWNpc2lvbjogZnVuY3Rpb24gdG9QcmVjaXNpb24ocHJlY2lzaW9uKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgcHJlY2lzaW9uID09PSAndW5kZWZpbmVkJyA/IG9yaWdpbmFsVG9QcmVjaXNpb24uY2FsbCh0aGlzKSA6IG9yaWdpbmFsVG9QcmVjaXNpb24uY2FsbCh0aGlzLCBwcmVjaXNpb24pO1xuICAgIH1cbn0sIGhhc1RvUHJlY2lzaW9uVW5kZWZpbmVkQnVnKTtcblxuLy9cbi8vIFN0cmluZ1xuLy8gPT09PT09XG4vL1xuXG4vLyBFUzUgMTUuNS40LjE0XG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS41LjQuMTRcblxuLy8gW2J1Z2ZpeCwgSUUgbHQgOSwgZmlyZWZveCA0LCBLb25xdWVyb3IsIE9wZXJhLCBvYnNjdXJlIGJyb3dzZXJzXVxuLy8gTWFueSBicm93c2VycyBkbyBub3Qgc3BsaXQgcHJvcGVybHkgd2l0aCByZWd1bGFyIGV4cHJlc3Npb25zIG9yIHRoZXlcbi8vIGRvIG5vdCBwZXJmb3JtIHRoZSBzcGxpdCBjb3JyZWN0bHkgdW5kZXIgb2JzY3VyZSBjb25kaXRpb25zLlxuLy8gU2VlIGh0dHA6Ly9ibG9nLnN0ZXZlbmxldml0aGFuLmNvbS9hcmNoaXZlcy9jcm9zcy1icm93c2VyLXNwbGl0XG4vLyBJJ3ZlIHRlc3RlZCBpbiBtYW55IGJyb3dzZXJzIGFuZCB0aGlzIHNlZW1zIHRvIGNvdmVyIHRoZSBkZXZpYW50IG9uZXM6XG4vLyAgICAnYWInLnNwbGl0KC8oPzphYikqLykgc2hvdWxkIGJlIFtcIlwiLCBcIlwiXSwgbm90IFtcIlwiXVxuLy8gICAgJy4nLnNwbGl0KC8oLj8pKC4/KS8pIHNob3VsZCBiZSBbXCJcIiwgXCIuXCIsIFwiXCIsIFwiXCJdLCBub3QgW1wiXCIsIFwiXCJdXG4vLyAgICAndGVzc3QnLnNwbGl0KC8ocykqLykgc2hvdWxkIGJlIFtcInRcIiwgdW5kZWZpbmVkLCBcImVcIiwgXCJzXCIsIFwidFwiXSwgbm90XG4vLyAgICAgICBbdW5kZWZpbmVkLCBcInRcIiwgdW5kZWZpbmVkLCBcImVcIiwgLi4uXVxuLy8gICAgJycuc3BsaXQoLy4/Lykgc2hvdWxkIGJlIFtdLCBub3QgW1wiXCJdXG4vLyAgICAnLicuc3BsaXQoLygpKCkvKSBzaG91bGQgYmUgW1wiLlwiXSwgbm90IFtcIlwiLCBcIlwiLCBcIi5cIl1cblxuaWYgKFxuICAgICdhYicuc3BsaXQoLyg/OmFiKSovKS5sZW5ndGggIT09IDIgfHxcbiAgICAnLicuc3BsaXQoLyguPykoLj8pLykubGVuZ3RoICE9PSA0IHx8XG4gICAgJ3Rlc3N0Jy5zcGxpdCgvKHMpKi8pWzFdID09PSAndCcgfHxcbiAgICAndGVzdCcuc3BsaXQoLyg/OikvLCAtMSkubGVuZ3RoICE9PSA0IHx8XG4gICAgJycuc3BsaXQoLy4/LykubGVuZ3RoIHx8XG4gICAgJy4nLnNwbGl0KC8oKSgpLykubGVuZ3RoID4gMVxuKSB7XG4gICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbXBsaWFudEV4ZWNOcGNnID0gdHlwZW9mICgvKCk/Py8pLmV4ZWMoJycpWzFdID09PSAndW5kZWZpbmVkJzsgLy8gTlBDRzogbm9ucGFydGljaXBhdGluZyBjYXB0dXJpbmcgZ3JvdXBcbiAgICAgICAgdmFyIG1heFNhZmUzMkJpdEludCA9IE1hdGgucG93KDIsIDMyKSAtIDE7XG5cbiAgICAgICAgU3RyaW5nUHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gKHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgICAgICAgIHZhciBzdHJpbmcgPSBTdHJpbmcodGhpcyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNlcGFyYXRvciA9PT0gJ3VuZGVmaW5lZCcgJiYgbGltaXQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIGBzZXBhcmF0b3JgIGlzIG5vdCBhIHJlZ2V4LCB1c2UgbmF0aXZlIHNwbGl0XG4gICAgICAgICAgICBpZiAoIWlzUmVnZXgoc2VwYXJhdG9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJTcGxpdCh0aGlzLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG91dHB1dCA9IFtdO1xuICAgICAgICAgICAgdmFyIGZsYWdzID0gKHNlcGFyYXRvci5pZ25vcmVDYXNlID8gJ2knIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3IubXVsdGlsaW5lID8gJ20nIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3IudW5pY29kZSA/ICd1JyA6ICcnKSArIC8vIGluIEVTNlxuICAgICAgICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5zdGlja3kgPyAneScgOiAnJyksIC8vIEZpcmVmb3ggMysgYW5kIEVTNlxuICAgICAgICAgICAgICAgIGxhc3RMYXN0SW5kZXggPSAwLFxuICAgICAgICAgICAgICAgIC8vIE1ha2UgYGdsb2JhbGAgYW5kIGF2b2lkIGBsYXN0SW5kZXhgIGlzc3VlcyBieSB3b3JraW5nIHdpdGggYSBjb3B5XG4gICAgICAgICAgICAgICAgc2VwYXJhdG9yMiwgbWF0Y2gsIGxhc3RJbmRleCwgbGFzdExlbmd0aDtcbiAgICAgICAgICAgIHZhciBzZXBhcmF0b3JDb3B5ID0gbmV3IFJlZ0V4cChzZXBhcmF0b3Iuc291cmNlLCBmbGFncyArICdnJyk7XG4gICAgICAgICAgICBpZiAoIWNvbXBsaWFudEV4ZWNOcGNnKSB7XG4gICAgICAgICAgICAgICAgLy8gRG9lc24ndCBuZWVkIGZsYWdzIGd5LCBidXQgdGhleSBkb24ndCBodXJ0XG4gICAgICAgICAgICAgICAgc2VwYXJhdG9yMiA9IG5ldyBSZWdFeHAoJ14nICsgc2VwYXJhdG9yQ29weS5zb3VyY2UgKyAnJCg/IVxcXFxzKScsIGZsYWdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIFZhbHVlcyBmb3IgYGxpbWl0YCwgcGVyIHRoZSBzcGVjOlxuICAgICAgICAgICAgICogSWYgdW5kZWZpbmVkOiA0Mjk0OTY3Mjk1IC8vIG1heFNhZmUzMkJpdEludFxuICAgICAgICAgICAgICogSWYgMCwgSW5maW5pdHksIG9yIE5hTjogMFxuICAgICAgICAgICAgICogSWYgcG9zaXRpdmUgbnVtYmVyOiBsaW1pdCA9IE1hdGguZmxvb3IobGltaXQpOyBpZiAobGltaXQgPiA0Mjk0OTY3Mjk1KSBsaW1pdCAtPSA0Mjk0OTY3Mjk2O1xuICAgICAgICAgICAgICogSWYgbmVnYXRpdmUgbnVtYmVyOiA0Mjk0OTY3Mjk2IC0gTWF0aC5mbG9vcihNYXRoLmFicyhsaW1pdCkpXG4gICAgICAgICAgICAgKiBJZiBvdGhlcjogVHlwZS1jb252ZXJ0LCB0aGVuIHVzZSB0aGUgYWJvdmUgcnVsZXNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIHNwbGl0TGltaXQgPSB0eXBlb2YgbGltaXQgPT09ICd1bmRlZmluZWQnID8gbWF4U2FmZTMyQml0SW50IDogRVMuVG9VaW50MzIobGltaXQpO1xuICAgICAgICAgICAgbWF0Y2ggPSBzZXBhcmF0b3JDb3B5LmV4ZWMoc3RyaW5nKTtcbiAgICAgICAgICAgIHdoaWxlIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIC8vIGBzZXBhcmF0b3JDb3B5Lmxhc3RJbmRleGAgaXMgbm90IHJlbGlhYmxlIGNyb3NzLWJyb3dzZXJcbiAgICAgICAgICAgICAgICBsYXN0SW5kZXggPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAobGFzdEluZGV4ID4gbGFzdExhc3RJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBwdXNoKG91dHB1dCwgc3RyU2xpY2Uoc3RyaW5nLCBsYXN0TGFzdEluZGV4LCBtYXRjaC5pbmRleCkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBGaXggYnJvd3NlcnMgd2hvc2UgYGV4ZWNgIG1ldGhvZHMgZG9uJ3QgY29uc2lzdGVudGx5IHJldHVybiBgdW5kZWZpbmVkYCBmb3JcbiAgICAgICAgICAgICAgICAgICAgLy8gbm9ucGFydGljaXBhdGluZyBjYXB0dXJpbmcgZ3JvdXBzXG4gICAgICAgICAgICAgICAgICAgIGlmICghY29tcGxpYW50RXhlY05wY2cgJiYgbWF0Y2gubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tbG9vcC1mdW5jICovXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFswXS5yZXBsYWNlKHNlcGFyYXRvcjIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGggLSAyOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbaV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFtpXSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1sb29wLWZ1bmMgKi9cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2gubGVuZ3RoID4gMSAmJiBtYXRjaC5pbmRleCA8IHN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5X3B1c2guYXBwbHkob3V0cHV0LCBhcnJheVNsaWNlKG1hdGNoLCAxKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGFzdExlbmd0aCA9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgbGFzdExhc3RJbmRleCA9IGxhc3RJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dHB1dC5sZW5ndGggPj0gc3BsaXRMaW1pdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlcGFyYXRvckNvcHkubGFzdEluZGV4ID09PSBtYXRjaC5pbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBzZXBhcmF0b3JDb3B5Lmxhc3RJbmRleCsrOyAvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1hdGNoID0gc2VwYXJhdG9yQ29weS5leGVjKHN0cmluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGFzdExhc3RJbmRleCA9PT0gc3RyaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0TGVuZ3RoIHx8ICFzZXBhcmF0b3JDb3B5LnRlc3QoJycpKSB7XG4gICAgICAgICAgICAgICAgICAgIHB1c2gob3V0cHV0LCAnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwdXNoKG91dHB1dCwgc3RyU2xpY2Uoc3RyaW5nLCBsYXN0TGFzdEluZGV4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0Lmxlbmd0aCA+IHNwbGl0TGltaXQgPyBzdHJTbGljZShvdXRwdXQsIDAsIHNwbGl0TGltaXQpIDogb3V0cHV0O1xuICAgICAgICB9O1xuICAgIH0oKSk7XG5cbi8vIFtidWdmaXgsIGNocm9tZV1cbi8vIElmIHNlcGFyYXRvciBpcyB1bmRlZmluZWQsIHRoZW4gdGhlIHJlc3VsdCBhcnJheSBjb250YWlucyBqdXN0IG9uZSBTdHJpbmcsXG4vLyB3aGljaCBpcyB0aGUgdGhpcyB2YWx1ZSAoY29udmVydGVkIHRvIGEgU3RyaW5nKS4gSWYgbGltaXQgaXMgbm90IHVuZGVmaW5lZCxcbi8vIHRoZW4gdGhlIG91dHB1dCBhcnJheSBpcyB0cnVuY2F0ZWQgc28gdGhhdCBpdCBjb250YWlucyBubyBtb3JlIHRoYW4gbGltaXRcbi8vIGVsZW1lbnRzLlxuLy8gXCIwXCIuc3BsaXQodW5kZWZpbmVkLCAwKSAtPiBbXVxufSBlbHNlIGlmICgnMCcuc3BsaXQodm9pZCAwLCAwKS5sZW5ndGgpIHtcbiAgICBTdHJpbmdQcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiBzcGxpdChzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2VwYXJhdG9yID09PSAndW5kZWZpbmVkJyAmJiBsaW1pdCA9PT0gMCkgeyByZXR1cm4gW107IH1cbiAgICAgICAgcmV0dXJuIHN0clNwbGl0KHRoaXMsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgIH07XG59XG5cbnZhciBzdHJfcmVwbGFjZSA9IFN0cmluZ1Byb3RvdHlwZS5yZXBsYWNlO1xudmFyIHJlcGxhY2VSZXBvcnRzR3JvdXBzQ29ycmVjdGx5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZ3JvdXBzID0gW107XG4gICAgJ3gnLnJlcGxhY2UoL3goLik/L2csIGZ1bmN0aW9uIChtYXRjaCwgZ3JvdXApIHtcbiAgICAgICAgcHVzaChncm91cHMsIGdyb3VwKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZ3JvdXBzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgZ3JvdXBzWzBdID09PSAndW5kZWZpbmVkJztcbn0oKSk7XG5cbmlmICghcmVwbGFjZVJlcG9ydHNHcm91cHNDb3JyZWN0bHkpIHtcbiAgICBTdHJpbmdQcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2Uoc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSkge1xuICAgICAgICB2YXIgaXNGbiA9IGlzQ2FsbGFibGUocmVwbGFjZVZhbHVlKTtcbiAgICAgICAgdmFyIGhhc0NhcHR1cmluZ0dyb3VwcyA9IGlzUmVnZXgoc2VhcmNoVmFsdWUpICYmICgvXFwpWyo/XS8pLnRlc3Qoc2VhcmNoVmFsdWUuc291cmNlKTtcbiAgICAgICAgaWYgKCFpc0ZuIHx8ICFoYXNDYXB0dXJpbmdHcm91cHMpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJfcmVwbGFjZS5jYWxsKHRoaXMsIHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHdyYXBwZWRSZXBsYWNlVmFsdWUgPSBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB2YXIgb3JpZ2luYWxMYXN0SW5kZXggPSBzZWFyY2hWYWx1ZS5sYXN0SW5kZXg7XG4gICAgICAgICAgICAgICAgc2VhcmNoVmFsdWUubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IHNlYXJjaFZhbHVlLmV4ZWMobWF0Y2gpIHx8IFtdO1xuICAgICAgICAgICAgICAgIHNlYXJjaFZhbHVlLmxhc3RJbmRleCA9IG9yaWdpbmFsTGFzdEluZGV4O1xuICAgICAgICAgICAgICAgIHB1c2goYXJncywgYXJndW1lbnRzW2xlbmd0aCAtIDJdLCBhcmd1bWVudHNbbGVuZ3RoIC0gMV0pO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXBsYWNlVmFsdWUuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHN0cl9yZXBsYWNlLmNhbGwodGhpcywgc2VhcmNoVmFsdWUsIHdyYXBwZWRSZXBsYWNlVmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuLy8gRUNNQS0yNjIsIDNyZCBCLjIuM1xuLy8gTm90IGFuIEVDTUFTY3JpcHQgc3RhbmRhcmQsIGFsdGhvdWdoIEVDTUFTY3JpcHQgM3JkIEVkaXRpb24gaGFzIGFcbi8vIG5vbi1ub3JtYXRpdmUgc2VjdGlvbiBzdWdnZXN0aW5nIHVuaWZvcm0gc2VtYW50aWNzIGFuZCBpdCBzaG91bGQgYmVcbi8vIG5vcm1hbGl6ZWQgYWNyb3NzIGFsbCBicm93c2Vyc1xuLy8gW2J1Z2ZpeCwgSUUgbHQgOV0gSUUgPCA5IHN1YnN0cigpIHdpdGggbmVnYXRpdmUgdmFsdWUgbm90IHdvcmtpbmcgaW4gSUVcbnZhciBzdHJpbmdfc3Vic3RyID0gU3RyaW5nUHJvdG90eXBlLnN1YnN0cjtcbnZhciBoYXNOZWdhdGl2ZVN1YnN0ckJ1ZyA9ICcnLnN1YnN0ciAmJiAnMGInLnN1YnN0cigtMSkgIT09ICdiJztcbmRlZmluZVByb3BlcnRpZXMoU3RyaW5nUHJvdG90eXBlLCB7XG4gICAgc3Vic3RyOiBmdW5jdGlvbiBzdWJzdHIoc3RhcnQsIGxlbmd0aCkge1xuICAgICAgICB2YXIgbm9ybWFsaXplZFN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRTdGFydCA9IG1heCh0aGlzLmxlbmd0aCArIHN0YXJ0LCAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyaW5nX3N1YnN0ci5jYWxsKHRoaXMsIG5vcm1hbGl6ZWRTdGFydCwgbGVuZ3RoKTtcbiAgICB9XG59LCBoYXNOZWdhdGl2ZVN1YnN0ckJ1Zyk7XG5cbi8vIEVTNSAxNS41LjQuMjBcbi8vIHdoaXRlc3BhY2UgZnJvbTogaHR0cDovL2VzNS5naXRodWIuaW8vI3gxNS41LjQuMjBcbnZhciB3cyA9ICdcXHgwOVxceDBBXFx4MEJcXHgwQ1xceDBEXFx4MjBcXHhBMFxcdTE2ODBcXHUxODBFXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwMycgK1xuICAgICdcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBBXFx1MjAyRlxcdTIwNUZcXHUzMDAwXFx1MjAyOCcgK1xuICAgICdcXHUyMDI5XFx1RkVGRic7XG52YXIgemVyb1dpZHRoID0gJ1xcdTIwMGInO1xudmFyIHdzUmVnZXhDaGFycyA9ICdbJyArIHdzICsgJ10nO1xudmFyIHRyaW1CZWdpblJlZ2V4cCA9IG5ldyBSZWdFeHAoJ14nICsgd3NSZWdleENoYXJzICsgd3NSZWdleENoYXJzICsgJyonKTtcbnZhciB0cmltRW5kUmVnZXhwID0gbmV3IFJlZ0V4cCh3c1JlZ2V4Q2hhcnMgKyB3c1JlZ2V4Q2hhcnMgKyAnKiQnKTtcbnZhciBoYXNUcmltV2hpdGVzcGFjZUJ1ZyA9IFN0cmluZ1Byb3RvdHlwZS50cmltICYmICh3cy50cmltKCkgfHwgIXplcm9XaWR0aC50cmltKCkpO1xuZGVmaW5lUHJvcGVydGllcyhTdHJpbmdQcm90b3R5cGUsIHtcbiAgICAvLyBodHRwOi8vYmxvZy5zdGV2ZW5sZXZpdGhhbi5jb20vYXJjaGl2ZXMvZmFzdGVyLXRyaW0tamF2YXNjcmlwdFxuICAgIC8vIGh0dHA6Ly9wZXJmZWN0aW9ua2lsbHMuY29tL3doaXRlc3BhY2UtZGV2aWF0aW9ucy9cbiAgICB0cmltOiBmdW5jdGlvbiB0cmltKCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMgPT09ICd1bmRlZmluZWQnIHx8IHRoaXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjYW4ndCBjb252ZXJ0IFwiICsgdGhpcyArICcgdG8gb2JqZWN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICRTdHJpbmcodGhpcykucmVwbGFjZSh0cmltQmVnaW5SZWdleHAsICcnKS5yZXBsYWNlKHRyaW1FbmRSZWdleHAsICcnKTtcbiAgICB9XG59LCBoYXNUcmltV2hpdGVzcGFjZUJ1Zyk7XG5cbnZhciBoYXNMYXN0SW5kZXhCdWcgPSBTdHJpbmdQcm90b3R5cGUubGFzdEluZGV4T2YgJiYgJ2FiY+OBguOBhCcubGFzdEluZGV4T2YoJ+OBguOBhCcsIDIpICE9PSAtMTtcbmRlZmluZVByb3BlcnRpZXMoU3RyaW5nUHJvdG90eXBlLCB7XG4gICAgbGFzdEluZGV4T2Y6IGZ1bmN0aW9uIGxhc3RJbmRleE9mKHNlYXJjaFN0cmluZykge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMgPT09ICd1bmRlZmluZWQnIHx8IHRoaXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjYW4ndCBjb252ZXJ0IFwiICsgdGhpcyArICcgdG8gb2JqZWN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIFMgPSAkU3RyaW5nKHRoaXMpO1xuICAgICAgICB2YXIgc2VhcmNoU3RyID0gJFN0cmluZyhzZWFyY2hTdHJpbmcpO1xuICAgICAgICB2YXIgbnVtUG9zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyAkTnVtYmVyKGFyZ3VtZW50c1sxXSkgOiBOYU47XG4gICAgICAgIHZhciBwb3MgPSBpc0FjdHVhbE5hTihudW1Qb3MpID8gSW5maW5pdHkgOiBFUy5Ub0ludGVnZXIobnVtUG9zKTtcbiAgICAgICAgdmFyIHN0YXJ0ID0gbWluKG1heChwb3MsIDApLCBTLmxlbmd0aCk7XG4gICAgICAgIHZhciBzZWFyY2hMZW4gPSBzZWFyY2hTdHIubGVuZ3RoO1xuICAgICAgICB2YXIgayA9IHN0YXJ0ICsgc2VhcmNoTGVuO1xuICAgICAgICB3aGlsZSAoayA+IDApIHtcbiAgICAgICAgICAgIGsgPSBtYXgoMCwgayAtIHNlYXJjaExlbik7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBzdHJJbmRleE9mKHN0clNsaWNlKFMsIGssIHN0YXJ0ICsgc2VhcmNoTGVuKSwgc2VhcmNoU3RyKTtcbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gayArIGluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG59LCBoYXNMYXN0SW5kZXhCdWcpO1xuXG52YXIgb3JpZ2luYWxMYXN0SW5kZXhPZiA9IFN0cmluZ1Byb3RvdHlwZS5sYXN0SW5kZXhPZjtcbmRlZmluZVByb3BlcnRpZXMoU3RyaW5nUHJvdG90eXBlLCB7XG4gICAgbGFzdEluZGV4T2Y6IGZ1bmN0aW9uIGxhc3RJbmRleE9mKHNlYXJjaFN0cmluZykge1xuICAgICAgICByZXR1cm4gb3JpZ2luYWxMYXN0SW5kZXhPZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbn0sIFN0cmluZ1Byb3RvdHlwZS5sYXN0SW5kZXhPZi5sZW5ndGggIT09IDEpO1xuXG4vLyBFUy01IDE1LjEuMi4yXG4vKiBlc2xpbnQtZGlzYWJsZSByYWRpeCAqL1xuaWYgKHBhcnNlSW50KHdzICsgJzA4JykgIT09IDggfHwgcGFyc2VJbnQod3MgKyAnMHgxNicpICE9PSAyMikge1xuLyogZXNsaW50LWVuYWJsZSByYWRpeCAqL1xuICAgIC8qIGdsb2JhbCBwYXJzZUludDogdHJ1ZSAqL1xuICAgIHBhcnNlSW50ID0gKGZ1bmN0aW9uIChvcmlnUGFyc2VJbnQpIHtcbiAgICAgICAgdmFyIGhleFJlZ2V4ID0gL15bXFwtK10/MFt4WF0vO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gcGFyc2VJbnQoc3RyLCByYWRpeCkge1xuICAgICAgICAgICAgdmFyIHN0cmluZyA9ICRTdHJpbmcoc3RyKS50cmltKCk7XG4gICAgICAgICAgICB2YXIgZGVmYXVsdGVkUmFkaXggPSAkTnVtYmVyKHJhZGl4KSB8fCAoaGV4UmVnZXgudGVzdChzdHJpbmcpID8gMTYgOiAxMCk7XG4gICAgICAgICAgICByZXR1cm4gb3JpZ1BhcnNlSW50KHN0cmluZywgZGVmYXVsdGVkUmFkaXgpO1xuICAgICAgICB9O1xuICAgIH0ocGFyc2VJbnQpKTtcbn1cblxuaWYgKFN0cmluZyhuZXcgUmFuZ2VFcnJvcigndGVzdCcpKSAhPT0gJ1JhbmdlRXJyb3I6IHRlc3QnKSB7XG4gICAgdmFyIGVycm9yVG9TdHJpbmdTaGltID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcyA9PT0gJ3VuZGVmaW5lZCcgfHwgdGhpcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbid0IGNvbnZlcnQgXCIgKyB0aGlzICsgJyB0byBvYmplY3QnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmFtZSA9IHRoaXMubmFtZTtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgbmFtZSA9ICdFcnJvcic7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBuYW1lID0gJFN0cmluZyhuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbXNnID0gdGhpcy5tZXNzYWdlO1xuICAgICAgICBpZiAodHlwZW9mIG1zZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIG1zZyA9ICcnO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBtc2cgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBtc2cgPSAkU3RyaW5nKG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gbXNnO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbXNnKSB7XG4gICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmFtZSArICc6ICcgKyBtc2c7XG4gICAgfTtcbiAgICAvLyBjYW4ndCB1c2UgZGVmaW5lUHJvcGVydGllcyBoZXJlIGJlY2F1c2Ugb2YgdG9TdHJpbmcgZW51bWVyYXRpb24gaXNzdWUgaW4gSUUgPD0gOFxuICAgIEVycm9yLnByb3RvdHlwZS50b1N0cmluZyA9IGVycm9yVG9TdHJpbmdTaGltO1xufVxuXG5pZiAoc3VwcG9ydHNEZXNjcmlwdG9ycykge1xuICAgIHZhciBlbnN1cmVOb25FbnVtZXJhYmxlID0gZnVuY3Rpb24gKG9iaiwgcHJvcCkge1xuICAgICAgICBpZiAoaXNFbnVtKG9iaiwgcHJvcCkpIHtcbiAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIHByb3ApO1xuICAgICAgICAgICAgZGVzYy5lbnVtZXJhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wLCBkZXNjKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZW5zdXJlTm9uRW51bWVyYWJsZShFcnJvci5wcm90b3R5cGUsICdtZXNzYWdlJyk7XG4gICAgaWYgKEVycm9yLnByb3RvdHlwZS5tZXNzYWdlICE9PSAnJykge1xuICAgICAgRXJyb3IucHJvdG90eXBlLm1lc3NhZ2UgPSAnJztcbiAgICB9XG4gICAgZW5zdXJlTm9uRW51bWVyYWJsZShFcnJvci5wcm90b3R5cGUsICduYW1lJyk7XG59XG5cbmlmIChTdHJpbmcoL2EvbWlnKSAhPT0gJy9hL2dpbScpIHtcbiAgICB2YXIgcmVnZXhUb1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICB2YXIgc3RyID0gJy8nICsgdGhpcy5zb3VyY2UgKyAnLyc7XG4gICAgICAgIGlmICh0aGlzLmdsb2JhbCkge1xuICAgICAgICAgICAgc3RyICs9ICdnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pZ25vcmVDYXNlKSB7XG4gICAgICAgICAgICBzdHIgKz0gJ2knO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm11bHRpbGluZSkge1xuICAgICAgICAgICAgc3RyICs9ICdtJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH07XG4gICAgLy8gY2FuJ3QgdXNlIGRlZmluZVByb3BlcnRpZXMgaGVyZSBiZWNhdXNlIG9mIHRvU3RyaW5nIGVudW1lcmF0aW9uIGlzc3VlIGluIElFIDw9IDhcbiAgICBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nID0gcmVnZXhUb1N0cmluZztcbn1cblxufSkpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZXM1LXNoaW0vZXM1LXNoaW0uanNcbiAqKiBtb2R1bGUgaWQgPSA1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiLypcXG4gKiBTdXBwb3J0IGZvciBzb3VyY2UgbWFwcyBpbiBWOCBzdGFjayB0cmFjZXNcXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZXZhbncvbm9kZS1zb3VyY2UtbWFwLXN1cHBvcnRcXG4gKi9cXG4odGhpcy5kZWZpbmV8fGZ1bmN0aW9uKEssTil7dGhpcy5zb3VyY2VNYXBTdXBwb3J0PU4oKX0pKFxcXCJicm93c2VyLXNvdXJjZS1tYXAtc3VwcG9ydFxcXCIsZnVuY3Rpb24oSyl7KGZ1bmN0aW9uIG4odyx0LGUpe2Z1bmN0aW9uIHIoZyxiKXtpZighdFtnXSl7aWYoIXdbZ10pe3ZhciBmPVxcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFiJiZmKXJldHVybiBmKGcsITApO2lmKGwpcmV0dXJuIGwoZywhMCk7dGhyb3cgRXJyb3IoXFxcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXFxcIitnK1xcXCInXFxcIik7fWY9dFtnXT17ZXhwb3J0czp7fX07d1tnXVswXS5jYWxsKGYuZXhwb3J0cyxmdW5jdGlvbihiKXt2YXIgYT13W2ddWzFdW2JdO3JldHVybiByKGE/YTpiKX0sZixmLmV4cG9ydHMsbix3LHQsZSl9cmV0dXJuIHRbZ10uZXhwb3J0c31mb3IodmFyIGw9XFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsbT0wO208ZS5sZW5ndGg7bSsrKXIoZVttXSk7cmV0dXJuIHJ9KSh7MTpbZnVuY3Rpb24obixcXG53LHQpe0s9bihcXFwiLi9zb3VyY2UtbWFwLXN1cHBvcnRcXFwiKX0se1xcXCIuL3NvdXJjZS1tYXAtc3VwcG9ydFxcXCI6MTh9XSwyOltmdW5jdGlvbihuLHcsdCl7KGZ1bmN0aW9uKGUscil7dy5leHBvcnRzPWZ1bmN0aW9uKGwsbSl7ZnVuY3Rpb24gZyhjLGQpe3ZhciBhO2lmKGMmJlxcXCIuXFxcIj09PWMuY2hhckF0KDApJiZkKXthPWQuc3BsaXQoXFxcIi9cXFwiKTthPWEuc2xpY2UoMCxhLmxlbmd0aC0xKTt2YXIgYj1hPWEuY29uY2F0KGMuc3BsaXQoXFxcIi9cXFwiKSksZixrO2ZvcihmPTA7YltmXTtmKz0xKWlmKGs9YltmXSxcXFwiLlxcXCI9PT1rKWIuc3BsaWNlKGYsMSksLS1mO2Vsc2UgaWYoXFxcIi4uXFxcIj09PWspaWYoMSE9PWZ8fFxcXCIuLlxcXCIhPT1iWzJdJiZcXFwiLi5cXFwiIT09YlswXSkwPGYmJihiLnNwbGljZShmLTEsMiksZi09Mik7ZWxzZSBicmVhaztjPWEuam9pbihcXFwiL1xcXCIpfXJldHVybiBjfWZ1bmN0aW9uIGIoYyl7cmV0dXJuIGZ1bmN0aW9uKGEpe3JldHVybiBnKGEsYyl9fWZ1bmN0aW9uIGYoYyl7ZnVuY3Rpb24gYShiKXtkW2NdPWJ9YS5mcm9tVGV4dD1cXG5mdW5jdGlvbihjLGEpe3Rocm93IEVycm9yKFxcXCJhbWRlZmluZSBkb2VzIG5vdCBpbXBsZW1lbnQgbG9hZC5mcm9tVGV4dFxcXCIpO307cmV0dXJuIGF9ZnVuY3Rpb24gayhjLGEsYil7dmFyIGYsayxnO2lmKGMpaz1kW2NdPXt9LGc9e2lkOmMsdXJpOnIsZXhwb3J0czprfSxmPUEobSxrLGcsYyk7ZWxzZXtpZih5KXRocm93IEVycm9yKFxcXCJhbWRlZmluZSB3aXRoIG5vIG1vZHVsZSBJRCBjYW5ub3QgYmUgY2FsbGVkIG1vcmUgdGhhbiBvbmNlIHBlciBmaWxlLlxcXCIpO3k9ITA7az1sLmV4cG9ydHM7Zz1sO2Y9QShtLGssZyxsLmlkKX1hJiYoYT1hLm1hcChmdW5jdGlvbihjKXtyZXR1cm4gZihjKX0pKTthPVxcXCJmdW5jdGlvblxcXCI9PT10eXBlb2YgYj9iLmFwcGx5KGcuZXhwb3J0cyxhKTpiO3ZvaWQgMCE9PWEmJihnLmV4cG9ydHM9YSxjJiYoZFtjXT1nLmV4cG9ydHMpKX1mdW5jdGlvbiBhKGEsZCxiKXtBcnJheS5pc0FycmF5KGEpPyhiPWQsZD1hLGE9dm9pZCAwKTpcXFwic3RyaW5nXFxcIiE9PXR5cGVvZiBhJiZcXG4oYj1hLGE9ZD12b2lkIDApO2QmJiFBcnJheS5pc0FycmF5KGQpJiYoYj1kLGQ9dm9pZCAwKTtkfHwoZD1bXFxcInJlcXVpcmVcXFwiLFxcXCJleHBvcnRzXFxcIixcXFwibW9kdWxlXFxcIl0pO2E/Y1thXT1bYSxkLGJdOmsoYSxkLGIpfXZhciBjPXt9LGQ9e30seT0hMSx4PW4oXFxcInBhdGhcXFwiKSxBLEI7QT1mdW5jdGlvbihjLGEsZCxiKXtmdW5jdGlvbiBmKGssZyl7aWYoXFxcInN0cmluZ1xcXCI9PT10eXBlb2YgaylyZXR1cm4gQihjLGEsZCxrLGIpO2s9ay5tYXAoZnVuY3Rpb24oZil7cmV0dXJuIEIoYyxhLGQsZixiKX0pO2cmJmUubmV4dFRpY2soZnVuY3Rpb24oKXtnLmFwcGx5KG51bGwsayl9KX1mLnRvVXJsPWZ1bmN0aW9uKGMpe3JldHVybiAwPT09Yy5pbmRleE9mKFxcXCIuXFxcIik/ZyhjLHguZGlybmFtZShkLmZpbGVuYW1lKSk6Y307cmV0dXJuIGZ9O209bXx8ZnVuY3Rpb24oKXtyZXR1cm4gbC5yZXF1aXJlLmFwcGx5KGwsYXJndW1lbnRzKX07Qj1mdW5jdGlvbihhLGUseSxtLHgpe3ZhciBsPW0uaW5kZXhPZihcXFwiIVxcXCIpLHI9bTtcXG5pZigtMT09PWwpe209ZyhtLHgpO2lmKFxcXCJyZXF1aXJlXFxcIj09PW0pcmV0dXJuIEEoYSxlLHkseCk7aWYoXFxcImV4cG9ydHNcXFwiPT09bSlyZXR1cm4gZTtpZihcXFwibW9kdWxlXFxcIj09PW0pcmV0dXJuIHk7aWYoZC5oYXNPd25Qcm9wZXJ0eShtKSlyZXR1cm4gZFttXTtpZihjW21dKXJldHVybiBrLmFwcGx5KG51bGwsY1ttXSksZFttXTtpZihhKXJldHVybiBhKHIpO3Rocm93IEVycm9yKFxcXCJObyBtb2R1bGUgd2l0aCBJRDogXFxcIittKTt9cj1tLnN1YnN0cmluZygwLGwpO209bS5zdWJzdHJpbmcobCsxLG0ubGVuZ3RoKTtsPUIoYSxlLHkscix4KTttPWwubm9ybWFsaXplP2wubm9ybWFsaXplKG0sYih4KSk6ZyhtLHgpO2RbbV18fGwubG9hZChtLEEoYSxlLHkseCksZihtKSx7fSk7cmV0dXJuIGRbbV19O2EucmVxdWlyZT1mdW5jdGlvbihhKXtpZihkW2FdKXJldHVybiBkW2FdO2lmKGNbYV0pcmV0dXJuIGsuYXBwbHkobnVsbCxjW2FdKSxkW2FdfTthLmFtZD17fTtyZXR1cm4gYX19KS5jYWxsKHRoaXMsbihcXFwibm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1xcXCIpLFxcblxcXCIvbm9kZV9tb2R1bGVzL2FtZGVmaW5lL2FtZGVmaW5lLmpzXFxcIil9LHtcXFwibm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1xcXCI6OCxwYXRoOjd9XSwzOltmdW5jdGlvbihuLHcsdCl7KGZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHIoZSl7ZT1lLmNoYXJDb2RlQXQoMCk7aWYoNDM9PT1lfHw0NT09PWUpcmV0dXJuIDYyO2lmKDQ3PT09ZXx8OTU9PT1lKXJldHVybiA2MztpZig0OD5lKXJldHVybi0xO2lmKDU4PmUpcmV0dXJuIGUtNDgrNTI7aWYoOTE+ZSlyZXR1cm4gZS02NTtpZigxMjM+ZSlyZXR1cm4gZS05NysyNn12YXIgbD1cXFwidW5kZWZpbmVkXFxcIiE9PXR5cGVvZiBVaW50OEFycmF5P1VpbnQ4QXJyYXk6QXJyYXk7ZS50b0J5dGVBcnJheT1mdW5jdGlvbihlKXtmdW5jdGlvbiBnKGEpe2NbZCsrXT1hfXZhciBiLGYsayxhLGM7aWYoMDxlLmxlbmd0aCU0KXRocm93IEVycm9yKFxcXCJJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0XFxcIik7Yj1lLmxlbmd0aDthPVxcXCI9XFxcIj09PVxcbmUuY2hhckF0KGItMik/MjpcXFwiPVxcXCI9PT1lLmNoYXJBdChiLTEpPzE6MDtjPW5ldyBsKDMqZS5sZW5ndGgvNC1hKTtmPTA8YT9lLmxlbmd0aC00OmUubGVuZ3RoO3ZhciBkPTA7Zm9yKGI9MDtiPGY7Yis9NClrPXIoZS5jaGFyQXQoYikpPDwxOHxyKGUuY2hhckF0KGIrMSkpPDwxMnxyKGUuY2hhckF0KGIrMikpPDw2fHIoZS5jaGFyQXQoYiszKSksZygoayYxNjcxMTY4MCk+PjE2KSxnKChrJjY1MjgwKT4+OCksZyhrJjI1NSk7Mj09PWE/KGs9cihlLmNoYXJBdChiKSk8PDJ8cihlLmNoYXJBdChiKzEpKT4+NCxnKGsmMjU1KSk6MT09PWEmJihrPXIoZS5jaGFyQXQoYikpPDwxMHxyKGUuY2hhckF0KGIrMSkpPDw0fHIoZS5jaGFyQXQoYisyKSk+PjIsZyhrPj44JjI1NSksZyhrJjI1NSkpO3JldHVybiBjfTtlLmZyb21CeXRlQXJyYXk9ZnVuY3Rpb24oZSl7dmFyIGcsYj1lLmxlbmd0aCUzLGY9XFxcIlxcXCIsayxhO2c9MDtmb3IoYT1lLmxlbmd0aC1iO2c8YTtnKz0zKWs9KGVbZ108PDE2KSsoZVtnK1xcbjFdPDw4KStlW2crMl0saz1cXFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1xcXCIuY2hhckF0KGs+PjE4JjYzKStcXFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1xcXCIuY2hhckF0KGs+PjEyJjYzKStcXFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1xcXCIuY2hhckF0KGs+PjYmNjMpK1xcXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXFxcIi5jaGFyQXQoayY2MyksZis9aztzd2l0Y2goYil7Y2FzZSAxOms9ZVtlLmxlbmd0aC0xXTtmKz1cXFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1xcXCIuY2hhckF0KGs+PjIpO2YrPVxcXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXFxcIi5jaGFyQXQoazw8XFxuNCY2Myk7Zis9XFxcIj09XFxcIjticmVhaztjYXNlIDI6az0oZVtlLmxlbmd0aC0yXTw8OCkrZVtlLmxlbmd0aC0xXSxmKz1cXFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1xcXCIuY2hhckF0KGs+PjEwKSxmKz1cXFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1xcXCIuY2hhckF0KGs+PjQmNjMpLGYrPVxcXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXFxcIi5jaGFyQXQoazw8MiY2MyksZis9XFxcIj1cXFwifXJldHVybiBmfX0pKFxcXCJ1bmRlZmluZWRcXFwiPT09dHlwZW9mIHQ/dGhpcy5iYXNlNjRqcz17fTp0KX0se31dLDQ6W2Z1bmN0aW9uKG4sdyx0KXt9LHt9XSw1OltmdW5jdGlvbihuLHcsdCl7ZnVuY3Rpb24gZShoLHEsYyl7aWYoISh0aGlzIGluc3RhbmNlb2YgZSkpcmV0dXJuIG5ldyBlKGgscSxjKTt2YXIgYT10eXBlb2YgaDtcXG5pZihcXFwiYmFzZTY0XFxcIj09PXEmJlxcXCJzdHJpbmdcXFwiPT09YSlmb3IoaD1oLnRyaW0/aC50cmltKCk6aC5yZXBsYWNlKC9eXFxcXHMrfFxcXFxzKyQvZyxcXFwiXFxcIik7MCE9PWgubGVuZ3RoJTQ7KWgrPVxcXCI9XFxcIjt2YXIgZDtpZihcXFwibnVtYmVyXFxcIj09PWEpZD1GKGgpO2Vsc2UgaWYoXFxcInN0cmluZ1xcXCI9PT1hKWQ9ZS5ieXRlTGVuZ3RoKGgscSk7ZWxzZSBpZihcXFwib2JqZWN0XFxcIj09PWEpZD1GKGgubGVuZ3RoKTtlbHNlIHRocm93IEVycm9yKFxcXCJGaXJzdCBhcmd1bWVudCBuZWVkcyB0byBiZSBhIG51bWJlciwgYXJyYXkgb3Igc3RyaW5nLlxcXCIpO3ZhciBiO2UuX3VzZVR5cGVkQXJyYXlzP2I9ZS5fYXVnbWVudChuZXcgVWludDhBcnJheShkKSk6KGI9dGhpcyxiLmxlbmd0aD1kLGIuX2lzQnVmZmVyPSEwKTtpZihlLl91c2VUeXBlZEFycmF5cyYmXFxcIm51bWJlclxcXCI9PT10eXBlb2YgaC5ieXRlTGVuZ3RoKWIuX3NldChoKTtlbHNle3ZhciBmPWg7aWYoRShmKXx8ZS5pc0J1ZmZlcihmKXx8ZiYmXFxcIm9iamVjdFxcXCI9PT10eXBlb2YgZiYmXFxcIm51bWJlclxcXCI9PT1cXG50eXBlb2YgZi5sZW5ndGgpZm9yKHE9MDtxPGQ7cSsrKWUuaXNCdWZmZXIoaCk/YltxXT1oLnJlYWRVSW50OChxKTpiW3FdPWhbcV07ZWxzZSBpZihcXFwic3RyaW5nXFxcIj09PWEpYi53cml0ZShoLDAscSk7ZWxzZSBpZihcXFwibnVtYmVyXFxcIj09PWEmJiFlLl91c2VUeXBlZEFycmF5cyYmIWMpZm9yKHE9MDtxPGQ7cSsrKWJbcV09MH1yZXR1cm4gYn1mdW5jdGlvbiByKGgscSxjKXt2YXIgYT1cXFwiXFxcIjtmb3IoYz1NYXRoLm1pbihoLmxlbmd0aCxjKTtxPGM7cSsrKWErPVN0cmluZy5mcm9tQ2hhckNvZGUoaFtxXSk7cmV0dXJuIGF9ZnVuY3Rpb24gbChoLHEsYyxhKXthfHwocChcXFwiYm9vbGVhblxcXCI9PT10eXBlb2YgYyxcXFwibWlzc2luZyBvciBpbnZhbGlkIGVuZGlhblxcXCIpLHAodm9pZCAwIT09cSYmbnVsbCE9PXEsXFxcIm1pc3Npbmcgb2Zmc2V0XFxcIikscChxKzE8aC5sZW5ndGgsXFxcIlRyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoXFxcIikpO2E9aC5sZW5ndGg7aWYoIShxPj1hKSlyZXR1cm4gYz8oYz1oW3FdLHErXFxuMTxhJiYoY3w9aFtxKzFdPDw4KSk6KGM9aFtxXTw8OCxxKzE8YSYmKGN8PWhbcSsxXSkpLGN9ZnVuY3Rpb24gbShoLHEsYyxhKXthfHwocChcXFwiYm9vbGVhblxcXCI9PT10eXBlb2YgYyxcXFwibWlzc2luZyBvciBpbnZhbGlkIGVuZGlhblxcXCIpLHAodm9pZCAwIT09cSYmbnVsbCE9PXEsXFxcIm1pc3Npbmcgb2Zmc2V0XFxcIikscChxKzM8aC5sZW5ndGgsXFxcIlRyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoXFxcIikpO2E9aC5sZW5ndGg7aWYoIShxPj1hKSl7dmFyIGQ7Yz8ocSsyPGEmJihkPWhbcSsyXTw8MTYpLHErMTxhJiYoZHw9aFtxKzFdPDw4KSxkfD1oW3FdLHErMzxhJiYoZCs9aFtxKzNdPDwyND4+PjApKToocSsxPGEmJihkPWhbcSsxXTw8MTYpLHErMjxhJiYoZHw9aFtxKzJdPDw4KSxxKzM8YSYmKGR8PWhbcSszXSksZCs9aFtxXTw8MjQ+Pj4wKTtyZXR1cm4gZH19ZnVuY3Rpb24gZyhoLHEsYSxjKXtjfHwocChcXFwiYm9vbGVhblxcXCI9PT10eXBlb2YgYSxcXFwibWlzc2luZyBvciBpbnZhbGlkIGVuZGlhblxcXCIpLFxcbnAodm9pZCAwIT09cSYmbnVsbCE9PXEsXFxcIm1pc3Npbmcgb2Zmc2V0XFxcIikscChxKzE8aC5sZW5ndGgsXFxcIlRyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoXFxcIikpO2lmKCEocT49aC5sZW5ndGgpKXJldHVybiBoPWwoaCxxLGEsITApLGgmMzI3Njg/LTEqKDY1NTM1LWgrMSk6aH1mdW5jdGlvbiBiKGgscSxhLGMpe2N8fChwKFxcXCJib29sZWFuXFxcIj09PXR5cGVvZiBhLFxcXCJtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuXFxcIikscCh2b2lkIDAhPT1xJiZudWxsIT09cSxcXFwibWlzc2luZyBvZmZzZXRcXFwiKSxwKHErMzxoLmxlbmd0aCxcXFwiVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGhcXFwiKSk7aWYoIShxPj1oLmxlbmd0aCkpcmV0dXJuIGg9bShoLHEsYSwhMCksaCYyMTQ3NDgzNjQ4Py0xKig0Mjk0OTY3Mjk1LWgrMSk6aH1mdW5jdGlvbiBmKGgscSxhLGMpe2N8fChwKFxcXCJib29sZWFuXFxcIj09PXR5cGVvZiBhLFxcXCJtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuXFxcIikscChxKzM8aC5sZW5ndGgsXFxcIlRyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoXFxcIikpO1xcbnJldHVybiBJLnJlYWQoaCxxLGEsMjMsNCl9ZnVuY3Rpb24gayhoLHEsYSxjKXtjfHwocChcXFwiYm9vbGVhblxcXCI9PT10eXBlb2YgYSxcXFwibWlzc2luZyBvciBpbnZhbGlkIGVuZGlhblxcXCIpLHAocSs3PGgubGVuZ3RoLFxcXCJUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aFxcXCIpKTtyZXR1cm4gSS5yZWFkKGgscSxhLDUyLDgpfWZ1bmN0aW9uIGEoaCxhLGMsZCxiKXtifHwocCh2b2lkIDAhPT1hJiZudWxsIT09YSxcXFwibWlzc2luZyB2YWx1ZVxcXCIpLHAoXFxcImJvb2xlYW5cXFwiPT09dHlwZW9mIGQsXFxcIm1pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW5cXFwiKSxwKHZvaWQgMCE9PWMmJm51bGwhPT1jLFxcXCJtaXNzaW5nIG9mZnNldFxcXCIpLHAoYysxPGgubGVuZ3RoLFxcXCJ0cnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGhcXFwiKSxIKGEsNjU1MzUpKTt2YXIgZj1oLmxlbmd0aDtpZighKGM+PWYpKWZvcihiPTAsZj1NYXRoLm1pbihmLWMsMik7YjxmO2IrKyloW2MrYl09KGEmMjU1PDw4KihkP2I6MS1iKSk+Pj44KlxcbihkP2I6MS1iKX1mdW5jdGlvbiBjKGgsYSxjLGQsYil7Ynx8KHAodm9pZCAwIT09YSYmbnVsbCE9PWEsXFxcIm1pc3NpbmcgdmFsdWVcXFwiKSxwKFxcXCJib29sZWFuXFxcIj09PXR5cGVvZiBkLFxcXCJtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuXFxcIikscCh2b2lkIDAhPT1jJiZudWxsIT09YyxcXFwibWlzc2luZyBvZmZzZXRcXFwiKSxwKGMrMzxoLmxlbmd0aCxcXFwidHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoXFxcIiksSChhLDQyOTQ5NjcyOTUpKTt2YXIgZj1oLmxlbmd0aDtpZighKGM+PWYpKWZvcihiPTAsZj1NYXRoLm1pbihmLWMsNCk7YjxmO2IrKyloW2MrYl09YT4+PjgqKGQ/YjozLWIpJjI1NX1mdW5jdGlvbiBkKGgsYyxkLGIsZil7Znx8KHAodm9pZCAwIT09YyYmbnVsbCE9PWMsXFxcIm1pc3NpbmcgdmFsdWVcXFwiKSxwKFxcXCJib29sZWFuXFxcIj09PXR5cGVvZiBiLFxcXCJtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuXFxcIikscCh2b2lkIDAhPT1kJiZudWxsIT09ZCxcXFwibWlzc2luZyBvZmZzZXRcXFwiKSxwKGQrMTxoLmxlbmd0aCxcXG5cXFwiVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoXFxcIiksTChjLDMyNzY3LC0zMjc2OCkpO2Q+PWgubGVuZ3RofHwoMDw9Yz9hKGgsYyxkLGIsZik6YShoLDY1NTM1K2MrMSxkLGIsZikpfWZ1bmN0aW9uIHkoaCxhLGQsYixmKXtmfHwocCh2b2lkIDAhPT1hJiZudWxsIT09YSxcXFwibWlzc2luZyB2YWx1ZVxcXCIpLHAoXFxcImJvb2xlYW5cXFwiPT09dHlwZW9mIGIsXFxcIm1pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW5cXFwiKSxwKHZvaWQgMCE9PWQmJm51bGwhPT1kLFxcXCJtaXNzaW5nIG9mZnNldFxcXCIpLHAoZCszPGgubGVuZ3RoLFxcXCJUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGhcXFwiKSxMKGEsMjE0NzQ4MzY0NywtMjE0NzQ4MzY0OCkpO2Q+PWgubGVuZ3RofHwoMDw9YT9jKGgsYSxkLGIsZik6YyhoLDQyOTQ5NjcyOTUrYSsxLGQsYixmKSl9ZnVuY3Rpb24geChoLGEsYyxkLGIpe2J8fChwKHZvaWQgMCE9PWEmJm51bGwhPT1hLFxcXCJtaXNzaW5nIHZhbHVlXFxcIikscChcXFwiYm9vbGVhblxcXCI9PT10eXBlb2YgZCxcXG5cXFwibWlzc2luZyBvciBpbnZhbGlkIGVuZGlhblxcXCIpLHAodm9pZCAwIT09YyYmbnVsbCE9PWMsXFxcIm1pc3Npbmcgb2Zmc2V0XFxcIikscChjKzM8aC5sZW5ndGgsXFxcIlRyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aFxcXCIpLE0oYSwzLjQwMjgyMzQ2NjM4NTI4ODZFMzgsLTMuNDAyODIzNDY2Mzg1Mjg4NkUzOCkpO2M+PWgubGVuZ3RofHxJLndyaXRlKGgsYSxjLGQsMjMsNCl9ZnVuY3Rpb24gQShoLGMsYSxkLGIpe2J8fChwKHZvaWQgMCE9PWMmJm51bGwhPT1jLFxcXCJtaXNzaW5nIHZhbHVlXFxcIikscChcXFwiYm9vbGVhblxcXCI9PT10eXBlb2YgZCxcXFwibWlzc2luZyBvciBpbnZhbGlkIGVuZGlhblxcXCIpLHAodm9pZCAwIT09YSYmbnVsbCE9PWEsXFxcIm1pc3Npbmcgb2Zmc2V0XFxcIikscChhKzc8aC5sZW5ndGgsXFxcIlRyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aFxcXCIpLE0oYywxLjc5NzY5MzEzNDg2MjMxNTdFMzA4LC0xLjc5NzY5MzEzNDg2MjMxNTdFMzA4KSk7YT49aC5sZW5ndGh8fEkud3JpdGUoaCxcXG5jLGEsZCw1Miw4KX1mdW5jdGlvbiBCKGgsYSxjKXtpZihcXFwibnVtYmVyXFxcIiE9PXR5cGVvZiBoKXJldHVybiBjO2g9fn5oO2lmKGg+PWEpcmV0dXJuIGE7aWYoMDw9aClyZXR1cm4gaDtoKz1hO3JldHVybiAwPD1oP2g6MH1mdW5jdGlvbiBGKGgpe2g9fn5NYXRoLmNlaWwoK2gpO3JldHVybiAwPmg/MDpofWZ1bmN0aW9uIEUoaCl7cmV0dXJuKEFycmF5LmlzQXJyYXl8fGZ1bmN0aW9uKGgpe3JldHVyblxcXCJbb2JqZWN0IEFycmF5XVxcXCI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaCl9KShoKX1mdW5jdGlvbiBHKGgpe3JldHVybiAxNj5oP1xcXCIwXFxcIitoLnRvU3RyaW5nKDE2KTpoLnRvU3RyaW5nKDE2KX1mdW5jdGlvbiB1KGgpe2Zvcih2YXIgYT1bXSxjPTA7YzxoLmxlbmd0aDtjKyspe3ZhciBkPWguY2hhckNvZGVBdChjKTtpZigxMjc+PWQpYS5wdXNoKGguY2hhckNvZGVBdChjKSk7ZWxzZXt2YXIgYj1jOzU1Mjk2PD1kJiY1NzM0Mz49ZCYmYysrO2Q9ZW5jb2RlVVJJQ29tcG9uZW50KGguc2xpY2UoYixcXG5jKzEpKS5zdWJzdHIoMSkuc3BsaXQoXFxcIiVcXFwiKTtmb3IoYj0wO2I8ZC5sZW5ndGg7YisrKWEucHVzaChwYXJzZUludChkW2JdLDE2KSl9fXJldHVybiBhfWZ1bmN0aW9uIEMoaCl7Zm9yKHZhciBjPVtdLGE9MDthPGgubGVuZ3RoO2ErKyljLnB1c2goaC5jaGFyQ29kZUF0KGEpJjI1NSk7cmV0dXJuIGN9ZnVuY3Rpb24geihoLGMsYSxkKXtmb3IodmFyIGI9MDtiPGQmJiEoYithPj1jLmxlbmd0aHx8Yj49aC5sZW5ndGgpO2IrKyljW2IrYV09aFtiXTtyZXR1cm4gYn1mdW5jdGlvbiBEKGgpe3RyeXtyZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGgpfWNhdGNoKGMpe3JldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKDY1NTMzKX19ZnVuY3Rpb24gSChoLGMpe3AoXFxcIm51bWJlclxcXCI9PT10eXBlb2YgaCxcXFwiY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlclxcXCIpO3AoMDw9aCxcXFwic3BlY2lmaWVkIGEgbmVnYXRpdmUgdmFsdWUgZm9yIHdyaXRpbmcgYW4gdW5zaWduZWQgdmFsdWVcXFwiKTtwKGg8PVxcbmMsXFxcInZhbHVlIGlzIGxhcmdlciB0aGFuIG1heGltdW0gdmFsdWUgZm9yIHR5cGVcXFwiKTtwKE1hdGguZmxvb3IoaCk9PT1oLFxcXCJ2YWx1ZSBoYXMgYSBmcmFjdGlvbmFsIGNvbXBvbmVudFxcXCIpfWZ1bmN0aW9uIEwoaCxjLGEpe3AoXFxcIm51bWJlclxcXCI9PT10eXBlb2YgaCxcXFwiY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlclxcXCIpO3AoaDw9YyxcXFwidmFsdWUgbGFyZ2VyIHRoYW4gbWF4aW11bSBhbGxvd2VkIHZhbHVlXFxcIik7cChoPj1hLFxcXCJ2YWx1ZSBzbWFsbGVyIHRoYW4gbWluaW11bSBhbGxvd2VkIHZhbHVlXFxcIik7cChNYXRoLmZsb29yKGgpPT09aCxcXFwidmFsdWUgaGFzIGEgZnJhY3Rpb25hbCBjb21wb25lbnRcXFwiKX1mdW5jdGlvbiBNKGgsYyxhKXtwKFxcXCJudW1iZXJcXFwiPT09dHlwZW9mIGgsXFxcImNhbm5vdCB3cml0ZSBhIG5vbi1udW1iZXIgYXMgYSBudW1iZXJcXFwiKTtwKGg8PWMsXFxcInZhbHVlIGxhcmdlciB0aGFuIG1heGltdW0gYWxsb3dlZCB2YWx1ZVxcXCIpO3AoaD49YSxcXFwidmFsdWUgc21hbGxlciB0aGFuIG1pbmltdW0gYWxsb3dlZCB2YWx1ZVxcXCIpfVxcbmZ1bmN0aW9uIHAoaCxjKXtpZighaCl0aHJvdyBFcnJvcihjfHxcXFwiRmFpbGVkIGFzc2VydGlvblxcXCIpO312YXIgSj1uKFxcXCJiYXNlNjQtanNcXFwiKSxJPW4oXFxcImllZWU3NTRcXFwiKTt0LkJ1ZmZlcj1lO3QuU2xvd0J1ZmZlcj1lO3QuSU5TUEVDVF9NQVhfQllURVM9NTA7ZS5wb29sU2l6ZT04MTkyO2UuX3VzZVR5cGVkQXJyYXlzPWZ1bmN0aW9uKCl7dHJ5e3ZhciBoPW5ldyBBcnJheUJ1ZmZlcigwKSxjPW5ldyBVaW50OEFycmF5KGgpO2MuZm9vPWZ1bmN0aW9uKCl7cmV0dXJuIDQyfTtyZXR1cm4gNDI9PT1jLmZvbygpJiZcXFwiZnVuY3Rpb25cXFwiPT09dHlwZW9mIGMuc3ViYXJyYXl9Y2F0Y2goYSl7cmV0dXJuITF9fSgpO2UuaXNFbmNvZGluZz1mdW5jdGlvbihoKXtzd2l0Y2goU3RyaW5nKGgpLnRvTG93ZXJDYXNlKCkpe2Nhc2UgXFxcImhleFxcXCI6Y2FzZSBcXFwidXRmOFxcXCI6Y2FzZSBcXFwidXRmLThcXFwiOmNhc2UgXFxcImFzY2lpXFxcIjpjYXNlIFxcXCJiaW5hcnlcXFwiOmNhc2UgXFxcImJhc2U2NFxcXCI6Y2FzZSBcXFwicmF3XFxcIjpjYXNlIFxcXCJ1Y3MyXFxcIjpjYXNlIFxcXCJ1Y3MtMlxcXCI6Y2FzZSBcXFwidXRmMTZsZVxcXCI6Y2FzZSBcXFwidXRmLTE2bGVcXFwiOnJldHVybiEwO1xcbmRlZmF1bHQ6cmV0dXJuITF9fTtlLmlzQnVmZmVyPWZ1bmN0aW9uKGgpe3JldHVybiEobnVsbD09PWh8fHZvaWQgMD09PWh8fCFoLl9pc0J1ZmZlcil9O2UuYnl0ZUxlbmd0aD1mdW5jdGlvbihoLGMpe3ZhciBhO2grPVxcXCJcXFwiO3N3aXRjaChjfHxcXFwidXRmOFxcXCIpe2Nhc2UgXFxcImhleFxcXCI6YT1oLmxlbmd0aC8yO2JyZWFrO2Nhc2UgXFxcInV0ZjhcXFwiOmNhc2UgXFxcInV0Zi04XFxcIjphPXUoaCkubGVuZ3RoO2JyZWFrO2Nhc2UgXFxcImFzY2lpXFxcIjpjYXNlIFxcXCJiaW5hcnlcXFwiOmNhc2UgXFxcInJhd1xcXCI6YT1oLmxlbmd0aDticmVhaztjYXNlIFxcXCJiYXNlNjRcXFwiOmE9Si50b0J5dGVBcnJheShoKS5sZW5ndGg7YnJlYWs7Y2FzZSBcXFwidWNzMlxcXCI6Y2FzZSBcXFwidWNzLTJcXFwiOmNhc2UgXFxcInV0ZjE2bGVcXFwiOmNhc2UgXFxcInV0Zi0xNmxlXFxcIjphPTIqaC5sZW5ndGg7YnJlYWs7ZGVmYXVsdDp0aHJvdyBFcnJvcihcXFwiVW5rbm93biBlbmNvZGluZ1xcXCIpO31yZXR1cm4gYX07ZS5jb25jYXQ9ZnVuY3Rpb24oaCxjKXtwKEUoaCksXFxcIlVzYWdlOiBCdWZmZXIuY29uY2F0KGxpc3QsIFt0b3RhbExlbmd0aF0pXFxcXG5saXN0IHNob3VsZCBiZSBhbiBBcnJheS5cXFwiKTtcXG5pZigwPT09aC5sZW5ndGgpcmV0dXJuIG5ldyBlKDApO2lmKDE9PT1oLmxlbmd0aClyZXR1cm4gaFswXTt2YXIgYTtpZihcXFwibnVtYmVyXFxcIiE9PXR5cGVvZiBjKWZvcihhPWM9MDthPGgubGVuZ3RoO2ErKyljKz1oW2FdLmxlbmd0aDt2YXIgZD1uZXcgZShjKSxiPTA7Zm9yKGE9MDthPGgubGVuZ3RoO2ErKyl7dmFyIGY9aFthXTtmLmNvcHkoZCxiKTtiKz1mLmxlbmd0aH1yZXR1cm4gZH07ZS5wcm90b3R5cGUud3JpdGU9ZnVuY3Rpb24oaCxjLGEsZCl7aWYoaXNGaW5pdGUoYykpaXNGaW5pdGUoYSl8fChkPWEsYT12b2lkIDApO2Vsc2V7dmFyIGI9ZDtkPWM7Yz1hO2E9Yn1jPU51bWJlcihjKXx8MDtiPXRoaXMubGVuZ3RoLWM7YT8oYT1OdW1iZXIoYSksYT5iJiYoYT1iKSk6YT1iO2Q9U3RyaW5nKGR8fFxcXCJ1dGY4XFxcIikudG9Mb3dlckNhc2UoKTtzd2l0Y2goZCl7Y2FzZSBcXFwiaGV4XFxcIjpjPU51bWJlcihjKXx8MDtkPXRoaXMubGVuZ3RoLWM7YT8oYT1OdW1iZXIoYSksYT5kJiYoYT1kKSk6YT1kO2Q9XFxuaC5sZW5ndGg7cCgwPT09ZCUyLFxcXCJJbnZhbGlkIGhleCBzdHJpbmdcXFwiKTthPmQvMiYmKGE9ZC8yKTtmb3IoZD0wO2Q8YTtkKyspYj1wYXJzZUludChoLnN1YnN0cigyKmQsMiksMTYpLHAoIWlzTmFOKGIpLFxcXCJJbnZhbGlkIGhleCBzdHJpbmdcXFwiKSx0aGlzW2MrZF09YjtlLl9jaGFyc1dyaXR0ZW49MipkO2g9ZDticmVhaztjYXNlIFxcXCJ1dGY4XFxcIjpjYXNlIFxcXCJ1dGYtOFxcXCI6aD1lLl9jaGFyc1dyaXR0ZW49eih1KGgpLHRoaXMsYyxhKTticmVhaztjYXNlIFxcXCJhc2NpaVxcXCI6aD1lLl9jaGFyc1dyaXR0ZW49eihDKGgpLHRoaXMsYyxhKTticmVhaztjYXNlIFxcXCJiaW5hcnlcXFwiOmg9ZS5fY2hhcnNXcml0dGVuPXooQyhoKSx0aGlzLGMsYSk7YnJlYWs7Y2FzZSBcXFwiYmFzZTY0XFxcIjpoPWUuX2NoYXJzV3JpdHRlbj16KEoudG9CeXRlQXJyYXkoaCksdGhpcyxjLGEpO2JyZWFrO2Nhc2UgXFxcInVjczJcXFwiOmNhc2UgXFxcInVjcy0yXFxcIjpjYXNlIFxcXCJ1dGYxNmxlXFxcIjpjYXNlIFxcXCJ1dGYtMTZsZVxcXCI6Zm9yKHZhciBmLGI9W10saz0wO2s8aC5sZW5ndGg7aysrKWY9XFxuaC5jaGFyQ29kZUF0KGspLGQ9Zj4+OCxmJT0yNTYsYi5wdXNoKGYpLGIucHVzaChkKTtoPWUuX2NoYXJzV3JpdHRlbj16KGIsdGhpcyxjLGEpO2JyZWFrO2RlZmF1bHQ6dGhyb3cgRXJyb3IoXFxcIlVua25vd24gZW5jb2RpbmdcXFwiKTt9cmV0dXJuIGh9O2UucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKGEsYyxkKXthPVN0cmluZyhhfHxcXFwidXRmOFxcXCIpLnRvTG93ZXJDYXNlKCk7Yz1OdW1iZXIoYyl8fDA7ZD12b2lkIDAhPT1kP051bWJlcihkKTpkPXRoaXMubGVuZ3RoO2lmKGQ9PT1jKXJldHVyblxcXCJcXFwiO3N3aXRjaChhKXtjYXNlIFxcXCJoZXhcXFwiOmE9dGhpcy5sZW5ndGg7aWYoIWN8fDA+YyljPTA7aWYoIWR8fDA+ZHx8ZD5hKWQ9YTtmb3IoYT1cXFwiXFxcIjtjPGQ7YysrKWErPUcodGhpc1tjXSk7ZD1hO2JyZWFrO2Nhc2UgXFxcInV0ZjhcXFwiOmNhc2UgXFxcInV0Zi04XFxcIjp2YXIgYj1hPVxcXCJcXFwiO2ZvcihkPU1hdGgubWluKHRoaXMubGVuZ3RoLGQpO2M8ZDtjKyspMTI3Pj10aGlzW2NdPyhhKz1EKGIpK1N0cmluZy5mcm9tQ2hhckNvZGUodGhpc1tjXSksXFxuYj1cXFwiXFxcIik6Yis9XFxcIiVcXFwiK3RoaXNbY10udG9TdHJpbmcoMTYpO2Q9YStEKGIpO2JyZWFrO2Nhc2UgXFxcImFzY2lpXFxcIjpkPXIodGhpcyxjLGQpO2JyZWFrO2Nhc2UgXFxcImJpbmFyeVxcXCI6ZD1yKHRoaXMsYyxkKTticmVhaztjYXNlIFxcXCJiYXNlNjRcXFwiOmQ9MD09PWMmJmQ9PT10aGlzLmxlbmd0aD9KLmZyb21CeXRlQXJyYXkodGhpcyk6Si5mcm9tQnl0ZUFycmF5KHRoaXMuc2xpY2UoYyxkKSk7YnJlYWs7Y2FzZSBcXFwidWNzMlxcXCI6Y2FzZSBcXFwidWNzLTJcXFwiOmNhc2UgXFxcInV0ZjE2bGVcXFwiOmNhc2UgXFxcInV0Zi0xNmxlXFxcIjpkPXRoaXMuc2xpY2UoYyxkKTtjPVxcXCJcXFwiO2ZvcihhPTA7YTxkLmxlbmd0aDthKz0yKWMrPVN0cmluZy5mcm9tQ2hhckNvZGUoZFthXSsyNTYqZFthKzFdKTtkPWM7YnJlYWs7ZGVmYXVsdDp0aHJvdyBFcnJvcihcXFwiVW5rbm93biBlbmNvZGluZ1xcXCIpO31yZXR1cm4gZH07ZS5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJue3R5cGU6XFxcIkJ1ZmZlclxcXCIsZGF0YTpBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnJ8fFxcbnRoaXMsMCl9fTtlLnByb3RvdHlwZS5jb3B5PWZ1bmN0aW9uKGEsYyxkLGIpe2R8fChkPTApO2J8fDA9PT1ifHwoYj10aGlzLmxlbmd0aCk7Y3x8KGM9MCk7aWYoYiE9PWQmJjAhPT1hLmxlbmd0aCYmMCE9PXRoaXMubGVuZ3RoKWlmKHAoYj49ZCxcXFwic291cmNlRW5kIDwgc291cmNlU3RhcnRcXFwiKSxwKDA8PWMmJmM8YS5sZW5ndGgsXFxcInRhcmdldFN0YXJ0IG91dCBvZiBib3VuZHNcXFwiKSxwKDA8PWQmJmQ8dGhpcy5sZW5ndGgsXFxcInNvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHNcXFwiKSxwKDA8PWImJmI8PXRoaXMubGVuZ3RoLFxcXCJzb3VyY2VFbmQgb3V0IG9mIGJvdW5kc1xcXCIpLGI+dGhpcy5sZW5ndGgmJihiPXRoaXMubGVuZ3RoKSxhLmxlbmd0aC1jPGItZCYmKGI9YS5sZW5ndGgtYytkKSxiLT1kLDEwMD5ifHwhZS5fdXNlVHlwZWRBcnJheXMpZm9yKHZhciBmPTA7ZjxiO2YrKylhW2YrY109dGhpc1tmK2RdO2Vsc2UgYS5fc2V0KHRoaXMuc3ViYXJyYXkoZCxkK2IpLGMpfTtlLnByb3RvdHlwZS5zbGljZT1cXG5mdW5jdGlvbihhLGMpe3ZhciBkPXRoaXMubGVuZ3RoO2E9QihhLGQsMCk7Yz1CKGMsZCxkKTtpZihlLl91c2VUeXBlZEFycmF5cylyZXR1cm4gZS5fYXVnbWVudCh0aGlzLnN1YmFycmF5KGEsYykpO2Zvcih2YXIgZD1jLWEsYj1uZXcgZShkLHZvaWQgMCwhMCksZj0wO2Y8ZDtmKyspYltmXT10aGlzW2YrYV07cmV0dXJuIGJ9O2UucHJvdG90eXBlLmdldD1mdW5jdGlvbihhKXtjb25zb2xlLmxvZyhcXFwiLmdldCgpIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB1c2luZyBhcnJheSBpbmRleGVzIGluc3RlYWQuXFxcIik7cmV0dXJuIHRoaXMucmVhZFVJbnQ4KGEpfTtlLnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24oYSxjKXtjb25zb2xlLmxvZyhcXFwiLnNldCgpIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB1c2luZyBhcnJheSBpbmRleGVzIGluc3RlYWQuXFxcIik7cmV0dXJuIHRoaXMud3JpdGVVSW50OChhLGMpfTtlLnByb3RvdHlwZS5yZWFkVUludDg9ZnVuY3Rpb24oYSxjKXtjfHwocCh2b2lkIDAhPT1hJiZudWxsIT09XFxuYSxcXFwibWlzc2luZyBvZmZzZXRcXFwiKSxwKGE8dGhpcy5sZW5ndGgsXFxcIlRyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoXFxcIikpO2lmKCEoYT49dGhpcy5sZW5ndGgpKXJldHVybiB0aGlzW2FdfTtlLnByb3RvdHlwZS5yZWFkVUludDE2TEU9ZnVuY3Rpb24oYSxjKXtyZXR1cm4gbCh0aGlzLGEsITAsYyl9O2UucHJvdG90eXBlLnJlYWRVSW50MTZCRT1mdW5jdGlvbihhLGMpe3JldHVybiBsKHRoaXMsYSwhMSxjKX07ZS5wcm90b3R5cGUucmVhZFVJbnQzMkxFPWZ1bmN0aW9uKGEsYyl7cmV0dXJuIG0odGhpcyxhLCEwLGMpfTtlLnByb3RvdHlwZS5yZWFkVUludDMyQkU9ZnVuY3Rpb24oYSxjKXtyZXR1cm4gbSh0aGlzLGEsITEsYyl9O2UucHJvdG90eXBlLnJlYWRJbnQ4PWZ1bmN0aW9uKGEsYyl7Y3x8KHAodm9pZCAwIT09YSYmbnVsbCE9PWEsXFxcIm1pc3Npbmcgb2Zmc2V0XFxcIikscChhPHRoaXMubGVuZ3RoLFxcXCJUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aFxcXCIpKTtpZighKGE+PVxcbnRoaXMubGVuZ3RoKSlyZXR1cm4gdGhpc1thXSYxMjg/LTEqKDI1NS10aGlzW2FdKzEpOnRoaXNbYV19O2UucHJvdG90eXBlLnJlYWRJbnQxNkxFPWZ1bmN0aW9uKGEsYyl7cmV0dXJuIGcodGhpcyxhLCEwLGMpfTtlLnByb3RvdHlwZS5yZWFkSW50MTZCRT1mdW5jdGlvbihhLGMpe3JldHVybiBnKHRoaXMsYSwhMSxjKX07ZS5wcm90b3R5cGUucmVhZEludDMyTEU9ZnVuY3Rpb24oYSxjKXtyZXR1cm4gYih0aGlzLGEsITAsYyl9O2UucHJvdG90eXBlLnJlYWRJbnQzMkJFPWZ1bmN0aW9uKGEsYyl7cmV0dXJuIGIodGhpcyxhLCExLGMpfTtlLnByb3RvdHlwZS5yZWFkRmxvYXRMRT1mdW5jdGlvbihhLGMpe3JldHVybiBmKHRoaXMsYSwhMCxjKX07ZS5wcm90b3R5cGUucmVhZEZsb2F0QkU9ZnVuY3Rpb24oYSxjKXtyZXR1cm4gZih0aGlzLGEsITEsYyl9O2UucHJvdG90eXBlLnJlYWREb3VibGVMRT1mdW5jdGlvbihhLGMpe3JldHVybiBrKHRoaXMsYSwhMCxjKX07ZS5wcm90b3R5cGUucmVhZERvdWJsZUJFPVxcbmZ1bmN0aW9uKGEsYyl7cmV0dXJuIGsodGhpcyxhLCExLGMpfTtlLnByb3RvdHlwZS53cml0ZVVJbnQ4PWZ1bmN0aW9uKGEsYyxkKXtkfHwocCh2b2lkIDAhPT1hJiZudWxsIT09YSxcXFwibWlzc2luZyB2YWx1ZVxcXCIpLHAodm9pZCAwIT09YyYmbnVsbCE9PWMsXFxcIm1pc3Npbmcgb2Zmc2V0XFxcIikscChjPHRoaXMubGVuZ3RoLFxcXCJ0cnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGhcXFwiKSxIKGEsMjU1KSk7Yz49dGhpcy5sZW5ndGh8fCh0aGlzW2NdPWEpfTtlLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFPWZ1bmN0aW9uKGMsZCxiKXthKHRoaXMsYyxkLCEwLGIpfTtlLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFPWZ1bmN0aW9uKGMsZCxiKXthKHRoaXMsYyxkLCExLGIpfTtlLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFPWZ1bmN0aW9uKGEsZCxiKXtjKHRoaXMsYSxkLCEwLGIpfTtlLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFPWZ1bmN0aW9uKGEsZCxiKXtjKHRoaXMsYSxkLCExLGIpfTtlLnByb3RvdHlwZS53cml0ZUludDg9XFxuZnVuY3Rpb24oYSxjLGQpe2R8fChwKHZvaWQgMCE9PWEmJm51bGwhPT1hLFxcXCJtaXNzaW5nIHZhbHVlXFxcIikscCh2b2lkIDAhPT1jJiZudWxsIT09YyxcXFwibWlzc2luZyBvZmZzZXRcXFwiKSxwKGM8dGhpcy5sZW5ndGgsXFxcIlRyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aFxcXCIpLEwoYSwxMjcsLTEyOCkpO2M+PXRoaXMubGVuZ3RofHwoMDw9YT90aGlzLndyaXRlVUludDgoYSxjLGQpOnRoaXMud3JpdGVVSW50OCgyNTUrYSsxLGMsZCkpfTtlLnByb3RvdHlwZS53cml0ZUludDE2TEU9ZnVuY3Rpb24oYSxjLGIpe2QodGhpcyxhLGMsITAsYil9O2UucHJvdG90eXBlLndyaXRlSW50MTZCRT1mdW5jdGlvbihhLGMsYil7ZCh0aGlzLGEsYywhMSxiKX07ZS5wcm90b3R5cGUud3JpdGVJbnQzMkxFPWZ1bmN0aW9uKGEsYyxkKXt5KHRoaXMsYSxjLCEwLGQpfTtlLnByb3RvdHlwZS53cml0ZUludDMyQkU9ZnVuY3Rpb24oYSxjLGQpe3kodGhpcyxhLGMsITEsZCl9O2UucHJvdG90eXBlLndyaXRlRmxvYXRMRT1cXG5mdW5jdGlvbihhLGMsZCl7eCh0aGlzLGEsYywhMCxkKX07ZS5wcm90b3R5cGUud3JpdGVGbG9hdEJFPWZ1bmN0aW9uKGEsYyxkKXt4KHRoaXMsYSxjLCExLGQpfTtlLnByb3RvdHlwZS53cml0ZURvdWJsZUxFPWZ1bmN0aW9uKGEsYyxkKXtBKHRoaXMsYSxjLCEwLGQpfTtlLnByb3RvdHlwZS53cml0ZURvdWJsZUJFPWZ1bmN0aW9uKGEsYyxkKXtBKHRoaXMsYSxjLCExLGQpfTtlLnByb3RvdHlwZS5maWxsPWZ1bmN0aW9uKGEsYyxkKXthfHwoYT0wKTtjfHwoYz0wKTtkfHwoZD10aGlzLmxlbmd0aCk7XFxcInN0cmluZ1xcXCI9PT10eXBlb2YgYSYmKGE9YS5jaGFyQ29kZUF0KDApKTtwKFxcXCJudW1iZXJcXFwiPT09dHlwZW9mIGEmJiFpc05hTihhKSxcXFwidmFsdWUgaXMgbm90IGEgbnVtYmVyXFxcIik7cChkPj1jLFxcXCJlbmQgPCBzdGFydFxcXCIpO2lmKGQhPT1jJiYwIT09dGhpcy5sZW5ndGgpZm9yKHAoMDw9YyYmYzx0aGlzLmxlbmd0aCxcXFwic3RhcnQgb3V0IG9mIGJvdW5kc1xcXCIpLHAoMDw9ZCYmZDw9dGhpcy5sZW5ndGgsXFxuXFxcImVuZCBvdXQgb2YgYm91bmRzXFxcIik7YzxkO2MrKyl0aGlzW2NdPWF9O2UucHJvdG90eXBlLmluc3BlY3Q9ZnVuY3Rpb24oKXtmb3IodmFyIGE9W10sYz10aGlzLmxlbmd0aCxkPTA7ZDxjO2QrKylpZihhW2RdPUcodGhpc1tkXSksZD09PXQuSU5TUEVDVF9NQVhfQllURVMpe2FbZCsxXT1cXFwiLi4uXFxcIjticmVha31yZXR1cm5cXFwiPEJ1ZmZlciBcXFwiK2Euam9pbihcXFwiIFxcXCIpK1xcXCI+XFxcIn07ZS5wcm90b3R5cGUudG9BcnJheUJ1ZmZlcj1mdW5jdGlvbigpe2lmKFxcXCJ1bmRlZmluZWRcXFwiIT09dHlwZW9mIFVpbnQ4QXJyYXkpe2lmKGUuX3VzZVR5cGVkQXJyYXlzKXJldHVybihuZXcgZSh0aGlzKSkuYnVmZmVyO2Zvcih2YXIgYT1uZXcgVWludDhBcnJheSh0aGlzLmxlbmd0aCksYz0wLGQ9YS5sZW5ndGg7YzxkO2MrPTEpYVtjXT10aGlzW2NdO3JldHVybiBhLmJ1ZmZlcn10aHJvdyBFcnJvcihcXFwiQnVmZmVyLnRvQXJyYXlCdWZmZXIgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXJcXFwiKTt9O3ZhciB2PWUucHJvdG90eXBlO1xcbmUuX2F1Z21lbnQ9ZnVuY3Rpb24oYSl7YS5faXNCdWZmZXI9ITA7YS5fZ2V0PWEuZ2V0O2EuX3NldD1hLnNldDthLmdldD12LmdldDthLnNldD12LnNldDthLndyaXRlPXYud3JpdGU7YS50b1N0cmluZz12LnRvU3RyaW5nO2EudG9Mb2NhbGVTdHJpbmc9di50b1N0cmluZzthLnRvSlNPTj12LnRvSlNPTjthLmNvcHk9di5jb3B5O2Euc2xpY2U9di5zbGljZTthLnJlYWRVSW50OD12LnJlYWRVSW50ODthLnJlYWRVSW50MTZMRT12LnJlYWRVSW50MTZMRTthLnJlYWRVSW50MTZCRT12LnJlYWRVSW50MTZCRTthLnJlYWRVSW50MzJMRT12LnJlYWRVSW50MzJMRTthLnJlYWRVSW50MzJCRT12LnJlYWRVSW50MzJCRTthLnJlYWRJbnQ4PXYucmVhZEludDg7YS5yZWFkSW50MTZMRT12LnJlYWRJbnQxNkxFO2EucmVhZEludDE2QkU9di5yZWFkSW50MTZCRTthLnJlYWRJbnQzMkxFPXYucmVhZEludDMyTEU7YS5yZWFkSW50MzJCRT12LnJlYWRJbnQzMkJFO2EucmVhZEZsb2F0TEU9di5yZWFkRmxvYXRMRTtcXG5hLnJlYWRGbG9hdEJFPXYucmVhZEZsb2F0QkU7YS5yZWFkRG91YmxlTEU9di5yZWFkRG91YmxlTEU7YS5yZWFkRG91YmxlQkU9di5yZWFkRG91YmxlQkU7YS53cml0ZVVJbnQ4PXYud3JpdGVVSW50ODthLndyaXRlVUludDE2TEU9di53cml0ZVVJbnQxNkxFO2Eud3JpdGVVSW50MTZCRT12LndyaXRlVUludDE2QkU7YS53cml0ZVVJbnQzMkxFPXYud3JpdGVVSW50MzJMRTthLndyaXRlVUludDMyQkU9di53cml0ZVVJbnQzMkJFO2Eud3JpdGVJbnQ4PXYud3JpdGVJbnQ4O2Eud3JpdGVJbnQxNkxFPXYud3JpdGVJbnQxNkxFO2Eud3JpdGVJbnQxNkJFPXYud3JpdGVJbnQxNkJFO2Eud3JpdGVJbnQzMkxFPXYud3JpdGVJbnQzMkxFO2Eud3JpdGVJbnQzMkJFPXYud3JpdGVJbnQzMkJFO2Eud3JpdGVGbG9hdExFPXYud3JpdGVGbG9hdExFO2Eud3JpdGVGbG9hdEJFPXYud3JpdGVGbG9hdEJFO2Eud3JpdGVEb3VibGVMRT12LndyaXRlRG91YmxlTEU7YS53cml0ZURvdWJsZUJFPXYud3JpdGVEb3VibGVCRTtcXG5hLmZpbGw9di5maWxsO2EuaW5zcGVjdD12Lmluc3BlY3Q7YS50b0FycmF5QnVmZmVyPXYudG9BcnJheUJ1ZmZlcjtyZXR1cm4gYX19LHtcXFwiYmFzZTY0LWpzXFxcIjozLGllZWU3NTQ6Nn1dLDY6W2Z1bmN0aW9uKG4sdyx0KXt0LnJlYWQ9ZnVuY3Rpb24oZSxyLGwsbSxnKXt2YXIgYjtiPTgqZy1tLTE7dmFyIGY9KDE8PGIpLTEsaz1mPj4xLGE9LTc7Zz1sP2ctMTowO3ZhciBjPWw/LTE6MSxkPWVbcitnXTtnKz1jO2w9ZCYoMTw8LWEpLTE7ZD4+PS1hO2ZvcihhKz1iOzA8YTtsPTI1NipsK2VbcitnXSxnKz1jLGEtPTgpO2I9bCYoMTw8LWEpLTE7bD4+PS1hO2ZvcihhKz1tOzA8YTtiPTI1NipiK2VbcitnXSxnKz1jLGEtPTgpO2lmKDA9PT1sKWw9MS1rO2Vsc2V7aWYobD09PWYpcmV0dXJuIGI/TmFOOkluZmluaXR5KihkPy0xOjEpO2IrPU1hdGgucG93KDIsbSk7bC09a31yZXR1cm4oZD8tMToxKSpiKk1hdGgucG93KDIsbC1tKX07dC53cml0ZT1mdW5jdGlvbihlLHIsbCxtLGcsYil7dmFyIGYsXFxuaz04KmItZy0xLGE9KDE8PGspLTEsYz1hPj4xLGQ9MjM9PT1nP01hdGgucG93KDIsLTI0KS1NYXRoLnBvdygyLC03Nyk6MDtiPW0/MDpiLTE7dmFyIHk9bT8xOi0xLHg9MD5yfHwwPT09ciYmMD4xL3I/MTowO3I9TWF0aC5hYnMocik7aXNOYU4ocil8fEluZmluaXR5PT09cj8ocj1pc05hTihyKT8xOjAsbT1hKToobT1NYXRoLmZsb29yKE1hdGgubG9nKHIpL01hdGguTE4yKSwxPnIqKGY9TWF0aC5wb3coMiwtbSkpJiYobS0tLGYqPTIpLHI9MTw9bStjP3IrZC9mOnIrZCpNYXRoLnBvdygyLDEtYyksMjw9cipmJiYobSsrLGYvPTIpLG0rYz49YT8ocj0wLG09YSk6MTw9bStjPyhyPShyKmYtMSkqTWF0aC5wb3coMixnKSxtKz1jKToocj1yKk1hdGgucG93KDIsYy0xKSpNYXRoLnBvdygyLGcpLG09MCkpO2Zvcig7ODw9ZztlW2wrYl09ciYyNTUsYis9eSxyLz0yNTYsZy09OCk7bT1tPDxnfHI7Zm9yKGsrPWc7MDxrO2VbbCtiXT1tJjI1NSxiKz15LG0vPTI1NixrLT04KTtlW2wrYi15XXw9XFxuMTI4Knh9fSx7fV0sNzpbZnVuY3Rpb24obix3LHQpeyhmdW5jdGlvbihlKXtmdW5jdGlvbiByKGIsZil7Zm9yKHZhciBlPTAsYT1iLmxlbmd0aC0xOzA8PWE7YS0tKXt2YXIgYz1iW2FdO1xcXCIuXFxcIj09PWM/Yi5zcGxpY2UoYSwxKTpcXFwiLi5cXFwiPT09Yz8oYi5zcGxpY2UoYSwxKSxlKyspOmUmJihiLnNwbGljZShhLDEpLGUtLSl9aWYoZilmb3IoO2UtLTtlKWIudW5zaGlmdChcXFwiLi5cXFwiKTtyZXR1cm4gYn1mdW5jdGlvbiBsKGIsZil7aWYoYi5maWx0ZXIpcmV0dXJuIGIuZmlsdGVyKGYpO2Zvcih2YXIgZT1bXSxhPTA7YTxiLmxlbmd0aDthKyspZihiW2FdLGEsYikmJmUucHVzaChiW2FdKTtyZXR1cm4gZX12YXIgbT0vXihcXFxcLz98KShbXFxcXHNcXFxcU10qPykoKD86XFxcXC57MSwyfXxbXlxcXFwvXSs/fCkoXFxcXC5bXi5cXFxcL10qfCkpKD86W1xcXFwvXSopJC87dC5yZXNvbHZlPWZ1bmN0aW9uKCl7Zm9yKHZhciBiPVxcXCJcXFwiLGY9ITEsaz1hcmd1bWVudHMubGVuZ3RoLTE7LTE8PWsmJiFmO2stLSl7dmFyIGE9MDw9az9hcmd1bWVudHNba106XFxuZS5jd2QoKTtpZihcXFwic3RyaW5nXFxcIiE9PXR5cGVvZiBhKXRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkFyZ3VtZW50cyB0byBwYXRoLnJlc29sdmUgbXVzdCBiZSBzdHJpbmdzXFxcIik7YSYmKGI9YStcXFwiL1xcXCIrYixmPVxcXCIvXFxcIj09PWEuY2hhckF0KDApKX1iPXIobChiLnNwbGl0KFxcXCIvXFxcIiksZnVuY3Rpb24oYSl7cmV0dXJuISFhfSksIWYpLmpvaW4oXFxcIi9cXFwiKTtyZXR1cm4oZj9cXFwiL1xcXCI6XFxcIlxcXCIpK2J8fFxcXCIuXFxcIn07dC5ub3JtYWxpemU9ZnVuY3Rpb24oYil7dmFyIGY9dC5pc0Fic29sdXRlKGIpLGU9XFxcIi9cXFwiPT09ZyhiLC0xKTsoYj1yKGwoYi5zcGxpdChcXFwiL1xcXCIpLGZ1bmN0aW9uKGEpe3JldHVybiEhYX0pLCFmKS5qb2luKFxcXCIvXFxcIikpfHxmfHwoYj1cXFwiLlxcXCIpO2ImJmUmJihiKz1cXFwiL1xcXCIpO3JldHVybihmP1xcXCIvXFxcIjpcXFwiXFxcIikrYn07dC5pc0Fic29sdXRlPWZ1bmN0aW9uKGIpe3JldHVyblxcXCIvXFxcIj09PWIuY2hhckF0KDApfTt0LmpvaW49ZnVuY3Rpb24oKXt2YXIgYj1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMCk7cmV0dXJuIHQubm9ybWFsaXplKGwoYixcXG5mdW5jdGlvbihiLGUpe2lmKFxcXCJzdHJpbmdcXFwiIT09dHlwZW9mIGIpdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQXJndW1lbnRzIHRvIHBhdGguam9pbiBtdXN0IGJlIHN0cmluZ3NcXFwiKTtyZXR1cm4gYn0pLmpvaW4oXFxcIi9cXFwiKSl9O3QucmVsYXRpdmU9ZnVuY3Rpb24oYixmKXtmdW5jdGlvbiBlKGEpe2Zvcih2YXIgYz0wO2M8YS5sZW5ndGgmJlxcXCJcXFwiPT09YVtjXTtjKyspO2Zvcih2YXIgZD1hLmxlbmd0aC0xOzA8PWQmJlxcXCJcXFwiPT09YVtkXTtkLS0pO3JldHVybiBjPmQ/W106YS5zbGljZShjLGQtYysxKX1iPXQucmVzb2x2ZShiKS5zdWJzdHIoMSk7Zj10LnJlc29sdmUoZikuc3Vic3RyKDEpO2Zvcih2YXIgYT1lKGIuc3BsaXQoXFxcIi9cXFwiKSksYz1lKGYuc3BsaXQoXFxcIi9cXFwiKSksZD1NYXRoLm1pbihhLmxlbmd0aCxjLmxlbmd0aCksZz1kLHg9MDt4PGQ7eCsrKWlmKGFbeF0hPT1jW3hdKXtnPXg7YnJlYWt9ZD1bXTtmb3IoeD1nO3g8YS5sZW5ndGg7eCsrKWQucHVzaChcXFwiLi5cXFwiKTtkPWQuY29uY2F0KGMuc2xpY2UoZykpO1xcbnJldHVybiBkLmpvaW4oXFxcIi9cXFwiKX07dC5zZXA9XFxcIi9cXFwiO3QuZGVsaW1pdGVyPVxcXCI6XFxcIjt0LmRpcm5hbWU9ZnVuY3Rpb24oYil7dmFyIGY9bS5leGVjKGIpLnNsaWNlKDEpO2I9ZlswXTtmPWZbMV07aWYoIWImJiFmKXJldHVyblxcXCIuXFxcIjtmJiYoZj1mLnN1YnN0cigwLGYubGVuZ3RoLTEpKTtyZXR1cm4gYitmfTt0LmJhc2VuYW1lPWZ1bmN0aW9uKGIsZil7dmFyIGU9bS5leGVjKGIpLnNsaWNlKDEpWzJdO2YmJmUuc3Vic3RyKC0xKmYubGVuZ3RoKT09PWYmJihlPWUuc3Vic3RyKDAsZS5sZW5ndGgtZi5sZW5ndGgpKTtyZXR1cm4gZX07dC5leHRuYW1lPWZ1bmN0aW9uKGIpe3JldHVybiBtLmV4ZWMoYikuc2xpY2UoMSlbM119O3ZhciBnPVxcXCJiXFxcIj09PVxcXCJhYlxcXCIuc3Vic3RyKC0xKT9mdW5jdGlvbihiLGYsZSl7cmV0dXJuIGIuc3Vic3RyKGYsZSl9OmZ1bmN0aW9uKGIsZixlKXswPmYmJihmPWIubGVuZ3RoK2YpO3JldHVybiBiLnN1YnN0cihmLGUpfX0pLmNhbGwodGhpcyxuKFxcXCJub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzXFxcIikpfSxcXG57XFxcIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanNcXFwiOjh9XSw4OltmdW5jdGlvbihuLHcsdCl7ZnVuY3Rpb24gZSgpe31uPXcuZXhwb3J0cz17fTtuLm5leHRUaWNrPWZ1bmN0aW9uKCl7aWYoXFxcInVuZGVmaW5lZFxcXCIhPT10eXBlb2Ygd2luZG93JiZ3aW5kb3cuc2V0SW1tZWRpYXRlKXJldHVybiBmdW5jdGlvbihlKXtyZXR1cm4gd2luZG93LnNldEltbWVkaWF0ZShlKX07aWYoXFxcInVuZGVmaW5lZFxcXCIhPT10eXBlb2Ygd2luZG93JiZ3aW5kb3cucG9zdE1lc3NhZ2UmJndpbmRvdy5hZGRFdmVudExpc3RlbmVyKXt2YXIgZT1bXTt3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcXFwibWVzc2FnZVxcXCIsZnVuY3Rpb24obCl7dmFyIG09bC5zb3VyY2U7bSE9PXdpbmRvdyYmbnVsbCE9PW18fFxcXCJwcm9jZXNzLXRpY2tcXFwiIT09bC5kYXRhfHwobC5zdG9wUHJvcGFnYXRpb24oKSwwPGUubGVuZ3RoJiZlLnNoaWZ0KCkoKSl9LCEwKTtyZXR1cm4gZnVuY3Rpb24obCl7ZS5wdXNoKGwpO3dpbmRvdy5wb3N0TWVzc2FnZShcXFwicHJvY2Vzcy10aWNrXFxcIixcXG5cXFwiKlxcXCIpfX1yZXR1cm4gZnVuY3Rpb24oZSl7c2V0VGltZW91dChlLDApfX0oKTtuLnRpdGxlPVxcXCJicm93c2VyXFxcIjtuLmJyb3dzZXI9ITA7bi5lbnY9e307bi5hcmd2PVtdO24ub249ZTtuLm9uY2U9ZTtuLm9mZj1lO24uZW1pdD1lO24uYmluZGluZz1mdW5jdGlvbihlKXt0aHJvdyBFcnJvcihcXFwicHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWRcXFwiKTt9O24uY3dkPWZ1bmN0aW9uKCl7cmV0dXJuXFxcIi9cXFwifTtuLmNoZGlyPWZ1bmN0aW9uKGUpe3Rocm93IEVycm9yKFxcXCJwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWRcXFwiKTt9fSx7fV0sOTpbZnVuY3Rpb24obix3LHQpe3QuU291cmNlTWFwR2VuZXJhdG9yPW4oXFxcIi4vc291cmNlLW1hcC9zb3VyY2UtbWFwLWdlbmVyYXRvclxcXCIpLlNvdXJjZU1hcEdlbmVyYXRvcjt0LlNvdXJjZU1hcENvbnN1bWVyPW4oXFxcIi4vc291cmNlLW1hcC9zb3VyY2UtbWFwLWNvbnN1bWVyXFxcIikuU291cmNlTWFwQ29uc3VtZXI7dC5Tb3VyY2VOb2RlPW4oXFxcIi4vc291cmNlLW1hcC9zb3VyY2Utbm9kZVxcXCIpLlNvdXJjZU5vZGV9LFxcbntcXFwiLi9zb3VyY2UtbWFwL3NvdXJjZS1tYXAtY29uc3VtZXJcXFwiOjE0LFxcXCIuL3NvdXJjZS1tYXAvc291cmNlLW1hcC1nZW5lcmF0b3JcXFwiOjE1LFxcXCIuL3NvdXJjZS1tYXAvc291cmNlLW5vZGVcXFwiOjE2fV0sMTA6W2Z1bmN0aW9uKG4sdyx0KXtpZihcXFwiZnVuY3Rpb25cXFwiIT09dHlwZW9mIGUpdmFyIGU9bihcXFwiYW1kZWZpbmVcXFwiKSh3LG4pO2UoZnVuY3Rpb24oZSxsLG0pe2Z1bmN0aW9uIGcoKXt0aGlzLl9hcnJheT1bXTt0aGlzLl9zZXQ9e319dmFyIGI9ZShcXFwiLi91dGlsXFxcIik7Zy5mcm9tQXJyYXk9ZnVuY3Rpb24oYixlKXtmb3IodmFyIGE9bmV3IGcsYz0wLGQ9Yi5sZW5ndGg7YzxkO2MrKylhLmFkZChiW2NdLGUpO3JldHVybiBhfTtnLnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24oZixlKXt2YXIgYT10aGlzLmhhcyhmKSxjPXRoaXMuX2FycmF5Lmxlbmd0aDthJiYhZXx8dGhpcy5fYXJyYXkucHVzaChmKTthfHwodGhpcy5fc2V0W2IudG9TZXRTdHJpbmcoZildPWMpfTtnLnByb3RvdHlwZS5oYXM9ZnVuY3Rpb24oZil7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLl9zZXQsXFxuYi50b1NldFN0cmluZyhmKSl9O2cucHJvdG90eXBlLmluZGV4T2Y9ZnVuY3Rpb24oZil7aWYodGhpcy5oYXMoZikpcmV0dXJuIHRoaXMuX3NldFtiLnRvU2V0U3RyaW5nKGYpXTt0aHJvdyBFcnJvcignXFxcIicrZisnXFxcIiBpcyBub3QgaW4gdGhlIHNldC4nKTt9O2cucHJvdG90eXBlLmF0PWZ1bmN0aW9uKGIpe2lmKDA8PWImJmI8dGhpcy5fYXJyYXkubGVuZ3RoKXJldHVybiB0aGlzLl9hcnJheVtiXTt0aHJvdyBFcnJvcihcXFwiTm8gZWxlbWVudCBpbmRleGVkIGJ5IFxcXCIrYik7fTtnLnByb3RvdHlwZS50b0FycmF5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2FycmF5LnNsaWNlKCl9O2wuQXJyYXlTZXQ9Z30pfSx7XFxcIi4vdXRpbFxcXCI6MTcsYW1kZWZpbmU6Mn1dLDExOltmdW5jdGlvbihuLHcsdCl7aWYoXFxcImZ1bmN0aW9uXFxcIiE9PXR5cGVvZiBlKXZhciBlPW4oXFxcImFtZGVmaW5lXFxcIikodyxuKTtlKGZ1bmN0aW9uKGUsbCxtKXt2YXIgZz1lKFxcXCIuL2Jhc2U2NFxcXCIpO2wuZW5jb2RlPWZ1bmN0aW9uKGIpe3ZhciBlPVxcblxcXCJcXFwiLGs9MD5iPygtYjw8MSkrMTooYjw8MSkrMDtkbyBiPWsmMzEsaz4+Pj01LDA8ayYmKGJ8PTMyKSxlKz1nLmVuY29kZShiKTt3aGlsZSgwPGspO3JldHVybiBlfTtsLmRlY29kZT1mdW5jdGlvbihiKXt2YXIgZT0wLGs9Yi5sZW5ndGgsYT0wLGM9MCxkLHk7ZG97aWYoZT49ayl0aHJvdyBFcnJvcihcXFwiRXhwZWN0ZWQgbW9yZSBkaWdpdHMgaW4gYmFzZSA2NCBWTFEgdmFsdWUuXFxcIik7eT1nLmRlY29kZShiLmNoYXJBdChlKyspKTtkPSEhKHkmMzIpO3kmPTMxO2ErPXk8PGM7Yys9NX13aGlsZShkKTtrPWE+PjE7cmV0dXJue3ZhbHVlOjE9PT0oYSYxKT8tazprLHJlc3Q6Yi5zbGljZShlKX19fSl9LHtcXFwiLi9iYXNlNjRcXFwiOjEyLGFtZGVmaW5lOjJ9XSwxMjpbZnVuY3Rpb24obix3LHQpe2lmKFxcXCJmdW5jdGlvblxcXCIhPT10eXBlb2YgZSl2YXIgZT1uKFxcXCJhbWRlZmluZVxcXCIpKHcsbik7ZShmdW5jdGlvbihlLGwsbSl7dmFyIGc9e30sYj17fTtcXFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1xcXCIuc3BsaXQoXFxcIlxcXCIpLmZvckVhY2goZnVuY3Rpb24oZSxcXG5rKXtnW2VdPWs7YltrXT1lfSk7bC5lbmNvZGU9ZnVuY3Rpb24oZSl7aWYoZSBpbiBiKXJldHVybiBiW2VdO3Rocm93IG5ldyBUeXBlRXJyb3IoXFxcIk11c3QgYmUgYmV0d2VlbiAwIGFuZCA2MzogXFxcIitlKTt9O2wuZGVjb2RlPWZ1bmN0aW9uKGIpe2lmKGIgaW4gZylyZXR1cm4gZ1tiXTt0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJOb3QgYSB2YWxpZCBiYXNlIDY0IGRpZ2l0OiBcXFwiK2IpO319KX0se2FtZGVmaW5lOjJ9XSwxMzpbZnVuY3Rpb24obix3LHQpe2lmKFxcXCJmdW5jdGlvblxcXCIhPT10eXBlb2YgZSl2YXIgZT1uKFxcXCJhbWRlZmluZVxcXCIpKHcsbik7ZShmdW5jdGlvbihlLGwsbSl7ZnVuY3Rpb24gZyhiLGUsayxhLGMpe3ZhciBkPU1hdGguZmxvb3IoKGUtYikvMikrYix5PWMoayxhW2RdLCEwKTtyZXR1cm4gMD09PXk/YVtkXTowPHk/MTxlLWQ/ZyhkLGUsayxhLGMpOmFbZF06MTxkLWI/ZyhiLGQsayxhLGMpOjA+Yj9udWxsOmFbYl19bC5zZWFyY2g9ZnVuY3Rpb24oYixlLGspe3JldHVybiAwPGUubGVuZ3RoP1xcbmcoLTEsZS5sZW5ndGgsYixlLGspOm51bGx9fSl9LHthbWRlZmluZToyfV0sMTQ6W2Z1bmN0aW9uKG4sdyx0KXtpZihcXFwiZnVuY3Rpb25cXFwiIT09dHlwZW9mIGUpdmFyIGU9bihcXFwiYW1kZWZpbmVcXFwiKSh3LG4pO2UoZnVuY3Rpb24oZSxsLG0pe2Z1bmN0aW9uIGcoYSl7dmFyIGQ9YTtcXFwic3RyaW5nXFxcIj09PXR5cGVvZiBhJiYoZD1KU09OLnBhcnNlKGEucmVwbGFjZSgvXlxcXFwpXFxcXF1cXFxcfScvLFxcXCJcXFwiKSkpO2E9Yi5nZXRBcmcoZCxcXFwidmVyc2lvblxcXCIpO3ZhciBlPWIuZ2V0QXJnKGQsXFxcInNvdXJjZXNcXFwiKSxmPWIuZ2V0QXJnKGQsXFxcIm5hbWVzXFxcIixbXSksZz1iLmdldEFyZyhkLFxcXCJzb3VyY2VSb290XFxcIixudWxsKSxsPWIuZ2V0QXJnKGQsXFxcInNvdXJjZXNDb250ZW50XFxcIixudWxsKSxtPWIuZ2V0QXJnKGQsXFxcIm1hcHBpbmdzXFxcIiksZD1iLmdldEFyZyhkLFxcXCJmaWxlXFxcIixudWxsKTtpZihhIT10aGlzLl92ZXJzaW9uKXRocm93IEVycm9yKFxcXCJVbnN1cHBvcnRlZCB2ZXJzaW9uOiBcXFwiK2EpO3RoaXMuX25hbWVzPWsuZnJvbUFycmF5KGYsITApO1xcbnRoaXMuX3NvdXJjZXM9ay5mcm9tQXJyYXkoZSwhMCk7dGhpcy5zb3VyY2VSb290PWc7dGhpcy5zb3VyY2VzQ29udGVudD1sO3RoaXMuX21hcHBpbmdzPW07dGhpcy5maWxlPWR9dmFyIGI9ZShcXFwiLi91dGlsXFxcIiksZj1lKFxcXCIuL2JpbmFyeS1zZWFyY2hcXFwiKSxrPWUoXFxcIi4vYXJyYXktc2V0XFxcIikuQXJyYXlTZXQsYT1lKFxcXCIuL2Jhc2U2NC12bHFcXFwiKTtnLmZyb21Tb3VyY2VNYXA9ZnVuY3Rpb24oYSl7dmFyIGQ9T2JqZWN0LmNyZWF0ZShnLnByb3RvdHlwZSk7ZC5fbmFtZXM9ay5mcm9tQXJyYXkoYS5fbmFtZXMudG9BcnJheSgpLCEwKTtkLl9zb3VyY2VzPWsuZnJvbUFycmF5KGEuX3NvdXJjZXMudG9BcnJheSgpLCEwKTtkLnNvdXJjZVJvb3Q9YS5fc291cmNlUm9vdDtkLnNvdXJjZXNDb250ZW50PWEuX2dlbmVyYXRlU291cmNlc0NvbnRlbnQoZC5fc291cmNlcy50b0FycmF5KCksZC5zb3VyY2VSb290KTtkLmZpbGU9YS5fZmlsZTtkLl9fZ2VuZXJhdGVkTWFwcGluZ3M9YS5fbWFwcGluZ3Muc2xpY2UoKS5zb3J0KGIuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zKTtcXG5kLl9fb3JpZ2luYWxNYXBwaW5ncz1hLl9tYXBwaW5ncy5zbGljZSgpLnNvcnQoYi5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyk7cmV0dXJuIGR9O2cucHJvdG90eXBlLl92ZXJzaW9uPTM7T2JqZWN0LmRlZmluZVByb3BlcnR5KGcucHJvdG90eXBlLFxcXCJzb3VyY2VzXFxcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3NvdXJjZXMudG9BcnJheSgpLm1hcChmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5zb3VyY2VSb290P2Iuam9pbih0aGlzLnNvdXJjZVJvb3QsYSk6YX0sdGhpcyl9fSk7Zy5wcm90b3R5cGUuX19nZW5lcmF0ZWRNYXBwaW5ncz1udWxsO09iamVjdC5kZWZpbmVQcm9wZXJ0eShnLnByb3RvdHlwZSxcXFwiX2dlbmVyYXRlZE1hcHBpbmdzXFxcIix7Z2V0OmZ1bmN0aW9uKCl7dGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzfHwodGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzPVtdLHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzPVtdLHRoaXMuX3BhcnNlTWFwcGluZ3ModGhpcy5fbWFwcGluZ3MsXFxudGhpcy5zb3VyY2VSb290KSk7cmV0dXJuIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5nc319KTtnLnByb3RvdHlwZS5fX29yaWdpbmFsTWFwcGluZ3M9bnVsbDtPYmplY3QuZGVmaW5lUHJvcGVydHkoZy5wcm90b3R5cGUsXFxcIl9vcmlnaW5hbE1hcHBpbmdzXFxcIix7Z2V0OmZ1bmN0aW9uKCl7dGhpcy5fX29yaWdpbmFsTWFwcGluZ3N8fCh0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3M9W10sdGhpcy5fX29yaWdpbmFsTWFwcGluZ3M9W10sdGhpcy5fcGFyc2VNYXBwaW5ncyh0aGlzLl9tYXBwaW5ncyx0aGlzLnNvdXJjZVJvb3QpKTtyZXR1cm4gdGhpcy5fX29yaWdpbmFsTWFwcGluZ3N9fSk7Zy5wcm90b3R5cGUuX3BhcnNlTWFwcGluZ3M9ZnVuY3Rpb24oYyxkKXtmb3IodmFyIGU9MSxmPTAsZz0wLGs9MCxsPTAsbT0wLHI9L15bLDtdLyx1PWMsbjswPHUubGVuZ3RoOylpZihcXFwiO1xcXCI9PT11LmNoYXJBdCgwKSllKyssdT11LnNsaWNlKDEpLGY9MDtlbHNlIGlmKFxcXCIsXFxcIj09PXUuY2hhckF0KDApKXU9dS5zbGljZSgxKTtcXG5lbHNle249e307bi5nZW5lcmF0ZWRMaW5lPWU7dT1hLmRlY29kZSh1KTtuLmdlbmVyYXRlZENvbHVtbj1mK3UudmFsdWU7Zj1uLmdlbmVyYXRlZENvbHVtbjt1PXUucmVzdDtpZigwPHUubGVuZ3RoJiYhci50ZXN0KHUuY2hhckF0KDApKSl7dT1hLmRlY29kZSh1KTtuLnNvdXJjZT10aGlzLl9zb3VyY2VzLmF0KGwrdS52YWx1ZSk7bCs9dS52YWx1ZTt1PXUucmVzdDtpZigwPT09dS5sZW5ndGh8fHIudGVzdCh1LmNoYXJBdCgwKSkpdGhyb3cgRXJyb3IoXFxcIkZvdW5kIGEgc291cmNlLCBidXQgbm8gbGluZSBhbmQgY29sdW1uXFxcIik7dT1hLmRlY29kZSh1KTtuLm9yaWdpbmFsTGluZT1nK3UudmFsdWU7Zz1uLm9yaWdpbmFsTGluZTtuLm9yaWdpbmFsTGluZSs9MTt1PXUucmVzdDtpZigwPT09dS5sZW5ndGh8fHIudGVzdCh1LmNoYXJBdCgwKSkpdGhyb3cgRXJyb3IoXFxcIkZvdW5kIGEgc291cmNlIGFuZCBsaW5lLCBidXQgbm8gY29sdW1uXFxcIik7dT1hLmRlY29kZSh1KTtuLm9yaWdpbmFsQ29sdW1uPVxcbmsrdS52YWx1ZTtrPW4ub3JpZ2luYWxDb2x1bW47dT11LnJlc3Q7MDx1Lmxlbmd0aCYmIXIudGVzdCh1LmNoYXJBdCgwKSkmJih1PWEuZGVjb2RlKHUpLG4ubmFtZT10aGlzLl9uYW1lcy5hdChtK3UudmFsdWUpLG0rPXUudmFsdWUsdT11LnJlc3QpfXRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncy5wdXNoKG4pO1xcXCJudW1iZXJcXFwiPT09dHlwZW9mIG4ub3JpZ2luYWxMaW5lJiZ0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncy5wdXNoKG4pfXRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncy5zb3J0KGIuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zKTt0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncy5zb3J0KGIuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMpfTtnLnByb3RvdHlwZS5fZmluZE1hcHBpbmc9ZnVuY3Rpb24oYSxkLGIsZSxnKXtpZigwPj1hW2JdKXRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkxpbmUgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMSwgZ290IFxcXCIrYVtiXSk7aWYoMD5hW2VdKXRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNvbHVtbiBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAwLCBnb3QgXFxcIitcXG5hW2VdKTtyZXR1cm4gZi5zZWFyY2goYSxkLGcpfTtnLnByb3RvdHlwZS5vcmlnaW5hbFBvc2l0aW9uRm9yPWZ1bmN0aW9uKGEpe2E9e2dlbmVyYXRlZExpbmU6Yi5nZXRBcmcoYSxcXFwibGluZVxcXCIpLGdlbmVyYXRlZENvbHVtbjpiLmdldEFyZyhhLFxcXCJjb2x1bW5cXFwiKX07aWYoYT10aGlzLl9maW5kTWFwcGluZyhhLHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzLFxcXCJnZW5lcmF0ZWRMaW5lXFxcIixcXFwiZ2VuZXJhdGVkQ29sdW1uXFxcIixiLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9ucykpe3ZhciBkPWIuZ2V0QXJnKGEsXFxcInNvdXJjZVxcXCIsbnVsbCk7ZCYmdGhpcy5zb3VyY2VSb290JiYoZD1iLmpvaW4odGhpcy5zb3VyY2VSb290LGQpKTtyZXR1cm57c291cmNlOmQsbGluZTpiLmdldEFyZyhhLFxcXCJvcmlnaW5hbExpbmVcXFwiLG51bGwpLGNvbHVtbjpiLmdldEFyZyhhLFxcXCJvcmlnaW5hbENvbHVtblxcXCIsbnVsbCksbmFtZTpiLmdldEFyZyhhLFxcXCJuYW1lXFxcIixudWxsKX19cmV0dXJue3NvdXJjZTpudWxsLGxpbmU6bnVsbCxjb2x1bW46bnVsbCxcXG5uYW1lOm51bGx9fTtnLnByb3RvdHlwZS5zb3VyY2VDb250ZW50Rm9yPWZ1bmN0aW9uKGEpe2lmKCF0aGlzLnNvdXJjZXNDb250ZW50KXJldHVybiBudWxsO3RoaXMuc291cmNlUm9vdCYmKGE9Yi5yZWxhdGl2ZSh0aGlzLnNvdXJjZVJvb3QsYSkpO2lmKHRoaXMuX3NvdXJjZXMuaGFzKGEpKXJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50W3RoaXMuX3NvdXJjZXMuaW5kZXhPZihhKV07dmFyIGQ7aWYodGhpcy5zb3VyY2VSb290JiYoZD1iLnVybFBhcnNlKHRoaXMuc291cmNlUm9vdCkpKXt2YXIgZT1hLnJlcGxhY2UoL15maWxlOlxcXFwvXFxcXC8vLFxcXCJcXFwiKTtpZihcXFwiZmlsZVxcXCI9PWQuc2NoZW1lJiZ0aGlzLl9zb3VyY2VzLmhhcyhlKSlyZXR1cm4gdGhpcy5zb3VyY2VzQ29udGVudFt0aGlzLl9zb3VyY2VzLmluZGV4T2YoZSldO2lmKCghZC5wYXRofHxcXFwiL1xcXCI9PWQucGF0aCkmJnRoaXMuX3NvdXJjZXMuaGFzKFxcXCIvXFxcIithKSlyZXR1cm4gdGhpcy5zb3VyY2VzQ29udGVudFt0aGlzLl9zb3VyY2VzLmluZGV4T2YoXFxcIi9cXFwiK1xcbmEpXX10aHJvdyBFcnJvcignXFxcIicrYSsnXFxcIiBpcyBub3QgaW4gdGhlIFNvdXJjZU1hcC4nKTt9O2cucHJvdG90eXBlLmdlbmVyYXRlZFBvc2l0aW9uRm9yPWZ1bmN0aW9uKGEpe2E9e3NvdXJjZTpiLmdldEFyZyhhLFxcXCJzb3VyY2VcXFwiKSxvcmlnaW5hbExpbmU6Yi5nZXRBcmcoYSxcXFwibGluZVxcXCIpLG9yaWdpbmFsQ29sdW1uOmIuZ2V0QXJnKGEsXFxcImNvbHVtblxcXCIpfTt0aGlzLnNvdXJjZVJvb3QmJihhLnNvdXJjZT1iLnJlbGF0aXZlKHRoaXMuc291cmNlUm9vdCxhLnNvdXJjZSkpO3JldHVybihhPXRoaXMuX2ZpbmRNYXBwaW5nKGEsdGhpcy5fb3JpZ2luYWxNYXBwaW5ncyxcXFwib3JpZ2luYWxMaW5lXFxcIixcXFwib3JpZ2luYWxDb2x1bW5cXFwiLGIuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMpKT97bGluZTpiLmdldEFyZyhhLFxcXCJnZW5lcmF0ZWRMaW5lXFxcIixudWxsKSxjb2x1bW46Yi5nZXRBcmcoYSxcXFwiZ2VuZXJhdGVkQ29sdW1uXFxcIixudWxsKX06e2xpbmU6bnVsbCxjb2x1bW46bnVsbH19O2cuR0VORVJBVEVEX09SREVSPVxcbjE7Zy5PUklHSU5BTF9PUkRFUj0yO2cucHJvdG90eXBlLmVhY2hNYXBwaW5nPWZ1bmN0aW9uKGEsZCxlKXtkPWR8fG51bGw7c3dpdGNoKGV8fGcuR0VORVJBVEVEX09SREVSKXtjYXNlIGcuR0VORVJBVEVEX09SREVSOmU9dGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3M7YnJlYWs7Y2FzZSBnLk9SSUdJTkFMX09SREVSOmU9dGhpcy5fb3JpZ2luYWxNYXBwaW5nczticmVhaztkZWZhdWx0OnRocm93IEVycm9yKFxcXCJVbmtub3duIG9yZGVyIG9mIGl0ZXJhdGlvbi5cXFwiKTt9dmFyIGY9dGhpcy5zb3VyY2VSb290O2UubWFwKGZ1bmN0aW9uKGEpe3ZhciBjPWEuc291cmNlO2MmJmYmJihjPWIuam9pbihmLGMpKTtyZXR1cm57c291cmNlOmMsZ2VuZXJhdGVkTGluZTphLmdlbmVyYXRlZExpbmUsZ2VuZXJhdGVkQ29sdW1uOmEuZ2VuZXJhdGVkQ29sdW1uLG9yaWdpbmFsTGluZTphLm9yaWdpbmFsTGluZSxvcmlnaW5hbENvbHVtbjphLm9yaWdpbmFsQ29sdW1uLG5hbWU6YS5uYW1lfX0pLmZvckVhY2goYSxcXG5kKX07bC5Tb3VyY2VNYXBDb25zdW1lcj1nfSl9LHtcXFwiLi9hcnJheS1zZXRcXFwiOjEwLFxcXCIuL2Jhc2U2NC12bHFcXFwiOjExLFxcXCIuL2JpbmFyeS1zZWFyY2hcXFwiOjEzLFxcXCIuL3V0aWxcXFwiOjE3LGFtZGVmaW5lOjJ9XSwxNTpbZnVuY3Rpb24obix3LHQpe2lmKFxcXCJmdW5jdGlvblxcXCIhPT10eXBlb2YgZSl2YXIgZT1uKFxcXCJhbWRlZmluZVxcXCIpKHcsbik7ZShmdW5jdGlvbihlLGwsbSl7ZnVuY3Rpb24gZyhhKXt0aGlzLl9maWxlPWYuZ2V0QXJnKGEsXFxcImZpbGVcXFwiKTt0aGlzLl9zb3VyY2VSb290PWYuZ2V0QXJnKGEsXFxcInNvdXJjZVJvb3RcXFwiLG51bGwpO3RoaXMuX3NvdXJjZXM9bmV3IGs7dGhpcy5fbmFtZXM9bmV3IGs7dGhpcy5fbWFwcGluZ3M9W107dGhpcy5fc291cmNlc0NvbnRlbnRzPW51bGx9dmFyIGI9ZShcXFwiLi9iYXNlNjQtdmxxXFxcIiksZj1lKFxcXCIuL3V0aWxcXFwiKSxrPWUoXFxcIi4vYXJyYXktc2V0XFxcIikuQXJyYXlTZXQ7Zy5wcm90b3R5cGUuX3ZlcnNpb249MztnLmZyb21Tb3VyY2VNYXA9ZnVuY3Rpb24oYSl7dmFyIGM9YS5zb3VyY2VSb290LFxcbmQ9bmV3IGcoe2ZpbGU6YS5maWxlLHNvdXJjZVJvb3Q6Y30pO2EuZWFjaE1hcHBpbmcoZnVuY3Rpb24oYSl7dmFyIGI9e2dlbmVyYXRlZDp7bGluZTphLmdlbmVyYXRlZExpbmUsY29sdW1uOmEuZ2VuZXJhdGVkQ29sdW1ufX07YS5zb3VyY2UmJihiLnNvdXJjZT1hLnNvdXJjZSxjJiYoYi5zb3VyY2U9Zi5yZWxhdGl2ZShjLGIuc291cmNlKSksYi5vcmlnaW5hbD17bGluZTphLm9yaWdpbmFsTGluZSxjb2x1bW46YS5vcmlnaW5hbENvbHVtbn0sYS5uYW1lJiYoYi5uYW1lPWEubmFtZSkpO2QuYWRkTWFwcGluZyhiKX0pO2Euc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uKGMpe3ZhciBiPWEuc291cmNlQ29udGVudEZvcihjKTtiJiZkLnNldFNvdXJjZUNvbnRlbnQoYyxiKX0pO3JldHVybiBkfTtnLnByb3RvdHlwZS5hZGRNYXBwaW5nPWZ1bmN0aW9uKGEpe3ZhciBjPWYuZ2V0QXJnKGEsXFxcImdlbmVyYXRlZFxcXCIpLGQ9Zi5nZXRBcmcoYSxcXFwib3JpZ2luYWxcXFwiLG51bGwpLGI9Zi5nZXRBcmcoYSxcXFwic291cmNlXFxcIixcXG5udWxsKTthPWYuZ2V0QXJnKGEsXFxcIm5hbWVcXFwiLG51bGwpO3RoaXMuX3ZhbGlkYXRlTWFwcGluZyhjLGQsYixhKTtiJiYhdGhpcy5fc291cmNlcy5oYXMoYikmJnRoaXMuX3NvdXJjZXMuYWRkKGIpO2EmJiF0aGlzLl9uYW1lcy5oYXMoYSkmJnRoaXMuX25hbWVzLmFkZChhKTt0aGlzLl9tYXBwaW5ncy5wdXNoKHtnZW5lcmF0ZWRMaW5lOmMubGluZSxnZW5lcmF0ZWRDb2x1bW46Yy5jb2x1bW4sb3JpZ2luYWxMaW5lOm51bGwhPWQmJmQubGluZSxvcmlnaW5hbENvbHVtbjpudWxsIT1kJiZkLmNvbHVtbixzb3VyY2U6YixuYW1lOmF9KX07Zy5wcm90b3R5cGUuc2V0U291cmNlQ29udGVudD1mdW5jdGlvbihhLGMpe3ZhciBkPWE7dGhpcy5fc291cmNlUm9vdCYmKGQ9Zi5yZWxhdGl2ZSh0aGlzLl9zb3VyY2VSb290LGQpKTtudWxsIT09Yz8odGhpcy5fc291cmNlc0NvbnRlbnRzfHwodGhpcy5fc291cmNlc0NvbnRlbnRzPXt9KSx0aGlzLl9zb3VyY2VzQ29udGVudHNbZi50b1NldFN0cmluZyhkKV09XFxuYyk6KGRlbGV0ZSB0aGlzLl9zb3VyY2VzQ29udGVudHNbZi50b1NldFN0cmluZyhkKV0sMD09PU9iamVjdC5rZXlzKHRoaXMuX3NvdXJjZXNDb250ZW50cykubGVuZ3RoJiYodGhpcy5fc291cmNlc0NvbnRlbnRzPW51bGwpKX07Zy5wcm90b3R5cGUuYXBwbHlTb3VyY2VNYXA9ZnVuY3Rpb24oYSxjKXtjfHwoYz1hLmZpbGUpO3ZhciBkPXRoaXMuX3NvdXJjZVJvb3Q7ZCYmKGM9Zi5yZWxhdGl2ZShkLGMpKTt2YXIgYj1uZXcgayxlPW5ldyBrO3RoaXMuX21hcHBpbmdzLmZvckVhY2goZnVuY3Rpb24oZyl7aWYoZy5zb3VyY2U9PT1jJiZnLm9yaWdpbmFsTGluZSl7dmFyIGs9YS5vcmlnaW5hbFBvc2l0aW9uRm9yKHtsaW5lOmcub3JpZ2luYWxMaW5lLGNvbHVtbjpnLm9yaWdpbmFsQ29sdW1ufSk7bnVsbCE9PWsuc291cmNlJiYoZy5zb3VyY2U9ZD9mLnJlbGF0aXZlKGQsay5zb3VyY2UpOmsuc291cmNlLGcub3JpZ2luYWxMaW5lPWsubGluZSxnLm9yaWdpbmFsQ29sdW1uPWsuY29sdW1uLFxcbm51bGwhPT1rLm5hbWUmJm51bGwhPT1nLm5hbWUmJihnLm5hbWU9ay5uYW1lKSl9KGs9Zy5zb3VyY2UpJiYhYi5oYXMoaykmJmIuYWRkKGspOyhnPWcubmFtZSkmJiFlLmhhcyhnKSYmZS5hZGQoZyl9LHRoaXMpO3RoaXMuX3NvdXJjZXM9Yjt0aGlzLl9uYW1lcz1lO2Euc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uKGMpe3ZhciBiPWEuc291cmNlQ29udGVudEZvcihjKTtiJiYoZCYmKGM9Zi5yZWxhdGl2ZShkLGMpKSx0aGlzLnNldFNvdXJjZUNvbnRlbnQoYyxiKSl9LHRoaXMpfTtnLnByb3RvdHlwZS5fdmFsaWRhdGVNYXBwaW5nPWZ1bmN0aW9uKGEsYyxkLGIpe2lmKCEoYSYmXFxcImxpbmVcXFwiaW4gYSYmXFxcImNvbHVtblxcXCJpbiBhJiYwPGEubGluZSYmMDw9YS5jb2x1bW4mJiFjJiYhZCYmIWJ8fGEmJlxcXCJsaW5lXFxcImluIGEmJlxcXCJjb2x1bW5cXFwiaW4gYSYmYyYmXFxcImxpbmVcXFwiaW4gYyYmXFxcImNvbHVtblxcXCJpbiBjJiYwPGEubGluZSYmMDw9YS5jb2x1bW4mJjA8Yy5saW5lJiYwPD1jLmNvbHVtbiYmZCkpdGhyb3cgRXJyb3IoXFxcIkludmFsaWQgbWFwcGluZzogXFxcIitcXG5KU09OLnN0cmluZ2lmeSh7Z2VuZXJhdGVkOmEsc291cmNlOmQsb3JpZ2luYWw6YyxuYW1lOmJ9KSk7fTtnLnByb3RvdHlwZS5fc2VyaWFsaXplTWFwcGluZ3M9ZnVuY3Rpb24oKXt2YXIgYT0wLGM9MSxkPTAsZT0wLGc9MCxrPTAsbD1cXFwiXFxcIixtO3RoaXMuX21hcHBpbmdzLnNvcnQoZi5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnMpO2Zvcih2YXIgbj0wLHI9dGhpcy5fbWFwcGluZ3MubGVuZ3RoO248cjtuKyspe209dGhpcy5fbWFwcGluZ3Nbbl07aWYobS5nZW5lcmF0ZWRMaW5lIT09Yylmb3IoYT0wO20uZ2VuZXJhdGVkTGluZSE9PWM7KWwrPVxcXCI7XFxcIixjKys7ZWxzZSBpZigwPG4pe2lmKCFmLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9ucyhtLHRoaXMuX21hcHBpbmdzW24tMV0pKWNvbnRpbnVlO2wrPVxcXCIsXFxcIn1sKz1iLmVuY29kZShtLmdlbmVyYXRlZENvbHVtbi1hKTthPW0uZ2VuZXJhdGVkQ29sdW1uO20uc291cmNlJiYobCs9Yi5lbmNvZGUodGhpcy5fc291cmNlcy5pbmRleE9mKG0uc291cmNlKS1cXG5rKSxrPXRoaXMuX3NvdXJjZXMuaW5kZXhPZihtLnNvdXJjZSksbCs9Yi5lbmNvZGUobS5vcmlnaW5hbExpbmUtMS1lKSxlPW0ub3JpZ2luYWxMaW5lLTEsbCs9Yi5lbmNvZGUobS5vcmlnaW5hbENvbHVtbi1kKSxkPW0ub3JpZ2luYWxDb2x1bW4sbS5uYW1lJiYobCs9Yi5lbmNvZGUodGhpcy5fbmFtZXMuaW5kZXhPZihtLm5hbWUpLWcpLGc9dGhpcy5fbmFtZXMuaW5kZXhPZihtLm5hbWUpKSl9cmV0dXJuIGx9O2cucHJvdG90eXBlLl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50PWZ1bmN0aW9uKGEsYyl7cmV0dXJuIGEubWFwKGZ1bmN0aW9uKGEpe2lmKCF0aGlzLl9zb3VyY2VzQ29udGVudHMpcmV0dXJuIG51bGw7YyYmKGE9Zi5yZWxhdGl2ZShjLGEpKTthPWYudG9TZXRTdHJpbmcoYSk7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLl9zb3VyY2VzQ29udGVudHMsYSk/dGhpcy5fc291cmNlc0NvbnRlbnRzW2FdOm51bGx9LHRoaXMpfTtnLnByb3RvdHlwZS50b0pTT049XFxuZnVuY3Rpb24oKXt2YXIgYT17dmVyc2lvbjp0aGlzLl92ZXJzaW9uLGZpbGU6dGhpcy5fZmlsZSxzb3VyY2VzOnRoaXMuX3NvdXJjZXMudG9BcnJheSgpLG5hbWVzOnRoaXMuX25hbWVzLnRvQXJyYXkoKSxtYXBwaW5nczp0aGlzLl9zZXJpYWxpemVNYXBwaW5ncygpfTt0aGlzLl9zb3VyY2VSb290JiYoYS5zb3VyY2VSb290PXRoaXMuX3NvdXJjZVJvb3QpO3RoaXMuX3NvdXJjZXNDb250ZW50cyYmKGEuc291cmNlc0NvbnRlbnQ9dGhpcy5fZ2VuZXJhdGVTb3VyY2VzQ29udGVudChhLnNvdXJjZXMsYS5zb3VyY2VSb290KSk7cmV0dXJuIGF9O2cucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMpfTtsLlNvdXJjZU1hcEdlbmVyYXRvcj1nfSl9LHtcXFwiLi9hcnJheS1zZXRcXFwiOjEwLFxcXCIuL2Jhc2U2NC12bHFcXFwiOjExLFxcXCIuL3V0aWxcXFwiOjE3LGFtZGVmaW5lOjJ9XSwxNjpbZnVuY3Rpb24obix3LHQpe2lmKFxcXCJmdW5jdGlvblxcXCIhPT10eXBlb2YgZSl2YXIgZT1cXG5uKFxcXCJhbWRlZmluZVxcXCIpKHcsbik7ZShmdW5jdGlvbihlLGwsbSl7ZnVuY3Rpb24gZyhiLGEsYyxkLGUpe3RoaXMuY2hpbGRyZW49W107dGhpcy5zb3VyY2VDb250ZW50cz17fTt0aGlzLmxpbmU9dm9pZCAwPT09Yj9udWxsOmI7dGhpcy5jb2x1bW49dm9pZCAwPT09YT9udWxsOmE7dGhpcy5zb3VyY2U9dm9pZCAwPT09Yz9udWxsOmM7dGhpcy5uYW1lPXZvaWQgMD09PWU/bnVsbDplO251bGwhPWQmJnRoaXMuYWRkKGQpfXZhciBiPWUoXFxcIi4vc291cmNlLW1hcC1nZW5lcmF0b3JcXFwiKS5Tb3VyY2VNYXBHZW5lcmF0b3IsZj1lKFxcXCIuL3V0aWxcXFwiKTtnLmZyb21TdHJpbmdXaXRoU291cmNlTWFwPWZ1bmN0aW9uKGIsYSl7ZnVuY3Rpb24gYyhhLGMpe251bGw9PT1hfHx2b2lkIDA9PT1hLnNvdXJjZT9kLmFkZChjKTpkLmFkZChuZXcgZyhhLm9yaWdpbmFsTGluZSxhLm9yaWdpbmFsQ29sdW1uLGEuc291cmNlLGMsYS5uYW1lKSl9dmFyIGQ9bmV3IGcsZT1iLnNwbGl0KFxcXCJcXFxcblxcXCIpLGY9MSxsPTAsbT1udWxsO1xcbmEuZWFjaE1hcHBpbmcoZnVuY3Rpb24oYSl7aWYobnVsbD09PW0pe2Zvcig7ZjxhLmdlbmVyYXRlZExpbmU7KWQuYWRkKGUuc2hpZnQoKStcXFwiXFxcXG5cXFwiKSxmKys7aWYobDxhLmdlbmVyYXRlZENvbHVtbil7dmFyIGI9ZVswXTtkLmFkZChiLnN1YnN0cigwLGEuZ2VuZXJhdGVkQ29sdW1uKSk7ZVswXT1iLnN1YnN0cihhLmdlbmVyYXRlZENvbHVtbik7bD1hLmdlbmVyYXRlZENvbHVtbn19ZWxzZXtpZihmPGEuZ2VuZXJhdGVkTGluZSl7dmFyIGc9XFxcIlxcXCI7ZG8gZys9ZS5zaGlmdCgpK1xcXCJcXFxcblxcXCIsZisrLGw9MDt3aGlsZShmPGEuZ2VuZXJhdGVkTGluZSk7bDxhLmdlbmVyYXRlZENvbHVtbiYmKGI9ZVswXSxnKz1iLnN1YnN0cigwLGEuZ2VuZXJhdGVkQ29sdW1uKSxlWzBdPWIuc3Vic3RyKGEuZ2VuZXJhdGVkQ29sdW1uKSxsPWEuZ2VuZXJhdGVkQ29sdW1uKX1lbHNlIGI9ZVswXSxnPWIuc3Vic3RyKDAsYS5nZW5lcmF0ZWRDb2x1bW4tbCksZVswXT1iLnN1YnN0cihhLmdlbmVyYXRlZENvbHVtbi1sKSxcXG5sPWEuZ2VuZXJhdGVkQ29sdW1uO2MobSxnKX1tPWF9LHRoaXMpO2MobSxlLmpvaW4oXFxcIlxcXFxuXFxcIikpO2Euc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uKGMpe3ZhciBiPWEuc291cmNlQ29udGVudEZvcihjKTtiJiZkLnNldFNvdXJjZUNvbnRlbnQoYyxiKX0pO3JldHVybiBkfTtnLnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24oYil7aWYoQXJyYXkuaXNBcnJheShiKSliLmZvckVhY2goZnVuY3Rpb24oYSl7dGhpcy5hZGQoYSl9LHRoaXMpO2Vsc2UgaWYoYiBpbnN0YW5jZW9mIGd8fFxcXCJzdHJpbmdcXFwiPT09dHlwZW9mIGIpYiYmdGhpcy5jaGlsZHJlbi5wdXNoKGIpO2Vsc2UgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiRXhwZWN0ZWQgYSBTb3VyY2VOb2RlLCBzdHJpbmcsIG9yIGFuIGFycmF5IG9mIFNvdXJjZU5vZGVzIGFuZCBzdHJpbmdzLiBHb3QgXFxcIitiKTtyZXR1cm4gdGhpc307Zy5wcm90b3R5cGUucHJlcGVuZD1mdW5jdGlvbihiKXtpZihBcnJheS5pc0FycmF5KGIpKWZvcih2YXIgYT1iLmxlbmd0aC1cXG4xOzA8PWE7YS0tKXRoaXMucHJlcGVuZChiW2FdKTtlbHNlIGlmKGIgaW5zdGFuY2VvZiBnfHxcXFwic3RyaW5nXFxcIj09PXR5cGVvZiBiKXRoaXMuY2hpbGRyZW4udW5zaGlmdChiKTtlbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkV4cGVjdGVkIGEgU291cmNlTm9kZSwgc3RyaW5nLCBvciBhbiBhcnJheSBvZiBTb3VyY2VOb2RlcyBhbmQgc3RyaW5ncy4gR290IFxcXCIrYik7cmV0dXJuIHRoaXN9O2cucHJvdG90eXBlLndhbGs9ZnVuY3Rpb24oYil7Zm9yKHZhciBhLGM9MCxkPXRoaXMuY2hpbGRyZW4ubGVuZ3RoO2M8ZDtjKyspYT10aGlzLmNoaWxkcmVuW2NdLGEgaW5zdGFuY2VvZiBnP2Eud2FsayhiKTpcXFwiXFxcIiE9PWEmJmIoYSx7c291cmNlOnRoaXMuc291cmNlLGxpbmU6dGhpcy5saW5lLGNvbHVtbjp0aGlzLmNvbHVtbixuYW1lOnRoaXMubmFtZX0pfTtnLnByb3RvdHlwZS5qb2luPWZ1bmN0aW9uKGIpe3ZhciBhLGMsZD10aGlzLmNoaWxkcmVuLmxlbmd0aDtpZigwPGQpe2E9W107Zm9yKGM9MDtjPFxcbmQtMTtjKyspYS5wdXNoKHRoaXMuY2hpbGRyZW5bY10pLGEucHVzaChiKTthLnB1c2godGhpcy5jaGlsZHJlbltjXSk7dGhpcy5jaGlsZHJlbj1hfXJldHVybiB0aGlzfTtnLnByb3RvdHlwZS5yZXBsYWNlUmlnaHQ9ZnVuY3Rpb24oYixhKXt2YXIgYz10aGlzLmNoaWxkcmVuW3RoaXMuY2hpbGRyZW4ubGVuZ3RoLTFdO2MgaW5zdGFuY2VvZiBnP2MucmVwbGFjZVJpZ2h0KGIsYSk6XFxcInN0cmluZ1xcXCI9PT10eXBlb2YgYz90aGlzLmNoaWxkcmVuW3RoaXMuY2hpbGRyZW4ubGVuZ3RoLTFdPWMucmVwbGFjZShiLGEpOnRoaXMuY2hpbGRyZW4ucHVzaChcXFwiXFxcIi5yZXBsYWNlKGIsYSkpO3JldHVybiB0aGlzfTtnLnByb3RvdHlwZS5zZXRTb3VyY2VDb250ZW50PWZ1bmN0aW9uKGIsYSl7dGhpcy5zb3VyY2VDb250ZW50c1tmLnRvU2V0U3RyaW5nKGIpXT1hfTtnLnByb3RvdHlwZS53YWxrU291cmNlQ29udGVudHM9ZnVuY3Rpb24oYil7Zm9yKHZhciBhPTAsYz10aGlzLmNoaWxkcmVuLmxlbmd0aDthPFxcbmM7YSsrKXRoaXMuY2hpbGRyZW5bYV1pbnN0YW5jZW9mIGcmJnRoaXMuY2hpbGRyZW5bYV0ud2Fsa1NvdXJjZUNvbnRlbnRzKGIpO2Zvcih2YXIgZD1PYmplY3Qua2V5cyh0aGlzLnNvdXJjZUNvbnRlbnRzKSxhPTAsYz1kLmxlbmd0aDthPGM7YSsrKWIoZi5mcm9tU2V0U3RyaW5nKGRbYV0pLHRoaXMuc291cmNlQ29udGVudHNbZFthXV0pfTtnLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3ZhciBiPVxcXCJcXFwiO3RoaXMud2FsayhmdW5jdGlvbihhKXtiKz1hfSk7cmV0dXJuIGJ9O2cucHJvdG90eXBlLnRvU3RyaW5nV2l0aFNvdXJjZU1hcD1mdW5jdGlvbihlKXt2YXIgYT1cXFwiXFxcIixjPTEsZD0wLGY9bmV3IGIoZSksZz0hMSxsPW51bGwsbT1udWxsLG49bnVsbCxyPW51bGw7dGhpcy53YWxrKGZ1bmN0aW9uKGIsZSl7YSs9YjtudWxsIT09ZS5zb3VyY2UmJm51bGwhPT1lLmxpbmUmJm51bGwhPT1lLmNvbHVtbj8obD09PWUuc291cmNlJiZtPT09ZS5saW5lJiZuPT09ZS5jb2x1bW4mJnI9PT1cXG5lLm5hbWV8fGYuYWRkTWFwcGluZyh7c291cmNlOmUuc291cmNlLG9yaWdpbmFsOntsaW5lOmUubGluZSxjb2x1bW46ZS5jb2x1bW59LGdlbmVyYXRlZDp7bGluZTpjLGNvbHVtbjpkfSxuYW1lOmUubmFtZX0pLGw9ZS5zb3VyY2UsbT1lLmxpbmUsbj1lLmNvbHVtbixyPWUubmFtZSxnPSEwKTpnJiYoZi5hZGRNYXBwaW5nKHtnZW5lcmF0ZWQ6e2xpbmU6Yyxjb2x1bW46ZH19KSxsPW51bGwsZz0hMSk7Yi5zcGxpdChcXFwiXFxcIikuZm9yRWFjaChmdW5jdGlvbihhKXtcXFwiXFxcXG5cXFwiPT09YT8oYysrLGQ9MCk6ZCsrfSl9KTt0aGlzLndhbGtTb3VyY2VDb250ZW50cyhmdW5jdGlvbihhLGMpe2Yuc2V0U291cmNlQ29udGVudChhLGMpfSk7cmV0dXJue2NvZGU6YSxtYXA6Zn19O2wuU291cmNlTm9kZT1nfSl9LHtcXFwiLi9zb3VyY2UtbWFwLWdlbmVyYXRvclxcXCI6MTUsXFxcIi4vdXRpbFxcXCI6MTcsYW1kZWZpbmU6Mn1dLDE3OltmdW5jdGlvbihuLHcsdCl7aWYoXFxcImZ1bmN0aW9uXFxcIiE9PXR5cGVvZiBlKXZhciBlPW4oXFxcImFtZGVmaW5lXFxcIikodyxcXG5uKTtlKGZ1bmN0aW9uKGUsbCxtKXtmdW5jdGlvbiBnKGEpe3JldHVybihhPWEubWF0Y2goaykpP3tzY2hlbWU6YVsxXSxhdXRoOmFbM10saG9zdDphWzRdLHBvcnQ6YVs2XSxwYXRoOmFbN119Om51bGx9ZnVuY3Rpb24gYihhKXt2YXIgYj1hLnNjaGVtZStcXFwiOi8vXFxcIjthLmF1dGgmJihiKz1hLmF1dGgrXFxcIkBcXFwiKTthLmhvc3QmJihiKz1hLmhvc3QpO2EucG9ydCYmKGIrPVxcXCI6XFxcIithLnBvcnQpO2EucGF0aCYmKGIrPWEucGF0aCk7cmV0dXJuIGJ9ZnVuY3Rpb24gZihhLGIpe3ZhciBlPWF8fFxcXCJcXFwiLGY9Ynx8XFxcIlxcXCI7cmV0dXJuKGU+ZiktKGU8Zil9bC5nZXRBcmc9ZnVuY3Rpb24oYSxiLGUpe2lmKGIgaW4gYSlyZXR1cm4gYVtiXTtpZigzPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gZTt0aHJvdyBFcnJvcignXFxcIicrYisnXFxcIiBpcyBhIHJlcXVpcmVkIGFyZ3VtZW50LicpO307dmFyIGs9LyhbXFxcXHcrXFxcXC0uXSspOlxcXFwvXFxcXC8oKFxcXFx3KzpcXFxcdyspQCk/KFtcXFxcdy5dKyk/KDooXFxcXGQrKSk/KFxcXFxTKyk/LyxhPS9eZGF0YTouK1xcXFwsLisvO1xcbmwudXJsUGFyc2U9ZztsLnVybEdlbmVyYXRlPWI7bC5qb2luPWZ1bmN0aW9uKGMsZCl7dmFyIGU7cmV0dXJuIGQubWF0Y2goayl8fGQubWF0Y2goYSk/ZDpcXFwiL1xcXCI9PT1kLmNoYXJBdCgwKSYmKGU9ZyhjKSk/KGUucGF0aD1kLGIoZSkpOmMucmVwbGFjZSgvXFxcXC8kLyxcXFwiXFxcIikrXFxcIi9cXFwiK2R9O2wudG9TZXRTdHJpbmc9ZnVuY3Rpb24oYSl7cmV0dXJuXFxcIiRcXFwiK2F9O2wuZnJvbVNldFN0cmluZz1mdW5jdGlvbihhKXtyZXR1cm4gYS5zdWJzdHIoMSl9O2wucmVsYXRpdmU9ZnVuY3Rpb24oYSxiKXthPWEucmVwbGFjZSgvXFxcXC8kLyxcXFwiXFxcIik7dmFyIGU9ZyhhKTtyZXR1cm5cXFwiL1xcXCI9PWIuY2hhckF0KDApJiZlJiZcXFwiL1xcXCI9PWUucGF0aD9iLnNsaWNlKDEpOjA9PT1iLmluZGV4T2YoYStcXFwiL1xcXCIpP2Iuc3Vic3RyKGEubGVuZ3RoKzEpOmJ9O2wuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnM9ZnVuY3Rpb24oYSxiLGUpe3ZhciBnO3JldHVybihnPWYoYS5zb3VyY2UsYi5zb3VyY2UpKXx8KGc9YS5vcmlnaW5hbExpbmUtYi5vcmlnaW5hbExpbmUpfHxcXG4oZz1hLm9yaWdpbmFsQ29sdW1uLWIub3JpZ2luYWxDb2x1bW4pfHxlfHwoZz1mKGEubmFtZSxiLm5hbWUpKT9nOihnPWEuZ2VuZXJhdGVkTGluZS1iLmdlbmVyYXRlZExpbmUpP2c6YS5nZW5lcmF0ZWRDb2x1bW4tYi5nZW5lcmF0ZWRDb2x1bW59O2wuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zPWZ1bmN0aW9uKGEsYixlKXt2YXIgZztyZXR1cm4oZz1hLmdlbmVyYXRlZExpbmUtYi5nZW5lcmF0ZWRMaW5lKXx8KGc9YS5nZW5lcmF0ZWRDb2x1bW4tYi5nZW5lcmF0ZWRDb2x1bW4pfHxlfHwoZz1mKGEuc291cmNlLGIuc291cmNlKSl8fChnPWEub3JpZ2luYWxMaW5lLWIub3JpZ2luYWxMaW5lKT9nOihnPWEub3JpZ2luYWxDb2x1bW4tYi5vcmlnaW5hbENvbHVtbik/ZzpmKGEubmFtZSxiLm5hbWUpfX0pfSx7YW1kZWZpbmU6Mn1dLDE4OltmdW5jdGlvbihuLHcsdCl7KGZ1bmN0aW9uKGUscil7ZnVuY3Rpb24gbCgpe3JldHVyblxcXCJicm93c2VyXFxcIj09PUM/ITA6XFxcIm5vZGVcXFwiPT09Qz8hMTpcXG5cXFwidW5kZWZpbmVkXFxcIiE9PXR5cGVvZiB3aW5kb3cmJlxcXCJmdW5jdGlvblxcXCI9PT10eXBlb2YgWE1MSHR0cFJlcXVlc3R9ZnVuY3Rpb24gbShhKXthPWEudHJpbSgpO2lmKGEgaW4geilyZXR1cm4gelthXTt0cnl7aWYobCgpKXt2YXIgYj1uZXcgWE1MSHR0cFJlcXVlc3Q7Yi5vcGVuKFxcXCJHRVRcXFwiLGEsITEpO2Iuc2VuZChudWxsKTt2YXIgYz1udWxsOzQ9PT1iLnJlYWR5U3RhdGUmJjIwMD09PWIuc3RhdHVzJiYoYz1iLnJlc3BvbnNlVGV4dCl9ZWxzZSBjPUUucmVhZEZpbGVTeW5jKGEsXFxcInV0ZjhcXFwiKX1jYXRjaChkKXtjPW51bGx9cmV0dXJuIHpbYV09Y31mdW5jdGlvbiBnKGEsYil7aWYoIWEpcmV0dXJuIGI7dmFyIGM9Ri5kaXJuYW1lKGEpLGQ9L15cXFxcdys6XFxcXC9cXFxcL1teXFxcXC9dKi8uZXhlYyhjKSxkPWQ/ZFswXTpcXFwiXFxcIjtyZXR1cm4gZCtGLnJlc29sdmUoYy5zbGljZShkLmxlbmd0aCksYil9ZnVuY3Rpb24gYihhKXt2YXIgYjthOnt2YXIgYztpZihsKCkmJihjPW5ldyBYTUxIdHRwUmVxdWVzdCxjLm9wZW4oXFxcIkdFVFxcXCIsXFxuYSwhMSksYy5zZW5kKG51bGwpLGM9Yy5nZXRSZXNwb25zZUhlYWRlcihcXFwiU291cmNlTWFwXFxcIil8fGMuZ2V0UmVzcG9uc2VIZWFkZXIoXFxcIlgtU291cmNlTWFwXFxcIikpKXtiPWM7YnJlYWsgYX1jPW0oYSk7Zm9yKHZhciBkPS8oPzpcXFxcL1xcXFwvW0AjXVsgXFxcXHRdK3NvdXJjZU1hcHBpbmdVUkw9KFteXFxcXHMnXFxcIl0rPylbIFxcXFx0XSokKXwoPzpcXFxcL1xcXFwqW0AjXVsgXFxcXHRdK3NvdXJjZU1hcHBpbmdVUkw9KFteXFxcXCpdKz8pWyBcXFxcdF0qKD86XFxcXCpcXFxcLylbIFxcXFx0XSokKS9tZyxlO2U9ZC5leGVjKGMpOyliPWU7Yj1iP2JbMV06bnVsbH1pZighYilyZXR1cm4gbnVsbDtILnRlc3QoYik/KGE9Yi5zbGljZShiLmluZGV4T2YoXFxcIixcXFwiKSsxKSxhPShuZXcgcihhLFxcXCJiYXNlNjRcXFwiKSkudG9TdHJpbmcoKSxiPW51bGwpOihiPWcoYSxiKSxhPW0oYikpO3JldHVybiBhP3t1cmw6YixtYXA6YX06bnVsbH1mdW5jdGlvbiBmKGEpe3ZhciBjPURbYS5zb3VyY2VdO2lmKCFjKXt2YXIgZD1iKGEuc291cmNlKTtkPyhjPURbYS5zb3VyY2VdPXt1cmw6ZC51cmwsXFxubWFwOm5ldyBCKGQubWFwKX0sYy5tYXAuc291cmNlc0NvbnRlbnQmJmMubWFwLnNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbihhLGIpe3ZhciBkPWMubWFwLnNvdXJjZXNDb250ZW50W2JdO2lmKGQpe3ZhciBlPWcoYy51cmwsYSk7eltlXT1kfX0pKTpjPURbYS5zb3VyY2VdPXt1cmw6bnVsbCxtYXA6bnVsbH19cmV0dXJuIGMmJmMubWFwJiYoZD1jLm1hcC5vcmlnaW5hbFBvc2l0aW9uRm9yKGEpLG51bGwhPT1kLnNvdXJjZSk/KGQuc291cmNlPWcoYy51cmwsZC5zb3VyY2UpLGQpOmF9ZnVuY3Rpb24gayhhKXt2YXIgYj0vXmV2YWwgYXQgKFteKF0rKSBcXFxcKCguKyk6KFxcXFxkKyk6KFxcXFxkKylcXFxcKSQvLmV4ZWMoYSk7cmV0dXJuIGI/KGE9Zih7c291cmNlOmJbMl0sbGluZTpiWzNdLGNvbHVtbjpiWzRdLTF9KSxcXFwiZXZhbCBhdCBcXFwiK2JbMV0rXFxcIiAoXFxcIithLnNvdXJjZStcXFwiOlxcXCIrYS5saW5lK1xcXCI6XFxcIisoYS5jb2x1bW4rMSkrXFxcIilcXFwiKTooYj0vXmV2YWwgYXQgKFteKF0rKSBcXFxcKCguKylcXFxcKSQvLmV4ZWMoYSkpP1xcXCJldmFsIGF0IFxcXCIrXFxuYlsxXStcXFwiIChcXFwiK2soYlsyXSkrXFxcIilcXFwiOmF9ZnVuY3Rpb24gYSgpe3ZhciBhLGI9XFxcIlxcXCI7dGhpcy5pc05hdGl2ZSgpP2I9XFxcIm5hdGl2ZVxcXCI6KGE9dGhpcy5nZXRTY3JpcHROYW1lT3JTb3VyY2VVUkwoKSwhYSYmdGhpcy5pc0V2YWwoKSYmKGI9dGhpcy5nZXRFdmFsT3JpZ2luKCksYis9XFxcIiwgXFxcIiksYj1hP2IrYTpiK1xcXCI8YW5vbnltb3VzPlxcXCIsYT10aGlzLmdldExpbmVOdW1iZXIoKSxudWxsIT1hJiYoYis9XFxcIjpcXFwiK2EsKGE9dGhpcy5nZXRDb2x1bW5OdW1iZXIoKSkmJihiKz1cXFwiOlxcXCIrYSkpKTthPVxcXCJcXFwiO3ZhciBjPXRoaXMuZ2V0RnVuY3Rpb25OYW1lKCksZD0hMCxlPXRoaXMuaXNDb25zdHJ1Y3RvcigpO2lmKHRoaXMuaXNUb3BsZXZlbCgpfHxlKWU/YSs9XFxcIm5ldyBcXFwiKyhjfHxcXFwiPGFub255bW91cz5cXFwiKTpjP2ErPWM6KGErPWIsZD0hMSk7ZWxzZXt2YXIgZT10aGlzLmdldFR5cGVOYW1lKCksZj10aGlzLmdldE1ldGhvZE5hbWUoKTtjPyhlJiYwIT1jLmluZGV4T2YoZSkmJihhKz1lK1xcXCIuXFxcIiksYSs9YyxmJiZjLmluZGV4T2YoXFxcIi5cXFwiK1xcbmYpIT1jLmxlbmd0aC1mLmxlbmd0aC0xJiYoYSs9XFxcIiBbYXMgXFxcIitmK1xcXCJdXFxcIikpOmErPWUrXFxcIi5cXFwiKyhmfHxcXFwiPGFub255bW91cz5cXFwiKX1kJiYoYSs9XFxcIiAoXFxcIitiK1xcXCIpXFxcIik7cmV0dXJuIGF9ZnVuY3Rpb24gYyhiKXt2YXIgYz17fTtPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPYmplY3QuZ2V0UHJvdG90eXBlT2YoYikpLmZvckVhY2goZnVuY3Rpb24oYSl7Y1thXT0vXig/OmlzfGdldCkvLnRlc3QoYSk/ZnVuY3Rpb24oKXtyZXR1cm4gYlthXS5jYWxsKGIpfTpiW2FdfSk7Yy50b1N0cmluZz1hO3JldHVybiBjfWZ1bmN0aW9uIGQoYSl7dmFyIGI9YS5nZXRGaWxlTmFtZSgpfHxhLmdldFNjcmlwdE5hbWVPclNvdXJjZVVSTCgpO2lmKGIpe3ZhciBkPWEuZ2V0TGluZU51bWJlcigpLGU9YS5nZXRDb2x1bW5OdW1iZXIoKS0xOzEhPT1kfHxsKCl8fGEuaXNFdmFsKCl8fChlLT02Mik7dmFyIGc9Zih7c291cmNlOmIsbGluZTpkLGNvbHVtbjplfSk7YT1jKGEpO2EuZ2V0RmlsZU5hbWU9ZnVuY3Rpb24oKXtyZXR1cm4gZy5zb3VyY2V9O1xcbmEuZ2V0TGluZU51bWJlcj1mdW5jdGlvbigpe3JldHVybiBnLmxpbmV9O2EuZ2V0Q29sdW1uTnVtYmVyPWZ1bmN0aW9uKCl7cmV0dXJuIGcuY29sdW1uKzF9O2EuZ2V0U2NyaXB0TmFtZU9yU291cmNlVVJMPWZ1bmN0aW9uKCl7cmV0dXJuIGcuc291cmNlfTtyZXR1cm4gYX12YXIgbT1hLmlzRXZhbCgpJiZhLmdldEV2YWxPcmlnaW4oKTttJiYobT1rKG0pLGE9YyhhKSxhLmdldEV2YWxPcmlnaW49ZnVuY3Rpb24oKXtyZXR1cm4gbX0pO3JldHVybiBhfWZ1bmN0aW9uIHcoYSxiKXt1JiYoej17fSxEPXt9KTtyZXR1cm4gYStiLm1hcChmdW5jdGlvbihhKXtyZXR1cm5cXFwiXFxcXG4gICAgYXQgXFxcIitkKGEpfSkuam9pbihcXFwiXFxcIil9ZnVuY3Rpb24geChhKXt2YXIgYj0vXFxcXG4gICAgYXQgW14oXSsgXFxcXCgoLiopOihcXFxcZCspOihcXFxcZCspXFxcXCkvLmV4ZWMoYS5zdGFjayk7aWYoYil7YT1iWzFdO3ZhciBjPStiWzJdLGI9K2JbM10sZD16W2FdOyFkJiZFLmV4aXN0c1N5bmMoYSkmJihkPUUucmVhZEZpbGVTeW5jKGEsXFxcInV0ZjhcXFwiKSk7XFxuaWYoZCYmKGQ9ZC5zcGxpdCgvKD86XFxcXHJcXFxcbnxcXFxccnxcXFxcbikvKVtjLTFdKSlyZXR1cm4gYStcXFwiOlxcXCIrYytcXFwiXFxcXG5cXFwiK2QrXFxcIlxcXFxuXFxcIitBcnJheShiKS5qb2luKFxcXCIgXFxcIikrXFxcIl5cXFwifXJldHVybiBudWxsfWZ1bmN0aW9uIEEoKXt2YXIgYT1lLmVtaXQ7ZS5lbWl0PWZ1bmN0aW9uKGIpe2lmKFxcXCJ1bmNhdWdodEV4Y2VwdGlvblxcXCI9PT1iKXt2YXIgYz1hcmd1bWVudHNbMV0mJmFyZ3VtZW50c1sxXS5zdGFjayxkPTA8dGhpcy5saXN0ZW5lcnMoYikubGVuZ3RoO2lmKGMmJiFkKXtjPWFyZ3VtZW50c1sxXTtpZihkPXgoYykpY29uc29sZS5lcnJvcigpLGNvbnNvbGUuZXJyb3IoZCk7Y29uc29sZS5lcnJvcihjLnN0YWNrKTtlLmV4aXQoMSk7cmV0dXJufX1yZXR1cm4gYS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9fXZhciBCPW4oXFxcInNvdXJjZS1tYXBcXFwiKS5Tb3VyY2VNYXBDb25zdW1lcixGPW4oXFxcInBhdGhcXFwiKSxFPW4oXFxcImZzXFxcIiksRz0hMSx1PSExLEM9XFxcImF1dG9cXFwiLHo9e30sRD17fSxIPS9eZGF0YTphcHBsaWNhdGlvblxcXFwvanNvblteLF0rYmFzZTY0LC87XFxudC53cmFwQ2FsbFNpdGU9ZDt0LmdldEVycm9yU291cmNlPXg7dC5tYXBTb3VyY2VQb3NpdGlvbj1mO3QucmV0cmlldmVTb3VyY2VNYXA9Yjt0Lmluc3RhbGw9ZnVuY3Rpb24oYSl7aWYoIUcpe0c9ITA7RXJyb3IucHJlcGFyZVN0YWNrVHJhY2U9dzthPWF8fHt9O3ZhciBjPVxcXCJoYW5kbGVVbmNhdWdodEV4Y2VwdGlvbnNcXFwiaW4gYT9hLmhhbmRsZVVuY2F1Z2h0RXhjZXB0aW9uczohMDt1PVxcXCJlbXB0eUNhY2hlQmV0d2Vlbk9wZXJhdGlvbnNcXFwiaW4gYT9hLmVtcHR5Q2FjaGVCZXR3ZWVuT3BlcmF0aW9uczohMTtpZihhLmVudmlyb25tZW50JiYoQz1hLmVudmlyb25tZW50LC0xPT09W1xcXCJub2RlXFxcIixcXFwiYnJvd3NlclxcXCIsXFxcImF1dG9cXFwiXS5pbmRleE9mKEMpKSl0aHJvdyBFcnJvcihcXFwiZW52aXJvbm1lbnQgXFxcIitDK1xcXCIgd2FzIHVua25vd24uIEF2YWlsYWJsZSBvcHRpb25zIGFyZSB7YXV0bywgYnJvd3Nlciwgbm9kZX1cXFwiKTthLnJldHJpZXZlRmlsZSYmKG09YS5yZXRyaWV2ZUZpbGUpO2EucmV0cmlldmVTb3VyY2VNYXAmJlxcbihiPWEucmV0cmlldmVTb3VyY2VNYXApO2MmJlxcXCJvYmplY3RcXFwiPT09dHlwZW9mIGUmJm51bGwhPT1lJiZcXFwiZnVuY3Rpb25cXFwiPT09dHlwZW9mIGUub24mJkEoKX19fSkuY2FsbCh0aGlzLG4oXFxcIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanNcXFwiKSxuKFxcXCJidWZmZXJcXFwiKS5CdWZmZXIpfSx7XFxcIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanNcXFwiOjgsYnVmZmVyOjUsZnM6NCxwYXRoOjcsXFxcInNvdXJjZS1tYXBcXFwiOjl9XX0se30sWzFdKTtyZXR1cm4gS30pO1xcblwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc291cmNlLW1hcC1zdXBwb3J0L2Jyb3dzZXItc291cmNlLW1hcC1zdXBwb3J0LmpzXG4gKiogbW9kdWxlIGlkID0gNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIi8qXFxuQ29weXJpZ2h0IChjKSAyMDA4LTIwMTUgUGl2b3RhbCBMYWJzXFxuXFxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nXFxuYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXFxuXFxcIlNvZnR3YXJlXFxcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xcbndpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcXG5kaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cXG5wZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG9cXG50aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XFxuXFxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcXG5pbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cXG5cXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXFxcIkFTIElTXFxcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcXG5FWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcXG5NRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxcbk5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkVcXG5MSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OXFxuT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXFxuV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXFxuKi9cXG52YXIgZ2V0SmFzbWluZVJlcXVpcmVPYmogPSAoZnVuY3Rpb24gKGphc21pbmVHbG9iYWwpIHtcXG4gIHZhciBqYXNtaW5lUmVxdWlyZTtcXG5cXG4gIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xcbiAgICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICBqYXNtaW5lR2xvYmFsID0gZ2xvYmFsO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGphc21pbmVHbG9iYWwgPSB7fTtcXG4gICAgfVxcbiAgICBqYXNtaW5lUmVxdWlyZSA9IGV4cG9ydHM7XFxuICB9IGVsc2Uge1xcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy50b1N0cmluZyA9PT0gJ2Z1bmN0aW9uJyAmJiB3aW5kb3cudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgR2pzR2xvYmFsXScpIHtcXG4gICAgICBqYXNtaW5lR2xvYmFsID0gd2luZG93O1xcbiAgICB9XFxuICAgIGphc21pbmVSZXF1aXJlID0gamFzbWluZUdsb2JhbC5qYXNtaW5lUmVxdWlyZSA9IGphc21pbmVHbG9iYWwuamFzbWluZVJlcXVpcmUgfHwge307XFxuICB9XFxuXFxuICBmdW5jdGlvbiBnZXRKYXNtaW5lUmVxdWlyZSgpIHtcXG4gICAgcmV0dXJuIGphc21pbmVSZXF1aXJlO1xcbiAgfVxcblxcbiAgZ2V0SmFzbWluZVJlcXVpcmUoKS5jb3JlID0gZnVuY3Rpb24oalJlcXVpcmUpIHtcXG4gICAgdmFyIGokID0ge307XFxuXFxuICAgIGpSZXF1aXJlLmJhc2UoaiQsIGphc21pbmVHbG9iYWwpO1xcbiAgICBqJC51dGlsID0galJlcXVpcmUudXRpbCgpO1xcbiAgICBqJC5lcnJvcnMgPSBqUmVxdWlyZS5lcnJvcnMoKTtcXG4gICAgaiQuQW55ID0galJlcXVpcmUuQW55KGokKTtcXG4gICAgaiQuQW55dGhpbmcgPSBqUmVxdWlyZS5Bbnl0aGluZyhqJCk7XFxuICAgIGokLkNhbGxUcmFja2VyID0galJlcXVpcmUuQ2FsbFRyYWNrZXIoKTtcXG4gICAgaiQuTW9ja0RhdGUgPSBqUmVxdWlyZS5Nb2NrRGF0ZSgpO1xcbiAgICBqJC5DbG9jayA9IGpSZXF1aXJlLkNsb2NrKCk7XFxuICAgIGokLkRlbGF5ZWRGdW5jdGlvblNjaGVkdWxlciA9IGpSZXF1aXJlLkRlbGF5ZWRGdW5jdGlvblNjaGVkdWxlcigpO1xcbiAgICBqJC5FbnYgPSBqUmVxdWlyZS5FbnYoaiQpO1xcbiAgICBqJC5FeGNlcHRpb25Gb3JtYXR0ZXIgPSBqUmVxdWlyZS5FeGNlcHRpb25Gb3JtYXR0ZXIoKTtcXG4gICAgaiQuRXhwZWN0YXRpb24gPSBqUmVxdWlyZS5FeHBlY3RhdGlvbigpO1xcbiAgICBqJC5idWlsZEV4cGVjdGF0aW9uUmVzdWx0ID0galJlcXVpcmUuYnVpbGRFeHBlY3RhdGlvblJlc3VsdCgpO1xcbiAgICBqJC5Kc0FwaVJlcG9ydGVyID0galJlcXVpcmUuSnNBcGlSZXBvcnRlcigpO1xcbiAgICBqJC5tYXRjaGVyc1V0aWwgPSBqUmVxdWlyZS5tYXRjaGVyc1V0aWwoaiQpO1xcbiAgICBqJC5PYmplY3RDb250YWluaW5nID0galJlcXVpcmUuT2JqZWN0Q29udGFpbmluZyhqJCk7XFxuICAgIGokLkFycmF5Q29udGFpbmluZyA9IGpSZXF1aXJlLkFycmF5Q29udGFpbmluZyhqJCk7XFxuICAgIGokLnBwID0galJlcXVpcmUucHAoaiQpO1xcbiAgICBqJC5RdWV1ZVJ1bm5lciA9IGpSZXF1aXJlLlF1ZXVlUnVubmVyKGokKTtcXG4gICAgaiQuUmVwb3J0RGlzcGF0Y2hlciA9IGpSZXF1aXJlLlJlcG9ydERpc3BhdGNoZXIoKTtcXG4gICAgaiQuU3BlYyA9IGpSZXF1aXJlLlNwZWMoaiQpO1xcbiAgICBqJC5TcHlSZWdpc3RyeSA9IGpSZXF1aXJlLlNweVJlZ2lzdHJ5KGokKTtcXG4gICAgaiQuU3B5U3RyYXRlZ3kgPSBqUmVxdWlyZS5TcHlTdHJhdGVneSgpO1xcbiAgICBqJC5TdHJpbmdNYXRjaGluZyA9IGpSZXF1aXJlLlN0cmluZ01hdGNoaW5nKGokKTtcXG4gICAgaiQuU3VpdGUgPSBqUmVxdWlyZS5TdWl0ZShqJCk7XFxuICAgIGokLlRpbWVyID0galJlcXVpcmUuVGltZXIoKTtcXG4gICAgaiQuVHJlZVByb2Nlc3NvciA9IGpSZXF1aXJlLlRyZWVQcm9jZXNzb3IoKTtcXG4gICAgaiQudmVyc2lvbiA9IGpSZXF1aXJlLnZlcnNpb24oKTtcXG4gICAgaiQuT3JkZXIgPSBqUmVxdWlyZS5PcmRlcigpO1xcblxcbiAgICBqJC5tYXRjaGVycyA9IGpSZXF1aXJlLnJlcXVpcmVNYXRjaGVycyhqUmVxdWlyZSwgaiQpO1xcblxcbiAgICByZXR1cm4gaiQ7XFxuICB9O1xcblxcbiAgcmV0dXJuIGdldEphc21pbmVSZXF1aXJlO1xcbn0pKHRoaXMpO1xcblxcbmdldEphc21pbmVSZXF1aXJlT2JqKCkucmVxdWlyZU1hdGNoZXJzID0gZnVuY3Rpb24oalJlcXVpcmUsIGokKSB7XFxuICB2YXIgYXZhaWxhYmxlTWF0Y2hlcnMgPSBbXFxuICAgICAgJ3RvQmUnLFxcbiAgICAgICd0b0JlQ2xvc2VUbycsXFxuICAgICAgJ3RvQmVEZWZpbmVkJyxcXG4gICAgICAndG9CZUZhbHN5JyxcXG4gICAgICAndG9CZUdyZWF0ZXJUaGFuJyxcXG4gICAgICAndG9CZUxlc3NUaGFuJyxcXG4gICAgICAndG9CZU5hTicsXFxuICAgICAgJ3RvQmVOdWxsJyxcXG4gICAgICAndG9CZVRydXRoeScsXFxuICAgICAgJ3RvQmVVbmRlZmluZWQnLFxcbiAgICAgICd0b0NvbnRhaW4nLFxcbiAgICAgICd0b0VxdWFsJyxcXG4gICAgICAndG9IYXZlQmVlbkNhbGxlZCcsXFxuICAgICAgJ3RvSGF2ZUJlZW5DYWxsZWRXaXRoJyxcXG4gICAgICAndG9IYXZlQmVlbkNhbGxlZFRpbWVzJyxcXG4gICAgICAndG9NYXRjaCcsXFxuICAgICAgJ3RvVGhyb3cnLFxcbiAgICAgICd0b1Rocm93RXJyb3InXFxuICAgIF0sXFxuICAgIG1hdGNoZXJzID0ge307XFxuXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGF2YWlsYWJsZU1hdGNoZXJzLmxlbmd0aDsgaSsrKSB7XFxuICAgIHZhciBuYW1lID0gYXZhaWxhYmxlTWF0Y2hlcnNbaV07XFxuICAgIG1hdGNoZXJzW25hbWVdID0galJlcXVpcmVbbmFtZV0oaiQpO1xcbiAgfVxcblxcbiAgcmV0dXJuIG1hdGNoZXJzO1xcbn07XFxuXFxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5iYXNlID0gZnVuY3Rpb24oaiQsIGphc21pbmVHbG9iYWwpIHtcXG4gIGokLnVuaW1wbGVtZW50ZWRNZXRob2RfID0gZnVuY3Rpb24oKSB7XFxuICAgIHRocm93IG5ldyBFcnJvcigndW5pbXBsZW1lbnRlZCBtZXRob2QnKTtcXG4gIH07XFxuXFxuICBqJC5NQVhfUFJFVFRZX1BSSU5UX0RFUFRIID0gNDA7XFxuICBqJC5NQVhfUFJFVFRZX1BSSU5UX0FSUkFZX0xFTkdUSCA9IDEwMDtcXG4gIGokLkRFRkFVTFRfVElNRU9VVF9JTlRFUlZBTCA9IDUwMDA7XFxuXFxuICBqJC5nZXRHbG9iYWwgPSBmdW5jdGlvbigpIHtcXG4gICAgcmV0dXJuIGphc21pbmVHbG9iYWw7XFxuICB9O1xcblxcbiAgaiQuZ2V0RW52ID0gZnVuY3Rpb24ob3B0aW9ucykge1xcbiAgICB2YXIgZW52ID0gaiQuY3VycmVudEVudl8gPSBqJC5jdXJyZW50RW52XyB8fCBuZXcgaiQuRW52KG9wdGlvbnMpO1xcbiAgICAvL2phc21pbmUuIHNpbmdsZXRvbnMgaW4gaGVyZSAoc2V0VGltZW91dCBibGFoIGJsYWgpLlxcbiAgICByZXR1cm4gZW52O1xcbiAgfTtcXG5cXG4gIGokLmlzQXJyYXlfID0gZnVuY3Rpb24odmFsdWUpIHtcXG4gICAgcmV0dXJuIGokLmlzQV8oJ0FycmF5JywgdmFsdWUpO1xcbiAgfTtcXG5cXG4gIGokLmlzU3RyaW5nXyA9IGZ1bmN0aW9uKHZhbHVlKSB7XFxuICAgIHJldHVybiBqJC5pc0FfKCdTdHJpbmcnLCB2YWx1ZSk7XFxuICB9O1xcblxcbiAgaiQuaXNOdW1iZXJfID0gZnVuY3Rpb24odmFsdWUpIHtcXG4gICAgcmV0dXJuIGokLmlzQV8oJ051bWJlcicsIHZhbHVlKTtcXG4gIH07XFxuXFxuICBqJC5pc0FfID0gZnVuY3Rpb24odHlwZU5hbWUsIHZhbHVlKSB7XFxuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KHZhbHVlKSA9PT0gJ1tvYmplY3QgJyArIHR5cGVOYW1lICsgJ10nO1xcbiAgfTtcXG5cXG4gIGokLmlzRG9tTm9kZSA9IGZ1bmN0aW9uKG9iaikge1xcbiAgICByZXR1cm4gb2JqLm5vZGVUeXBlID4gMDtcXG4gIH07XFxuXFxuICBqJC5mbk5hbWVGb3IgPSBmdW5jdGlvbihmdW5jKSB7XFxuICAgIHJldHVybiBmdW5jLm5hbWUgfHwgZnVuYy50b1N0cmluZygpLm1hdGNoKC9eXFxcXHMqZnVuY3Rpb25cXFxccyooXFxcXHcqKVxcXFxzKlxcXFwoLylbMV07XFxuICB9O1xcblxcbiAgaiQuYW55ID0gZnVuY3Rpb24oY2xhenopIHtcXG4gICAgcmV0dXJuIG5ldyBqJC5BbnkoY2xhenopO1xcbiAgfTtcXG5cXG4gIGokLmFueXRoaW5nID0gZnVuY3Rpb24oKSB7XFxuICAgIHJldHVybiBuZXcgaiQuQW55dGhpbmcoKTtcXG4gIH07XFxuXFxuICBqJC5vYmplY3RDb250YWluaW5nID0gZnVuY3Rpb24oc2FtcGxlKSB7XFxuICAgIHJldHVybiBuZXcgaiQuT2JqZWN0Q29udGFpbmluZyhzYW1wbGUpO1xcbiAgfTtcXG5cXG4gIGokLnN0cmluZ01hdGNoaW5nID0gZnVuY3Rpb24oZXhwZWN0ZWQpIHtcXG4gICAgcmV0dXJuIG5ldyBqJC5TdHJpbmdNYXRjaGluZyhleHBlY3RlZCk7XFxuICB9O1xcblxcbiAgaiQuYXJyYXlDb250YWluaW5nID0gZnVuY3Rpb24oc2FtcGxlKSB7XFxuICAgIHJldHVybiBuZXcgaiQuQXJyYXlDb250YWluaW5nKHNhbXBsZSk7XFxuICB9O1xcblxcbiAgaiQuY3JlYXRlU3B5ID0gZnVuY3Rpb24obmFtZSwgb3JpZ2luYWxGbikge1xcblxcbiAgICB2YXIgc3B5U3RyYXRlZ3kgPSBuZXcgaiQuU3B5U3RyYXRlZ3koe1xcbiAgICAgICAgbmFtZTogbmFtZSxcXG4gICAgICAgIGZuOiBvcmlnaW5hbEZuLFxcbiAgICAgICAgZ2V0U3B5OiBmdW5jdGlvbigpIHsgcmV0dXJuIHNweTsgfVxcbiAgICAgIH0pLFxcbiAgICAgIGNhbGxUcmFja2VyID0gbmV3IGokLkNhbGxUcmFja2VyKCksXFxuICAgICAgc3B5ID0gZnVuY3Rpb24oKSB7XFxuICAgICAgICB2YXIgY2FsbERhdGEgPSB7XFxuICAgICAgICAgIG9iamVjdDogdGhpcyxcXG4gICAgICAgICAgYXJnczogQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGFyZ3VtZW50cylcXG4gICAgICAgIH07XFxuXFxuICAgICAgICBjYWxsVHJhY2tlci50cmFjayhjYWxsRGF0YSk7XFxuICAgICAgICB2YXIgcmV0dXJuVmFsdWUgPSBzcHlTdHJhdGVneS5leGVjLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICAgICAgICBjYWxsRGF0YS5yZXR1cm5WYWx1ZSA9IHJldHVyblZhbHVlO1xcblxcbiAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xcbiAgICAgIH07XFxuXFxuICAgIGZvciAodmFyIHByb3AgaW4gb3JpZ2luYWxGbikge1xcbiAgICAgIGlmIChwcm9wID09PSAnYW5kJyB8fCBwcm9wID09PSAnY2FsbHMnKSB7XFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0phc21pbmUgc3BpZXMgd291bGQgb3ZlcndyaXRlIHRoZSBcXFxcJ2FuZFxcXFwnIGFuZCBcXFxcJ2NhbGxzXFxcXCcgcHJvcGVydGllcyBvbiB0aGUgb2JqZWN0IGJlaW5nIHNwaWVkIHVwb24nKTtcXG4gICAgICB9XFxuXFxuICAgICAgc3B5W3Byb3BdID0gb3JpZ2luYWxGbltwcm9wXTtcXG4gICAgfVxcblxcbiAgICBzcHkuYW5kID0gc3B5U3RyYXRlZ3k7XFxuICAgIHNweS5jYWxscyA9IGNhbGxUcmFja2VyO1xcblxcbiAgICByZXR1cm4gc3B5O1xcbiAgfTtcXG5cXG4gIGokLmlzU3B5ID0gZnVuY3Rpb24ocHV0YXRpdmVTcHkpIHtcXG4gICAgaWYgKCFwdXRhdGl2ZVNweSkge1xcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcbiAgICByZXR1cm4gcHV0YXRpdmVTcHkuYW5kIGluc3RhbmNlb2YgaiQuU3B5U3RyYXRlZ3kgJiZcXG4gICAgICBwdXRhdGl2ZVNweS5jYWxscyBpbnN0YW5jZW9mIGokLkNhbGxUcmFja2VyO1xcbiAgfTtcXG5cXG4gIGokLmNyZWF0ZVNweU9iaiA9IGZ1bmN0aW9uKGJhc2VOYW1lLCBtZXRob2ROYW1lcykge1xcbiAgICBpZiAoaiQuaXNBcnJheV8oYmFzZU5hbWUpICYmIGokLnV0aWwuaXNVbmRlZmluZWQobWV0aG9kTmFtZXMpKSB7XFxuICAgICAgbWV0aG9kTmFtZXMgPSBiYXNlTmFtZTtcXG4gICAgICBiYXNlTmFtZSA9ICd1bmtub3duJztcXG4gICAgfVxcblxcbiAgICBpZiAoIWokLmlzQXJyYXlfKG1ldGhvZE5hbWVzKSB8fCBtZXRob2ROYW1lcy5sZW5ndGggPT09IDApIHtcXG4gICAgICB0aHJvdyAnY3JlYXRlU3B5T2JqIHJlcXVpcmVzIGEgbm9uLWVtcHR5IGFycmF5IG9mIG1ldGhvZCBuYW1lcyB0byBjcmVhdGUgc3BpZXMgZm9yJztcXG4gICAgfVxcbiAgICB2YXIgb2JqID0ge307XFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWV0aG9kTmFtZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgICBvYmpbbWV0aG9kTmFtZXNbaV1dID0gaiQuY3JlYXRlU3B5KGJhc2VOYW1lICsgJy4nICsgbWV0aG9kTmFtZXNbaV0pO1xcbiAgICB9XFxuICAgIHJldHVybiBvYmo7XFxuICB9O1xcbn07XFxuXFxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS51dGlsID0gZnVuY3Rpb24oKSB7XFxuXFxuICB2YXIgdXRpbCA9IHt9O1xcblxcbiAgdXRpbC5pbmhlcml0ID0gZnVuY3Rpb24oY2hpbGRDbGFzcywgcGFyZW50Q2xhc3MpIHtcXG4gICAgdmFyIFN1YmNsYXNzID0gZnVuY3Rpb24oKSB7XFxuICAgIH07XFxuICAgIFN1YmNsYXNzLnByb3RvdHlwZSA9IHBhcmVudENsYXNzLnByb3RvdHlwZTtcXG4gICAgY2hpbGRDbGFzcy5wcm90b3R5cGUgPSBuZXcgU3ViY2xhc3MoKTtcXG4gIH07XFxuXFxuICB1dGlsLmh0bWxFc2NhcGUgPSBmdW5jdGlvbihzdHIpIHtcXG4gICAgaWYgKCFzdHIpIHtcXG4gICAgICByZXR1cm4gc3RyO1xcbiAgICB9XFxuICAgIHJldHVybiBzdHIucmVwbGFjZSgvJi9nLCAnJmFtcDsnKVxcbiAgICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcXG4gICAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpO1xcbiAgfTtcXG5cXG4gIHV0aWwuYXJnc1RvQXJyYXkgPSBmdW5jdGlvbihhcmdzKSB7XFxuICAgIHZhciBhcnJheU9mQXJncyA9IFtdO1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcXG4gICAgICBhcnJheU9mQXJncy5wdXNoKGFyZ3NbaV0pO1xcbiAgICB9XFxuICAgIHJldHVybiBhcnJheU9mQXJncztcXG4gIH07XFxuXFxuICB1dGlsLmlzVW5kZWZpbmVkID0gZnVuY3Rpb24ob2JqKSB7XFxuICAgIHJldHVybiBvYmogPT09IHZvaWQgMDtcXG4gIH07XFxuXFxuICB1dGlsLmFycmF5Q29udGFpbnMgPSBmdW5jdGlvbihhcnJheSwgc2VhcmNoKSB7XFxuICAgIHZhciBpID0gYXJyYXkubGVuZ3RoO1xcbiAgICB3aGlsZSAoaS0tKSB7XFxuICAgICAgaWYgKGFycmF5W2ldID09PSBzZWFyY2gpIHtcXG4gICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICByZXR1cm4gZmFsc2U7XFxuICB9O1xcblxcbiAgdXRpbC5jbG9uZSA9IGZ1bmN0aW9uKG9iaikge1xcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5hcHBseShvYmopID09PSAnW29iamVjdCBBcnJheV0nKSB7XFxuICAgICAgcmV0dXJuIG9iai5zbGljZSgpO1xcbiAgICB9XFxuXFxuICAgIHZhciBjbG9uZWQgPSB7fTtcXG4gICAgZm9yICh2YXIgcHJvcCBpbiBvYmopIHtcXG4gICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHByb3ApKSB7XFxuICAgICAgICBjbG9uZWRbcHJvcF0gPSBvYmpbcHJvcF07XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHJldHVybiBjbG9uZWQ7XFxuICB9O1xcblxcbiAgcmV0dXJuIHV0aWw7XFxufTtcXG5cXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLlNwZWMgPSBmdW5jdGlvbihqJCkge1xcbiAgZnVuY3Rpb24gU3BlYyhhdHRycykge1xcbiAgICB0aGlzLmV4cGVjdGF0aW9uRmFjdG9yeSA9IGF0dHJzLmV4cGVjdGF0aW9uRmFjdG9yeTtcXG4gICAgdGhpcy5yZXN1bHRDYWxsYmFjayA9IGF0dHJzLnJlc3VsdENhbGxiYWNrIHx8IGZ1bmN0aW9uKCkge307XFxuICAgIHRoaXMuaWQgPSBhdHRycy5pZDtcXG4gICAgdGhpcy5kZXNjcmlwdGlvbiA9IGF0dHJzLmRlc2NyaXB0aW9uIHx8ICcnO1xcbiAgICB0aGlzLnF1ZXVlYWJsZUZuID0gYXR0cnMucXVldWVhYmxlRm47XFxuICAgIHRoaXMuYmVmb3JlQW5kQWZ0ZXJGbnMgPSBhdHRycy5iZWZvcmVBbmRBZnRlckZucyB8fCBmdW5jdGlvbigpIHsgcmV0dXJuIHtiZWZvcmVzOiBbXSwgYWZ0ZXJzOiBbXX07IH07XFxuICAgIHRoaXMudXNlckNvbnRleHQgPSBhdHRycy51c2VyQ29udGV4dCB8fCBmdW5jdGlvbigpIHsgcmV0dXJuIHt9OyB9O1xcbiAgICB0aGlzLm9uU3RhcnQgPSBhdHRycy5vblN0YXJ0IHx8IGZ1bmN0aW9uKCkge307XFxuICAgIHRoaXMuZ2V0U3BlY05hbWUgPSBhdHRycy5nZXRTcGVjTmFtZSB8fCBmdW5jdGlvbigpIHsgcmV0dXJuICcnOyB9O1xcbiAgICB0aGlzLmV4cGVjdGF0aW9uUmVzdWx0RmFjdG9yeSA9IGF0dHJzLmV4cGVjdGF0aW9uUmVzdWx0RmFjdG9yeSB8fCBmdW5jdGlvbigpIHsgfTtcXG4gICAgdGhpcy5xdWV1ZVJ1bm5lckZhY3RvcnkgPSBhdHRycy5xdWV1ZVJ1bm5lckZhY3RvcnkgfHwgZnVuY3Rpb24oKSB7fTtcXG4gICAgdGhpcy5jYXRjaGluZ0V4Y2VwdGlvbnMgPSBhdHRycy5jYXRjaGluZ0V4Y2VwdGlvbnMgfHwgZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9O1xcbiAgICB0aGlzLnRocm93T25FeHBlY3RhdGlvbkZhaWx1cmUgPSAhIWF0dHJzLnRocm93T25FeHBlY3RhdGlvbkZhaWx1cmU7XFxuXFxuICAgIGlmICghdGhpcy5xdWV1ZWFibGVGbi5mbikge1xcbiAgICAgIHRoaXMucGVuZCgpO1xcbiAgICB9XFxuXFxuICAgIHRoaXMucmVzdWx0ID0ge1xcbiAgICAgIGlkOiB0aGlzLmlkLFxcbiAgICAgIGRlc2NyaXB0aW9uOiB0aGlzLmRlc2NyaXB0aW9uLFxcbiAgICAgIGZ1bGxOYW1lOiB0aGlzLmdldEZ1bGxOYW1lKCksXFxuICAgICAgZmFpbGVkRXhwZWN0YXRpb25zOiBbXSxcXG4gICAgICBwYXNzZWRFeHBlY3RhdGlvbnM6IFtdLFxcbiAgICAgIHBlbmRpbmdSZWFzb246ICcnXFxuICAgIH07XFxuICB9XFxuXFxuICBTcGVjLnByb3RvdHlwZS5hZGRFeHBlY3RhdGlvblJlc3VsdCA9IGZ1bmN0aW9uKHBhc3NlZCwgZGF0YSwgaXNFcnJvcikge1xcbiAgICB2YXIgZXhwZWN0YXRpb25SZXN1bHQgPSB0aGlzLmV4cGVjdGF0aW9uUmVzdWx0RmFjdG9yeShkYXRhKTtcXG4gICAgaWYgKHBhc3NlZCkge1xcbiAgICAgIHRoaXMucmVzdWx0LnBhc3NlZEV4cGVjdGF0aW9ucy5wdXNoKGV4cGVjdGF0aW9uUmVzdWx0KTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICB0aGlzLnJlc3VsdC5mYWlsZWRFeHBlY3RhdGlvbnMucHVzaChleHBlY3RhdGlvblJlc3VsdCk7XFxuXFxuICAgICAgaWYgKHRoaXMudGhyb3dPbkV4cGVjdGF0aW9uRmFpbHVyZSAmJiAhaXNFcnJvcikge1xcbiAgICAgICAgdGhyb3cgbmV3IGokLmVycm9ycy5FeHBlY3RhdGlvbkZhaWxlZCgpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfTtcXG5cXG4gIFNwZWMucHJvdG90eXBlLmV4cGVjdCA9IGZ1bmN0aW9uKGFjdHVhbCkge1xcbiAgICByZXR1cm4gdGhpcy5leHBlY3RhdGlvbkZhY3RvcnkoYWN0dWFsLCB0aGlzKTtcXG4gIH07XFxuXFxuICBTcGVjLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24ob25Db21wbGV0ZSwgZW5hYmxlZCkge1xcbiAgICB2YXIgc2VsZiA9IHRoaXM7XFxuXFxuICAgIHRoaXMub25TdGFydCh0aGlzKTtcXG5cXG4gICAgaWYgKCF0aGlzLmlzRXhlY3V0YWJsZSgpIHx8IHRoaXMubWFya2VkUGVuZGluZyB8fCBlbmFibGVkID09PSBmYWxzZSkge1xcbiAgICAgIGNvbXBsZXRlKGVuYWJsZWQpO1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICB2YXIgZm5zID0gdGhpcy5iZWZvcmVBbmRBZnRlckZucygpO1xcbiAgICB2YXIgYWxsRm5zID0gZm5zLmJlZm9yZXMuY29uY2F0KHRoaXMucXVldWVhYmxlRm4pLmNvbmNhdChmbnMuYWZ0ZXJzKTtcXG5cXG4gICAgdGhpcy5xdWV1ZVJ1bm5lckZhY3Rvcnkoe1xcbiAgICAgIHF1ZXVlYWJsZUZuczogYWxsRm5zLFxcbiAgICAgIG9uRXhjZXB0aW9uOiBmdW5jdGlvbigpIHsgc2VsZi5vbkV4Y2VwdGlvbi5hcHBseShzZWxmLCBhcmd1bWVudHMpOyB9LFxcbiAgICAgIG9uQ29tcGxldGU6IGNvbXBsZXRlLFxcbiAgICAgIHVzZXJDb250ZXh0OiB0aGlzLnVzZXJDb250ZXh0KClcXG4gICAgfSk7XFxuXFxuICAgIGZ1bmN0aW9uIGNvbXBsZXRlKGVuYWJsZWRBZ2Fpbikge1xcbiAgICAgIHNlbGYucmVzdWx0LnN0YXR1cyA9IHNlbGYuc3RhdHVzKGVuYWJsZWRBZ2Fpbik7XFxuICAgICAgc2VsZi5yZXN1bHRDYWxsYmFjayhzZWxmLnJlc3VsdCk7XFxuXFxuICAgICAgaWYgKG9uQ29tcGxldGUpIHtcXG4gICAgICAgIG9uQ29tcGxldGUoKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH07XFxuXFxuICBTcGVjLnByb3RvdHlwZS5vbkV4Y2VwdGlvbiA9IGZ1bmN0aW9uIG9uRXhjZXB0aW9uKGUpIHtcXG4gICAgaWYgKFNwZWMuaXNQZW5kaW5nU3BlY0V4Y2VwdGlvbihlKSkge1xcbiAgICAgIHRoaXMucGVuZChleHRyYWN0Q3VzdG9tUGVuZGluZ01lc3NhZ2UoZSkpO1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBpZiAoZSBpbnN0YW5jZW9mIGokLmVycm9ycy5FeHBlY3RhdGlvbkZhaWxlZCkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICB0aGlzLmFkZEV4cGVjdGF0aW9uUmVzdWx0KGZhbHNlLCB7XFxuICAgICAgbWF0Y2hlck5hbWU6ICcnLFxcbiAgICAgIHBhc3NlZDogZmFsc2UsXFxuICAgICAgZXhwZWN0ZWQ6ICcnLFxcbiAgICAgIGFjdHVhbDogJycsXFxuICAgICAgZXJyb3I6IGVcXG4gICAgfSwgdHJ1ZSk7XFxuICB9O1xcblxcbiAgU3BlYy5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uKCkge1xcbiAgICB0aGlzLmRpc2FibGVkID0gdHJ1ZTtcXG4gIH07XFxuXFxuICBTcGVjLnByb3RvdHlwZS5wZW5kID0gZnVuY3Rpb24obWVzc2FnZSkge1xcbiAgICB0aGlzLm1hcmtlZFBlbmRpbmcgPSB0cnVlO1xcbiAgICBpZiAobWVzc2FnZSkge1xcbiAgICAgIHRoaXMucmVzdWx0LnBlbmRpbmdSZWFzb24gPSBtZXNzYWdlO1xcbiAgICB9XFxuICB9O1xcblxcbiAgU3BlYy5wcm90b3R5cGUuZ2V0UmVzdWx0ID0gZnVuY3Rpb24oKSB7XFxuICAgIHRoaXMucmVzdWx0LnN0YXR1cyA9IHRoaXMuc3RhdHVzKCk7XFxuICAgIHJldHVybiB0aGlzLnJlc3VsdDtcXG4gIH07XFxuXFxuICBTcGVjLnByb3RvdHlwZS5zdGF0dXMgPSBmdW5jdGlvbihlbmFibGVkKSB7XFxuICAgIGlmICh0aGlzLmRpc2FibGVkIHx8IGVuYWJsZWQgPT09IGZhbHNlKSB7XFxuICAgICAgcmV0dXJuICdkaXNhYmxlZCc7XFxuICAgIH1cXG5cXG4gICAgaWYgKHRoaXMubWFya2VkUGVuZGluZykge1xcbiAgICAgIHJldHVybiAncGVuZGluZyc7XFxuICAgIH1cXG5cXG4gICAgaWYgKHRoaXMucmVzdWx0LmZhaWxlZEV4cGVjdGF0aW9ucy5sZW5ndGggPiAwKSB7XFxuICAgICAgcmV0dXJuICdmYWlsZWQnO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHJldHVybiAncGFzc2VkJztcXG4gICAgfVxcbiAgfTtcXG5cXG4gIFNwZWMucHJvdG90eXBlLmlzRXhlY3V0YWJsZSA9IGZ1bmN0aW9uKCkge1xcbiAgICByZXR1cm4gIXRoaXMuZGlzYWJsZWQ7XFxuICB9O1xcblxcbiAgU3BlYy5wcm90b3R5cGUuZ2V0RnVsbE5hbWUgPSBmdW5jdGlvbigpIHtcXG4gICAgcmV0dXJuIHRoaXMuZ2V0U3BlY05hbWUodGhpcyk7XFxuICB9O1xcblxcbiAgdmFyIGV4dHJhY3RDdXN0b21QZW5kaW5nTWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcXG4gICAgdmFyIGZ1bGxNZXNzYWdlID0gZS50b1N0cmluZygpLFxcbiAgICAgICAgYm9pbGVycGxhdGVTdGFydCA9IGZ1bGxNZXNzYWdlLmluZGV4T2YoU3BlYy5wZW5kaW5nU3BlY0V4Y2VwdGlvbk1lc3NhZ2UpLFxcbiAgICAgICAgYm9pbGVycGxhdGVFbmQgPSBib2lsZXJwbGF0ZVN0YXJ0ICsgU3BlYy5wZW5kaW5nU3BlY0V4Y2VwdGlvbk1lc3NhZ2UubGVuZ3RoO1xcblxcbiAgICByZXR1cm4gZnVsbE1lc3NhZ2Uuc3Vic3RyKGJvaWxlcnBsYXRlRW5kKTtcXG4gIH07XFxuXFxuICBTcGVjLnBlbmRpbmdTcGVjRXhjZXB0aW9uTWVzc2FnZSA9ICc9PiBtYXJrZWQgUGVuZGluZyc7XFxuXFxuICBTcGVjLmlzUGVuZGluZ1NwZWNFeGNlcHRpb24gPSBmdW5jdGlvbihlKSB7XFxuICAgIHJldHVybiAhIShlICYmIGUudG9TdHJpbmcgJiYgZS50b1N0cmluZygpLmluZGV4T2YoU3BlYy5wZW5kaW5nU3BlY0V4Y2VwdGlvbk1lc3NhZ2UpICE9PSAtMSk7XFxuICB9O1xcblxcbiAgcmV0dXJuIFNwZWM7XFxufTtcXG5cXG5pZiAodHlwZW9mIHdpbmRvdyA9PSB2b2lkIDAgJiYgdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcpIHtcXG4gIGV4cG9ydHMuU3BlYyA9IGphc21pbmVSZXF1aXJlLlNwZWM7XFxufVxcblxcbi8qanNoaW50IGJpdHdpc2U6IGZhbHNlKi9cXG5cXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLk9yZGVyID0gZnVuY3Rpb24oKSB7XFxuICBmdW5jdGlvbiBPcmRlcihvcHRpb25zKSB7XFxuICAgIHRoaXMucmFuZG9tID0gJ3JhbmRvbScgaW4gb3B0aW9ucyA/IG9wdGlvbnMucmFuZG9tIDogdHJ1ZTtcXG4gICAgdmFyIHNlZWQgPSB0aGlzLnNlZWQgPSBvcHRpb25zLnNlZWQgfHwgZ2VuZXJhdGVTZWVkKCk7XFxuICAgIHRoaXMuc29ydCA9IHRoaXMucmFuZG9tID8gcmFuZG9tT3JkZXIgOiBuYXR1cmFsT3JkZXI7XFxuXFxuICAgIGZ1bmN0aW9uIG5hdHVyYWxPcmRlcihpdGVtcykge1xcbiAgICAgIHJldHVybiBpdGVtcztcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiByYW5kb21PcmRlcihpdGVtcykge1xcbiAgICAgIHZhciBjb3B5ID0gaXRlbXMuc2xpY2UoKTtcXG4gICAgICBjb3B5LnNvcnQoZnVuY3Rpb24oYSwgYikge1xcbiAgICAgICAgcmV0dXJuIGplbmtpbnNIYXNoKHNlZWQgKyBhLmlkKSAtIGplbmtpbnNIYXNoKHNlZWQgKyBiLmlkKTtcXG4gICAgICB9KTtcXG4gICAgICByZXR1cm4gY29weTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBnZW5lcmF0ZVNlZWQoKSB7XFxuICAgICAgcmV0dXJuIFN0cmluZyhNYXRoLnJhbmRvbSgpKS5zbGljZSgtNSk7XFxuICAgIH1cXG5cXG4gICAgLy8gQm9iIEplbmtpbnMgT25lLWF0LWEtVGltZSBIYXNoIGFsZ29yaXRobSBpcyBhIG5vbi1jcnlwdG9ncmFwaGljIGhhc2ggZnVuY3Rpb25cXG4gICAgLy8gdXNlZCB0byBnZXQgYSBkaWZmZXJlbnQgb3V0cHV0IHdoZW4gdGhlIGtleSBjaGFuZ2VzIHNsaWdobHkuXFxuICAgIC8vIFdlIHVzZSB5b3VyIHJldHVybiB0byBzb3J0IHRoZSBjaGlsZHJlbiByYW5kb21seSBpbiBhIGNvbnNpc3RlbnQgd2F5IHdoZW5cXG4gICAgLy8gdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGEgc2VlZFxcblxcbiAgICBmdW5jdGlvbiBqZW5raW5zSGFzaChrZXkpIHtcXG4gICAgICB2YXIgaGFzaCwgaTtcXG4gICAgICBmb3IoaGFzaCA9IGkgPSAwOyBpIDwga2V5Lmxlbmd0aDsgKytpKSB7XFxuICAgICAgICBoYXNoICs9IGtleS5jaGFyQ29kZUF0KGkpO1xcbiAgICAgICAgaGFzaCArPSAoaGFzaCA8PCAxMCk7XFxuICAgICAgICBoYXNoIF49IChoYXNoID4+IDYpO1xcbiAgICAgIH1cXG4gICAgICBoYXNoICs9IChoYXNoIDw8IDMpO1xcbiAgICAgIGhhc2ggXj0gKGhhc2ggPj4gMTEpO1xcbiAgICAgIGhhc2ggKz0gKGhhc2ggPDwgMTUpO1xcbiAgICAgIHJldHVybiBoYXNoO1xcbiAgICB9XFxuXFxuICB9XFxuXFxuICByZXR1cm4gT3JkZXI7XFxufTtcXG5cXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLkVudiA9IGZ1bmN0aW9uKGokKSB7XFxuICBmdW5jdGlvbiBFbnYob3B0aW9ucykge1xcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcXG5cXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgICB2YXIgZ2xvYmFsID0gb3B0aW9ucy5nbG9iYWwgfHwgaiQuZ2V0R2xvYmFsKCk7XFxuXFxuICAgIHZhciB0b3RhbFNwZWNzRGVmaW5lZCA9IDA7XFxuXFxuICAgIHZhciBjYXRjaEV4Y2VwdGlvbnMgPSB0cnVlO1xcblxcbiAgICB2YXIgcmVhbFNldFRpbWVvdXQgPSBqJC5nZXRHbG9iYWwoKS5zZXRUaW1lb3V0O1xcbiAgICB2YXIgcmVhbENsZWFyVGltZW91dCA9IGokLmdldEdsb2JhbCgpLmNsZWFyVGltZW91dDtcXG4gICAgdGhpcy5jbG9jayA9IG5ldyBqJC5DbG9jayhnbG9iYWwsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBqJC5EZWxheWVkRnVuY3Rpb25TY2hlZHVsZXIoKTsgfSwgbmV3IGokLk1vY2tEYXRlKGdsb2JhbCkpO1xcblxcbiAgICB2YXIgcnVubmFibGVMb29rdXBUYWJsZSA9IHt9O1xcbiAgICB2YXIgcnVubmFibGVSZXNvdXJjZXMgPSB7fTtcXG5cXG4gICAgdmFyIGN1cnJlbnRTcGVjID0gbnVsbDtcXG4gICAgdmFyIGN1cnJlbnRseUV4ZWN1dGluZ1N1aXRlcyA9IFtdO1xcbiAgICB2YXIgY3VycmVudERlY2xhcmF0aW9uU3VpdGUgPSBudWxsO1xcbiAgICB2YXIgdGhyb3dPbkV4cGVjdGF0aW9uRmFpbHVyZSA9IGZhbHNlO1xcbiAgICB2YXIgcmFuZG9tID0gZmFsc2U7XFxuICAgIHZhciBzZWVkID0gbnVsbDtcXG5cXG4gICAgdmFyIGN1cnJlbnRTdWl0ZSA9IGZ1bmN0aW9uKCkge1xcbiAgICAgIHJldHVybiBjdXJyZW50bHlFeGVjdXRpbmdTdWl0ZXNbY3VycmVudGx5RXhlY3V0aW5nU3VpdGVzLmxlbmd0aCAtIDFdO1xcbiAgICB9O1xcblxcbiAgICB2YXIgY3VycmVudFJ1bm5hYmxlID0gZnVuY3Rpb24oKSB7XFxuICAgICAgcmV0dXJuIGN1cnJlbnRTcGVjIHx8IGN1cnJlbnRTdWl0ZSgpO1xcbiAgICB9O1xcblxcbiAgICB2YXIgcmVwb3J0ZXIgPSBuZXcgaiQuUmVwb3J0RGlzcGF0Y2hlcihbXFxuICAgICAgJ2phc21pbmVTdGFydGVkJyxcXG4gICAgICAnamFzbWluZURvbmUnLFxcbiAgICAgICdzdWl0ZVN0YXJ0ZWQnLFxcbiAgICAgICdzdWl0ZURvbmUnLFxcbiAgICAgICdzcGVjU3RhcnRlZCcsXFxuICAgICAgJ3NwZWNEb25lJ1xcbiAgICBdKTtcXG5cXG4gICAgdGhpcy5zcGVjRmlsdGVyID0gZnVuY3Rpb24oKSB7XFxuICAgICAgcmV0dXJuIHRydWU7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuYWRkQ3VzdG9tRXF1YWxpdHlUZXN0ZXIgPSBmdW5jdGlvbih0ZXN0ZXIpIHtcXG4gICAgICBpZighY3VycmVudFJ1bm5hYmxlKCkpIHtcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ3VzdG9tIEVxdWFsaXRpZXMgbXVzdCBiZSBhZGRlZCBpbiBhIGJlZm9yZSBmdW5jdGlvbiBvciBhIHNwZWMnKTtcXG4gICAgICB9XFxuICAgICAgcnVubmFibGVSZXNvdXJjZXNbY3VycmVudFJ1bm5hYmxlKCkuaWRdLmN1c3RvbUVxdWFsaXR5VGVzdGVycy5wdXNoKHRlc3Rlcik7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuYWRkTWF0Y2hlcnMgPSBmdW5jdGlvbihtYXRjaGVyc1RvQWRkKSB7XFxuICAgICAgaWYoIWN1cnJlbnRSdW5uYWJsZSgpKSB7XFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hdGNoZXJzIG11c3QgYmUgYWRkZWQgaW4gYSBiZWZvcmUgZnVuY3Rpb24gb3IgYSBzcGVjJyk7XFxuICAgICAgfVxcbiAgICAgIHZhciBjdXN0b21NYXRjaGVycyA9IHJ1bm5hYmxlUmVzb3VyY2VzW2N1cnJlbnRSdW5uYWJsZSgpLmlkXS5jdXN0b21NYXRjaGVycztcXG4gICAgICBmb3IgKHZhciBtYXRjaGVyTmFtZSBpbiBtYXRjaGVyc1RvQWRkKSB7XFxuICAgICAgICBjdXN0b21NYXRjaGVyc1ttYXRjaGVyTmFtZV0gPSBtYXRjaGVyc1RvQWRkW21hdGNoZXJOYW1lXTtcXG4gICAgICB9XFxuICAgIH07XFxuXFxuICAgIGokLkV4cGVjdGF0aW9uLmFkZENvcmVNYXRjaGVycyhqJC5tYXRjaGVycyk7XFxuXFxuICAgIHZhciBuZXh0U3BlY0lkID0gMDtcXG4gICAgdmFyIGdldE5leHRTcGVjSWQgPSBmdW5jdGlvbigpIHtcXG4gICAgICByZXR1cm4gJ3NwZWMnICsgbmV4dFNwZWNJZCsrO1xcbiAgICB9O1xcblxcbiAgICB2YXIgbmV4dFN1aXRlSWQgPSAwO1xcbiAgICB2YXIgZ2V0TmV4dFN1aXRlSWQgPSBmdW5jdGlvbigpIHtcXG4gICAgICByZXR1cm4gJ3N1aXRlJyArIG5leHRTdWl0ZUlkKys7XFxuICAgIH07XFxuXFxuICAgIHZhciBleHBlY3RhdGlvbkZhY3RvcnkgPSBmdW5jdGlvbihhY3R1YWwsIHNwZWMpIHtcXG4gICAgICByZXR1cm4gaiQuRXhwZWN0YXRpb24uRmFjdG9yeSh7XFxuICAgICAgICB1dGlsOiBqJC5tYXRjaGVyc1V0aWwsXFxuICAgICAgICBjdXN0b21FcXVhbGl0eVRlc3RlcnM6IHJ1bm5hYmxlUmVzb3VyY2VzW3NwZWMuaWRdLmN1c3RvbUVxdWFsaXR5VGVzdGVycyxcXG4gICAgICAgIGN1c3RvbU1hdGNoZXJzOiBydW5uYWJsZVJlc291cmNlc1tzcGVjLmlkXS5jdXN0b21NYXRjaGVycyxcXG4gICAgICAgIGFjdHVhbDogYWN0dWFsLFxcbiAgICAgICAgYWRkRXhwZWN0YXRpb25SZXN1bHQ6IGFkZEV4cGVjdGF0aW9uUmVzdWx0XFxuICAgICAgfSk7XFxuXFxuICAgICAgZnVuY3Rpb24gYWRkRXhwZWN0YXRpb25SZXN1bHQocGFzc2VkLCByZXN1bHQpIHtcXG4gICAgICAgIHJldHVybiBzcGVjLmFkZEV4cGVjdGF0aW9uUmVzdWx0KHBhc3NlZCwgcmVzdWx0KTtcXG4gICAgICB9XFxuICAgIH07XFxuXFxuICAgIHZhciBkZWZhdWx0UmVzb3VyY2VzRm9yUnVubmFibGUgPSBmdW5jdGlvbihpZCwgcGFyZW50UnVubmFibGVJZCkge1xcbiAgICAgIHZhciByZXNvdXJjZXMgPSB7c3BpZXM6IFtdLCBjdXN0b21FcXVhbGl0eVRlc3RlcnM6IFtdLCBjdXN0b21NYXRjaGVyczoge319O1xcblxcbiAgICAgIGlmKHJ1bm5hYmxlUmVzb3VyY2VzW3BhcmVudFJ1bm5hYmxlSWRdKXtcXG4gICAgICAgIHJlc291cmNlcy5jdXN0b21FcXVhbGl0eVRlc3RlcnMgPSBqJC51dGlsLmNsb25lKHJ1bm5hYmxlUmVzb3VyY2VzW3BhcmVudFJ1bm5hYmxlSWRdLmN1c3RvbUVxdWFsaXR5VGVzdGVycyk7XFxuICAgICAgICByZXNvdXJjZXMuY3VzdG9tTWF0Y2hlcnMgPSBqJC51dGlsLmNsb25lKHJ1bm5hYmxlUmVzb3VyY2VzW3BhcmVudFJ1bm5hYmxlSWRdLmN1c3RvbU1hdGNoZXJzKTtcXG4gICAgICB9XFxuXFxuICAgICAgcnVubmFibGVSZXNvdXJjZXNbaWRdID0gcmVzb3VyY2VzO1xcbiAgICB9O1xcblxcbiAgICB2YXIgY2xlYXJSZXNvdXJjZXNGb3JSdW5uYWJsZSA9IGZ1bmN0aW9uKGlkKSB7XFxuICAgICAgICBzcHlSZWdpc3RyeS5jbGVhclNwaWVzKCk7XFxuICAgICAgICBkZWxldGUgcnVubmFibGVSZXNvdXJjZXNbaWRdO1xcbiAgICB9O1xcblxcbiAgICB2YXIgYmVmb3JlQW5kQWZ0ZXJGbnMgPSBmdW5jdGlvbihzdWl0ZSkge1xcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcXG4gICAgICAgIHZhciBiZWZvcmVzID0gW10sXFxuICAgICAgICAgIGFmdGVycyA9IFtdO1xcblxcbiAgICAgICAgd2hpbGUoc3VpdGUpIHtcXG4gICAgICAgICAgYmVmb3JlcyA9IGJlZm9yZXMuY29uY2F0KHN1aXRlLmJlZm9yZUZucyk7XFxuICAgICAgICAgIGFmdGVycyA9IGFmdGVycy5jb25jYXQoc3VpdGUuYWZ0ZXJGbnMpO1xcblxcbiAgICAgICAgICBzdWl0ZSA9IHN1aXRlLnBhcmVudFN1aXRlO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgYmVmb3JlczogYmVmb3Jlcy5yZXZlcnNlKCksXFxuICAgICAgICAgIGFmdGVyczogYWZ0ZXJzXFxuICAgICAgICB9O1xcbiAgICAgIH07XFxuICAgIH07XFxuXFxuICAgIHZhciBnZXRTcGVjTmFtZSA9IGZ1bmN0aW9uKHNwZWMsIHN1aXRlKSB7XFxuICAgICAgcmV0dXJuIHN1aXRlLmdldEZ1bGxOYW1lKCkgKyAnICcgKyBzcGVjLmRlc2NyaXB0aW9uO1xcbiAgICB9O1xcblxcbiAgICAvLyBUT0RPOiB3ZSBtYXkganVzdCBiZSBhYmxlIHRvIHBhc3MgaW4gdGhlIGZuIGluc3RlYWQgb2Ygd3JhcHBpbmcgaGVyZVxcbiAgICB2YXIgYnVpbGRFeHBlY3RhdGlvblJlc3VsdCA9IGokLmJ1aWxkRXhwZWN0YXRpb25SZXN1bHQsXFxuICAgICAgICBleGNlcHRpb25Gb3JtYXR0ZXIgPSBuZXcgaiQuRXhjZXB0aW9uRm9ybWF0dGVyKCksXFxuICAgICAgICBleHBlY3RhdGlvblJlc3VsdEZhY3RvcnkgPSBmdW5jdGlvbihhdHRycykge1xcbiAgICAgICAgICBhdHRycy5tZXNzYWdlRm9ybWF0dGVyID0gZXhjZXB0aW9uRm9ybWF0dGVyLm1lc3NhZ2U7XFxuICAgICAgICAgIGF0dHJzLnN0YWNrRm9ybWF0dGVyID0gZXhjZXB0aW9uRm9ybWF0dGVyLnN0YWNrO1xcblxcbiAgICAgICAgICByZXR1cm4gYnVpbGRFeHBlY3RhdGlvblJlc3VsdChhdHRycyk7XFxuICAgICAgICB9O1xcblxcbiAgICAvLyBUT0RPOiBmaXggdGhpcyBuYW1pbmcsIGFuZCBoZXJlJ3Mgd2hlcmUgdGhlIHZhbHVlIGNvbWVzIGluXFxuICAgIHRoaXMuY2F0Y2hFeGNlcHRpb25zID0gZnVuY3Rpb24odmFsdWUpIHtcXG4gICAgICBjYXRjaEV4Y2VwdGlvbnMgPSAhIXZhbHVlO1xcbiAgICAgIHJldHVybiBjYXRjaEV4Y2VwdGlvbnM7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuY2F0Y2hpbmdFeGNlcHRpb25zID0gZnVuY3Rpb24oKSB7XFxuICAgICAgcmV0dXJuIGNhdGNoRXhjZXB0aW9ucztcXG4gICAgfTtcXG5cXG4gICAgdmFyIG1heGltdW1TcGVjQ2FsbGJhY2tEZXB0aCA9IDIwO1xcbiAgICB2YXIgY3VycmVudFNwZWNDYWxsYmFja0RlcHRoID0gMDtcXG5cXG4gICAgZnVuY3Rpb24gY2xlYXJTdGFjayhmbikge1xcbiAgICAgIGN1cnJlbnRTcGVjQ2FsbGJhY2tEZXB0aCsrO1xcbiAgICAgIGlmIChjdXJyZW50U3BlY0NhbGxiYWNrRGVwdGggPj0gbWF4aW11bVNwZWNDYWxsYmFja0RlcHRoKSB7XFxuICAgICAgICBjdXJyZW50U3BlY0NhbGxiYWNrRGVwdGggPSAwO1xcbiAgICAgICAgcmVhbFNldFRpbWVvdXQoZm4sIDApO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBmbigpO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICB2YXIgY2F0Y2hFeGNlcHRpb24gPSBmdW5jdGlvbihlKSB7XFxuICAgICAgcmV0dXJuIGokLlNwZWMuaXNQZW5kaW5nU3BlY0V4Y2VwdGlvbihlKSB8fCBjYXRjaEV4Y2VwdGlvbnM7XFxuICAgIH07XFxuXFxuICAgIHRoaXMudGhyb3dPbkV4cGVjdGF0aW9uRmFpbHVyZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XFxuICAgICAgdGhyb3dPbkV4cGVjdGF0aW9uRmFpbHVyZSA9ICEhdmFsdWU7XFxuICAgIH07XFxuXFxuICAgIHRoaXMudGhyb3dpbmdFeHBlY3RhdGlvbkZhaWx1cmVzID0gZnVuY3Rpb24oKSB7XFxuICAgICAgcmV0dXJuIHRocm93T25FeHBlY3RhdGlvbkZhaWx1cmU7XFxuICAgIH07XFxuXFxuICAgIHRoaXMucmFuZG9taXplVGVzdHMgPSBmdW5jdGlvbih2YWx1ZSkge1xcbiAgICAgIHJhbmRvbSA9ICEhdmFsdWU7XFxuICAgIH07XFxuXFxuICAgIHRoaXMucmFuZG9tVGVzdHMgPSBmdW5jdGlvbigpIHtcXG4gICAgICByZXR1cm4gcmFuZG9tO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLnNlZWQgPSBmdW5jdGlvbih2YWx1ZSkge1xcbiAgICAgIGlmICh2YWx1ZSkge1xcbiAgICAgICAgc2VlZCA9IHZhbHVlO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gc2VlZDtcXG4gICAgfTtcXG5cXG4gICAgdmFyIHF1ZXVlUnVubmVyRmFjdG9yeSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcXG4gICAgICBvcHRpb25zLmNhdGNoRXhjZXB0aW9uID0gY2F0Y2hFeGNlcHRpb247XFxuICAgICAgb3B0aW9ucy5jbGVhclN0YWNrID0gb3B0aW9ucy5jbGVhclN0YWNrIHx8IGNsZWFyU3RhY2s7XFxuICAgICAgb3B0aW9ucy50aW1lb3V0ID0ge3NldFRpbWVvdXQ6IHJlYWxTZXRUaW1lb3V0LCBjbGVhclRpbWVvdXQ6IHJlYWxDbGVhclRpbWVvdXR9O1xcbiAgICAgIG9wdGlvbnMuZmFpbCA9IHNlbGYuZmFpbDtcXG5cXG4gICAgICBuZXcgaiQuUXVldWVSdW5uZXIob3B0aW9ucykuZXhlY3V0ZSgpO1xcbiAgICB9O1xcblxcbiAgICB2YXIgdG9wU3VpdGUgPSBuZXcgaiQuU3VpdGUoe1xcbiAgICAgIGVudjogdGhpcyxcXG4gICAgICBpZDogZ2V0TmV4dFN1aXRlSWQoKSxcXG4gICAgICBkZXNjcmlwdGlvbjogJ0phc21pbmVfX1RvcExldmVsX19TdWl0ZScsXFxuICAgICAgcXVldWVSdW5uZXI6IHF1ZXVlUnVubmVyRmFjdG9yeVxcbiAgICB9KTtcXG4gICAgcnVubmFibGVMb29rdXBUYWJsZVt0b3BTdWl0ZS5pZF0gPSB0b3BTdWl0ZTtcXG4gICAgZGVmYXVsdFJlc291cmNlc0ZvclJ1bm5hYmxlKHRvcFN1aXRlLmlkKTtcXG4gICAgY3VycmVudERlY2xhcmF0aW9uU3VpdGUgPSB0b3BTdWl0ZTtcXG5cXG4gICAgdGhpcy50b3BTdWl0ZSA9IGZ1bmN0aW9uKCkge1xcbiAgICAgIHJldHVybiB0b3BTdWl0ZTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5leGVjdXRlID0gZnVuY3Rpb24ocnVubmFibGVzVG9SdW4pIHtcXG4gICAgICBpZighcnVubmFibGVzVG9SdW4pIHtcXG4gICAgICAgIGlmIChmb2N1c2VkUnVubmFibGVzLmxlbmd0aCkge1xcbiAgICAgICAgICBydW5uYWJsZXNUb1J1biA9IGZvY3VzZWRSdW5uYWJsZXM7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBydW5uYWJsZXNUb1J1biA9IFt0b3BTdWl0ZS5pZF07XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBvcmRlciA9IG5ldyBqJC5PcmRlcih7XFxuICAgICAgICByYW5kb206IHJhbmRvbSxcXG4gICAgICAgIHNlZWQ6IHNlZWRcXG4gICAgICB9KTtcXG5cXG4gICAgICB2YXIgcHJvY2Vzc29yID0gbmV3IGokLlRyZWVQcm9jZXNzb3Ioe1xcbiAgICAgICAgdHJlZTogdG9wU3VpdGUsXFxuICAgICAgICBydW5uYWJsZUlkczogcnVubmFibGVzVG9SdW4sXFxuICAgICAgICBxdWV1ZVJ1bm5lckZhY3Rvcnk6IHF1ZXVlUnVubmVyRmFjdG9yeSxcXG4gICAgICAgIG5vZGVTdGFydDogZnVuY3Rpb24oc3VpdGUpIHtcXG4gICAgICAgICAgY3VycmVudGx5RXhlY3V0aW5nU3VpdGVzLnB1c2goc3VpdGUpO1xcbiAgICAgICAgICBkZWZhdWx0UmVzb3VyY2VzRm9yUnVubmFibGUoc3VpdGUuaWQsIHN1aXRlLnBhcmVudFN1aXRlLmlkKTtcXG4gICAgICAgICAgcmVwb3J0ZXIuc3VpdGVTdGFydGVkKHN1aXRlLnJlc3VsdCk7XFxuICAgICAgICB9LFxcbiAgICAgICAgbm9kZUNvbXBsZXRlOiBmdW5jdGlvbihzdWl0ZSwgcmVzdWx0KSB7XFxuICAgICAgICAgIGlmICghc3VpdGUuZGlzYWJsZWQpIHtcXG4gICAgICAgICAgICBjbGVhclJlc291cmNlc0ZvclJ1bm5hYmxlKHN1aXRlLmlkKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBjdXJyZW50bHlFeGVjdXRpbmdTdWl0ZXMucG9wKCk7XFxuICAgICAgICAgIHJlcG9ydGVyLnN1aXRlRG9uZShyZXN1bHQpO1xcbiAgICAgICAgfSxcXG4gICAgICAgIG9yZGVyQ2hpbGRyZW46IGZ1bmN0aW9uKG5vZGUpIHtcXG4gICAgICAgICAgcmV0dXJuIG9yZGVyLnNvcnQobm9kZS5jaGlsZHJlbik7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuXFxuICAgICAgaWYoIXByb2Nlc3Nvci5wcm9jZXNzVHJlZSgpLnZhbGlkKSB7XFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgb3JkZXI6IHdvdWxkIGNhdXNlIGEgYmVmb3JlQWxsIG9yIGFmdGVyQWxsIHRvIGJlIHJ1biBtdWx0aXBsZSB0aW1lcycpO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXBvcnRlci5qYXNtaW5lU3RhcnRlZCh7XFxuICAgICAgICB0b3RhbFNwZWNzRGVmaW5lZDogdG90YWxTcGVjc0RlZmluZWRcXG4gICAgICB9KTtcXG5cXG4gICAgICBwcm9jZXNzb3IuZXhlY3V0ZShmdW5jdGlvbigpIHtcXG4gICAgICAgIHJlcG9ydGVyLmphc21pbmVEb25lKHtcXG4gICAgICAgICAgb3JkZXI6IG9yZGVyXFxuICAgICAgICB9KTtcXG4gICAgICB9KTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5hZGRSZXBvcnRlciA9IGZ1bmN0aW9uKHJlcG9ydGVyVG9BZGQpIHtcXG4gICAgICByZXBvcnRlci5hZGRSZXBvcnRlcihyZXBvcnRlclRvQWRkKTtcXG4gICAgfTtcXG5cXG4gICAgdmFyIHNweVJlZ2lzdHJ5ID0gbmV3IGokLlNweVJlZ2lzdHJ5KHtjdXJyZW50U3BpZXM6IGZ1bmN0aW9uKCkge1xcbiAgICAgIGlmKCFjdXJyZW50UnVubmFibGUoKSkge1xcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTcGllcyBtdXN0IGJlIGNyZWF0ZWQgaW4gYSBiZWZvcmUgZnVuY3Rpb24gb3IgYSBzcGVjJyk7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBydW5uYWJsZVJlc291cmNlc1tjdXJyZW50UnVubmFibGUoKS5pZF0uc3BpZXM7XFxuICAgIH19KTtcXG5cXG4gICAgdGhpcy5zcHlPbiA9IGZ1bmN0aW9uKCkge1xcbiAgICAgIHJldHVybiBzcHlSZWdpc3RyeS5zcHlPbi5hcHBseShzcHlSZWdpc3RyeSwgYXJndW1lbnRzKTtcXG4gICAgfTtcXG5cXG4gICAgdmFyIHN1aXRlRmFjdG9yeSA9IGZ1bmN0aW9uKGRlc2NyaXB0aW9uKSB7XFxuICAgICAgdmFyIHN1aXRlID0gbmV3IGokLlN1aXRlKHtcXG4gICAgICAgIGVudjogc2VsZixcXG4gICAgICAgIGlkOiBnZXROZXh0U3VpdGVJZCgpLFxcbiAgICAgICAgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uLFxcbiAgICAgICAgcGFyZW50U3VpdGU6IGN1cnJlbnREZWNsYXJhdGlvblN1aXRlLFxcbiAgICAgICAgZXhwZWN0YXRpb25GYWN0b3J5OiBleHBlY3RhdGlvbkZhY3RvcnksXFxuICAgICAgICBleHBlY3RhdGlvblJlc3VsdEZhY3Rvcnk6IGV4cGVjdGF0aW9uUmVzdWx0RmFjdG9yeSxcXG4gICAgICAgIHRocm93T25FeHBlY3RhdGlvbkZhaWx1cmU6IHRocm93T25FeHBlY3RhdGlvbkZhaWx1cmVcXG4gICAgICB9KTtcXG5cXG4gICAgICBydW5uYWJsZUxvb2t1cFRhYmxlW3N1aXRlLmlkXSA9IHN1aXRlO1xcbiAgICAgIHJldHVybiBzdWl0ZTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5kZXNjcmliZSA9IGZ1bmN0aW9uKGRlc2NyaXB0aW9uLCBzcGVjRGVmaW5pdGlvbnMpIHtcXG4gICAgICB2YXIgc3VpdGUgPSBzdWl0ZUZhY3RvcnkoZGVzY3JpcHRpb24pO1xcbiAgICAgIGlmIChzcGVjRGVmaW5pdGlvbnMubGVuZ3RoID4gMCkge1xcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkZXNjcmliZSBkb2VzIG5vdCBleHBlY3QgYSBkb25lIHBhcmFtZXRlcicpO1xcbiAgICAgIH1cXG4gICAgICBpZiAoY3VycmVudERlY2xhcmF0aW9uU3VpdGUubWFya2VkUGVuZGluZykge1xcbiAgICAgICAgc3VpdGUucGVuZCgpO1xcbiAgICAgIH1cXG4gICAgICBhZGRTcGVjc1RvU3VpdGUoc3VpdGUsIHNwZWNEZWZpbml0aW9ucyk7XFxuICAgICAgcmV0dXJuIHN1aXRlO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLnhkZXNjcmliZSA9IGZ1bmN0aW9uKGRlc2NyaXB0aW9uLCBzcGVjRGVmaW5pdGlvbnMpIHtcXG4gICAgICB2YXIgc3VpdGUgPSBzdWl0ZUZhY3RvcnkoZGVzY3JpcHRpb24pO1xcbiAgICAgIHN1aXRlLnBlbmQoKTtcXG4gICAgICBhZGRTcGVjc1RvU3VpdGUoc3VpdGUsIHNwZWNEZWZpbml0aW9ucyk7XFxuICAgICAgcmV0dXJuIHN1aXRlO1xcbiAgICB9O1xcblxcbiAgICB2YXIgZm9jdXNlZFJ1bm5hYmxlcyA9IFtdO1xcblxcbiAgICB0aGlzLmZkZXNjcmliZSA9IGZ1bmN0aW9uKGRlc2NyaXB0aW9uLCBzcGVjRGVmaW5pdGlvbnMpIHtcXG4gICAgICB2YXIgc3VpdGUgPSBzdWl0ZUZhY3RvcnkoZGVzY3JpcHRpb24pO1xcbiAgICAgIHN1aXRlLmlzRm9jdXNlZCA9IHRydWU7XFxuXFxuICAgICAgZm9jdXNlZFJ1bm5hYmxlcy5wdXNoKHN1aXRlLmlkKTtcXG4gICAgICB1bmZvY3VzQW5jZXN0b3IoKTtcXG4gICAgICBhZGRTcGVjc1RvU3VpdGUoc3VpdGUsIHNwZWNEZWZpbml0aW9ucyk7XFxuXFxuICAgICAgcmV0dXJuIHN1aXRlO1xcbiAgICB9O1xcblxcbiAgICBmdW5jdGlvbiBhZGRTcGVjc1RvU3VpdGUoc3VpdGUsIHNwZWNEZWZpbml0aW9ucykge1xcbiAgICAgIHZhciBwYXJlbnRTdWl0ZSA9IGN1cnJlbnREZWNsYXJhdGlvblN1aXRlO1xcbiAgICAgIHBhcmVudFN1aXRlLmFkZENoaWxkKHN1aXRlKTtcXG4gICAgICBjdXJyZW50RGVjbGFyYXRpb25TdWl0ZSA9IHN1aXRlO1xcblxcbiAgICAgIHZhciBkZWNsYXJhdGlvbkVycm9yID0gbnVsbDtcXG4gICAgICB0cnkge1xcbiAgICAgICAgc3BlY0RlZmluaXRpb25zLmNhbGwoc3VpdGUpO1xcbiAgICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgIGRlY2xhcmF0aW9uRXJyb3IgPSBlO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoZGVjbGFyYXRpb25FcnJvcikge1xcbiAgICAgICAgc2VsZi5pdCgnZW5jb3VudGVyZWQgYSBkZWNsYXJhdGlvbiBleGNlcHRpb24nLCBmdW5jdGlvbigpIHtcXG4gICAgICAgICAgdGhyb3cgZGVjbGFyYXRpb25FcnJvcjtcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG5cXG4gICAgICBjdXJyZW50RGVjbGFyYXRpb25TdWl0ZSA9IHBhcmVudFN1aXRlO1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIGZpbmRGb2N1c2VkQW5jZXN0b3Ioc3VpdGUpIHtcXG4gICAgICB3aGlsZSAoc3VpdGUpIHtcXG4gICAgICAgIGlmIChzdWl0ZS5pc0ZvY3VzZWQpIHtcXG4gICAgICAgICAgcmV0dXJuIHN1aXRlLmlkO1xcbiAgICAgICAgfVxcbiAgICAgICAgc3VpdGUgPSBzdWl0ZS5wYXJlbnRTdWl0ZTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIG51bGw7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gdW5mb2N1c0FuY2VzdG9yKCkge1xcbiAgICAgIHZhciBmb2N1c2VkQW5jZXN0b3IgPSBmaW5kRm9jdXNlZEFuY2VzdG9yKGN1cnJlbnREZWNsYXJhdGlvblN1aXRlKTtcXG4gICAgICBpZiAoZm9jdXNlZEFuY2VzdG9yKSB7XFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZvY3VzZWRSdW5uYWJsZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgaWYgKGZvY3VzZWRSdW5uYWJsZXNbaV0gPT09IGZvY3VzZWRBbmNlc3Rvcikge1xcbiAgICAgICAgICAgIGZvY3VzZWRSdW5uYWJsZXMuc3BsaWNlKGksIDEpO1xcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHZhciBzcGVjRmFjdG9yeSA9IGZ1bmN0aW9uKGRlc2NyaXB0aW9uLCBmbiwgc3VpdGUsIHRpbWVvdXQpIHtcXG4gICAgICB0b3RhbFNwZWNzRGVmaW5lZCsrO1xcbiAgICAgIHZhciBzcGVjID0gbmV3IGokLlNwZWMoe1xcbiAgICAgICAgaWQ6IGdldE5leHRTcGVjSWQoKSxcXG4gICAgICAgIGJlZm9yZUFuZEFmdGVyRm5zOiBiZWZvcmVBbmRBZnRlckZucyhzdWl0ZSksXFxuICAgICAgICBleHBlY3RhdGlvbkZhY3Rvcnk6IGV4cGVjdGF0aW9uRmFjdG9yeSxcXG4gICAgICAgIHJlc3VsdENhbGxiYWNrOiBzcGVjUmVzdWx0Q2FsbGJhY2ssXFxuICAgICAgICBnZXRTcGVjTmFtZTogZnVuY3Rpb24oc3BlYykge1xcbiAgICAgICAgICByZXR1cm4gZ2V0U3BlY05hbWUoc3BlYywgc3VpdGUpO1xcbiAgICAgICAgfSxcXG4gICAgICAgIG9uU3RhcnQ6IHNwZWNTdGFydGVkLFxcbiAgICAgICAgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uLFxcbiAgICAgICAgZXhwZWN0YXRpb25SZXN1bHRGYWN0b3J5OiBleHBlY3RhdGlvblJlc3VsdEZhY3RvcnksXFxuICAgICAgICBxdWV1ZVJ1bm5lckZhY3Rvcnk6IHF1ZXVlUnVubmVyRmFjdG9yeSxcXG4gICAgICAgIHVzZXJDb250ZXh0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHN1aXRlLmNsb25lZFNoYXJlZFVzZXJDb250ZXh0KCk7IH0sXFxuICAgICAgICBxdWV1ZWFibGVGbjoge1xcbiAgICAgICAgICBmbjogZm4sXFxuICAgICAgICAgIHRpbWVvdXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGltZW91dCB8fCBqJC5ERUZBVUxUX1RJTUVPVVRfSU5URVJWQUw7IH1cXG4gICAgICAgIH0sXFxuICAgICAgICB0aHJvd09uRXhwZWN0YXRpb25GYWlsdXJlOiB0aHJvd09uRXhwZWN0YXRpb25GYWlsdXJlXFxuICAgICAgfSk7XFxuXFxuICAgICAgcnVubmFibGVMb29rdXBUYWJsZVtzcGVjLmlkXSA9IHNwZWM7XFxuXFxuICAgICAgaWYgKCFzZWxmLnNwZWNGaWx0ZXIoc3BlYykpIHtcXG4gICAgICAgIHNwZWMuZGlzYWJsZSgpO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gc3BlYztcXG5cXG4gICAgICBmdW5jdGlvbiBzcGVjUmVzdWx0Q2FsbGJhY2socmVzdWx0KSB7XFxuICAgICAgICBjbGVhclJlc291cmNlc0ZvclJ1bm5hYmxlKHNwZWMuaWQpO1xcbiAgICAgICAgY3VycmVudFNwZWMgPSBudWxsO1xcbiAgICAgICAgcmVwb3J0ZXIuc3BlY0RvbmUocmVzdWx0KTtcXG4gICAgICB9XFxuXFxuICAgICAgZnVuY3Rpb24gc3BlY1N0YXJ0ZWQoc3BlYykge1xcbiAgICAgICAgY3VycmVudFNwZWMgPSBzcGVjO1xcbiAgICAgICAgZGVmYXVsdFJlc291cmNlc0ZvclJ1bm5hYmxlKHNwZWMuaWQsIHN1aXRlLmlkKTtcXG4gICAgICAgIHJlcG9ydGVyLnNwZWNTdGFydGVkKHNwZWMucmVzdWx0KTtcXG4gICAgICB9XFxuICAgIH07XFxuXFxuICAgIHRoaXMuaXQgPSBmdW5jdGlvbihkZXNjcmlwdGlvbiwgZm4sIHRpbWVvdXQpIHtcXG4gICAgICB2YXIgc3BlYyA9IHNwZWNGYWN0b3J5KGRlc2NyaXB0aW9uLCBmbiwgY3VycmVudERlY2xhcmF0aW9uU3VpdGUsIHRpbWVvdXQpO1xcbiAgICAgIGlmIChjdXJyZW50RGVjbGFyYXRpb25TdWl0ZS5tYXJrZWRQZW5kaW5nKSB7XFxuICAgICAgICBzcGVjLnBlbmQoKTtcXG4gICAgICB9XFxuICAgICAgY3VycmVudERlY2xhcmF0aW9uU3VpdGUuYWRkQ2hpbGQoc3BlYyk7XFxuICAgICAgcmV0dXJuIHNwZWM7XFxuICAgIH07XFxuXFxuICAgIHRoaXMueGl0ID0gZnVuY3Rpb24oKSB7XFxuICAgICAgdmFyIHNwZWMgPSB0aGlzLml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICAgICAgc3BlYy5wZW5kKCdUZW1wb3JhcmlseSBkaXNhYmxlZCB3aXRoIHhpdCcpO1xcbiAgICAgIHJldHVybiBzcGVjO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLmZpdCA9IGZ1bmN0aW9uKGRlc2NyaXB0aW9uLCBmbiwgdGltZW91dCl7XFxuICAgICAgdmFyIHNwZWMgPSBzcGVjRmFjdG9yeShkZXNjcmlwdGlvbiwgZm4sIGN1cnJlbnREZWNsYXJhdGlvblN1aXRlLCB0aW1lb3V0KTtcXG4gICAgICBjdXJyZW50RGVjbGFyYXRpb25TdWl0ZS5hZGRDaGlsZChzcGVjKTtcXG4gICAgICBmb2N1c2VkUnVubmFibGVzLnB1c2goc3BlYy5pZCk7XFxuICAgICAgdW5mb2N1c0FuY2VzdG9yKCk7XFxuICAgICAgcmV0dXJuIHNwZWM7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuZXhwZWN0ID0gZnVuY3Rpb24oYWN0dWFsKSB7XFxuICAgICAgaWYgKCFjdXJyZW50UnVubmFibGUoKSkge1xcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcXFxcJ2V4cGVjdFxcXFwnIHdhcyB1c2VkIHdoZW4gdGhlcmUgd2FzIG5vIGN1cnJlbnQgc3BlYywgdGhpcyBjb3VsZCBiZSBiZWNhdXNlIGFuIGFzeW5jaHJvbm91cyB0ZXN0IHRpbWVkIG91dCcpO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gY3VycmVudFJ1bm5hYmxlKCkuZXhwZWN0KGFjdHVhbCk7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuYmVmb3JlRWFjaCA9IGZ1bmN0aW9uKGJlZm9yZUVhY2hGdW5jdGlvbiwgdGltZW91dCkge1xcbiAgICAgIGN1cnJlbnREZWNsYXJhdGlvblN1aXRlLmJlZm9yZUVhY2goe1xcbiAgICAgICAgZm46IGJlZm9yZUVhY2hGdW5jdGlvbixcXG4gICAgICAgIHRpbWVvdXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGltZW91dCB8fCBqJC5ERUZBVUxUX1RJTUVPVVRfSU5URVJWQUw7IH1cXG4gICAgICB9KTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5iZWZvcmVBbGwgPSBmdW5jdGlvbihiZWZvcmVBbGxGdW5jdGlvbiwgdGltZW91dCkge1xcbiAgICAgIGN1cnJlbnREZWNsYXJhdGlvblN1aXRlLmJlZm9yZUFsbCh7XFxuICAgICAgICBmbjogYmVmb3JlQWxsRnVuY3Rpb24sXFxuICAgICAgICB0aW1lb3V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRpbWVvdXQgfHwgaiQuREVGQVVMVF9USU1FT1VUX0lOVEVSVkFMOyB9XFxuICAgICAgfSk7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuYWZ0ZXJFYWNoID0gZnVuY3Rpb24oYWZ0ZXJFYWNoRnVuY3Rpb24sIHRpbWVvdXQpIHtcXG4gICAgICBjdXJyZW50RGVjbGFyYXRpb25TdWl0ZS5hZnRlckVhY2goe1xcbiAgICAgICAgZm46IGFmdGVyRWFjaEZ1bmN0aW9uLFxcbiAgICAgICAgdGltZW91dDogZnVuY3Rpb24oKSB7IHJldHVybiB0aW1lb3V0IHx8IGokLkRFRkFVTFRfVElNRU9VVF9JTlRFUlZBTDsgfVxcbiAgICAgIH0pO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLmFmdGVyQWxsID0gZnVuY3Rpb24oYWZ0ZXJBbGxGdW5jdGlvbiwgdGltZW91dCkge1xcbiAgICAgIGN1cnJlbnREZWNsYXJhdGlvblN1aXRlLmFmdGVyQWxsKHtcXG4gICAgICAgIGZuOiBhZnRlckFsbEZ1bmN0aW9uLFxcbiAgICAgICAgdGltZW91dDogZnVuY3Rpb24oKSB7IHJldHVybiB0aW1lb3V0IHx8IGokLkRFRkFVTFRfVElNRU9VVF9JTlRFUlZBTDsgfVxcbiAgICAgIH0pO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLnBlbmRpbmcgPSBmdW5jdGlvbihtZXNzYWdlKSB7XFxuICAgICAgdmFyIGZ1bGxNZXNzYWdlID0gaiQuU3BlYy5wZW5kaW5nU3BlY0V4Y2VwdGlvbk1lc3NhZ2U7XFxuICAgICAgaWYobWVzc2FnZSkge1xcbiAgICAgICAgZnVsbE1lc3NhZ2UgKz0gbWVzc2FnZTtcXG4gICAgICB9XFxuICAgICAgdGhyb3cgZnVsbE1lc3NhZ2U7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuZmFpbCA9IGZ1bmN0aW9uKGVycm9yKSB7XFxuICAgICAgdmFyIG1lc3NhZ2UgPSAnRmFpbGVkJztcXG4gICAgICBpZiAoZXJyb3IpIHtcXG4gICAgICAgIG1lc3NhZ2UgKz0gJzogJztcXG4gICAgICAgIG1lc3NhZ2UgKz0gZXJyb3IubWVzc2FnZSB8fCBlcnJvcjtcXG4gICAgICB9XFxuXFxuICAgICAgY3VycmVudFJ1bm5hYmxlKCkuYWRkRXhwZWN0YXRpb25SZXN1bHQoZmFsc2UsIHtcXG4gICAgICAgIG1hdGNoZXJOYW1lOiAnJyxcXG4gICAgICAgIHBhc3NlZDogZmFsc2UsXFxuICAgICAgICBleHBlY3RlZDogJycsXFxuICAgICAgICBhY3R1YWw6ICcnLFxcbiAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcXG4gICAgICAgIGVycm9yOiBlcnJvciAmJiBlcnJvci5tZXNzYWdlID8gZXJyb3IgOiBudWxsXFxuICAgICAgfSk7XFxuICAgIH07XFxuICB9XFxuXFxuICByZXR1cm4gRW52O1xcbn07XFxuXFxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5Kc0FwaVJlcG9ydGVyID0gZnVuY3Rpb24oKSB7XFxuXFxuICB2YXIgbm9vcFRpbWVyID0ge1xcbiAgICBzdGFydDogZnVuY3Rpb24oKXt9LFxcbiAgICBlbGFwc2VkOiBmdW5jdGlvbigpeyByZXR1cm4gMDsgfVxcbiAgfTtcXG5cXG4gIGZ1bmN0aW9uIEpzQXBpUmVwb3J0ZXIob3B0aW9ucykge1xcbiAgICB2YXIgdGltZXIgPSBvcHRpb25zLnRpbWVyIHx8IG5vb3BUaW1lcixcXG4gICAgICAgIHN0YXR1cyA9ICdsb2FkZWQnO1xcblxcbiAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcXG4gICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xcbiAgICB0aGlzLnJ1bkRldGFpbHMgPSB7fTtcXG5cXG4gICAgdGhpcy5qYXNtaW5lU3RhcnRlZCA9IGZ1bmN0aW9uKCkge1xcbiAgICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XFxuICAgICAgc3RhdHVzID0gJ3N0YXJ0ZWQnO1xcbiAgICAgIHRpbWVyLnN0YXJ0KCk7XFxuICAgIH07XFxuXFxuICAgIHZhciBleGVjdXRpb25UaW1lO1xcblxcbiAgICB0aGlzLmphc21pbmVEb25lID0gZnVuY3Rpb24ocnVuRGV0YWlscykge1xcbiAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xcbiAgICAgIHRoaXMucnVuRGV0YWlscyA9IHJ1bkRldGFpbHM7XFxuICAgICAgZXhlY3V0aW9uVGltZSA9IHRpbWVyLmVsYXBzZWQoKTtcXG4gICAgICBzdGF0dXMgPSAnZG9uZSc7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuc3RhdHVzID0gZnVuY3Rpb24oKSB7XFxuICAgICAgcmV0dXJuIHN0YXR1cztcXG4gICAgfTtcXG5cXG4gICAgdmFyIHN1aXRlcyA9IFtdLFxcbiAgICAgIHN1aXRlc19oYXNoID0ge307XFxuXFxuICAgIHRoaXMuc3VpdGVTdGFydGVkID0gZnVuY3Rpb24ocmVzdWx0KSB7XFxuICAgICAgc3VpdGVzX2hhc2hbcmVzdWx0LmlkXSA9IHJlc3VsdDtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5zdWl0ZURvbmUgPSBmdW5jdGlvbihyZXN1bHQpIHtcXG4gICAgICBzdG9yZVN1aXRlKHJlc3VsdCk7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuc3VpdGVSZXN1bHRzID0gZnVuY3Rpb24oaW5kZXgsIGxlbmd0aCkge1xcbiAgICAgIHJldHVybiBzdWl0ZXMuc2xpY2UoaW5kZXgsIGluZGV4ICsgbGVuZ3RoKTtcXG4gICAgfTtcXG5cXG4gICAgZnVuY3Rpb24gc3RvcmVTdWl0ZShyZXN1bHQpIHtcXG4gICAgICBzdWl0ZXMucHVzaChyZXN1bHQpO1xcbiAgICAgIHN1aXRlc19oYXNoW3Jlc3VsdC5pZF0gPSByZXN1bHQ7XFxuICAgIH1cXG5cXG4gICAgdGhpcy5zdWl0ZXMgPSBmdW5jdGlvbigpIHtcXG4gICAgICByZXR1cm4gc3VpdGVzX2hhc2g7XFxuICAgIH07XFxuXFxuICAgIHZhciBzcGVjcyA9IFtdO1xcblxcbiAgICB0aGlzLnNwZWNEb25lID0gZnVuY3Rpb24ocmVzdWx0KSB7XFxuICAgICAgc3BlY3MucHVzaChyZXN1bHQpO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLnNwZWNSZXN1bHRzID0gZnVuY3Rpb24oaW5kZXgsIGxlbmd0aCkge1xcbiAgICAgIHJldHVybiBzcGVjcy5zbGljZShpbmRleCwgaW5kZXggKyBsZW5ndGgpO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLnNwZWNzID0gZnVuY3Rpb24oKSB7XFxuICAgICAgcmV0dXJuIHNwZWNzO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLmV4ZWN1dGlvblRpbWUgPSBmdW5jdGlvbigpIHtcXG4gICAgICByZXR1cm4gZXhlY3V0aW9uVGltZTtcXG4gICAgfTtcXG5cXG4gIH1cXG5cXG4gIHJldHVybiBKc0FwaVJlcG9ydGVyO1xcbn07XFxuXFxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5DYWxsVHJhY2tlciA9IGZ1bmN0aW9uKCkge1xcblxcbiAgZnVuY3Rpb24gQ2FsbFRyYWNrZXIoKSB7XFxuICAgIHZhciBjYWxscyA9IFtdO1xcblxcbiAgICB0aGlzLnRyYWNrID0gZnVuY3Rpb24oY29udGV4dCkge1xcbiAgICAgIGNhbGxzLnB1c2goY29udGV4dCk7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuYW55ID0gZnVuY3Rpb24oKSB7XFxuICAgICAgcmV0dXJuICEhY2FsbHMubGVuZ3RoO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLmNvdW50ID0gZnVuY3Rpb24oKSB7XFxuICAgICAgcmV0dXJuIGNhbGxzLmxlbmd0aDtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5hcmdzRm9yID0gZnVuY3Rpb24oaW5kZXgpIHtcXG4gICAgICB2YXIgY2FsbCA9IGNhbGxzW2luZGV4XTtcXG4gICAgICByZXR1cm4gY2FsbCA/IGNhbGwuYXJncyA6IFtdO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLmFsbCA9IGZ1bmN0aW9uKCkge1xcbiAgICAgIHJldHVybiBjYWxscztcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5hbGxBcmdzID0gZnVuY3Rpb24oKSB7XFxuICAgICAgdmFyIGNhbGxBcmdzID0gW107XFxuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGNhbGxzLmxlbmd0aDsgaSsrKXtcXG4gICAgICAgIGNhbGxBcmdzLnB1c2goY2FsbHNbaV0uYXJncyk7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBjYWxsQXJncztcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5maXJzdCA9IGZ1bmN0aW9uKCkge1xcbiAgICAgIHJldHVybiBjYWxsc1swXTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5tb3N0UmVjZW50ID0gZnVuY3Rpb24oKSB7XFxuICAgICAgcmV0dXJuIGNhbGxzW2NhbGxzLmxlbmd0aCAtIDFdO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLnJlc2V0ID0gZnVuY3Rpb24oKSB7XFxuICAgICAgY2FsbHMgPSBbXTtcXG4gICAgfTtcXG4gIH1cXG5cXG4gIHJldHVybiBDYWxsVHJhY2tlcjtcXG59O1xcblxcbmdldEphc21pbmVSZXF1aXJlT2JqKCkuQ2xvY2sgPSBmdW5jdGlvbigpIHtcXG4gIGZ1bmN0aW9uIENsb2NrKGdsb2JhbCwgZGVsYXllZEZ1bmN0aW9uU2NoZWR1bGVyRmFjdG9yeSwgbW9ja0RhdGUpIHtcXG4gICAgdmFyIHNlbGYgPSB0aGlzLFxcbiAgICAgIHJlYWxUaW1pbmdGdW5jdGlvbnMgPSB7XFxuICAgICAgICBzZXRUaW1lb3V0OiBnbG9iYWwuc2V0VGltZW91dCxcXG4gICAgICAgIGNsZWFyVGltZW91dDogZ2xvYmFsLmNsZWFyVGltZW91dCxcXG4gICAgICAgIHNldEludGVydmFsOiBnbG9iYWwuc2V0SW50ZXJ2YWwsXFxuICAgICAgICBjbGVhckludGVydmFsOiBnbG9iYWwuY2xlYXJJbnRlcnZhbFxcbiAgICAgIH0sXFxuICAgICAgZmFrZVRpbWluZ0Z1bmN0aW9ucyA9IHtcXG4gICAgICAgIHNldFRpbWVvdXQ6IHNldFRpbWVvdXQsXFxuICAgICAgICBjbGVhclRpbWVvdXQ6IGNsZWFyVGltZW91dCxcXG4gICAgICAgIHNldEludGVydmFsOiBzZXRJbnRlcnZhbCxcXG4gICAgICAgIGNsZWFySW50ZXJ2YWw6IGNsZWFySW50ZXJ2YWxcXG4gICAgICB9LFxcbiAgICAgIGluc3RhbGxlZCA9IGZhbHNlLFxcbiAgICAgIGRlbGF5ZWRGdW5jdGlvblNjaGVkdWxlcixcXG4gICAgICB0aW1lcjtcXG5cXG5cXG4gICAgc2VsZi5pbnN0YWxsID0gZnVuY3Rpb24oKSB7XFxuICAgICAgaWYoIW9yaWdpbmFsVGltaW5nRnVuY3Rpb25zSW50YWN0KCkpIHtcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSmFzbWluZSBDbG9jayB3YXMgdW5hYmxlIHRvIGluc3RhbGwgb3ZlciBjdXN0b20gZ2xvYmFsIHRpbWVyIGZ1bmN0aW9ucy4gSXMgdGhlIGNsb2NrIGFscmVhZHkgaW5zdGFsbGVkPycpO1xcbiAgICAgIH1cXG4gICAgICByZXBsYWNlKGdsb2JhbCwgZmFrZVRpbWluZ0Z1bmN0aW9ucyk7XFxuICAgICAgdGltZXIgPSBmYWtlVGltaW5nRnVuY3Rpb25zO1xcbiAgICAgIGRlbGF5ZWRGdW5jdGlvblNjaGVkdWxlciA9IGRlbGF5ZWRGdW5jdGlvblNjaGVkdWxlckZhY3RvcnkoKTtcXG4gICAgICBpbnN0YWxsZWQgPSB0cnVlO1xcblxcbiAgICAgIHJldHVybiBzZWxmO1xcbiAgICB9O1xcblxcbiAgICBzZWxmLnVuaW5zdGFsbCA9IGZ1bmN0aW9uKCkge1xcbiAgICAgIGRlbGF5ZWRGdW5jdGlvblNjaGVkdWxlciA9IG51bGw7XFxuICAgICAgbW9ja0RhdGUudW5pbnN0YWxsKCk7XFxuICAgICAgcmVwbGFjZShnbG9iYWwsIHJlYWxUaW1pbmdGdW5jdGlvbnMpO1xcblxcbiAgICAgIHRpbWVyID0gcmVhbFRpbWluZ0Z1bmN0aW9ucztcXG4gICAgICBpbnN0YWxsZWQgPSBmYWxzZTtcXG4gICAgfTtcXG5cXG4gICAgc2VsZi53aXRoTW9jayA9IGZ1bmN0aW9uKGNsb3N1cmUpIHtcXG4gICAgICB0aGlzLmluc3RhbGwoKTtcXG4gICAgICB0cnkge1xcbiAgICAgICAgY2xvc3VyZSgpO1xcbiAgICAgIH0gZmluYWxseSB7XFxuICAgICAgICB0aGlzLnVuaW5zdGFsbCgpO1xcbiAgICAgIH1cXG4gICAgfTtcXG5cXG4gICAgc2VsZi5tb2NrRGF0ZSA9IGZ1bmN0aW9uKGluaXRpYWxEYXRlKSB7XFxuICAgICAgbW9ja0RhdGUuaW5zdGFsbChpbml0aWFsRGF0ZSk7XFxuICAgIH07XFxuXFxuICAgIHNlbGYuc2V0VGltZW91dCA9IGZ1bmN0aW9uKGZuLCBkZWxheSwgcGFyYW1zKSB7XFxuICAgICAgaWYgKGxlZ2FjeUlFKCkpIHtcXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lFIDwgOSBjYW5ub3Qgc3VwcG9ydCBleHRyYSBwYXJhbXMgdG8gc2V0VGltZW91dCB3aXRob3V0IGEgcG9seWZpbGwnKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiB0aW1lci5zZXRUaW1lb3V0KGZuLCBkZWxheSk7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkodGltZXIuc2V0VGltZW91dCwgW2dsb2JhbCwgYXJndW1lbnRzXSk7XFxuICAgIH07XFxuXFxuICAgIHNlbGYuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbihmbiwgZGVsYXksIHBhcmFtcykge1xcbiAgICAgIGlmIChsZWdhY3lJRSgpKSB7XFxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJRSA8IDkgY2Fubm90IHN1cHBvcnQgZXh0cmEgcGFyYW1zIHRvIHNldEludGVydmFsIHdpdGhvdXQgYSBwb2x5ZmlsbCcpO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIHRpbWVyLnNldEludGVydmFsKGZuLCBkZWxheSk7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkodGltZXIuc2V0SW50ZXJ2YWwsIFtnbG9iYWwsIGFyZ3VtZW50c10pO1xcbiAgICB9O1xcblxcbiAgICBzZWxmLmNsZWFyVGltZW91dCA9IGZ1bmN0aW9uKGlkKSB7XFxuICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsLmFwcGx5KHRpbWVyLmNsZWFyVGltZW91dCwgW2dsb2JhbCwgaWRdKTtcXG4gICAgfTtcXG5cXG4gICAgc2VsZi5jbGVhckludGVydmFsID0gZnVuY3Rpb24oaWQpIHtcXG4gICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwuYXBwbHkodGltZXIuY2xlYXJJbnRlcnZhbCwgW2dsb2JhbCwgaWRdKTtcXG4gICAgfTtcXG5cXG4gICAgc2VsZi50aWNrID0gZnVuY3Rpb24obWlsbGlzKSB7XFxuICAgICAgaWYgKGluc3RhbGxlZCkge1xcbiAgICAgICAgbW9ja0RhdGUudGljayhtaWxsaXMpO1xcbiAgICAgICAgZGVsYXllZEZ1bmN0aW9uU2NoZWR1bGVyLnRpY2sobWlsbGlzKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNb2NrIGNsb2NrIGlzIG5vdCBpbnN0YWxsZWQsIHVzZSBqYXNtaW5lLmNsb2NrKCkuaW5zdGFsbCgpJyk7XFxuICAgICAgfVxcbiAgICB9O1xcblxcbiAgICByZXR1cm4gc2VsZjtcXG5cXG4gICAgZnVuY3Rpb24gb3JpZ2luYWxUaW1pbmdGdW5jdGlvbnNJbnRhY3QoKSB7XFxuICAgICAgcmV0dXJuIGdsb2JhbC5zZXRUaW1lb3V0ID09PSByZWFsVGltaW5nRnVuY3Rpb25zLnNldFRpbWVvdXQgJiZcXG4gICAgICAgIGdsb2JhbC5jbGVhclRpbWVvdXQgPT09IHJlYWxUaW1pbmdGdW5jdGlvbnMuY2xlYXJUaW1lb3V0ICYmXFxuICAgICAgICBnbG9iYWwuc2V0SW50ZXJ2YWwgPT09IHJlYWxUaW1pbmdGdW5jdGlvbnMuc2V0SW50ZXJ2YWwgJiZcXG4gICAgICAgIGdsb2JhbC5jbGVhckludGVydmFsID09PSByZWFsVGltaW5nRnVuY3Rpb25zLmNsZWFySW50ZXJ2YWw7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gbGVnYWN5SUUoKSB7XFxuICAgICAgLy9pZiB0aGVzZSBtZXRob2RzIGFyZSBwb2x5ZmlsbGVkLCBhcHBseSB3aWxsIGJlIHByZXNlbnRcXG4gICAgICByZXR1cm4gIShyZWFsVGltaW5nRnVuY3Rpb25zLnNldFRpbWVvdXQgfHwgcmVhbFRpbWluZ0Z1bmN0aW9ucy5zZXRJbnRlcnZhbCkuYXBwbHk7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gcmVwbGFjZShkZXN0LCBzb3VyY2UpIHtcXG4gICAgICBmb3IgKHZhciBwcm9wIGluIHNvdXJjZSkge1xcbiAgICAgICAgZGVzdFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gc2V0VGltZW91dChmbiwgZGVsYXkpIHtcXG4gICAgICByZXR1cm4gZGVsYXllZEZ1bmN0aW9uU2NoZWR1bGVyLnNjaGVkdWxlRnVuY3Rpb24oZm4sIGRlbGF5LCBhcmdTbGljZShhcmd1bWVudHMsIDIpKTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBjbGVhclRpbWVvdXQoaWQpIHtcXG4gICAgICByZXR1cm4gZGVsYXllZEZ1bmN0aW9uU2NoZWR1bGVyLnJlbW92ZUZ1bmN0aW9uV2l0aElkKGlkKTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBzZXRJbnRlcnZhbChmbiwgaW50ZXJ2YWwpIHtcXG4gICAgICByZXR1cm4gZGVsYXllZEZ1bmN0aW9uU2NoZWR1bGVyLnNjaGVkdWxlRnVuY3Rpb24oZm4sIGludGVydmFsLCBhcmdTbGljZShhcmd1bWVudHMsIDIpLCB0cnVlKTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBjbGVhckludGVydmFsKGlkKSB7XFxuICAgICAgcmV0dXJuIGRlbGF5ZWRGdW5jdGlvblNjaGVkdWxlci5yZW1vdmVGdW5jdGlvbldpdGhJZChpZCk7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gYXJnU2xpY2UoYXJnc09iaiwgbikge1xcbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzT2JqLCBuKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgcmV0dXJuIENsb2NrO1xcbn07XFxuXFxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5EZWxheWVkRnVuY3Rpb25TY2hlZHVsZXIgPSBmdW5jdGlvbigpIHtcXG4gIGZ1bmN0aW9uIERlbGF5ZWRGdW5jdGlvblNjaGVkdWxlcigpIHtcXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgICB2YXIgc2NoZWR1bGVkTG9va3VwID0gW107XFxuICAgIHZhciBzY2hlZHVsZWRGdW5jdGlvbnMgPSB7fTtcXG4gICAgdmFyIGN1cnJlbnRUaW1lID0gMDtcXG4gICAgdmFyIGRlbGF5ZWRGbkNvdW50ID0gMDtcXG5cXG4gICAgc2VsZi50aWNrID0gZnVuY3Rpb24obWlsbGlzKSB7XFxuICAgICAgbWlsbGlzID0gbWlsbGlzIHx8IDA7XFxuICAgICAgdmFyIGVuZFRpbWUgPSBjdXJyZW50VGltZSArIG1pbGxpcztcXG5cXG4gICAgICBydW5TY2hlZHVsZWRGdW5jdGlvbnMoZW5kVGltZSk7XFxuICAgICAgY3VycmVudFRpbWUgPSBlbmRUaW1lO1xcbiAgICB9O1xcblxcbiAgICBzZWxmLnNjaGVkdWxlRnVuY3Rpb24gPSBmdW5jdGlvbihmdW5jVG9DYWxsLCBtaWxsaXMsIHBhcmFtcywgcmVjdXJyaW5nLCB0aW1lb3V0S2V5LCBydW5BdE1pbGxpcykge1xcbiAgICAgIHZhciBmO1xcbiAgICAgIGlmICh0eXBlb2YoZnVuY1RvQ2FsbCkgPT09ICdzdHJpbmcnKSB7XFxuICAgICAgICAvKiBqc2hpbnQgZXZpbDogdHJ1ZSAqL1xcbiAgICAgICAgZiA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gZXZhbChmdW5jVG9DYWxsKTsgfTtcXG4gICAgICAgIC8qIGpzaGludCBldmlsOiBmYWxzZSAqL1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBmID0gZnVuY1RvQ2FsbDtcXG4gICAgICB9XFxuXFxuICAgICAgbWlsbGlzID0gbWlsbGlzIHx8IDA7XFxuICAgICAgdGltZW91dEtleSA9IHRpbWVvdXRLZXkgfHwgKytkZWxheWVkRm5Db3VudDtcXG4gICAgICBydW5BdE1pbGxpcyA9IHJ1bkF0TWlsbGlzIHx8IChjdXJyZW50VGltZSArIG1pbGxpcyk7XFxuXFxuICAgICAgdmFyIGZ1bmNUb1NjaGVkdWxlID0ge1xcbiAgICAgICAgcnVuQXRNaWxsaXM6IHJ1bkF0TWlsbGlzLFxcbiAgICAgICAgZnVuY1RvQ2FsbDogZixcXG4gICAgICAgIHJlY3VycmluZzogcmVjdXJyaW5nLFxcbiAgICAgICAgcGFyYW1zOiBwYXJhbXMsXFxuICAgICAgICB0aW1lb3V0S2V5OiB0aW1lb3V0S2V5LFxcbiAgICAgICAgbWlsbGlzOiBtaWxsaXNcXG4gICAgICB9O1xcblxcbiAgICAgIGlmIChydW5BdE1pbGxpcyBpbiBzY2hlZHVsZWRGdW5jdGlvbnMpIHtcXG4gICAgICAgIHNjaGVkdWxlZEZ1bmN0aW9uc1tydW5BdE1pbGxpc10ucHVzaChmdW5jVG9TY2hlZHVsZSk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHNjaGVkdWxlZEZ1bmN0aW9uc1tydW5BdE1pbGxpc10gPSBbZnVuY1RvU2NoZWR1bGVdO1xcbiAgICAgICAgc2NoZWR1bGVkTG9va3VwLnB1c2gocnVuQXRNaWxsaXMpO1xcbiAgICAgICAgc2NoZWR1bGVkTG9va3VwLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgICAgICAgcmV0dXJuIGEgLSBiO1xcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiB0aW1lb3V0S2V5O1xcbiAgICB9O1xcblxcbiAgICBzZWxmLnJlbW92ZUZ1bmN0aW9uV2l0aElkID0gZnVuY3Rpb24odGltZW91dEtleSkge1xcbiAgICAgIGZvciAodmFyIHJ1bkF0TWlsbGlzIGluIHNjaGVkdWxlZEZ1bmN0aW9ucykge1xcbiAgICAgICAgdmFyIGZ1bmNzID0gc2NoZWR1bGVkRnVuY3Rpb25zW3J1bkF0TWlsbGlzXTtcXG4gICAgICAgIHZhciBpID0gaW5kZXhPZkZpcnN0VG9QYXNzKGZ1bmNzLCBmdW5jdGlvbiAoZnVuYykge1xcbiAgICAgICAgICByZXR1cm4gZnVuYy50aW1lb3V0S2V5ID09PSB0aW1lb3V0S2V5O1xcbiAgICAgICAgfSk7XFxuXFxuICAgICAgICBpZiAoaSA+IC0xKSB7XFxuICAgICAgICAgIGlmIChmdW5jcy5sZW5ndGggPT09IDEpIHtcXG4gICAgICAgICAgICBkZWxldGUgc2NoZWR1bGVkRnVuY3Rpb25zW3J1bkF0TWlsbGlzXTtcXG4gICAgICAgICAgICBkZWxldGVGcm9tTG9va3VwKHJ1bkF0TWlsbGlzKTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBmdW5jcy5zcGxpY2UoaSwgMSk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgLy8gaW50ZXJ2YWxzIGdldCByZXNjaGVkdWxlZCB3aGVuIGV4ZWN1dGVkLCBzbyB0aGVyZSdzIG5ldmVyIG1vcmVcXG4gICAgICAgICAgLy8gdGhhbiBhIHNpbmdsZSBzY2hlZHVsZWQgZnVuY3Rpb24gd2l0aCBhIGdpdmVuIHRpbWVvdXRLZXlcXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9O1xcblxcbiAgICByZXR1cm4gc2VsZjtcXG5cXG4gICAgZnVuY3Rpb24gaW5kZXhPZkZpcnN0VG9QYXNzKGFycmF5LCB0ZXN0Rm4pIHtcXG4gICAgICB2YXIgaW5kZXggPSAtMTtcXG5cXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgKytpKSB7XFxuICAgICAgICBpZiAodGVzdEZuKGFycmF5W2ldKSkge1xcbiAgICAgICAgICBpbmRleCA9IGk7XFxuICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gaW5kZXg7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gZGVsZXRlRnJvbUxvb2t1cChrZXkpIHtcXG4gICAgICB2YXIgdmFsdWUgPSBOdW1iZXIoa2V5KTtcXG4gICAgICB2YXIgaSA9IGluZGV4T2ZGaXJzdFRvUGFzcyhzY2hlZHVsZWRMb29rdXAsIGZ1bmN0aW9uIChtaWxsaXMpIHtcXG4gICAgICAgIHJldHVybiBtaWxsaXMgPT09IHZhbHVlO1xcbiAgICAgIH0pO1xcblxcbiAgICAgIGlmIChpID4gLTEpIHtcXG4gICAgICAgIHNjaGVkdWxlZExvb2t1cC5zcGxpY2UoaSwgMSk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIHJlc2NoZWR1bGUoc2NoZWR1bGVkRm4pIHtcXG4gICAgICBzZWxmLnNjaGVkdWxlRnVuY3Rpb24oc2NoZWR1bGVkRm4uZnVuY1RvQ2FsbCxcXG4gICAgICAgIHNjaGVkdWxlZEZuLm1pbGxpcyxcXG4gICAgICAgIHNjaGVkdWxlZEZuLnBhcmFtcyxcXG4gICAgICAgIHRydWUsXFxuICAgICAgICBzY2hlZHVsZWRGbi50aW1lb3V0S2V5LFxcbiAgICAgICAgc2NoZWR1bGVkRm4ucnVuQXRNaWxsaXMgKyBzY2hlZHVsZWRGbi5taWxsaXMpO1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIGZvckVhY2hGdW5jdGlvbihmdW5jc1RvUnVuLCBjYWxsYmFjaykge1xcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnVuY3NUb1J1bi5sZW5ndGg7ICsraSkge1xcbiAgICAgICAgY2FsbGJhY2soZnVuY3NUb1J1bltpXSk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIHJ1blNjaGVkdWxlZEZ1bmN0aW9ucyhlbmRUaW1lKSB7XFxuICAgICAgaWYgKHNjaGVkdWxlZExvb2t1cC5sZW5ndGggPT09IDAgfHwgc2NoZWR1bGVkTG9va3VwWzBdID4gZW5kVGltZSkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBkbyB7XFxuICAgICAgICBjdXJyZW50VGltZSA9IHNjaGVkdWxlZExvb2t1cC5zaGlmdCgpO1xcblxcbiAgICAgICAgdmFyIGZ1bmNzVG9SdW4gPSBzY2hlZHVsZWRGdW5jdGlvbnNbY3VycmVudFRpbWVdO1xcbiAgICAgICAgZGVsZXRlIHNjaGVkdWxlZEZ1bmN0aW9uc1tjdXJyZW50VGltZV07XFxuXFxuICAgICAgICBmb3JFYWNoRnVuY3Rpb24oZnVuY3NUb1J1biwgZnVuY3Rpb24oZnVuY1RvUnVuKSB7XFxuICAgICAgICAgIGlmIChmdW5jVG9SdW4ucmVjdXJyaW5nKSB7XFxuICAgICAgICAgICAgcmVzY2hlZHVsZShmdW5jVG9SdW4pO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG5cXG4gICAgICAgIGZvckVhY2hGdW5jdGlvbihmdW5jc1RvUnVuLCBmdW5jdGlvbihmdW5jVG9SdW4pIHtcXG4gICAgICAgICAgZnVuY1RvUnVuLmZ1bmNUb0NhbGwuYXBwbHkobnVsbCwgZnVuY1RvUnVuLnBhcmFtcyB8fCBbXSk7XFxuICAgICAgICB9KTtcXG4gICAgICB9IHdoaWxlIChzY2hlZHVsZWRMb29rdXAubGVuZ3RoID4gMCAmJlxcbiAgICAgICAgICAgICAgLy8gY2hlY2tpbmcgZmlyc3QgaWYgd2UncmUgb3V0IG9mIHRpbWUgcHJldmVudHMgc2V0VGltZW91dCgwKVxcbiAgICAgICAgICAgICAgLy8gc2NoZWR1bGVkIGluIGEgZnVuY1RvUnVuIGZyb20gZm9yY2luZyBhbiBleHRyYSBpdGVyYXRpb25cXG4gICAgICAgICAgICAgICAgIGN1cnJlbnRUaW1lICE9PSBlbmRUaW1lICAmJlxcbiAgICAgICAgICAgICAgICAgc2NoZWR1bGVkTG9va3VwWzBdIDw9IGVuZFRpbWUpO1xcbiAgICB9XFxuICB9XFxuXFxuICByZXR1cm4gRGVsYXllZEZ1bmN0aW9uU2NoZWR1bGVyO1xcbn07XFxuXFxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5FeGNlcHRpb25Gb3JtYXR0ZXIgPSBmdW5jdGlvbigpIHtcXG4gIGZ1bmN0aW9uIEV4Y2VwdGlvbkZvcm1hdHRlcigpIHtcXG4gICAgdGhpcy5tZXNzYWdlID0gZnVuY3Rpb24oZXJyb3IpIHtcXG4gICAgICB2YXIgbWVzc2FnZSA9ICcnO1xcblxcbiAgICAgIGlmIChlcnJvci5uYW1lICYmIGVycm9yLm1lc3NhZ2UpIHtcXG4gICAgICAgIG1lc3NhZ2UgKz0gZXJyb3IubmFtZSArICc6ICcgKyBlcnJvci5tZXNzYWdlO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBtZXNzYWdlICs9IGVycm9yLnRvU3RyaW5nKCkgKyAnIHRocm93bic7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChlcnJvci5maWxlTmFtZSB8fCBlcnJvci5zb3VyY2VVUkwpIHtcXG4gICAgICAgIG1lc3NhZ2UgKz0gJyBpbiAnICsgKGVycm9yLmZpbGVOYW1lIHx8IGVycm9yLnNvdXJjZVVSTCk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChlcnJvci5saW5lIHx8IGVycm9yLmxpbmVOdW1iZXIpIHtcXG4gICAgICAgIG1lc3NhZ2UgKz0gJyAobGluZSAnICsgKGVycm9yLmxpbmUgfHwgZXJyb3IubGluZU51bWJlcikgKyAnKSc7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBtZXNzYWdlO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLnN0YWNrID0gZnVuY3Rpb24oZXJyb3IpIHtcXG4gICAgICByZXR1cm4gZXJyb3IgPyBlcnJvci5zdGFjayA6IG51bGw7XFxuICAgIH07XFxuICB9XFxuXFxuICByZXR1cm4gRXhjZXB0aW9uRm9ybWF0dGVyO1xcbn07XFxuXFxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5FeHBlY3RhdGlvbiA9IGZ1bmN0aW9uKCkge1xcblxcbiAgZnVuY3Rpb24gRXhwZWN0YXRpb24ob3B0aW9ucykge1xcbiAgICB0aGlzLnV0aWwgPSBvcHRpb25zLnV0aWwgfHwgeyBidWlsZEZhaWx1cmVNZXNzYWdlOiBmdW5jdGlvbigpIHt9IH07XFxuICAgIHRoaXMuY3VzdG9tRXF1YWxpdHlUZXN0ZXJzID0gb3B0aW9ucy5jdXN0b21FcXVhbGl0eVRlc3RlcnMgfHwgW107XFxuICAgIHRoaXMuYWN0dWFsID0gb3B0aW9ucy5hY3R1YWw7XFxuICAgIHRoaXMuYWRkRXhwZWN0YXRpb25SZXN1bHQgPSBvcHRpb25zLmFkZEV4cGVjdGF0aW9uUmVzdWx0IHx8IGZ1bmN0aW9uKCl7fTtcXG4gICAgdGhpcy5pc05vdCA9IG9wdGlvbnMuaXNOb3Q7XFxuXFxuICAgIHZhciBjdXN0b21NYXRjaGVycyA9IG9wdGlvbnMuY3VzdG9tTWF0Y2hlcnMgfHwge307XFxuICAgIGZvciAodmFyIG1hdGNoZXJOYW1lIGluIGN1c3RvbU1hdGNoZXJzKSB7XFxuICAgICAgdGhpc1ttYXRjaGVyTmFtZV0gPSBFeHBlY3RhdGlvbi5wcm90b3R5cGUud3JhcENvbXBhcmUobWF0Y2hlck5hbWUsIGN1c3RvbU1hdGNoZXJzW21hdGNoZXJOYW1lXSk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIEV4cGVjdGF0aW9uLnByb3RvdHlwZS53cmFwQ29tcGFyZSA9IGZ1bmN0aW9uKG5hbWUsIG1hdGNoZXJGYWN0b3J5KSB7XFxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcXG4gICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCksXFxuICAgICAgICBleHBlY3RlZCA9IGFyZ3Muc2xpY2UoMCksXFxuICAgICAgICBtZXNzYWdlID0gJyc7XFxuXFxuICAgICAgYXJncy51bnNoaWZ0KHRoaXMuYWN0dWFsKTtcXG5cXG4gICAgICB2YXIgbWF0Y2hlciA9IG1hdGNoZXJGYWN0b3J5KHRoaXMudXRpbCwgdGhpcy5jdXN0b21FcXVhbGl0eVRlc3RlcnMpLFxcbiAgICAgICAgICBtYXRjaGVyQ29tcGFyZSA9IG1hdGNoZXIuY29tcGFyZTtcXG5cXG4gICAgICBmdW5jdGlvbiBkZWZhdWx0TmVnYXRpdmVDb21wYXJlKCkge1xcbiAgICAgICAgdmFyIHJlc3VsdCA9IG1hdGNoZXIuY29tcGFyZS5hcHBseShudWxsLCBhcmdzKTtcXG4gICAgICAgIHJlc3VsdC5wYXNzID0gIXJlc3VsdC5wYXNzO1xcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMuaXNOb3QpIHtcXG4gICAgICAgIG1hdGNoZXJDb21wYXJlID0gbWF0Y2hlci5uZWdhdGl2ZUNvbXBhcmUgfHwgZGVmYXVsdE5lZ2F0aXZlQ29tcGFyZTtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIHJlc3VsdCA9IG1hdGNoZXJDb21wYXJlLmFwcGx5KG51bGwsIGFyZ3MpO1xcblxcbiAgICAgIGlmICghcmVzdWx0LnBhc3MpIHtcXG4gICAgICAgIGlmICghcmVzdWx0Lm1lc3NhZ2UpIHtcXG4gICAgICAgICAgYXJncy51bnNoaWZ0KHRoaXMuaXNOb3QpO1xcbiAgICAgICAgICBhcmdzLnVuc2hpZnQobmFtZSk7XFxuICAgICAgICAgIG1lc3NhZ2UgPSB0aGlzLnV0aWwuYnVpbGRGYWlsdXJlTWVzc2FnZS5hcHBseShudWxsLCBhcmdzKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KHJlc3VsdC5tZXNzYWdlKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJykge1xcbiAgICAgICAgICAgIG1lc3NhZ2UgPSByZXN1bHQubWVzc2FnZSgpO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIG1lc3NhZ2UgPSByZXN1bHQubWVzc2FnZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoZXhwZWN0ZWQubGVuZ3RoID09IDEpIHtcXG4gICAgICAgIGV4cGVjdGVkID0gZXhwZWN0ZWRbMF07XFxuICAgICAgfVxcblxcbiAgICAgIC8vIFRPRE86IGhvdyBtYW55IG9mIHRoZXNlIHBhcmFtcyBhcmUgbmVlZGVkP1xcbiAgICAgIHRoaXMuYWRkRXhwZWN0YXRpb25SZXN1bHQoXFxuICAgICAgICByZXN1bHQucGFzcyxcXG4gICAgICAgIHtcXG4gICAgICAgICAgbWF0Y2hlck5hbWU6IG5hbWUsXFxuICAgICAgICAgIHBhc3NlZDogcmVzdWx0LnBhc3MsXFxuICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXFxuICAgICAgICAgIGFjdHVhbDogdGhpcy5hY3R1YWwsXFxuICAgICAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCAvLyBUT0RPOiB0aGlzIG1heSBuZWVkIHRvIGJlIGFycmF5aWZpZWQvc2xpY2VkXFxuICAgICAgICB9XFxuICAgICAgKTtcXG4gICAgfTtcXG4gIH07XFxuXFxuICBFeHBlY3RhdGlvbi5hZGRDb3JlTWF0Y2hlcnMgPSBmdW5jdGlvbihtYXRjaGVycykge1xcbiAgICB2YXIgcHJvdG90eXBlID0gRXhwZWN0YXRpb24ucHJvdG90eXBlO1xcbiAgICBmb3IgKHZhciBtYXRjaGVyTmFtZSBpbiBtYXRjaGVycykge1xcbiAgICAgIHZhciBtYXRjaGVyID0gbWF0Y2hlcnNbbWF0Y2hlck5hbWVdO1xcbiAgICAgIHByb3RvdHlwZVttYXRjaGVyTmFtZV0gPSBwcm90b3R5cGUud3JhcENvbXBhcmUobWF0Y2hlck5hbWUsIG1hdGNoZXIpO1xcbiAgICB9XFxuICB9O1xcblxcbiAgRXhwZWN0YXRpb24uRmFjdG9yeSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XFxuXFxuICAgIHZhciBleHBlY3QgPSBuZXcgRXhwZWN0YXRpb24ob3B0aW9ucyk7XFxuXFxuICAgIC8vIFRPRE86IHRoaXMgd291bGQgYmUgbmljZSBhcyBpdHMgb3duIE9iamVjdCAtIE5lZ2F0aXZlRXhwZWN0YXRpb25cXG4gICAgLy8gVE9ETzogY29weSBpbnN0ZWFkIG9mIG11dGF0ZSBvcHRpb25zXFxuICAgIG9wdGlvbnMuaXNOb3QgPSB0cnVlO1xcbiAgICBleHBlY3Qubm90ID0gbmV3IEV4cGVjdGF0aW9uKG9wdGlvbnMpO1xcblxcbiAgICByZXR1cm4gZXhwZWN0O1xcbiAgfTtcXG5cXG4gIHJldHVybiBFeHBlY3RhdGlvbjtcXG59O1xcblxcbi8vVE9ETzogZXhwZWN0YXRpb24gcmVzdWx0IG1heSBtYWtlIG1vcmUgc2Vuc2UgYXMgYSBwcmVzZW50YXRpb24gb2YgYW4gZXhwZWN0YXRpb24uXFxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5idWlsZEV4cGVjdGF0aW9uUmVzdWx0ID0gZnVuY3Rpb24oKSB7XFxuICBmdW5jdGlvbiBidWlsZEV4cGVjdGF0aW9uUmVzdWx0KG9wdGlvbnMpIHtcXG4gICAgdmFyIG1lc3NhZ2VGb3JtYXR0ZXIgPSBvcHRpb25zLm1lc3NhZ2VGb3JtYXR0ZXIgfHwgZnVuY3Rpb24oKSB7fSxcXG4gICAgICBzdGFja0Zvcm1hdHRlciA9IG9wdGlvbnMuc3RhY2tGb3JtYXR0ZXIgfHwgZnVuY3Rpb24oKSB7fTtcXG5cXG4gICAgdmFyIHJlc3VsdCA9IHtcXG4gICAgICBtYXRjaGVyTmFtZTogb3B0aW9ucy5tYXRjaGVyTmFtZSxcXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlKCksXFxuICAgICAgc3RhY2s6IHN0YWNrKCksXFxuICAgICAgcGFzc2VkOiBvcHRpb25zLnBhc3NlZFxcbiAgICB9O1xcblxcbiAgICBpZighcmVzdWx0LnBhc3NlZCkge1xcbiAgICAgIHJlc3VsdC5leHBlY3RlZCA9IG9wdGlvbnMuZXhwZWN0ZWQ7XFxuICAgICAgcmVzdWx0LmFjdHVhbCA9IG9wdGlvbnMuYWN0dWFsO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiByZXN1bHQ7XFxuXFxuICAgIGZ1bmN0aW9uIG1lc3NhZ2UoKSB7XFxuICAgICAgaWYgKG9wdGlvbnMucGFzc2VkKSB7XFxuICAgICAgICByZXR1cm4gJ1Bhc3NlZC4nO1xcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5tZXNzYWdlKSB7XFxuICAgICAgICByZXR1cm4gb3B0aW9ucy5tZXNzYWdlO1xcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5lcnJvcikge1xcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2VGb3JtYXR0ZXIob3B0aW9ucy5lcnJvcik7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiAnJztcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBzdGFjaygpIHtcXG4gICAgICBpZiAob3B0aW9ucy5wYXNzZWQpIHtcXG4gICAgICAgIHJldHVybiAnJztcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIGVycm9yID0gb3B0aW9ucy5lcnJvcjtcXG4gICAgICBpZiAoIWVycm9yKSB7XFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSgpKTtcXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgICAgZXJyb3IgPSBlO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gc3RhY2tGb3JtYXR0ZXIoZXJyb3IpO1xcbiAgICB9XFxuICB9XFxuXFxuICByZXR1cm4gYnVpbGRFeHBlY3RhdGlvblJlc3VsdDtcXG59O1xcblxcbmdldEphc21pbmVSZXF1aXJlT2JqKCkuTW9ja0RhdGUgPSBmdW5jdGlvbigpIHtcXG4gIGZ1bmN0aW9uIE1vY2tEYXRlKGdsb2JhbCkge1xcbiAgICB2YXIgc2VsZiA9IHRoaXM7XFxuICAgIHZhciBjdXJyZW50VGltZSA9IDA7XFxuXFxuICAgIGlmICghZ2xvYmFsIHx8ICFnbG9iYWwuRGF0ZSkge1xcbiAgICAgIHNlbGYuaW5zdGFsbCA9IGZ1bmN0aW9uKCkge307XFxuICAgICAgc2VsZi50aWNrID0gZnVuY3Rpb24oKSB7fTtcXG4gICAgICBzZWxmLnVuaW5zdGFsbCA9IGZ1bmN0aW9uKCkge307XFxuICAgICAgcmV0dXJuIHNlbGY7XFxuICAgIH1cXG5cXG4gICAgdmFyIEdsb2JhbERhdGUgPSBnbG9iYWwuRGF0ZTtcXG5cXG4gICAgc2VsZi5pbnN0YWxsID0gZnVuY3Rpb24obW9ja0RhdGUpIHtcXG4gICAgICBpZiAobW9ja0RhdGUgaW5zdGFuY2VvZiBHbG9iYWxEYXRlKSB7XFxuICAgICAgICBjdXJyZW50VGltZSA9IG1vY2tEYXRlLmdldFRpbWUoKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgY3VycmVudFRpbWUgPSBuZXcgR2xvYmFsRGF0ZSgpLmdldFRpbWUoKTtcXG4gICAgICB9XFxuXFxuICAgICAgZ2xvYmFsLkRhdGUgPSBGYWtlRGF0ZTtcXG4gICAgfTtcXG5cXG4gICAgc2VsZi50aWNrID0gZnVuY3Rpb24obWlsbGlzKSB7XFxuICAgICAgbWlsbGlzID0gbWlsbGlzIHx8IDA7XFxuICAgICAgY3VycmVudFRpbWUgPSBjdXJyZW50VGltZSArIG1pbGxpcztcXG4gICAgfTtcXG5cXG4gICAgc2VsZi51bmluc3RhbGwgPSBmdW5jdGlvbigpIHtcXG4gICAgICBjdXJyZW50VGltZSA9IDA7XFxuICAgICAgZ2xvYmFsLkRhdGUgPSBHbG9iYWxEYXRlO1xcbiAgICB9O1xcblxcbiAgICBjcmVhdGVEYXRlUHJvcGVydGllcygpO1xcblxcbiAgICByZXR1cm4gc2VsZjtcXG5cXG4gICAgZnVuY3Rpb24gRmFrZURhdGUoKSB7XFxuICAgICAgc3dpdGNoKGFyZ3VtZW50cy5sZW5ndGgpIHtcXG4gICAgICAgIGNhc2UgMDpcXG4gICAgICAgICAgcmV0dXJuIG5ldyBHbG9iYWxEYXRlKGN1cnJlbnRUaW1lKTtcXG4gICAgICAgIGNhc2UgMTpcXG4gICAgICAgICAgcmV0dXJuIG5ldyBHbG9iYWxEYXRlKGFyZ3VtZW50c1swXSk7XFxuICAgICAgICBjYXNlIDI6XFxuICAgICAgICAgIHJldHVybiBuZXcgR2xvYmFsRGF0ZShhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSk7XFxuICAgICAgICBjYXNlIDM6XFxuICAgICAgICAgIHJldHVybiBuZXcgR2xvYmFsRGF0ZShhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcXG4gICAgICAgIGNhc2UgNDpcXG4gICAgICAgICAgcmV0dXJuIG5ldyBHbG9iYWxEYXRlKGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0sIGFyZ3VtZW50c1szXSk7XFxuICAgICAgICBjYXNlIDU6XFxuICAgICAgICAgIHJldHVybiBuZXcgR2xvYmFsRGF0ZShhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdLCBhcmd1bWVudHNbM10sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHNbNF0pO1xcbiAgICAgICAgY2FzZSA2OlxcbiAgICAgICAgICByZXR1cm4gbmV3IEdsb2JhbERhdGUoYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSwgYXJndW1lbnRzWzNdLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzWzRdLCBhcmd1bWVudHNbNV0pO1xcbiAgICAgICAgZGVmYXVsdDpcXG4gICAgICAgICAgcmV0dXJuIG5ldyBHbG9iYWxEYXRlKGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0sIGFyZ3VtZW50c1szXSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50c1s0XSwgYXJndW1lbnRzWzVdLCBhcmd1bWVudHNbNl0pO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBjcmVhdGVEYXRlUHJvcGVydGllcygpIHtcXG4gICAgICBGYWtlRGF0ZS5wcm90b3R5cGUgPSBHbG9iYWxEYXRlLnByb3RvdHlwZTtcXG5cXG4gICAgICBGYWtlRGF0ZS5ub3cgPSBmdW5jdGlvbigpIHtcXG4gICAgICAgIGlmIChHbG9iYWxEYXRlLm5vdykge1xcbiAgICAgICAgICByZXR1cm4gY3VycmVudFRpbWU7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Jyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBEYXRlLm5vdygpJyk7XFxuICAgICAgICB9XFxuICAgICAgfTtcXG5cXG4gICAgICBGYWtlRGF0ZS50b1NvdXJjZSA9IEdsb2JhbERhdGUudG9Tb3VyY2U7XFxuICAgICAgRmFrZURhdGUudG9TdHJpbmcgPSBHbG9iYWxEYXRlLnRvU3RyaW5nO1xcbiAgICAgIEZha2VEYXRlLnBhcnNlID0gR2xvYmFsRGF0ZS5wYXJzZTtcXG4gICAgICBGYWtlRGF0ZS5VVEMgPSBHbG9iYWxEYXRlLlVUQztcXG4gICAgfVxcblxcdH1cXG5cXG4gIHJldHVybiBNb2NrRGF0ZTtcXG59O1xcblxcbmdldEphc21pbmVSZXF1aXJlT2JqKCkucHAgPSBmdW5jdGlvbihqJCkge1xcblxcbiAgZnVuY3Rpb24gUHJldHR5UHJpbnRlcigpIHtcXG4gICAgdGhpcy5wcE5lc3RMZXZlbF8gPSAwO1xcbiAgICB0aGlzLnNlZW4gPSBbXTtcXG4gIH1cXG5cXG4gIFByZXR0eVByaW50ZXIucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uKHZhbHVlKSB7XFxuICAgIHRoaXMucHBOZXN0TGV2ZWxfKys7XFxuICAgIHRyeSB7XFxuICAgICAgaWYgKGokLnV0aWwuaXNVbmRlZmluZWQodmFsdWUpKSB7XFxuICAgICAgICB0aGlzLmVtaXRTY2FsYXIoJ3VuZGVmaW5lZCcpO1xcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IG51bGwpIHtcXG4gICAgICAgIHRoaXMuZW1pdFNjYWxhcignbnVsbCcpO1xcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IDAgJiYgMS92YWx1ZSA9PT0gLUluZmluaXR5KSB7XFxuICAgICAgICB0aGlzLmVtaXRTY2FsYXIoJy0wJyk7XFxuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gaiQuZ2V0R2xvYmFsKCkpIHtcXG4gICAgICAgIHRoaXMuZW1pdFNjYWxhcignPGdsb2JhbD4nKTtcXG4gICAgICB9IGVsc2UgaWYgKHZhbHVlLmphc21pbmVUb1N0cmluZykge1xcbiAgICAgICAgdGhpcy5lbWl0U2NhbGFyKHZhbHVlLmphc21pbmVUb1N0cmluZygpKTtcXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcXG4gICAgICAgIHRoaXMuZW1pdFN0cmluZyh2YWx1ZSk7XFxuICAgICAgfSBlbHNlIGlmIChqJC5pc1NweSh2YWx1ZSkpIHtcXG4gICAgICAgIHRoaXMuZW1pdFNjYWxhcignc3B5IG9uICcgKyB2YWx1ZS5hbmQuaWRlbnRpdHkoKSk7XFxuICAgICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xcbiAgICAgICAgdGhpcy5lbWl0U2NhbGFyKHZhbHVlLnRvU3RyaW5nKCkpO1xcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICB0aGlzLmVtaXRTY2FsYXIoJ0Z1bmN0aW9uJyk7XFxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUubm9kZVR5cGUgPT09ICdudW1iZXInKSB7XFxuICAgICAgICB0aGlzLmVtaXRTY2FsYXIoJ0hUTUxOb2RlJyk7XFxuICAgICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcXG4gICAgICAgIHRoaXMuZW1pdFNjYWxhcignRGF0ZSgnICsgdmFsdWUgKyAnKScpO1xcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUudG9TdHJpbmcgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiAhKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpICYmIHZhbHVlLnRvU3RyaW5nICE9PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKSB7XFxuICAgICAgICB0aGlzLmVtaXRTY2FsYXIodmFsdWUudG9TdHJpbmcoKSk7XFxuICAgICAgfSBlbHNlIGlmIChqJC51dGlsLmFycmF5Q29udGFpbnModGhpcy5zZWVuLCB2YWx1ZSkpIHtcXG4gICAgICAgIHRoaXMuZW1pdFNjYWxhcignPGNpcmN1bGFyIHJlZmVyZW5jZTogJyArIChqJC5pc0FycmF5Xyh2YWx1ZSkgPyAnQXJyYXknIDogJ09iamVjdCcpICsgJz4nKTtcXG4gICAgICB9IGVsc2UgaWYgKGokLmlzQXJyYXlfKHZhbHVlKSB8fCBqJC5pc0FfKCdPYmplY3QnLCB2YWx1ZSkpIHtcXG4gICAgICAgIHRoaXMuc2Vlbi5wdXNoKHZhbHVlKTtcXG4gICAgICAgIGlmIChqJC5pc0FycmF5Xyh2YWx1ZSkpIHtcXG4gICAgICAgICAgdGhpcy5lbWl0QXJyYXkodmFsdWUpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgdGhpcy5lbWl0T2JqZWN0KHZhbHVlKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHRoaXMuc2Vlbi5wb3AoKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdGhpcy5lbWl0U2NhbGFyKHZhbHVlLnRvU3RyaW5nKCkpO1xcbiAgICAgIH1cXG4gICAgfSBmaW5hbGx5IHtcXG4gICAgICB0aGlzLnBwTmVzdExldmVsXy0tO1xcbiAgICB9XFxuICB9O1xcblxcbiAgUHJldHR5UHJpbnRlci5wcm90b3R5cGUuaXRlcmF0ZU9iamVjdCA9IGZ1bmN0aW9uKG9iaiwgZm4pIHtcXG4gICAgZm9yICh2YXIgcHJvcGVydHkgaW4gb2JqKSB7XFxuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wZXJ0eSkpIHsgY29udGludWU7IH1cXG4gICAgICBmbihwcm9wZXJ0eSwgb2JqLl9fbG9va3VwR2V0dGVyX18gPyAoIWokLnV0aWwuaXNVbmRlZmluZWQob2JqLl9fbG9va3VwR2V0dGVyX18ocHJvcGVydHkpKSAmJlxcbiAgICAgICAgICBvYmouX19sb29rdXBHZXR0ZXJfXyhwcm9wZXJ0eSkgIT09IG51bGwpIDogZmFsc2UpO1xcbiAgICB9XFxuICB9O1xcblxcbiAgUHJldHR5UHJpbnRlci5wcm90b3R5cGUuZW1pdEFycmF5ID0gaiQudW5pbXBsZW1lbnRlZE1ldGhvZF87XFxuICBQcmV0dHlQcmludGVyLnByb3RvdHlwZS5lbWl0T2JqZWN0ID0gaiQudW5pbXBsZW1lbnRlZE1ldGhvZF87XFxuICBQcmV0dHlQcmludGVyLnByb3RvdHlwZS5lbWl0U2NhbGFyID0gaiQudW5pbXBsZW1lbnRlZE1ldGhvZF87XFxuICBQcmV0dHlQcmludGVyLnByb3RvdHlwZS5lbWl0U3RyaW5nID0gaiQudW5pbXBsZW1lbnRlZE1ldGhvZF87XFxuXFxuICBmdW5jdGlvbiBTdHJpbmdQcmV0dHlQcmludGVyKCkge1xcbiAgICBQcmV0dHlQcmludGVyLmNhbGwodGhpcyk7XFxuXFxuICAgIHRoaXMuc3RyaW5nID0gJyc7XFxuICB9XFxuXFxuICBqJC51dGlsLmluaGVyaXQoU3RyaW5nUHJldHR5UHJpbnRlciwgUHJldHR5UHJpbnRlcik7XFxuXFxuICBTdHJpbmdQcmV0dHlQcmludGVyLnByb3RvdHlwZS5lbWl0U2NhbGFyID0gZnVuY3Rpb24odmFsdWUpIHtcXG4gICAgdGhpcy5hcHBlbmQodmFsdWUpO1xcbiAgfTtcXG5cXG4gIFN0cmluZ1ByZXR0eVByaW50ZXIucHJvdG90eXBlLmVtaXRTdHJpbmcgPSBmdW5jdGlvbih2YWx1ZSkge1xcbiAgICB0aGlzLmFwcGVuZCgnXFxcXCcnICsgdmFsdWUgKyAnXFxcXCcnKTtcXG4gIH07XFxuXFxuICBTdHJpbmdQcmV0dHlQcmludGVyLnByb3RvdHlwZS5lbWl0QXJyYXkgPSBmdW5jdGlvbihhcnJheSkge1xcbiAgICBpZiAodGhpcy5wcE5lc3RMZXZlbF8gPiBqJC5NQVhfUFJFVFRZX1BSSU5UX0RFUFRIKSB7XFxuICAgICAgdGhpcy5hcHBlbmQoJ0FycmF5Jyk7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgIHZhciBsZW5ndGggPSBNYXRoLm1pbihhcnJheS5sZW5ndGgsIGokLk1BWF9QUkVUVFlfUFJJTlRfQVJSQVlfTEVOR1RIKTtcXG4gICAgdGhpcy5hcHBlbmQoJ1sgJyk7XFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcXG4gICAgICBpZiAoaSA+IDApIHtcXG4gICAgICAgIHRoaXMuYXBwZW5kKCcsICcpO1xcbiAgICAgIH1cXG4gICAgICB0aGlzLmZvcm1hdChhcnJheVtpXSk7XFxuICAgIH1cXG4gICAgaWYoYXJyYXkubGVuZ3RoID4gbGVuZ3RoKXtcXG4gICAgICB0aGlzLmFwcGVuZCgnLCAuLi4nKTtcXG4gICAgfVxcblxcbiAgICB2YXIgc2VsZiA9IHRoaXM7XFxuICAgIHZhciBmaXJzdCA9IGFycmF5Lmxlbmd0aCA9PT0gMDtcXG4gICAgdGhpcy5pdGVyYXRlT2JqZWN0KGFycmF5LCBmdW5jdGlvbihwcm9wZXJ0eSwgaXNHZXR0ZXIpIHtcXG4gICAgICBpZiAocHJvcGVydHkubWF0Y2goL15cXFxcZCskLykpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGZpcnN0KSB7XFxuICAgICAgICBmaXJzdCA9IGZhbHNlO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBzZWxmLmFwcGVuZCgnLCAnKTtcXG4gICAgICB9XFxuXFxuICAgICAgc2VsZi5mb3JtYXRQcm9wZXJ0eShhcnJheSwgcHJvcGVydHksIGlzR2V0dGVyKTtcXG4gICAgfSk7XFxuXFxuICAgIHRoaXMuYXBwZW5kKCcgXScpO1xcbiAgfTtcXG5cXG4gIFN0cmluZ1ByZXR0eVByaW50ZXIucHJvdG90eXBlLmVtaXRPYmplY3QgPSBmdW5jdGlvbihvYmopIHtcXG4gICAgdmFyIGNvbnN0cnVjdG9yTmFtZSA9IG9iai5jb25zdHJ1Y3RvciA/IGokLmZuTmFtZUZvcihvYmouY29uc3RydWN0b3IpIDogJ251bGwnO1xcbiAgICB0aGlzLmFwcGVuZChjb25zdHJ1Y3Rvck5hbWUpO1xcblxcbiAgICBpZiAodGhpcy5wcE5lc3RMZXZlbF8gPiBqJC5NQVhfUFJFVFRZX1BSSU5UX0RFUFRIKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIHZhciBzZWxmID0gdGhpcztcXG4gICAgdGhpcy5hcHBlbmQoJyh7ICcpO1xcbiAgICB2YXIgZmlyc3QgPSB0cnVlO1xcblxcbiAgICB0aGlzLml0ZXJhdGVPYmplY3Qob2JqLCBmdW5jdGlvbihwcm9wZXJ0eSwgaXNHZXR0ZXIpIHtcXG4gICAgICBpZiAoZmlyc3QpIHtcXG4gICAgICAgIGZpcnN0ID0gZmFsc2U7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHNlbGYuYXBwZW5kKCcsICcpO1xcbiAgICAgIH1cXG5cXG4gICAgICBzZWxmLmZvcm1hdFByb3BlcnR5KG9iaiwgcHJvcGVydHksIGlzR2V0dGVyKTtcXG4gICAgfSk7XFxuXFxuICAgIHRoaXMuYXBwZW5kKCcgfSknKTtcXG4gIH07XFxuXFxuICBTdHJpbmdQcmV0dHlQcmludGVyLnByb3RvdHlwZS5mb3JtYXRQcm9wZXJ0eSA9IGZ1bmN0aW9uKG9iaiwgcHJvcGVydHksIGlzR2V0dGVyKSB7XFxuICAgICAgdGhpcy5hcHBlbmQocHJvcGVydHkpO1xcbiAgICAgIHRoaXMuYXBwZW5kKCc6ICcpO1xcbiAgICAgIGlmIChpc0dldHRlcikge1xcbiAgICAgICAgdGhpcy5hcHBlbmQoJzxnZXR0ZXI+Jyk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRoaXMuZm9ybWF0KG9ialtwcm9wZXJ0eV0pO1xcbiAgICAgIH1cXG4gIH07XFxuXFxuICBTdHJpbmdQcmV0dHlQcmludGVyLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbih2YWx1ZSkge1xcbiAgICB0aGlzLnN0cmluZyArPSB2YWx1ZTtcXG4gIH07XFxuXFxuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcXG4gICAgdmFyIHN0cmluZ1ByZXR0eVByaW50ZXIgPSBuZXcgU3RyaW5nUHJldHR5UHJpbnRlcigpO1xcbiAgICBzdHJpbmdQcmV0dHlQcmludGVyLmZvcm1hdCh2YWx1ZSk7XFxuICAgIHJldHVybiBzdHJpbmdQcmV0dHlQcmludGVyLnN0cmluZztcXG4gIH07XFxufTtcXG5cXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLlF1ZXVlUnVubmVyID0gZnVuY3Rpb24oaiQpIHtcXG5cXG4gIGZ1bmN0aW9uIG9uY2UoZm4pIHtcXG4gICAgdmFyIGNhbGxlZCA9IGZhbHNlO1xcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XFxuICAgICAgaWYgKCFjYWxsZWQpIHtcXG4gICAgICAgIGNhbGxlZCA9IHRydWU7XFxuICAgICAgICBmbigpO1xcbiAgICAgIH1cXG4gICAgfTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIFF1ZXVlUnVubmVyKGF0dHJzKSB7XFxuICAgIHRoaXMucXVldWVhYmxlRm5zID0gYXR0cnMucXVldWVhYmxlRm5zIHx8IFtdO1xcbiAgICB0aGlzLm9uQ29tcGxldGUgPSBhdHRycy5vbkNvbXBsZXRlIHx8IGZ1bmN0aW9uKCkge307XFxuICAgIHRoaXMuY2xlYXJTdGFjayA9IGF0dHJzLmNsZWFyU3RhY2sgfHwgZnVuY3Rpb24oZm4pIHtmbigpO307XFxuICAgIHRoaXMub25FeGNlcHRpb24gPSBhdHRycy5vbkV4Y2VwdGlvbiB8fCBmdW5jdGlvbigpIHt9O1xcbiAgICB0aGlzLmNhdGNoRXhjZXB0aW9uID0gYXR0cnMuY2F0Y2hFeGNlcHRpb24gfHwgZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9O1xcbiAgICB0aGlzLnVzZXJDb250ZXh0ID0gYXR0cnMudXNlckNvbnRleHQgfHwge307XFxuICAgIHRoaXMudGltZW91dCA9IGF0dHJzLnRpbWVvdXQgfHwge3NldFRpbWVvdXQ6IHNldFRpbWVvdXQsIGNsZWFyVGltZW91dDogY2xlYXJUaW1lb3V0fTtcXG4gICAgdGhpcy5mYWlsID0gYXR0cnMuZmFpbCB8fCBmdW5jdGlvbigpIHt9O1xcbiAgfVxcblxcbiAgUXVldWVSdW5uZXIucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcXG4gICAgdGhpcy5ydW4odGhpcy5xdWV1ZWFibGVGbnMsIDApO1xcbiAgfTtcXG5cXG4gIFF1ZXVlUnVubmVyLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbihxdWV1ZWFibGVGbnMsIHJlY3Vyc2l2ZUluZGV4KSB7XFxuICAgIHZhciBsZW5ndGggPSBxdWV1ZWFibGVGbnMubGVuZ3RoLFxcbiAgICAgIHNlbGYgPSB0aGlzLFxcbiAgICAgIGl0ZXJhdGl2ZUluZGV4O1xcblxcblxcbiAgICBmb3IoaXRlcmF0aXZlSW5kZXggPSByZWN1cnNpdmVJbmRleDsgaXRlcmF0aXZlSW5kZXggPCBsZW5ndGg7IGl0ZXJhdGl2ZUluZGV4KyspIHtcXG4gICAgICB2YXIgcXVldWVhYmxlRm4gPSBxdWV1ZWFibGVGbnNbaXRlcmF0aXZlSW5kZXhdO1xcbiAgICAgIGlmIChxdWV1ZWFibGVGbi5mbi5sZW5ndGggPiAwKSB7XFxuICAgICAgICBhdHRlbXB0QXN5bmMocXVldWVhYmxlRm4pO1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBhdHRlbXB0U3luYyhxdWV1ZWFibGVGbik7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHZhciBydW5uZXJEb25lID0gaXRlcmF0aXZlSW5kZXggPj0gbGVuZ3RoO1xcblxcbiAgICBpZiAocnVubmVyRG9uZSkge1xcbiAgICAgIHRoaXMuY2xlYXJTdGFjayh0aGlzLm9uQ29tcGxldGUpO1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIGF0dGVtcHRTeW5jKHF1ZXVlYWJsZUZuKSB7XFxuICAgICAgdHJ5IHtcXG4gICAgICAgIHF1ZXVlYWJsZUZuLmZuLmNhbGwoc2VsZi51c2VyQ29udGV4dCk7XFxuICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgaGFuZGxlRXhjZXB0aW9uKGUsIHF1ZXVlYWJsZUZuKTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gYXR0ZW1wdEFzeW5jKHF1ZXVlYWJsZUZuKSB7XFxuICAgICAgdmFyIGNsZWFyVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmFwcGx5KHNlbGYudGltZW91dC5jbGVhclRpbWVvdXQsIFtqJC5nZXRHbG9iYWwoKSwgW3RpbWVvdXRJZF1dKTtcXG4gICAgICAgIH0sXFxuICAgICAgICBuZXh0ID0gb25jZShmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xcbiAgICAgICAgICBzZWxmLnJ1bihxdWV1ZWFibGVGbnMsIGl0ZXJhdGl2ZUluZGV4ICsgMSk7XFxuICAgICAgICB9KSxcXG4gICAgICAgIHRpbWVvdXRJZDtcXG5cXG4gICAgICBuZXh0LmZhaWwgPSBmdW5jdGlvbigpIHtcXG4gICAgICAgIHNlbGYuZmFpbC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xcbiAgICAgICAgbmV4dCgpO1xcbiAgICAgIH07XFxuXFxuICAgICAgaWYgKHF1ZXVlYWJsZUZuLnRpbWVvdXQpIHtcXG4gICAgICAgIHRpbWVvdXRJZCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5hcHBseShzZWxmLnRpbWVvdXQuc2V0VGltZW91dCwgW2okLmdldEdsb2JhbCgpLCBbZnVuY3Rpb24oKSB7XFxuICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignVGltZW91dCAtIEFzeW5jIGNhbGxiYWNrIHdhcyBub3QgaW52b2tlZCB3aXRoaW4gdGltZW91dCBzcGVjaWZpZWQgYnkgamFzbWluZS5ERUZBVUxUX1RJTUVPVVRfSU5URVJWQUwuJyk7XFxuICAgICAgICAgIG9uRXhjZXB0aW9uKGVycm9yKTtcXG4gICAgICAgICAgbmV4dCgpO1xcbiAgICAgICAgfSwgcXVldWVhYmxlRm4udGltZW91dCgpXV0pO1xcbiAgICAgIH1cXG5cXG4gICAgICB0cnkge1xcbiAgICAgICAgcXVldWVhYmxlRm4uZm4uY2FsbChzZWxmLnVzZXJDb250ZXh0LCBuZXh0KTtcXG4gICAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICBoYW5kbGVFeGNlcHRpb24oZSwgcXVldWVhYmxlRm4pO1xcbiAgICAgICAgbmV4dCgpO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBvbkV4Y2VwdGlvbihlKSB7XFxuICAgICAgc2VsZi5vbkV4Y2VwdGlvbihlKTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBoYW5kbGVFeGNlcHRpb24oZSwgcXVldWVhYmxlRm4pIHtcXG4gICAgICBvbkV4Y2VwdGlvbihlKTtcXG4gICAgICBpZiAoIXNlbGYuY2F0Y2hFeGNlcHRpb24oZSkpIHtcXG4gICAgICAgIC8vVE9ETzogc2V0IGEgdmFyIHdoZW4gd2UgY2F0Y2ggYW4gZXhjZXB0aW9uIGFuZFxcbiAgICAgICAgLy91c2UgYSBmaW5hbGx5IGJsb2NrIHRvIGNsb3NlIHRoZSBsb29wIGluIGEgbmljZSB3YXkuLlxcbiAgICAgICAgdGhyb3cgZTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH07XFxuXFxuICByZXR1cm4gUXVldWVSdW5uZXI7XFxufTtcXG5cXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLlJlcG9ydERpc3BhdGNoZXIgPSBmdW5jdGlvbigpIHtcXG4gIGZ1bmN0aW9uIFJlcG9ydERpc3BhdGNoZXIobWV0aG9kcykge1xcblxcbiAgICB2YXIgZGlzcGF0Y2hlZE1ldGhvZHMgPSBtZXRob2RzIHx8IFtdO1xcblxcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3BhdGNoZWRNZXRob2RzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgdmFyIG1ldGhvZCA9IGRpc3BhdGNoZWRNZXRob2RzW2ldO1xcbiAgICAgIHRoaXNbbWV0aG9kXSA9IChmdW5jdGlvbihtKSB7XFxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XFxuICAgICAgICAgIGRpc3BhdGNoKG0sIGFyZ3VtZW50cyk7XFxuICAgICAgICB9O1xcbiAgICAgIH0obWV0aG9kKSk7XFxuICAgIH1cXG5cXG4gICAgdmFyIHJlcG9ydGVycyA9IFtdO1xcblxcbiAgICB0aGlzLmFkZFJlcG9ydGVyID0gZnVuY3Rpb24ocmVwb3J0ZXIpIHtcXG4gICAgICByZXBvcnRlcnMucHVzaChyZXBvcnRlcik7XFxuICAgIH07XFxuXFxuICAgIHJldHVybiB0aGlzO1xcblxcbiAgICBmdW5jdGlvbiBkaXNwYXRjaChtZXRob2QsIGFyZ3MpIHtcXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlcG9ydGVycy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgdmFyIHJlcG9ydGVyID0gcmVwb3J0ZXJzW2ldO1xcbiAgICAgICAgaWYgKHJlcG9ydGVyW21ldGhvZF0pIHtcXG4gICAgICAgICAgcmVwb3J0ZXJbbWV0aG9kXS5hcHBseShyZXBvcnRlciwgYXJncyk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuXFxuICByZXR1cm4gUmVwb3J0RGlzcGF0Y2hlcjtcXG59O1xcblxcblxcbmdldEphc21pbmVSZXF1aXJlT2JqKCkuU3B5UmVnaXN0cnkgPSBmdW5jdGlvbihqJCkge1xcblxcbiAgZnVuY3Rpb24gU3B5UmVnaXN0cnkob3B0aW9ucykge1xcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcXG4gICAgdmFyIGN1cnJlbnRTcGllcyA9IG9wdGlvbnMuY3VycmVudFNwaWVzIHx8IGZ1bmN0aW9uKCkgeyByZXR1cm4gW107IH07XFxuXFxuICAgIHRoaXMuc3B5T24gPSBmdW5jdGlvbihvYmosIG1ldGhvZE5hbWUpIHtcXG4gICAgICBpZiAoaiQudXRpbC5pc1VuZGVmaW5lZChvYmopKSB7XFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NweU9uIGNvdWxkIG5vdCBmaW5kIGFuIG9iamVjdCB0byBzcHkgdXBvbiBmb3IgJyArIG1ldGhvZE5hbWUgKyAnKCknKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGokLnV0aWwuaXNVbmRlZmluZWQobWV0aG9kTmFtZSkpIHtcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gbWV0aG9kIG5hbWUgc3VwcGxpZWQnKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGokLnV0aWwuaXNVbmRlZmluZWQob2JqW21ldGhvZE5hbWVdKSkge1xcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1ldGhvZE5hbWUgKyAnKCkgbWV0aG9kIGRvZXMgbm90IGV4aXN0Jyk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChvYmpbbWV0aG9kTmFtZV0gJiYgaiQuaXNTcHkob2JqW21ldGhvZE5hbWVdKSkge1xcbiAgICAgICAgLy9UT0RPPzogc2hvdWxkIHRoaXMgcmV0dXJuIHRoZSBjdXJyZW50IHNweT8gRG93bnNpZGU6IG1heSBjYXVzZSB1c2VyIGNvbmZ1c2lvbiBhYm91dCBzcHkgc3RhdGVcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXRob2ROYW1lICsgJyBoYXMgYWxyZWFkeSBiZWVuIHNwaWVkIHVwb24nKTtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIGRlc2NyaXB0b3I7XFxuICAgICAgdHJ5IHtcXG4gICAgICAgIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgbWV0aG9kTmFtZSk7XFxuICAgICAgfSBjYXRjaChlKSB7XFxuICAgICAgICAvLyBJRSA4IGRvZXNuJ3Qgc3VwcG9ydCBgZGVmaW5lUHJvcGVyeWAgb24gbm9uLURPTSBub2Rlc1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoZGVzY3JpcHRvciAmJiAhKGRlc2NyaXB0b3Iud3JpdGFibGUgfHwgZGVzY3JpcHRvci5zZXQpKSB7XFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWV0aG9kTmFtZSArICcgaXMgbm90IGRlY2xhcmVkIHdyaXRhYmxlIG9yIGhhcyBubyBzZXR0ZXInKTtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIHNweSA9IGokLmNyZWF0ZVNweShtZXRob2ROYW1lLCBvYmpbbWV0aG9kTmFtZV0pO1xcblxcbiAgICAgIGN1cnJlbnRTcGllcygpLnB1c2goe1xcbiAgICAgICAgc3B5OiBzcHksXFxuICAgICAgICBiYXNlT2JqOiBvYmosXFxuICAgICAgICBtZXRob2ROYW1lOiBtZXRob2ROYW1lLFxcbiAgICAgICAgb3JpZ2luYWxWYWx1ZTogb2JqW21ldGhvZE5hbWVdXFxuICAgICAgfSk7XFxuXFxuICAgICAgb2JqW21ldGhvZE5hbWVdID0gc3B5O1xcblxcbiAgICAgIHJldHVybiBzcHk7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuY2xlYXJTcGllcyA9IGZ1bmN0aW9uKCkge1xcbiAgICAgIHZhciBzcGllcyA9IGN1cnJlbnRTcGllcygpO1xcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3BpZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgIHZhciBzcHlFbnRyeSA9IHNwaWVzW2ldO1xcbiAgICAgICAgc3B5RW50cnkuYmFzZU9ialtzcHlFbnRyeS5tZXRob2ROYW1lXSA9IHNweUVudHJ5Lm9yaWdpbmFsVmFsdWU7XFxuICAgICAgfVxcbiAgICB9O1xcbiAgfVxcblxcbiAgcmV0dXJuIFNweVJlZ2lzdHJ5O1xcbn07XFxuXFxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5TcHlTdHJhdGVneSA9IGZ1bmN0aW9uKCkge1xcblxcbiAgZnVuY3Rpb24gU3B5U3RyYXRlZ3kob3B0aW9ucykge1xcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcXG5cXG4gICAgdmFyIGlkZW50aXR5ID0gb3B0aW9ucy5uYW1lIHx8ICd1bmtub3duJyxcXG4gICAgICAgIG9yaWdpbmFsRm4gPSBvcHRpb25zLmZuIHx8IGZ1bmN0aW9uKCkge30sXFxuICAgICAgICBnZXRTcHkgPSBvcHRpb25zLmdldFNweSB8fCBmdW5jdGlvbigpIHt9LFxcbiAgICAgICAgcGxhbiA9IGZ1bmN0aW9uKCkge307XFxuXFxuICAgIHRoaXMuaWRlbnRpdHkgPSBmdW5jdGlvbigpIHtcXG4gICAgICByZXR1cm4gaWRlbnRpdHk7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuZXhlYyA9IGZ1bmN0aW9uKCkge1xcbiAgICAgIHJldHVybiBwbGFuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuY2FsbFRocm91Z2ggPSBmdW5jdGlvbigpIHtcXG4gICAgICBwbGFuID0gb3JpZ2luYWxGbjtcXG4gICAgICByZXR1cm4gZ2V0U3B5KCk7XFxuICAgIH07XFxuXFxuICAgIHRoaXMucmV0dXJuVmFsdWUgPSBmdW5jdGlvbih2YWx1ZSkge1xcbiAgICAgIHBsYW4gPSBmdW5jdGlvbigpIHtcXG4gICAgICAgIHJldHVybiB2YWx1ZTtcXG4gICAgICB9O1xcbiAgICAgIHJldHVybiBnZXRTcHkoKTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5yZXR1cm5WYWx1ZXMgPSBmdW5jdGlvbigpIHtcXG4gICAgICB2YXIgdmFsdWVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcXG4gICAgICBwbGFuID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgcmV0dXJuIHZhbHVlcy5zaGlmdCgpO1xcbiAgICAgIH07XFxuICAgICAgcmV0dXJuIGdldFNweSgpO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLnRocm93RXJyb3IgPSBmdW5jdGlvbihzb21ldGhpbmcpIHtcXG4gICAgICB2YXIgZXJyb3IgPSAoc29tZXRoaW5nIGluc3RhbmNlb2YgRXJyb3IpID8gc29tZXRoaW5nIDogbmV3IEVycm9yKHNvbWV0aGluZyk7XFxuICAgICAgcGxhbiA9IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgdGhyb3cgZXJyb3I7XFxuICAgICAgfTtcXG4gICAgICByZXR1cm4gZ2V0U3B5KCk7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuY2FsbEZha2UgPSBmdW5jdGlvbihmbikge1xcbiAgICAgIHBsYW4gPSBmbjtcXG4gICAgICByZXR1cm4gZ2V0U3B5KCk7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuc3R1YiA9IGZ1bmN0aW9uKGZuKSB7XFxuICAgICAgcGxhbiA9IGZ1bmN0aW9uKCkge307XFxuICAgICAgcmV0dXJuIGdldFNweSgpO1xcbiAgICB9O1xcbiAgfVxcblxcbiAgcmV0dXJuIFNweVN0cmF0ZWd5O1xcbn07XFxuXFxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5TdWl0ZSA9IGZ1bmN0aW9uKGokKSB7XFxuICBmdW5jdGlvbiBTdWl0ZShhdHRycykge1xcbiAgICB0aGlzLmVudiA9IGF0dHJzLmVudjtcXG4gICAgdGhpcy5pZCA9IGF0dHJzLmlkO1xcbiAgICB0aGlzLnBhcmVudFN1aXRlID0gYXR0cnMucGFyZW50U3VpdGU7XFxuICAgIHRoaXMuZGVzY3JpcHRpb24gPSBhdHRycy5kZXNjcmlwdGlvbjtcXG4gICAgdGhpcy5leHBlY3RhdGlvbkZhY3RvcnkgPSBhdHRycy5leHBlY3RhdGlvbkZhY3Rvcnk7XFxuICAgIHRoaXMuZXhwZWN0YXRpb25SZXN1bHRGYWN0b3J5ID0gYXR0cnMuZXhwZWN0YXRpb25SZXN1bHRGYWN0b3J5O1xcbiAgICB0aGlzLnRocm93T25FeHBlY3RhdGlvbkZhaWx1cmUgPSAhIWF0dHJzLnRocm93T25FeHBlY3RhdGlvbkZhaWx1cmU7XFxuXFxuICAgIHRoaXMuYmVmb3JlRm5zID0gW107XFxuICAgIHRoaXMuYWZ0ZXJGbnMgPSBbXTtcXG4gICAgdGhpcy5iZWZvcmVBbGxGbnMgPSBbXTtcXG4gICAgdGhpcy5hZnRlckFsbEZucyA9IFtdO1xcbiAgICB0aGlzLmRpc2FibGVkID0gZmFsc2U7XFxuXFxuICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcXG5cXG4gICAgdGhpcy5yZXN1bHQgPSB7XFxuICAgICAgaWQ6IHRoaXMuaWQsXFxuICAgICAgZGVzY3JpcHRpb246IHRoaXMuZGVzY3JpcHRpb24sXFxuICAgICAgZnVsbE5hbWU6IHRoaXMuZ2V0RnVsbE5hbWUoKSxcXG4gICAgICBmYWlsZWRFeHBlY3RhdGlvbnM6IFtdXFxuICAgIH07XFxuICB9XFxuXFxuICBTdWl0ZS5wcm90b3R5cGUuZXhwZWN0ID0gZnVuY3Rpb24oYWN0dWFsKSB7XFxuICAgIHJldHVybiB0aGlzLmV4cGVjdGF0aW9uRmFjdG9yeShhY3R1YWwsIHRoaXMpO1xcbiAgfTtcXG5cXG4gIFN1aXRlLnByb3RvdHlwZS5nZXRGdWxsTmFtZSA9IGZ1bmN0aW9uKCkge1xcbiAgICB2YXIgZnVsbE5hbWUgPSB0aGlzLmRlc2NyaXB0aW9uO1xcbiAgICBmb3IgKHZhciBwYXJlbnRTdWl0ZSA9IHRoaXMucGFyZW50U3VpdGU7IHBhcmVudFN1aXRlOyBwYXJlbnRTdWl0ZSA9IHBhcmVudFN1aXRlLnBhcmVudFN1aXRlKSB7XFxuICAgICAgaWYgKHBhcmVudFN1aXRlLnBhcmVudFN1aXRlKSB7XFxuICAgICAgICBmdWxsTmFtZSA9IHBhcmVudFN1aXRlLmRlc2NyaXB0aW9uICsgJyAnICsgZnVsbE5hbWU7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIHJldHVybiBmdWxsTmFtZTtcXG4gIH07XFxuXFxuICBTdWl0ZS5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uKCkge1xcbiAgICB0aGlzLmRpc2FibGVkID0gdHJ1ZTtcXG4gIH07XFxuXFxuICBTdWl0ZS5wcm90b3R5cGUucGVuZCA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcXG4gICAgdGhpcy5tYXJrZWRQZW5kaW5nID0gdHJ1ZTtcXG4gIH07XFxuXFxuICBTdWl0ZS5wcm90b3R5cGUuYmVmb3JlRWFjaCA9IGZ1bmN0aW9uKGZuKSB7XFxuICAgIHRoaXMuYmVmb3JlRm5zLnVuc2hpZnQoZm4pO1xcbiAgfTtcXG5cXG4gIFN1aXRlLnByb3RvdHlwZS5iZWZvcmVBbGwgPSBmdW5jdGlvbihmbikge1xcbiAgICB0aGlzLmJlZm9yZUFsbEZucy5wdXNoKGZuKTtcXG4gIH07XFxuXFxuICBTdWl0ZS5wcm90b3R5cGUuYWZ0ZXJFYWNoID0gZnVuY3Rpb24oZm4pIHtcXG4gICAgdGhpcy5hZnRlckZucy51bnNoaWZ0KGZuKTtcXG4gIH07XFxuXFxuICBTdWl0ZS5wcm90b3R5cGUuYWZ0ZXJBbGwgPSBmdW5jdGlvbihmbikge1xcbiAgICB0aGlzLmFmdGVyQWxsRm5zLnB1c2goZm4pO1xcbiAgfTtcXG5cXG4gIFN1aXRlLnByb3RvdHlwZS5hZGRDaGlsZCA9IGZ1bmN0aW9uKGNoaWxkKSB7XFxuICAgIHRoaXMuY2hpbGRyZW4ucHVzaChjaGlsZCk7XFxuICB9O1xcblxcbiAgU3VpdGUucHJvdG90eXBlLnN0YXR1cyA9IGZ1bmN0aW9uKCkge1xcbiAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xcbiAgICAgIHJldHVybiAnZGlzYWJsZWQnO1xcbiAgICB9XFxuXFxuICAgIGlmICh0aGlzLm1hcmtlZFBlbmRpbmcpIHtcXG4gICAgICByZXR1cm4gJ3BlbmRpbmcnO1xcbiAgICB9XFxuXFxuICAgIGlmICh0aGlzLnJlc3VsdC5mYWlsZWRFeHBlY3RhdGlvbnMubGVuZ3RoID4gMCkge1xcbiAgICAgIHJldHVybiAnZmFpbGVkJztcXG4gICAgfSBlbHNlIHtcXG4gICAgICByZXR1cm4gJ2ZpbmlzaGVkJztcXG4gICAgfVxcbiAgfTtcXG5cXG4gIFN1aXRlLnByb3RvdHlwZS5pc0V4ZWN1dGFibGUgPSBmdW5jdGlvbigpIHtcXG4gICAgcmV0dXJuICF0aGlzLmRpc2FibGVkO1xcbiAgfTtcXG5cXG4gIFN1aXRlLnByb3RvdHlwZS5jYW5CZVJlZW50ZXJlZCA9IGZ1bmN0aW9uKCkge1xcbiAgICByZXR1cm4gdGhpcy5iZWZvcmVBbGxGbnMubGVuZ3RoID09PSAwICYmIHRoaXMuYWZ0ZXJBbGxGbnMubGVuZ3RoID09PSAwO1xcbiAgfTtcXG5cXG4gIFN1aXRlLnByb3RvdHlwZS5nZXRSZXN1bHQgPSBmdW5jdGlvbigpIHtcXG4gICAgdGhpcy5yZXN1bHQuc3RhdHVzID0gdGhpcy5zdGF0dXMoKTtcXG4gICAgcmV0dXJuIHRoaXMucmVzdWx0O1xcbiAgfTtcXG5cXG4gIFN1aXRlLnByb3RvdHlwZS5zaGFyZWRVc2VyQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xcbiAgICBpZiAoIXRoaXMuc2hhcmVkQ29udGV4dCkge1xcbiAgICAgIHRoaXMuc2hhcmVkQ29udGV4dCA9IHRoaXMucGFyZW50U3VpdGUgPyBjbG9uZSh0aGlzLnBhcmVudFN1aXRlLnNoYXJlZFVzZXJDb250ZXh0KCkpIDoge307XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHRoaXMuc2hhcmVkQ29udGV4dDtcXG4gIH07XFxuXFxuICBTdWl0ZS5wcm90b3R5cGUuY2xvbmVkU2hhcmVkVXNlckNvbnRleHQgPSBmdW5jdGlvbigpIHtcXG4gICAgcmV0dXJuIGNsb25lKHRoaXMuc2hhcmVkVXNlckNvbnRleHQoKSk7XFxuICB9O1xcblxcbiAgU3VpdGUucHJvdG90eXBlLm9uRXhjZXB0aW9uID0gZnVuY3Rpb24oKSB7XFxuICAgIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBqJC5lcnJvcnMuRXhwZWN0YXRpb25GYWlsZWQpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgaWYoaXNBZnRlckFsbCh0aGlzLmNoaWxkcmVuKSkge1xcbiAgICAgIHZhciBkYXRhID0ge1xcbiAgICAgICAgbWF0Y2hlck5hbWU6ICcnLFxcbiAgICAgICAgcGFzc2VkOiBmYWxzZSxcXG4gICAgICAgIGV4cGVjdGVkOiAnJyxcXG4gICAgICAgIGFjdHVhbDogJycsXFxuICAgICAgICBlcnJvcjogYXJndW1lbnRzWzBdXFxuICAgICAgfTtcXG4gICAgICB0aGlzLnJlc3VsdC5mYWlsZWRFeHBlY3RhdGlvbnMucHVzaCh0aGlzLmV4cGVjdGF0aW9uUmVzdWx0RmFjdG9yeShkYXRhKSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xcbiAgICAgICAgY2hpbGQub25FeGNlcHRpb24uYXBwbHkoY2hpbGQsIGFyZ3VtZW50cyk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9O1xcblxcbiAgU3VpdGUucHJvdG90eXBlLmFkZEV4cGVjdGF0aW9uUmVzdWx0ID0gZnVuY3Rpb24gKCkge1xcbiAgICBpZihpc0FmdGVyQWxsKHRoaXMuY2hpbGRyZW4pICYmIGlzRmFpbHVyZShhcmd1bWVudHMpKXtcXG4gICAgICB2YXIgZGF0YSA9IGFyZ3VtZW50c1sxXTtcXG4gICAgICB0aGlzLnJlc3VsdC5mYWlsZWRFeHBlY3RhdGlvbnMucHVzaCh0aGlzLmV4cGVjdGF0aW9uUmVzdWx0RmFjdG9yeShkYXRhKSk7XFxuICAgICAgaWYodGhpcy50aHJvd09uRXhwZWN0YXRpb25GYWlsdXJlKSB7XFxuICAgICAgICB0aHJvdyBuZXcgaiQuZXJyb3JzLkV4cGVjdGF0aW9uRmFpbGVkKCk7XFxuICAgICAgfVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgIGNoaWxkLmFkZEV4cGVjdGF0aW9uUmVzdWx0LmFwcGx5KGNoaWxkLCBhcmd1bWVudHMpO1xcbiAgICAgICAgfSBjYXRjaChlKSB7XFxuICAgICAgICAgIC8vIGtlZXAgZ29pbmdcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG4gIH07XFxuXFxuICBmdW5jdGlvbiBpc0FmdGVyQWxsKGNoaWxkcmVuKSB7XFxuICAgIHJldHVybiBjaGlsZHJlbiAmJiBjaGlsZHJlblswXS5yZXN1bHQuc3RhdHVzO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gaXNGYWlsdXJlKGFyZ3MpIHtcXG4gICAgcmV0dXJuICFhcmdzWzBdO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gY2xvbmUob2JqKSB7XFxuICAgIHZhciBjbG9uZWRPYmogPSB7fTtcXG4gICAgZm9yICh2YXIgcHJvcCBpbiBvYmopIHtcXG4gICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHByb3ApKSB7XFxuICAgICAgICBjbG9uZWRPYmpbcHJvcF0gPSBvYmpbcHJvcF07XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHJldHVybiBjbG9uZWRPYmo7XFxuICB9XFxuXFxuICByZXR1cm4gU3VpdGU7XFxufTtcXG5cXG5pZiAodHlwZW9mIHdpbmRvdyA9PSB2b2lkIDAgJiYgdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcpIHtcXG4gIGV4cG9ydHMuU3VpdGUgPSBqYXNtaW5lUmVxdWlyZS5TdWl0ZTtcXG59XFxuXFxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5UaW1lciA9IGZ1bmN0aW9uKCkge1xcbiAgdmFyIGRlZmF1bHROb3cgPSAoZnVuY3Rpb24oRGF0ZSkge1xcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7IHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTsgfTtcXG4gIH0pKERhdGUpO1xcblxcbiAgZnVuY3Rpb24gVGltZXIob3B0aW9ucykge1xcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcXG5cXG4gICAgdmFyIG5vdyA9IG9wdGlvbnMubm93IHx8IGRlZmF1bHROb3csXFxuICAgICAgc3RhcnRUaW1lO1xcblxcbiAgICB0aGlzLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XFxuICAgICAgc3RhcnRUaW1lID0gbm93KCk7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuZWxhcHNlZCA9IGZ1bmN0aW9uKCkge1xcbiAgICAgIHJldHVybiBub3coKSAtIHN0YXJ0VGltZTtcXG4gICAgfTtcXG4gIH1cXG5cXG4gIHJldHVybiBUaW1lcjtcXG59O1xcblxcbmdldEphc21pbmVSZXF1aXJlT2JqKCkuVHJlZVByb2Nlc3NvciA9IGZ1bmN0aW9uKCkge1xcbiAgZnVuY3Rpb24gVHJlZVByb2Nlc3NvcihhdHRycykge1xcbiAgICB2YXIgdHJlZSA9IGF0dHJzLnRyZWUsXFxuICAgICAgICBydW5uYWJsZUlkcyA9IGF0dHJzLnJ1bm5hYmxlSWRzLFxcbiAgICAgICAgcXVldWVSdW5uZXJGYWN0b3J5ID0gYXR0cnMucXVldWVSdW5uZXJGYWN0b3J5LFxcbiAgICAgICAgbm9kZVN0YXJ0ID0gYXR0cnMubm9kZVN0YXJ0IHx8IGZ1bmN0aW9uKCkge30sXFxuICAgICAgICBub2RlQ29tcGxldGUgPSBhdHRycy5ub2RlQ29tcGxldGUgfHwgZnVuY3Rpb24oKSB7fSxcXG4gICAgICAgIG9yZGVyQ2hpbGRyZW4gPSBhdHRycy5vcmRlckNoaWxkcmVuIHx8IGZ1bmN0aW9uKG5vZGUpIHsgcmV0dXJuIG5vZGUuY2hpbGRyZW47IH0sXFxuICAgICAgICBzdGF0cyA9IHsgdmFsaWQ6IHRydWUgfSxcXG4gICAgICAgIHByb2Nlc3NlZCA9IGZhbHNlLFxcbiAgICAgICAgZGVmYXVsdE1pbiA9IEluZmluaXR5LFxcbiAgICAgICAgZGVmYXVsdE1heCA9IDEgLSBJbmZpbml0eTtcXG5cXG4gICAgdGhpcy5wcm9jZXNzVHJlZSA9IGZ1bmN0aW9uKCkge1xcbiAgICAgIHByb2Nlc3NOb2RlKHRyZWUsIGZhbHNlKTtcXG4gICAgICBwcm9jZXNzZWQgPSB0cnVlO1xcbiAgICAgIHJldHVybiBzdGF0cztcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5leGVjdXRlID0gZnVuY3Rpb24oZG9uZSkge1xcbiAgICAgIGlmICghcHJvY2Vzc2VkKSB7XFxuICAgICAgICB0aGlzLnByb2Nlc3NUcmVlKCk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghc3RhdHMudmFsaWQpIHtcXG4gICAgICAgIHRocm93ICdpbnZhbGlkIG9yZGVyJztcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIGNoaWxkRm5zID0gd3JhcENoaWxkcmVuKHRyZWUsIDApO1xcblxcbiAgICAgIHF1ZXVlUnVubmVyRmFjdG9yeSh7XFxuICAgICAgICBxdWV1ZWFibGVGbnM6IGNoaWxkRm5zLFxcbiAgICAgICAgdXNlckNvbnRleHQ6IHRyZWUuc2hhcmVkVXNlckNvbnRleHQoKSxcXG4gICAgICAgIG9uRXhjZXB0aW9uOiBmdW5jdGlvbigpIHtcXG4gICAgICAgICAgdHJlZS5vbkV4Y2VwdGlvbi5hcHBseSh0cmVlLCBhcmd1bWVudHMpO1xcbiAgICAgICAgfSxcXG4gICAgICAgIG9uQ29tcGxldGU6IGRvbmVcXG4gICAgICB9KTtcXG4gICAgfTtcXG5cXG4gICAgZnVuY3Rpb24gcnVubmFibGVJbmRleChpZCkge1xcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcnVubmFibGVJZHMubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgIGlmIChydW5uYWJsZUlkc1tpXSA9PT0gaWQpIHtcXG4gICAgICAgICAgcmV0dXJuIGk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIHByb2Nlc3NOb2RlKG5vZGUsIHBhcmVudEVuYWJsZWQpIHtcXG4gICAgICB2YXIgZXhlY3V0YWJsZUluZGV4ID0gcnVubmFibGVJbmRleChub2RlLmlkKTtcXG5cXG4gICAgICBpZiAoZXhlY3V0YWJsZUluZGV4ICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICAgIHBhcmVudEVuYWJsZWQgPSB0cnVlO1xcbiAgICAgIH1cXG5cXG4gICAgICBwYXJlbnRFbmFibGVkID0gcGFyZW50RW5hYmxlZCAmJiBub2RlLmlzRXhlY3V0YWJsZSgpO1xcblxcbiAgICAgIGlmICghbm9kZS5jaGlsZHJlbikge1xcbiAgICAgICAgc3RhdHNbbm9kZS5pZF0gPSB7XFxuICAgICAgICAgIGV4ZWN1dGFibGU6IHBhcmVudEVuYWJsZWQgJiYgbm9kZS5pc0V4ZWN1dGFibGUoKSxcXG4gICAgICAgICAgc2VnbWVudHM6IFt7XFxuICAgICAgICAgICAgaW5kZXg6IDAsXFxuICAgICAgICAgICAgb3duZXI6IG5vZGUsXFxuICAgICAgICAgICAgbm9kZXM6IFtub2RlXSxcXG4gICAgICAgICAgICBtaW46IHN0YXJ0aW5nTWluKGV4ZWN1dGFibGVJbmRleCksXFxuICAgICAgICAgICAgbWF4OiBzdGFydGluZ01heChleGVjdXRhYmxlSW5kZXgpXFxuICAgICAgICAgIH1dXFxuICAgICAgICB9O1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB2YXIgaGFzRXhlY3V0YWJsZUNoaWxkID0gZmFsc2U7XFxuXFxuICAgICAgICB2YXIgb3JkZXJlZENoaWxkcmVuID0gb3JkZXJDaGlsZHJlbihub2RlKTtcXG5cXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3JkZXJlZENoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgIHZhciBjaGlsZCA9IG9yZGVyZWRDaGlsZHJlbltpXTtcXG5cXG4gICAgICAgICAgcHJvY2Vzc05vZGUoY2hpbGQsIHBhcmVudEVuYWJsZWQpO1xcblxcbiAgICAgICAgICBpZiAoIXN0YXRzLnZhbGlkKSB7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHZhciBjaGlsZFN0YXRzID0gc3RhdHNbY2hpbGQuaWRdO1xcblxcbiAgICAgICAgICBoYXNFeGVjdXRhYmxlQ2hpbGQgPSBoYXNFeGVjdXRhYmxlQ2hpbGQgfHwgY2hpbGRTdGF0cy5leGVjdXRhYmxlO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgc3RhdHNbbm9kZS5pZF0gPSB7XFxuICAgICAgICAgIGV4ZWN1dGFibGU6IGhhc0V4ZWN1dGFibGVDaGlsZFxcbiAgICAgICAgfTtcXG5cXG4gICAgICAgIHNlZ21lbnRDaGlsZHJlbihub2RlLCBvcmRlcmVkQ2hpbGRyZW4sIHN0YXRzW25vZGUuaWRdLCBleGVjdXRhYmxlSW5kZXgpO1xcblxcbiAgICAgICAgaWYgKCFub2RlLmNhbkJlUmVlbnRlcmVkKCkgJiYgc3RhdHNbbm9kZS5pZF0uc2VnbWVudHMubGVuZ3RoID4gMSkge1xcbiAgICAgICAgICBzdGF0cyA9IHsgdmFsaWQ6IGZhbHNlIH07XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIHN0YXJ0aW5nTWluKGV4ZWN1dGFibGVJbmRleCkge1xcbiAgICAgIHJldHVybiBleGVjdXRhYmxlSW5kZXggPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRNaW4gOiBleGVjdXRhYmxlSW5kZXg7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gc3RhcnRpbmdNYXgoZXhlY3V0YWJsZUluZGV4KSB7XFxuICAgICAgcmV0dXJuIGV4ZWN1dGFibGVJbmRleCA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdE1heCA6IGV4ZWN1dGFibGVJbmRleDtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBzZWdtZW50Q2hpbGRyZW4obm9kZSwgb3JkZXJlZENoaWxkcmVuLCBub2RlU3RhdHMsIGV4ZWN1dGFibGVJbmRleCkge1xcbiAgICAgIHZhciBjdXJyZW50U2VnbWVudCA9IHsgaW5kZXg6IDAsIG93bmVyOiBub2RlLCBub2RlczogW10sIG1pbjogc3RhcnRpbmdNaW4oZXhlY3V0YWJsZUluZGV4KSwgbWF4OiBzdGFydGluZ01heChleGVjdXRhYmxlSW5kZXgpIH0sXFxuICAgICAgICAgIHJlc3VsdCA9IFtjdXJyZW50U2VnbWVudF0sXFxuICAgICAgICAgIGxhc3RNYXggPSBkZWZhdWx0TWF4LFxcbiAgICAgICAgICBvcmRlcmVkQ2hpbGRTZWdtZW50cyA9IG9yZGVyQ2hpbGRTZWdtZW50cyhvcmRlcmVkQ2hpbGRyZW4pO1xcblxcbiAgICAgIGZ1bmN0aW9uIGlzU2VnbWVudEJvdW5kYXJ5KG1pbkluZGV4KSB7XFxuICAgICAgICByZXR1cm4gbGFzdE1heCAhPT0gZGVmYXVsdE1heCAmJiBtaW5JbmRleCAhPT0gZGVmYXVsdE1pbiAmJiBsYXN0TWF4IDwgbWluSW5kZXggLSAxO1xcbiAgICAgIH1cXG5cXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9yZGVyZWRDaGlsZFNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICB2YXIgY2hpbGRTZWdtZW50ID0gb3JkZXJlZENoaWxkU2VnbWVudHNbaV0sXFxuICAgICAgICAgIG1heEluZGV4ID0gY2hpbGRTZWdtZW50Lm1heCxcXG4gICAgICAgICAgbWluSW5kZXggPSBjaGlsZFNlZ21lbnQubWluO1xcblxcbiAgICAgICAgaWYgKGlzU2VnbWVudEJvdW5kYXJ5KG1pbkluZGV4KSkge1xcbiAgICAgICAgICBjdXJyZW50U2VnbWVudCA9IHtpbmRleDogcmVzdWx0Lmxlbmd0aCwgb3duZXI6IG5vZGUsIG5vZGVzOiBbXSwgbWluOiBkZWZhdWx0TWluLCBtYXg6IGRlZmF1bHRNYXh9O1xcbiAgICAgICAgICByZXN1bHQucHVzaChjdXJyZW50U2VnbWVudCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBjdXJyZW50U2VnbWVudC5ub2Rlcy5wdXNoKGNoaWxkU2VnbWVudCk7XFxuICAgICAgICBjdXJyZW50U2VnbWVudC5taW4gPSBNYXRoLm1pbihjdXJyZW50U2VnbWVudC5taW4sIG1pbkluZGV4KTtcXG4gICAgICAgIGN1cnJlbnRTZWdtZW50Lm1heCA9IE1hdGgubWF4KGN1cnJlbnRTZWdtZW50Lm1heCwgbWF4SW5kZXgpO1xcbiAgICAgICAgbGFzdE1heCA9IG1heEluZGV4O1xcbiAgICAgIH1cXG5cXG4gICAgICBub2RlU3RhdHMuc2VnbWVudHMgPSByZXN1bHQ7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gb3JkZXJDaGlsZFNlZ21lbnRzKGNoaWxkcmVuKSB7XFxuICAgICAgdmFyIHNwZWNpZmllZE9yZGVyID0gW10sXFxuICAgICAgICAgIHVuc3BlY2lmaWVkT3JkZXIgPSBbXTtcXG5cXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXSxcXG4gICAgICAgICAgICBzZWdtZW50cyA9IHN0YXRzW2NoaWxkLmlkXS5zZWdtZW50cztcXG5cXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2VnbWVudHMubGVuZ3RoOyBqKyspIHtcXG4gICAgICAgICAgdmFyIHNlZyA9IHNlZ21lbnRzW2pdO1xcblxcbiAgICAgICAgICBpZiAoc2VnLm1pbiA9PT0gZGVmYXVsdE1pbikge1xcbiAgICAgICAgICAgIHVuc3BlY2lmaWVkT3JkZXIucHVzaChzZWcpO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHNwZWNpZmllZE9yZGVyLnB1c2goc2VnKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBzcGVjaWZpZWRPcmRlci5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcXG4gICAgICAgIHJldHVybiBhLm1pbiAtIGIubWluO1xcbiAgICAgIH0pO1xcblxcbiAgICAgIHJldHVybiBzcGVjaWZpZWRPcmRlci5jb25jYXQodW5zcGVjaWZpZWRPcmRlcik7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gZXhlY3V0ZU5vZGUobm9kZSwgc2VnbWVudE51bWJlcikge1xcbiAgICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XFxuICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICBmbjogZnVuY3Rpb24oZG9uZSkge1xcbiAgICAgICAgICAgIG5vZGVTdGFydChub2RlKTtcXG5cXG4gICAgICAgICAgICBxdWV1ZVJ1bm5lckZhY3Rvcnkoe1xcbiAgICAgICAgICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24oKSB7XFxuICAgICAgICAgICAgICAgIG5vZGVDb21wbGV0ZShub2RlLCBub2RlLmdldFJlc3VsdCgpKTtcXG4gICAgICAgICAgICAgICAgZG9uZSgpO1xcbiAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgIHF1ZXVlYWJsZUZuczogd3JhcENoaWxkcmVuKG5vZGUsIHNlZ21lbnROdW1iZXIpLFxcbiAgICAgICAgICAgICAgdXNlckNvbnRleHQ6IG5vZGUuc2hhcmVkVXNlckNvbnRleHQoKSxcXG4gICAgICAgICAgICAgIG9uRXhjZXB0aW9uOiBmdW5jdGlvbigpIHtcXG4gICAgICAgICAgICAgICAgbm9kZS5vbkV4Y2VwdGlvbi5hcHBseShub2RlLCBhcmd1bWVudHMpO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9O1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICBmbjogZnVuY3Rpb24oZG9uZSkgeyBub2RlLmV4ZWN1dGUoZG9uZSwgc3RhdHNbbm9kZS5pZF0uZXhlY3V0YWJsZSk7IH1cXG4gICAgICAgIH07XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIHdyYXBDaGlsZHJlbihub2RlLCBzZWdtZW50TnVtYmVyKSB7XFxuICAgICAgdmFyIHJlc3VsdCA9IFtdLFxcbiAgICAgICAgICBzZWdtZW50Q2hpbGRyZW4gPSBzdGF0c1tub2RlLmlkXS5zZWdtZW50c1tzZWdtZW50TnVtYmVyXS5ub2RlcztcXG5cXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnRDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgcmVzdWx0LnB1c2goZXhlY3V0ZU5vZGUoc2VnbWVudENoaWxkcmVuW2ldLm93bmVyLCBzZWdtZW50Q2hpbGRyZW5baV0uaW5kZXgpKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCFzdGF0c1tub2RlLmlkXS5leGVjdXRhYmxlKSB7XFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gbm9kZS5iZWZvcmVBbGxGbnMuY29uY2F0KHJlc3VsdCkuY29uY2F0KG5vZGUuYWZ0ZXJBbGxGbnMpO1xcbiAgICB9XFxuICB9XFxuXFxuICByZXR1cm4gVHJlZVByb2Nlc3NvcjtcXG59O1xcblxcbmdldEphc21pbmVSZXF1aXJlT2JqKCkuQW55ID0gZnVuY3Rpb24oaiQpIHtcXG5cXG4gIGZ1bmN0aW9uIEFueShleHBlY3RlZE9iamVjdCkge1xcbiAgICBpZiAodHlwZW9mIGV4cGVjdGVkT2JqZWN0ID09PSAndW5kZWZpbmVkJykge1xcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXFxuICAgICAgICAnamFzbWluZS5hbnkoKSBleHBlY3RzIHRvIGJlIHBhc3NlZCBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLiAnICtcXG4gICAgICAgICdQbGVhc2UgcGFzcyBvbmUgb3IgdXNlIGphc21pbmUuYW55dGhpbmcoKSB0byBtYXRjaCBhbnkgb2JqZWN0LidcXG4gICAgICApO1xcbiAgICB9XFxuICAgIHRoaXMuZXhwZWN0ZWRPYmplY3QgPSBleHBlY3RlZE9iamVjdDtcXG4gIH1cXG5cXG4gIEFueS5wcm90b3R5cGUuYXN5bW1ldHJpY01hdGNoID0gZnVuY3Rpb24ob3RoZXIpIHtcXG4gICAgaWYgKHRoaXMuZXhwZWN0ZWRPYmplY3QgPT0gU3RyaW5nKSB7XFxuICAgICAgcmV0dXJuIHR5cGVvZiBvdGhlciA9PSAnc3RyaW5nJyB8fCBvdGhlciBpbnN0YW5jZW9mIFN0cmluZztcXG4gICAgfVxcblxcbiAgICBpZiAodGhpcy5leHBlY3RlZE9iamVjdCA9PSBOdW1iZXIpIHtcXG4gICAgICByZXR1cm4gdHlwZW9mIG90aGVyID09ICdudW1iZXInIHx8IG90aGVyIGluc3RhbmNlb2YgTnVtYmVyO1xcbiAgICB9XFxuXFxuICAgIGlmICh0aGlzLmV4cGVjdGVkT2JqZWN0ID09IEZ1bmN0aW9uKSB7XFxuICAgICAgcmV0dXJuIHR5cGVvZiBvdGhlciA9PSAnZnVuY3Rpb24nIHx8IG90aGVyIGluc3RhbmNlb2YgRnVuY3Rpb247XFxuICAgIH1cXG5cXG4gICAgaWYgKHRoaXMuZXhwZWN0ZWRPYmplY3QgPT0gT2JqZWN0KSB7XFxuICAgICAgcmV0dXJuIHR5cGVvZiBvdGhlciA9PSAnb2JqZWN0JztcXG4gICAgfVxcblxcbiAgICBpZiAodGhpcy5leHBlY3RlZE9iamVjdCA9PSBCb29sZWFuKSB7XFxuICAgICAgcmV0dXJuIHR5cGVvZiBvdGhlciA9PSAnYm9vbGVhbic7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgdGhpcy5leHBlY3RlZE9iamVjdDtcXG4gIH07XFxuXFxuICBBbnkucHJvdG90eXBlLmphc21pbmVUb1N0cmluZyA9IGZ1bmN0aW9uKCkge1xcbiAgICByZXR1cm4gJzxqYXNtaW5lLmFueSgnICsgaiQuZm5OYW1lRm9yKHRoaXMuZXhwZWN0ZWRPYmplY3QpICsgJyk+JztcXG4gIH07XFxuXFxuICByZXR1cm4gQW55O1xcbn07XFxuXFxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5Bbnl0aGluZyA9IGZ1bmN0aW9uKGokKSB7XFxuXFxuICBmdW5jdGlvbiBBbnl0aGluZygpIHt9XFxuXFxuICBBbnl0aGluZy5wcm90b3R5cGUuYXN5bW1ldHJpY01hdGNoID0gZnVuY3Rpb24ob3RoZXIpIHtcXG4gICAgcmV0dXJuICFqJC51dGlsLmlzVW5kZWZpbmVkKG90aGVyKSAmJiBvdGhlciAhPT0gbnVsbDtcXG4gIH07XFxuXFxuICBBbnl0aGluZy5wcm90b3R5cGUuamFzbWluZVRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XFxuICAgIHJldHVybiAnPGphc21pbmUuYW55dGhpbmc+JztcXG4gIH07XFxuXFxuICByZXR1cm4gQW55dGhpbmc7XFxufTtcXG5cXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLkFycmF5Q29udGFpbmluZyA9IGZ1bmN0aW9uKGokKSB7XFxuICBmdW5jdGlvbiBBcnJheUNvbnRhaW5pbmcoc2FtcGxlKSB7XFxuICAgIHRoaXMuc2FtcGxlID0gc2FtcGxlO1xcbiAgfVxcblxcbiAgQXJyYXlDb250YWluaW5nLnByb3RvdHlwZS5hc3ltbWV0cmljTWF0Y2ggPSBmdW5jdGlvbihvdGhlcikge1xcbiAgICB2YXIgY2xhc3NOYW1lID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRoaXMuc2FtcGxlKTtcXG4gICAgaWYgKGNsYXNzTmFtZSAhPT0gJ1tvYmplY3QgQXJyYXldJykgeyB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IHByb3ZpZGUgYW4gYXJyYXkgdG8gYXJyYXlDb250YWluaW5nLCBub3QgXFxcXCcnICsgdGhpcy5zYW1wbGUgKyAnXFxcXCcuJyk7IH1cXG5cXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnNhbXBsZS5sZW5ndGg7IGkrKykge1xcbiAgICAgIHZhciBpdGVtID0gdGhpcy5zYW1wbGVbaV07XFxuICAgICAgaWYgKCFqJC5tYXRjaGVyc1V0aWwuY29udGFpbnMob3RoZXIsIGl0ZW0pKSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHJldHVybiB0cnVlO1xcbiAgfTtcXG5cXG4gIEFycmF5Q29udGFpbmluZy5wcm90b3R5cGUuamFzbWluZVRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xcbiAgICByZXR1cm4gJzxqYXNtaW5lLmFycmF5Q29udGFpbmluZygnICsgamFzbWluZS5wcCh0aGlzLnNhbXBsZSkgKycpPic7XFxuICB9O1xcblxcbiAgcmV0dXJuIEFycmF5Q29udGFpbmluZztcXG59O1xcblxcbmdldEphc21pbmVSZXF1aXJlT2JqKCkuT2JqZWN0Q29udGFpbmluZyA9IGZ1bmN0aW9uKGokKSB7XFxuXFxuICBmdW5jdGlvbiBPYmplY3RDb250YWluaW5nKHNhbXBsZSkge1xcbiAgICB0aGlzLnNhbXBsZSA9IHNhbXBsZTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGdldFByb3RvdHlwZShvYmopIHtcXG4gICAgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZikge1xcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKTtcXG4gICAgfVxcblxcbiAgICBpZiAob2JqLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PSBvYmopIHtcXG4gICAgICByZXR1cm4gbnVsbDtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gb2JqLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGhhc1Byb3BlcnR5KG9iaiwgcHJvcGVydHkpIHtcXG4gICAgaWYgKCFvYmopIHtcXG4gICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG5cXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3BlcnR5KSkge1xcbiAgICAgIHJldHVybiB0cnVlO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBoYXNQcm9wZXJ0eShnZXRQcm90b3R5cGUob2JqKSwgcHJvcGVydHkpO1xcbiAgfVxcblxcbiAgT2JqZWN0Q29udGFpbmluZy5wcm90b3R5cGUuYXN5bW1ldHJpY01hdGNoID0gZnVuY3Rpb24ob3RoZXIpIHtcXG4gICAgaWYgKHR5cGVvZih0aGlzLnNhbXBsZSkgIT09ICdvYmplY3QnKSB7IHRocm93IG5ldyBFcnJvcignWW91IG11c3QgcHJvdmlkZSBhbiBvYmplY3QgdG8gb2JqZWN0Q29udGFpbmluZywgbm90IFxcXFwnJyt0aGlzLnNhbXBsZSsnXFxcXCcuJyk7IH1cXG5cXG4gICAgZm9yICh2YXIgcHJvcGVydHkgaW4gdGhpcy5zYW1wbGUpIHtcXG4gICAgICBpZiAoIWhhc1Byb3BlcnR5KG90aGVyLCBwcm9wZXJ0eSkgfHxcXG4gICAgICAgICAgIWokLm1hdGNoZXJzVXRpbC5lcXVhbHModGhpcy5zYW1wbGVbcHJvcGVydHldLCBvdGhlcltwcm9wZXJ0eV0pKSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHJldHVybiB0cnVlO1xcbiAgfTtcXG5cXG4gIE9iamVjdENvbnRhaW5pbmcucHJvdG90eXBlLmphc21pbmVUb1N0cmluZyA9IGZ1bmN0aW9uKCkge1xcbiAgICByZXR1cm4gJzxqYXNtaW5lLm9iamVjdENvbnRhaW5pbmcoJyArIGokLnBwKHRoaXMuc2FtcGxlKSArICcpPic7XFxuICB9O1xcblxcbiAgcmV0dXJuIE9iamVjdENvbnRhaW5pbmc7XFxufTtcXG5cXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLlN0cmluZ01hdGNoaW5nID0gZnVuY3Rpb24oaiQpIHtcXG5cXG4gIGZ1bmN0aW9uIFN0cmluZ01hdGNoaW5nKGV4cGVjdGVkKSB7XFxuICAgIGlmICghaiQuaXNTdHJpbmdfKGV4cGVjdGVkKSAmJiAhaiQuaXNBXygnUmVnRXhwJywgZXhwZWN0ZWQpKSB7XFxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBpcyBub3QgYSBTdHJpbmcgb3IgYSBSZWdFeHAnKTtcXG4gICAgfVxcblxcbiAgICB0aGlzLnJlZ2V4cCA9IG5ldyBSZWdFeHAoZXhwZWN0ZWQpO1xcbiAgfVxcblxcbiAgU3RyaW5nTWF0Y2hpbmcucHJvdG90eXBlLmFzeW1tZXRyaWNNYXRjaCA9IGZ1bmN0aW9uKG90aGVyKSB7XFxuICAgIHJldHVybiB0aGlzLnJlZ2V4cC50ZXN0KG90aGVyKTtcXG4gIH07XFxuXFxuICBTdHJpbmdNYXRjaGluZy5wcm90b3R5cGUuamFzbWluZVRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XFxuICAgIHJldHVybiAnPGphc21pbmUuc3RyaW5nTWF0Y2hpbmcoJyArIHRoaXMucmVnZXhwICsgJyk+JztcXG4gIH07XFxuXFxuICByZXR1cm4gU3RyaW5nTWF0Y2hpbmc7XFxufTtcXG5cXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLmVycm9ycyA9IGZ1bmN0aW9uKCkge1xcbiAgZnVuY3Rpb24gRXhwZWN0YXRpb25GYWlsZWQoKSB7fVxcblxcbiAgRXhwZWN0YXRpb25GYWlsZWQucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XFxuICBFeHBlY3RhdGlvbkZhaWxlZC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFeHBlY3RhdGlvbkZhaWxlZDtcXG5cXG4gIHJldHVybiB7XFxuICAgIEV4cGVjdGF0aW9uRmFpbGVkOiBFeHBlY3RhdGlvbkZhaWxlZFxcbiAgfTtcXG59O1xcbmdldEphc21pbmVSZXF1aXJlT2JqKCkubWF0Y2hlcnNVdGlsID0gZnVuY3Rpb24oaiQpIHtcXG4gIC8vIFRPRE86IHdoYXQgdG8gZG8gYWJvdXQgamFzbWluZS5wcCBub3QgYmVpbmcgaW5qZWN0PyBtb3ZlIHRvIEpTT04uc3RyaW5naWZ5PyBndXQgUHJldHR5UHJpbnRlcj9cXG5cXG4gIHJldHVybiB7XFxuICAgIGVxdWFsczogZnVuY3Rpb24oYSwgYiwgY3VzdG9tVGVzdGVycykge1xcbiAgICAgIGN1c3RvbVRlc3RlcnMgPSBjdXN0b21UZXN0ZXJzIHx8IFtdO1xcblxcbiAgICAgIHJldHVybiBlcShhLCBiLCBbXSwgW10sIGN1c3RvbVRlc3RlcnMpO1xcbiAgICB9LFxcblxcbiAgICBjb250YWluczogZnVuY3Rpb24oaGF5c3RhY2ssIG5lZWRsZSwgY3VzdG9tVGVzdGVycykge1xcbiAgICAgIGN1c3RvbVRlc3RlcnMgPSBjdXN0b21UZXN0ZXJzIHx8IFtdO1xcblxcbiAgICAgIGlmICgoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5hcHBseShoYXlzdGFjaykgPT09ICdbb2JqZWN0IEFycmF5XScpIHx8XFxuICAgICAgICAoISFoYXlzdGFjayAmJiAhaGF5c3RhY2suaW5kZXhPZikpXFxuICAgICAge1xcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYXlzdGFjay5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgICBpZiAoZXEoaGF5c3RhY2tbaV0sIG5lZWRsZSwgW10sIFtdLCBjdXN0b21UZXN0ZXJzKSkge1xcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiAhIWhheXN0YWNrICYmIGhheXN0YWNrLmluZGV4T2YobmVlZGxlKSA+PSAwO1xcbiAgICB9LFxcblxcbiAgICBidWlsZEZhaWx1cmVNZXNzYWdlOiBmdW5jdGlvbigpIHtcXG4gICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCksXFxuICAgICAgICBtYXRjaGVyTmFtZSA9IGFyZ3NbMF0sXFxuICAgICAgICBpc05vdCA9IGFyZ3NbMV0sXFxuICAgICAgICBhY3R1YWwgPSBhcmdzWzJdLFxcbiAgICAgICAgZXhwZWN0ZWQgPSBhcmdzLnNsaWNlKDMpLFxcbiAgICAgICAgZW5nbGlzaHlQcmVkaWNhdGUgPSBtYXRjaGVyTmFtZS5yZXBsYWNlKC9bQS1aXS9nLCBmdW5jdGlvbihzKSB7IHJldHVybiAnICcgKyBzLnRvTG93ZXJDYXNlKCk7IH0pO1xcblxcbiAgICAgIHZhciBtZXNzYWdlID0gJ0V4cGVjdGVkICcgK1xcbiAgICAgICAgaiQucHAoYWN0dWFsKSArXFxuICAgICAgICAoaXNOb3QgPyAnIG5vdCAnIDogJyAnKSArXFxuICAgICAgICBlbmdsaXNoeVByZWRpY2F0ZTtcXG5cXG4gICAgICBpZiAoZXhwZWN0ZWQubGVuZ3RoID4gMCkge1xcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBlY3RlZC5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgICBpZiAoaSA+IDApIHtcXG4gICAgICAgICAgICBtZXNzYWdlICs9ICcsJztcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBtZXNzYWdlICs9ICcgJyArIGokLnBwKGV4cGVjdGVkW2ldKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIG1lc3NhZ2UgKyAnLic7XFxuICAgIH1cXG4gIH07XFxuXFxuICBmdW5jdGlvbiBpc0FzeW1tZXRyaWMob2JqKSB7XFxuICAgIHJldHVybiBvYmogJiYgaiQuaXNBXygnRnVuY3Rpb24nLCBvYmouYXN5bW1ldHJpY01hdGNoKTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGFzeW1tZXRyaWNNYXRjaChhLCBiKSB7XFxuICAgIHZhciBhc3ltbWV0cmljQSA9IGlzQXN5bW1ldHJpYyhhKSxcXG4gICAgICAgIGFzeW1tZXRyaWNCID0gaXNBc3ltbWV0cmljKGIpO1xcblxcbiAgICBpZiAoYXN5bW1ldHJpY0EgJiYgYXN5bW1ldHJpY0IpIHtcXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xcbiAgICB9XFxuXFxuICAgIGlmIChhc3ltbWV0cmljQSkge1xcbiAgICAgIHJldHVybiBhLmFzeW1tZXRyaWNNYXRjaChiKTtcXG4gICAgfVxcblxcbiAgICBpZiAoYXN5bW1ldHJpY0IpIHtcXG4gICAgICByZXR1cm4gYi5hc3ltbWV0cmljTWF0Y2goYSk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIC8vIEVxdWFsaXR5IGZ1bmN0aW9uIGxvdmluZ2x5IGFkYXB0ZWQgZnJvbSBpc0VxdWFsIGluXFxuICAvLyAgIFtVbmRlcnNjb3JlXShodHRwOi8vdW5kZXJzY29yZWpzLm9yZylcXG4gIGZ1bmN0aW9uIGVxKGEsIGIsIGFTdGFjaywgYlN0YWNrLCBjdXN0b21UZXN0ZXJzKSB7XFxuICAgIHZhciByZXN1bHQgPSB0cnVlO1xcblxcbiAgICB2YXIgYXN5bW1ldHJpY1Jlc3VsdCA9IGFzeW1tZXRyaWNNYXRjaChhLCBiKTtcXG4gICAgaWYgKCFqJC51dGlsLmlzVW5kZWZpbmVkKGFzeW1tZXRyaWNSZXN1bHQpKSB7XFxuICAgICAgcmV0dXJuIGFzeW1tZXRyaWNSZXN1bHQ7XFxuICAgIH1cXG5cXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdXN0b21UZXN0ZXJzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgdmFyIGN1c3RvbVRlc3RlclJlc3VsdCA9IGN1c3RvbVRlc3RlcnNbaV0oYSwgYik7XFxuICAgICAgaWYgKCFqJC51dGlsLmlzVW5kZWZpbmVkKGN1c3RvbVRlc3RlclJlc3VsdCkpIHtcXG4gICAgICAgIHJldHVybiBjdXN0b21UZXN0ZXJSZXN1bHQ7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGlmIChhIGluc3RhbmNlb2YgRXJyb3IgJiYgYiBpbnN0YW5jZW9mIEVycm9yKSB7XFxuICAgICAgcmV0dXJuIGEubWVzc2FnZSA9PSBiLm1lc3NhZ2U7XFxuICAgIH1cXG5cXG4gICAgLy8gSWRlbnRpY2FsIG9iamVjdHMgYXJlIGVxdWFsLiBgMCA9PT0gLTBgLCBidXQgdGhleSBhcmVuJ3QgaWRlbnRpY2FsLlxcbiAgICAvLyBTZWUgdGhlIFtIYXJtb255IGBlZ2FsYCBwcm9wb3NhbF0oaHR0cDovL3dpa2kuZWNtYXNjcmlwdC5vcmcvZG9rdS5waHA/aWQ9aGFybW9ueTplZ2FsKS5cXG4gICAgaWYgKGEgPT09IGIpIHsgcmV0dXJuIGEgIT09IDAgfHwgMSAvIGEgPT0gMSAvIGI7IH1cXG4gICAgLy8gQSBzdHJpY3QgY29tcGFyaXNvbiBpcyBuZWNlc3NhcnkgYmVjYXVzZSBgbnVsbCA9PSB1bmRlZmluZWRgLlxcbiAgICBpZiAoYSA9PT0gbnVsbCB8fCBiID09PSBudWxsKSB7IHJldHVybiBhID09PSBiOyB9XFxuICAgIHZhciBjbGFzc05hbWUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYSk7XFxuICAgIGlmIChjbGFzc05hbWUgIT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGIpKSB7IHJldHVybiBmYWxzZTsgfVxcbiAgICBzd2l0Y2ggKGNsYXNzTmFtZSkge1xcbiAgICAgIC8vIFN0cmluZ3MsIG51bWJlcnMsIGRhdGVzLCBhbmQgYm9vbGVhbnMgYXJlIGNvbXBhcmVkIGJ5IHZhbHVlLlxcbiAgICAgIGNhc2UgJ1tvYmplY3QgU3RyaW5nXSc6XFxuICAgICAgICAvLyBQcmltaXRpdmVzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIG9iamVjdCB3cmFwcGVycyBhcmUgZXF1aXZhbGVudDsgdGh1cywgYFxcXCI1XFxcImAgaXNcXG4gICAgICAgIC8vIGVxdWl2YWxlbnQgdG8gYG5ldyBTdHJpbmcoXFxcIjVcXFwiKWAuXFxuICAgICAgICByZXR1cm4gYSA9PSBTdHJpbmcoYik7XFxuICAgICAgY2FzZSAnW29iamVjdCBOdW1iZXJdJzpcXG4gICAgICAgIC8vIGBOYU5gcyBhcmUgZXF1aXZhbGVudCwgYnV0IG5vbi1yZWZsZXhpdmUuIEFuIGBlZ2FsYCBjb21wYXJpc29uIGlzIHBlcmZvcm1lZCBmb3JcXG4gICAgICAgIC8vIG90aGVyIG51bWVyaWMgdmFsdWVzLlxcbiAgICAgICAgcmV0dXJuIGEgIT0gK2EgPyBiICE9ICtiIDogKGEgPT09IDAgPyAxIC8gYSA9PSAxIC8gYiA6IGEgPT0gK2IpO1xcbiAgICAgIGNhc2UgJ1tvYmplY3QgRGF0ZV0nOlxcbiAgICAgIGNhc2UgJ1tvYmplY3QgQm9vbGVhbl0nOlxcbiAgICAgICAgLy8gQ29lcmNlIGRhdGVzIGFuZCBib29sZWFucyB0byBudW1lcmljIHByaW1pdGl2ZSB2YWx1ZXMuIERhdGVzIGFyZSBjb21wYXJlZCBieSB0aGVpclxcbiAgICAgICAgLy8gbWlsbGlzZWNvbmQgcmVwcmVzZW50YXRpb25zLiBOb3RlIHRoYXQgaW52YWxpZCBkYXRlcyB3aXRoIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9uc1xcbiAgICAgICAgLy8gb2YgYE5hTmAgYXJlIG5vdCBlcXVpdmFsZW50LlxcbiAgICAgICAgcmV0dXJuICthID09ICtiO1xcbiAgICAgIC8vIFJlZ0V4cHMgYXJlIGNvbXBhcmVkIGJ5IHRoZWlyIHNvdXJjZSBwYXR0ZXJucyBhbmQgZmxhZ3MuXFxuICAgICAgY2FzZSAnW29iamVjdCBSZWdFeHBdJzpcXG4gICAgICAgIHJldHVybiBhLnNvdXJjZSA9PSBiLnNvdXJjZSAmJlxcbiAgICAgICAgICBhLmdsb2JhbCA9PSBiLmdsb2JhbCAmJlxcbiAgICAgICAgICBhLm11bHRpbGluZSA9PSBiLm11bHRpbGluZSAmJlxcbiAgICAgICAgICBhLmlnbm9yZUNhc2UgPT0gYi5pZ25vcmVDYXNlO1xcbiAgICB9XFxuICAgIGlmICh0eXBlb2YgYSAhPSAnb2JqZWN0JyB8fCB0eXBlb2YgYiAhPSAnb2JqZWN0JykgeyByZXR1cm4gZmFsc2U7IH1cXG5cXG4gICAgdmFyIGFJc0RvbU5vZGUgPSBqJC5pc0RvbU5vZGUoYSk7XFxuICAgIHZhciBiSXNEb21Ob2RlID0gaiQuaXNEb21Ob2RlKGIpO1xcbiAgICBpZiAoYUlzRG9tTm9kZSAmJiBiSXNEb21Ob2RlKSB7XFxuICAgICAgLy8gQXQgZmlyc3QgdHJ5IHRvIHVzZSBET00zIG1ldGhvZCBpc0VxdWFsTm9kZVxcbiAgICAgIGlmIChhLmlzRXF1YWxOb2RlKSB7XFxuICAgICAgICByZXR1cm4gYS5pc0VxdWFsTm9kZShiKTtcXG4gICAgICB9XFxuICAgICAgLy8gSUU4IGRvZXNuJ3Qgc3VwcG9ydCBpc0VxdWFsTm9kZSwgdHJ5IHRvIHVzZSBvdXRlckhUTUwgJiYgaW5uZXJUZXh0XFxuICAgICAgdmFyIGFJc0VsZW1lbnQgPSBhIGluc3RhbmNlb2YgRWxlbWVudDtcXG4gICAgICB2YXIgYklzRWxlbWVudCA9IGIgaW5zdGFuY2VvZiBFbGVtZW50O1xcbiAgICAgIGlmIChhSXNFbGVtZW50ICYmIGJJc0VsZW1lbnQpIHtcXG4gICAgICAgIHJldHVybiBhLm91dGVySFRNTCA9PSBiLm91dGVySFRNTDtcXG4gICAgICB9XFxuICAgICAgaWYgKGFJc0VsZW1lbnQgfHwgYklzRWxlbWVudCkge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gYS5pbm5lclRleHQgPT0gYi5pbm5lclRleHQgJiYgYS50ZXh0Q29udGVudCA9PSBiLnRleHRDb250ZW50O1xcbiAgICB9XFxuICAgIGlmIChhSXNEb21Ob2RlIHx8IGJJc0RvbU5vZGUpIHtcXG4gICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG5cXG4gICAgLy8gQXNzdW1lIGVxdWFsaXR5IGZvciBjeWNsaWMgc3RydWN0dXJlcy4gVGhlIGFsZ29yaXRobSBmb3IgZGV0ZWN0aW5nIGN5Y2xpY1xcbiAgICAvLyBzdHJ1Y3R1cmVzIGlzIGFkYXB0ZWQgZnJvbSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLCBhYnN0cmFjdCBvcGVyYXRpb24gYEpPYC5cXG4gICAgdmFyIGxlbmd0aCA9IGFTdGFjay5sZW5ndGg7XFxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xcbiAgICAgIC8vIExpbmVhciBzZWFyY2guIFBlcmZvcm1hbmNlIGlzIGludmVyc2VseSBwcm9wb3J0aW9uYWwgdG8gdGhlIG51bWJlciBvZlxcbiAgICAgIC8vIHVuaXF1ZSBuZXN0ZWQgc3RydWN0dXJlcy5cXG4gICAgICBpZiAoYVN0YWNrW2xlbmd0aF0gPT0gYSkgeyByZXR1cm4gYlN0YWNrW2xlbmd0aF0gPT0gYjsgfVxcbiAgICB9XFxuICAgIC8vIEFkZCB0aGUgZmlyc3Qgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cXG4gICAgYVN0YWNrLnB1c2goYSk7XFxuICAgIGJTdGFjay5wdXNoKGIpO1xcbiAgICB2YXIgc2l6ZSA9IDA7XFxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyBhbmQgYXJyYXlzLlxcbiAgICAvLyBDb21wYXJlIGFycmF5IGxlbmd0aHMgdG8gZGV0ZXJtaW5lIGlmIGEgZGVlcCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeS5cXG4gICAgaWYgKGNsYXNzTmFtZSA9PSAnW29iamVjdCBBcnJheV0nICYmIGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xcbiAgICB9XFxuXFxuICAgIGlmIChyZXN1bHQpIHtcXG4gICAgICAvLyBPYmplY3RzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWl2YWxlbnQsIGJ1dCBgT2JqZWN0YHNcXG4gICAgICAvLyBvciBgQXJyYXlgcyBmcm9tIGRpZmZlcmVudCBmcmFtZXMgYXJlLlxcbiAgICAgIGlmIChjbGFzc05hbWUgIT09ICdbb2JqZWN0IEFycmF5XScpIHtcXG4gICAgICAgIHZhciBhQ3RvciA9IGEuY29uc3RydWN0b3IsIGJDdG9yID0gYi5jb25zdHJ1Y3RvcjtcXG4gICAgICAgIGlmIChhQ3RvciAhPT0gYkN0b3IgJiYgIShpc0Z1bmN0aW9uKGFDdG9yKSAmJiBhQ3RvciBpbnN0YW5jZW9mIGFDdG9yICYmXFxuICAgICAgICAgICAgICAgaXNGdW5jdGlvbihiQ3RvcikgJiYgYkN0b3IgaW5zdGFuY2VvZiBiQ3RvcikpIHtcXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICAvLyBEZWVwIGNvbXBhcmUgb2JqZWN0cy5cXG4gICAgICBmb3IgKHZhciBrZXkgaW4gYSkge1xcbiAgICAgICAgaWYgKGhhcyhhLCBrZXkpKSB7XFxuICAgICAgICAgIC8vIENvdW50IHRoZSBleHBlY3RlZCBudW1iZXIgb2YgcHJvcGVydGllcy5cXG4gICAgICAgICAgc2l6ZSsrO1xcbiAgICAgICAgICAvLyBEZWVwIGNvbXBhcmUgZWFjaCBtZW1iZXIuXFxuICAgICAgICAgIGlmICghKHJlc3VsdCA9IGhhcyhiLCBrZXkpICYmIGVxKGFba2V5XSwgYltrZXldLCBhU3RhY2ssIGJTdGFjaywgY3VzdG9tVGVzdGVycykpKSB7IGJyZWFrOyB9XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIC8vIEVuc3VyZSB0aGF0IGJvdGggb2JqZWN0cyBjb250YWluIHRoZSBzYW1lIG51bWJlciBvZiBwcm9wZXJ0aWVzLlxcbiAgICAgIGlmIChyZXN1bHQpIHtcXG4gICAgICAgIGZvciAoa2V5IGluIGIpIHtcXG4gICAgICAgICAgaWYgKGhhcyhiLCBrZXkpICYmICEoc2l6ZS0tKSkgeyBicmVhazsgfVxcbiAgICAgICAgfVxcbiAgICAgICAgcmVzdWx0ID0gIXNpemU7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIC8vIFJlbW92ZSB0aGUgZmlyc3Qgb2JqZWN0IGZyb20gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxcbiAgICBhU3RhY2sucG9wKCk7XFxuICAgIGJTdGFjay5wb3AoKTtcXG5cXG4gICAgcmV0dXJuIHJlc3VsdDtcXG5cXG4gICAgZnVuY3Rpb24gaGFzKG9iaiwga2V5KSB7XFxuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gaXNGdW5jdGlvbihvYmopIHtcXG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJztcXG4gICAgfVxcbiAgfVxcbn07XFxuXFxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS50b0JlID0gZnVuY3Rpb24oKSB7XFxuICBmdW5jdGlvbiB0b0JlKCkge1xcbiAgICByZXR1cm4ge1xcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpIHtcXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgIHBhc3M6IGFjdHVhbCA9PT0gZXhwZWN0ZWRcXG4gICAgICAgIH07XFxuICAgICAgfVxcbiAgICB9O1xcbiAgfVxcblxcbiAgcmV0dXJuIHRvQmU7XFxufTtcXG5cXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvQmVDbG9zZVRvID0gZnVuY3Rpb24oKSB7XFxuXFxuICBmdW5jdGlvbiB0b0JlQ2xvc2VUbygpIHtcXG4gICAgcmV0dXJuIHtcXG4gICAgICBjb21wYXJlOiBmdW5jdGlvbihhY3R1YWwsIGV4cGVjdGVkLCBwcmVjaXNpb24pIHtcXG4gICAgICAgIGlmIChwcmVjaXNpb24gIT09IDApIHtcXG4gICAgICAgICAgcHJlY2lzaW9uID0gcHJlY2lzaW9uIHx8IDI7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICBwYXNzOiBNYXRoLmFicyhleHBlY3RlZCAtIGFjdHVhbCkgPCAoTWF0aC5wb3coMTAsIC1wcmVjaXNpb24pIC8gMilcXG4gICAgICAgIH07XFxuICAgICAgfVxcbiAgICB9O1xcbiAgfVxcblxcbiAgcmV0dXJuIHRvQmVDbG9zZVRvO1xcbn07XFxuXFxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS50b0JlRGVmaW5lZCA9IGZ1bmN0aW9uKCkge1xcbiAgZnVuY3Rpb24gdG9CZURlZmluZWQoKSB7XFxuICAgIHJldHVybiB7XFxuICAgICAgY29tcGFyZTogZnVuY3Rpb24oYWN0dWFsKSB7XFxuICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICBwYXNzOiAodm9pZCAwICE9PSBhY3R1YWwpXFxuICAgICAgICB9O1xcbiAgICAgIH1cXG4gICAgfTtcXG4gIH1cXG5cXG4gIHJldHVybiB0b0JlRGVmaW5lZDtcXG59O1xcblxcbmdldEphc21pbmVSZXF1aXJlT2JqKCkudG9CZUZhbHN5ID0gZnVuY3Rpb24oKSB7XFxuICBmdW5jdGlvbiB0b0JlRmFsc3koKSB7XFxuICAgIHJldHVybiB7XFxuICAgICAgY29tcGFyZTogZnVuY3Rpb24oYWN0dWFsKSB7XFxuICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICBwYXNzOiAhISFhY3R1YWxcXG4gICAgICAgIH07XFxuICAgICAgfVxcbiAgICB9O1xcbiAgfVxcblxcbiAgcmV0dXJuIHRvQmVGYWxzeTtcXG59O1xcblxcbmdldEphc21pbmVSZXF1aXJlT2JqKCkudG9CZUdyZWF0ZXJUaGFuID0gZnVuY3Rpb24oKSB7XFxuXFxuICBmdW5jdGlvbiB0b0JlR3JlYXRlclRoYW4oKSB7XFxuICAgIHJldHVybiB7XFxuICAgICAgY29tcGFyZTogZnVuY3Rpb24oYWN0dWFsLCBleHBlY3RlZCkge1xcbiAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgcGFzczogYWN0dWFsID4gZXhwZWN0ZWRcXG4gICAgICAgIH07XFxuICAgICAgfVxcbiAgICB9O1xcbiAgfVxcblxcbiAgcmV0dXJuIHRvQmVHcmVhdGVyVGhhbjtcXG59O1xcblxcblxcbmdldEphc21pbmVSZXF1aXJlT2JqKCkudG9CZUxlc3NUaGFuID0gZnVuY3Rpb24oKSB7XFxuICBmdW5jdGlvbiB0b0JlTGVzc1RoYW4oKSB7XFxuICAgIHJldHVybiB7XFxuXFxuICAgICAgY29tcGFyZTogZnVuY3Rpb24oYWN0dWFsLCBleHBlY3RlZCkge1xcbiAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgcGFzczogYWN0dWFsIDwgZXhwZWN0ZWRcXG4gICAgICAgIH07XFxuICAgICAgfVxcbiAgICB9O1xcbiAgfVxcblxcbiAgcmV0dXJuIHRvQmVMZXNzVGhhbjtcXG59O1xcbmdldEphc21pbmVSZXF1aXJlT2JqKCkudG9CZU5hTiA9IGZ1bmN0aW9uKGokKSB7XFxuXFxuICBmdW5jdGlvbiB0b0JlTmFOKCkge1xcbiAgICByZXR1cm4ge1xcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGFjdHVhbCkge1xcbiAgICAgICAgdmFyIHJlc3VsdCA9IHtcXG4gICAgICAgICAgcGFzczogKGFjdHVhbCAhPT0gYWN0dWFsKVxcbiAgICAgICAgfTtcXG5cXG4gICAgICAgIGlmIChyZXN1bHQucGFzcykge1xcbiAgICAgICAgICByZXN1bHQubWVzc2FnZSA9ICdFeHBlY3RlZCBhY3R1YWwgbm90IHRvIGJlIE5hTi4nO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgcmVzdWx0Lm1lc3NhZ2UgPSBmdW5jdGlvbigpIHsgcmV0dXJuICdFeHBlY3RlZCAnICsgaiQucHAoYWN0dWFsKSArICcgdG8gYmUgTmFOLic7IH07XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICAgIH1cXG4gICAgfTtcXG4gIH1cXG5cXG4gIHJldHVybiB0b0JlTmFOO1xcbn07XFxuXFxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS50b0JlTnVsbCA9IGZ1bmN0aW9uKCkge1xcblxcbiAgZnVuY3Rpb24gdG9CZU51bGwoKSB7XFxuICAgIHJldHVybiB7XFxuICAgICAgY29tcGFyZTogZnVuY3Rpb24oYWN0dWFsKSB7XFxuICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICBwYXNzOiBhY3R1YWwgPT09IG51bGxcXG4gICAgICAgIH07XFxuICAgICAgfVxcbiAgICB9O1xcbiAgfVxcblxcbiAgcmV0dXJuIHRvQmVOdWxsO1xcbn07XFxuXFxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS50b0JlVHJ1dGh5ID0gZnVuY3Rpb24oKSB7XFxuXFxuICBmdW5jdGlvbiB0b0JlVHJ1dGh5KCkge1xcbiAgICByZXR1cm4ge1xcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGFjdHVhbCkge1xcbiAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgcGFzczogISFhY3R1YWxcXG4gICAgICAgIH07XFxuICAgICAgfVxcbiAgICB9O1xcbiAgfVxcblxcbiAgcmV0dXJuIHRvQmVUcnV0aHk7XFxufTtcXG5cXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvQmVVbmRlZmluZWQgPSBmdW5jdGlvbigpIHtcXG5cXG4gIGZ1bmN0aW9uIHRvQmVVbmRlZmluZWQoKSB7XFxuICAgIHJldHVybiB7XFxuICAgICAgY29tcGFyZTogZnVuY3Rpb24oYWN0dWFsKSB7XFxuICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICBwYXNzOiB2b2lkIDAgPT09IGFjdHVhbFxcbiAgICAgICAgfTtcXG4gICAgICB9XFxuICAgIH07XFxuICB9XFxuXFxuICByZXR1cm4gdG9CZVVuZGVmaW5lZDtcXG59O1xcblxcbmdldEphc21pbmVSZXF1aXJlT2JqKCkudG9Db250YWluID0gZnVuY3Rpb24oKSB7XFxuICBmdW5jdGlvbiB0b0NvbnRhaW4odXRpbCwgY3VzdG9tRXF1YWxpdHlUZXN0ZXJzKSB7XFxuICAgIGN1c3RvbUVxdWFsaXR5VGVzdGVycyA9IGN1c3RvbUVxdWFsaXR5VGVzdGVycyB8fCBbXTtcXG5cXG4gICAgcmV0dXJuIHtcXG4gICAgICBjb21wYXJlOiBmdW5jdGlvbihhY3R1YWwsIGV4cGVjdGVkKSB7XFxuXFxuICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICBwYXNzOiB1dGlsLmNvbnRhaW5zKGFjdHVhbCwgZXhwZWN0ZWQsIGN1c3RvbUVxdWFsaXR5VGVzdGVycylcXG4gICAgICAgIH07XFxuICAgICAgfVxcbiAgICB9O1xcbiAgfVxcblxcbiAgcmV0dXJuIHRvQ29udGFpbjtcXG59O1xcblxcbmdldEphc21pbmVSZXF1aXJlT2JqKCkudG9FcXVhbCA9IGZ1bmN0aW9uKCkge1xcblxcbiAgZnVuY3Rpb24gdG9FcXVhbCh1dGlsLCBjdXN0b21FcXVhbGl0eVRlc3RlcnMpIHtcXG4gICAgY3VzdG9tRXF1YWxpdHlUZXN0ZXJzID0gY3VzdG9tRXF1YWxpdHlUZXN0ZXJzIHx8IFtdO1xcblxcbiAgICByZXR1cm4ge1xcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpIHtcXG4gICAgICAgIHZhciByZXN1bHQgPSB7XFxuICAgICAgICAgIHBhc3M6IGZhbHNlXFxuICAgICAgICB9O1xcblxcbiAgICAgICAgcmVzdWx0LnBhc3MgPSB1dGlsLmVxdWFscyhhY3R1YWwsIGV4cGVjdGVkLCBjdXN0b21FcXVhbGl0eVRlc3RlcnMpO1xcblxcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgICB9XFxuICAgIH07XFxuICB9XFxuXFxuICByZXR1cm4gdG9FcXVhbDtcXG59O1xcblxcbmdldEphc21pbmVSZXF1aXJlT2JqKCkudG9IYXZlQmVlbkNhbGxlZCA9IGZ1bmN0aW9uKGokKSB7XFxuXFxuICBmdW5jdGlvbiB0b0hhdmVCZWVuQ2FsbGVkKCkge1xcbiAgICByZXR1cm4ge1xcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGFjdHVhbCkge1xcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xcblxcbiAgICAgICAgaWYgKCFqJC5pc1NweShhY3R1YWwpKSB7XFxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgYSBzcHksIGJ1dCBnb3QgJyArIGokLnBwKGFjdHVhbCkgKyAnLicpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XFxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndG9IYXZlQmVlbkNhbGxlZCBkb2VzIG5vdCB0YWtlIGFyZ3VtZW50cywgdXNlIHRvSGF2ZUJlZW5DYWxsZWRXaXRoJyk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXN1bHQucGFzcyA9IGFjdHVhbC5jYWxscy5hbnkoKTtcXG5cXG4gICAgICAgIHJlc3VsdC5tZXNzYWdlID0gcmVzdWx0LnBhc3MgP1xcbiAgICAgICAgICAnRXhwZWN0ZWQgc3B5ICcgKyBhY3R1YWwuYW5kLmlkZW50aXR5KCkgKyAnIG5vdCB0byBoYXZlIGJlZW4gY2FsbGVkLicgOlxcbiAgICAgICAgICAnRXhwZWN0ZWQgc3B5ICcgKyBhY3R1YWwuYW5kLmlkZW50aXR5KCkgKyAnIHRvIGhhdmUgYmVlbiBjYWxsZWQuJztcXG5cXG4gICAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgICAgfVxcbiAgICB9O1xcbiAgfVxcblxcbiAgcmV0dXJuIHRvSGF2ZUJlZW5DYWxsZWQ7XFxufTtcXG5cXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcyA9IGZ1bmN0aW9uKGokKSB7XFxuXFxuICBmdW5jdGlvbiB0b0hhdmVCZWVuQ2FsbGVkVGltZXMoKSB7XFxuICAgIHJldHVybiB7XFxuICAgICAgY29tcGFyZTogZnVuY3Rpb24oYWN0dWFsLCBleHBlY3RlZCkge1xcbiAgICAgICAgaWYgKCFqJC5pc1NweShhY3R1YWwpKSB7XFxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgYSBzcHksIGJ1dCBnb3QgJyArIGokLnBwKGFjdHVhbCkgKyAnLicpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApLFxcbiAgICAgICAgICByZXN1bHQgPSB7IHBhc3M6IGZhbHNlIH07XFxuXFxuICAgICAgICBpZighZXhwZWN0ZWQpe1xcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRpbWVzIGZhaWxlZCBpcyByZXF1aXJlZCBhcyBhbiBhcmd1bWVudC4nKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGFjdHVhbCA9IGFyZ3NbMF07XFxuICAgICAgICB2YXIgY2FsbHMgPSBhY3R1YWwuY2FsbHMuY291bnQoKTtcXG4gICAgICAgIHZhciB0aW1lc01lc3NhZ2UgPSBleHBlY3RlZCA9PT0gMSA/ICdvbmNlJyA6IGV4cGVjdGVkICsgJyB0aW1lcyc7XFxuICAgICAgICByZXN1bHQucGFzcyA9IGNhbGxzID09PSBleHBlY3RlZDtcXG4gICAgICAgIHJlc3VsdC5tZXNzYWdlID0gcmVzdWx0LnBhc3MgP1xcbiAgICAgICAgICAnRXhwZWN0ZWQgc3B5ICcgKyBhY3R1YWwuYW5kLmlkZW50aXR5KCkgKyAnIG5vdCB0byBoYXZlIGJlZW4gY2FsbGVkICcgKyB0aW1lc01lc3NhZ2UgKyAnLiBJdCB3YXMgY2FsbGVkICcgKyAgY2FsbHMgKyAnIHRpbWVzLicgOlxcbiAgICAgICAgICAnRXhwZWN0ZWQgc3B5ICcgKyBhY3R1YWwuYW5kLmlkZW50aXR5KCkgKyAnIHRvIGhhdmUgYmVlbiBjYWxsZWQgJyArIHRpbWVzTWVzc2FnZSArICcuIEl0IHdhcyBjYWxsZWQgJyArICBjYWxscyArICcgdGltZXMuJztcXG4gICAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgICAgfVxcbiAgICB9O1xcbiAgfVxcblxcbiAgcmV0dXJuIHRvSGF2ZUJlZW5DYWxsZWRUaW1lcztcXG59O1xcblxcbmdldEphc21pbmVSZXF1aXJlT2JqKCkudG9IYXZlQmVlbkNhbGxlZFdpdGggPSBmdW5jdGlvbihqJCkge1xcblxcbiAgZnVuY3Rpb24gdG9IYXZlQmVlbkNhbGxlZFdpdGgodXRpbCwgY3VzdG9tRXF1YWxpdHlUZXN0ZXJzKSB7XFxuICAgIHJldHVybiB7XFxuICAgICAgY29tcGFyZTogZnVuY3Rpb24oKSB7XFxuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCksXFxuICAgICAgICAgIGFjdHVhbCA9IGFyZ3NbMF0sXFxuICAgICAgICAgIGV4cGVjdGVkQXJncyA9IGFyZ3Muc2xpY2UoMSksXFxuICAgICAgICAgIHJlc3VsdCA9IHsgcGFzczogZmFsc2UgfTtcXG5cXG4gICAgICAgIGlmICghaiQuaXNTcHkoYWN0dWFsKSkge1xcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGEgc3B5LCBidXQgZ290ICcgKyBqJC5wcChhY3R1YWwpICsgJy4nKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICghYWN0dWFsLmNhbGxzLmFueSgpKSB7XFxuICAgICAgICAgIHJlc3VsdC5tZXNzYWdlID0gZnVuY3Rpb24oKSB7IHJldHVybiAnRXhwZWN0ZWQgc3B5ICcgKyBhY3R1YWwuYW5kLmlkZW50aXR5KCkgKyAnIHRvIGhhdmUgYmVlbiBjYWxsZWQgd2l0aCAnICsgaiQucHAoZXhwZWN0ZWRBcmdzKSArICcgYnV0IGl0IHdhcyBuZXZlciBjYWxsZWQuJzsgfTtcXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICh1dGlsLmNvbnRhaW5zKGFjdHVhbC5jYWxscy5hbGxBcmdzKCksIGV4cGVjdGVkQXJncywgY3VzdG9tRXF1YWxpdHlUZXN0ZXJzKSkge1xcbiAgICAgICAgICByZXN1bHQucGFzcyA9IHRydWU7XFxuICAgICAgICAgIHJlc3VsdC5tZXNzYWdlID0gZnVuY3Rpb24oKSB7IHJldHVybiAnRXhwZWN0ZWQgc3B5ICcgKyBhY3R1YWwuYW5kLmlkZW50aXR5KCkgKyAnIG5vdCB0byBoYXZlIGJlZW4gY2FsbGVkIHdpdGggJyArIGokLnBwKGV4cGVjdGVkQXJncykgKyAnIGJ1dCBpdCB3YXMuJzsgfTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHJlc3VsdC5tZXNzYWdlID0gZnVuY3Rpb24oKSB7IHJldHVybiAnRXhwZWN0ZWQgc3B5ICcgKyBhY3R1YWwuYW5kLmlkZW50aXR5KCkgKyAnIHRvIGhhdmUgYmVlbiBjYWxsZWQgd2l0aCAnICsgaiQucHAoZXhwZWN0ZWRBcmdzKSArICcgYnV0IGFjdHVhbCBjYWxscyB3ZXJlICcgKyBqJC5wcChhY3R1YWwuY2FsbHMuYWxsQXJncygpKS5yZXBsYWNlKC9eXFxcXFsgfCBcXFxcXSQvZywgJycpICsgJy4nOyB9O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgICB9XFxuICAgIH07XFxuICB9XFxuXFxuICByZXR1cm4gdG9IYXZlQmVlbkNhbGxlZFdpdGg7XFxufTtcXG5cXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvTWF0Y2ggPSBmdW5jdGlvbihqJCkge1xcblxcbiAgZnVuY3Rpb24gdG9NYXRjaCgpIHtcXG4gICAgcmV0dXJuIHtcXG4gICAgICBjb21wYXJlOiBmdW5jdGlvbihhY3R1YWwsIGV4cGVjdGVkKSB7XFxuICAgICAgICBpZiAoIWokLmlzU3RyaW5nXyhleHBlY3RlZCkgJiYgIWokLmlzQV8oJ1JlZ0V4cCcsIGV4cGVjdGVkKSkge1xcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGlzIG5vdCBhIFN0cmluZyBvciBhIFJlZ0V4cCcpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdmFyIHJlZ2V4cCA9IG5ldyBSZWdFeHAoZXhwZWN0ZWQpO1xcblxcbiAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgcGFzczogcmVnZXhwLnRlc3QoYWN0dWFsKVxcbiAgICAgICAgfTtcXG4gICAgICB9XFxuICAgIH07XFxuICB9XFxuXFxuICByZXR1cm4gdG9NYXRjaDtcXG59O1xcblxcbmdldEphc21pbmVSZXF1aXJlT2JqKCkudG9UaHJvdyA9IGZ1bmN0aW9uKGokKSB7XFxuXFxuICBmdW5jdGlvbiB0b1Rocm93KHV0aWwpIHtcXG4gICAgcmV0dXJuIHtcXG4gICAgICBjb21wYXJlOiBmdW5jdGlvbihhY3R1YWwsIGV4cGVjdGVkKSB7XFxuICAgICAgICB2YXIgcmVzdWx0ID0geyBwYXNzOiBmYWxzZSB9LFxcbiAgICAgICAgICB0aHJldyA9IGZhbHNlLFxcbiAgICAgICAgICB0aHJvd247XFxuXFxuICAgICAgICBpZiAodHlwZW9mIGFjdHVhbCAhPSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQWN0dWFsIGlzIG5vdCBhIEZ1bmN0aW9uJyk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICBhY3R1YWwoKTtcXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgICAgdGhyZXcgPSB0cnVlO1xcbiAgICAgICAgICB0aHJvd24gPSBlO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKCF0aHJldykge1xcbiAgICAgICAgICByZXN1bHQubWVzc2FnZSA9ICdFeHBlY3RlZCBmdW5jdGlvbiB0byB0aHJvdyBhbiBleGNlcHRpb24uJztcXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEpIHtcXG4gICAgICAgICAgcmVzdWx0LnBhc3MgPSB0cnVlO1xcbiAgICAgICAgICByZXN1bHQubWVzc2FnZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gJ0V4cGVjdGVkIGZ1bmN0aW9uIG5vdCB0byB0aHJvdywgYnV0IGl0IHRocmV3ICcgKyBqJC5wcCh0aHJvd24pICsgJy4nOyB9O1xcblxcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKHV0aWwuZXF1YWxzKHRocm93biwgZXhwZWN0ZWQpKSB7XFxuICAgICAgICAgIHJlc3VsdC5wYXNzID0gdHJ1ZTtcXG4gICAgICAgICAgcmVzdWx0Lm1lc3NhZ2UgPSBmdW5jdGlvbigpIHsgcmV0dXJuICdFeHBlY3RlZCBmdW5jdGlvbiBub3QgdG8gdGhyb3cgJyArIGokLnBwKGV4cGVjdGVkKSArICcuJzsgfTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHJlc3VsdC5tZXNzYWdlID0gZnVuY3Rpb24oKSB7IHJldHVybiAnRXhwZWN0ZWQgZnVuY3Rpb24gdG8gdGhyb3cgJyArIGokLnBwKGV4cGVjdGVkKSArICcsIGJ1dCBpdCB0aHJldyAnICsgIGokLnBwKHRocm93bikgKyAnLic7IH07XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICAgIH1cXG4gICAgfTtcXG4gIH1cXG5cXG4gIHJldHVybiB0b1Rocm93O1xcbn07XFxuXFxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS50b1Rocm93RXJyb3IgPSBmdW5jdGlvbihqJCkge1xcbiAgZnVuY3Rpb24gdG9UaHJvd0Vycm9yICgpIHtcXG4gICAgcmV0dXJuIHtcXG4gICAgICBjb21wYXJlOiBmdW5jdGlvbihhY3R1YWwpIHtcXG4gICAgICAgIHZhciB0aHJldyA9IGZhbHNlLFxcbiAgICAgICAgICBwYXNzID0ge3Bhc3M6IHRydWV9LFxcbiAgICAgICAgICBmYWlsID0ge3Bhc3M6IGZhbHNlfSxcXG4gICAgICAgICAgdGhyb3duO1xcblxcbiAgICAgICAgaWYgKHR5cGVvZiBhY3R1YWwgIT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjdHVhbCBpcyBub3QgYSBGdW5jdGlvbicpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdmFyIGVycm9yTWF0Y2hlciA9IGdldE1hdGNoZXIuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcXG5cXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgIGFjdHVhbCgpO1xcbiAgICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgICB0aHJldyA9IHRydWU7XFxuICAgICAgICAgIHRocm93biA9IGU7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoIXRocmV3KSB7XFxuICAgICAgICAgIGZhaWwubWVzc2FnZSA9ICdFeHBlY3RlZCBmdW5jdGlvbiB0byB0aHJvdyBhbiBFcnJvci4nO1xcbiAgICAgICAgICByZXR1cm4gZmFpbDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICghKHRocm93biBpbnN0YW5jZW9mIEVycm9yKSkge1xcbiAgICAgICAgICBmYWlsLm1lc3NhZ2UgPSBmdW5jdGlvbigpIHsgcmV0dXJuICdFeHBlY3RlZCBmdW5jdGlvbiB0byB0aHJvdyBhbiBFcnJvciwgYnV0IGl0IHRocmV3ICcgKyBqJC5wcCh0aHJvd24pICsgJy4nOyB9O1xcbiAgICAgICAgICByZXR1cm4gZmFpbDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChlcnJvck1hdGNoZXIuaGFzTm9TcGVjaWZpY3MoKSkge1xcbiAgICAgICAgICBwYXNzLm1lc3NhZ2UgPSAnRXhwZWN0ZWQgZnVuY3Rpb24gbm90IHRvIHRocm93IGFuIEVycm9yLCBidXQgaXQgdGhyZXcgJyArIGokLmZuTmFtZUZvcih0aHJvd24pICsgJy4nO1xcbiAgICAgICAgICByZXR1cm4gcGFzcztcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChlcnJvck1hdGNoZXIubWF0Y2hlcyh0aHJvd24pKSB7XFxuICAgICAgICAgIHBhc3MubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgICAgIHJldHVybiAnRXhwZWN0ZWQgZnVuY3Rpb24gbm90IHRvIHRocm93ICcgKyBlcnJvck1hdGNoZXIuZXJyb3JUeXBlRGVzY3JpcHRpb24gKyBlcnJvck1hdGNoZXIubWVzc2FnZURlc2NyaXB0aW9uKCkgKyAnLic7XFxuICAgICAgICAgIH07XFxuICAgICAgICAgIHJldHVybiBwYXNzO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgZmFpbC5tZXNzYWdlID0gZnVuY3Rpb24oKSB7XFxuICAgICAgICAgICAgcmV0dXJuICdFeHBlY3RlZCBmdW5jdGlvbiB0byB0aHJvdyAnICsgZXJyb3JNYXRjaGVyLmVycm9yVHlwZURlc2NyaXB0aW9uICsgZXJyb3JNYXRjaGVyLm1lc3NhZ2VEZXNjcmlwdGlvbigpICtcXG4gICAgICAgICAgICAgICcsIGJ1dCBpdCB0aHJldyAnICsgZXJyb3JNYXRjaGVyLnRocm93bkRlc2NyaXB0aW9uKHRocm93bikgKyAnLic7XFxuICAgICAgICAgIH07XFxuICAgICAgICAgIHJldHVybiBmYWlsO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfTtcXG5cXG4gICAgZnVuY3Rpb24gZ2V0TWF0Y2hlcigpIHtcXG4gICAgICB2YXIgZXhwZWN0ZWQgPSBudWxsLFxcbiAgICAgICAgICBlcnJvclR5cGUgPSBudWxsO1xcblxcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDIpIHtcXG4gICAgICAgIGV4cGVjdGVkID0gYXJndW1lbnRzWzFdO1xcbiAgICAgICAgaWYgKGlzQW5FcnJvclR5cGUoZXhwZWN0ZWQpKSB7XFxuICAgICAgICAgIGVycm9yVHlwZSA9IGV4cGVjdGVkO1xcbiAgICAgICAgICBleHBlY3RlZCA9IG51bGw7XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xcbiAgICAgICAgZXJyb3JUeXBlID0gYXJndW1lbnRzWzFdO1xcbiAgICAgICAgZXhwZWN0ZWQgPSBhcmd1bWVudHNbMl07XFxuICAgICAgICBpZiAoIWlzQW5FcnJvclR5cGUoZXJyb3JUeXBlKSkge1xcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGVycm9yIHR5cGUgaXMgbm90IGFuIEVycm9yLicpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoZXhwZWN0ZWQgJiYgIWlzU3RyaW5nT3JSZWdFeHAoZXhwZWN0ZWQpKSB7XFxuICAgICAgICBpZiAoZXJyb3JUeXBlKSB7XFxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgZXJyb3IgbWVzc2FnZSBpcyBub3QgYSBzdHJpbmcgb3IgUmVnRXhwLicpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBpcyBub3QgYW4gRXJyb3IsIHN0cmluZywgb3IgUmVnRXhwLicpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBmdW5jdGlvbiBtZXNzYWdlTWF0Y2gobWVzc2FnZSkge1xcbiAgICAgICAgaWYgKHR5cGVvZiBleHBlY3RlZCA9PSAnc3RyaW5nJykge1xcbiAgICAgICAgICByZXR1cm4gZXhwZWN0ZWQgPT0gbWVzc2FnZTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHJldHVybiBleHBlY3RlZC50ZXN0KG1lc3NhZ2UpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4ge1xcbiAgICAgICAgZXJyb3JUeXBlRGVzY3JpcHRpb246IGVycm9yVHlwZSA/IGokLmZuTmFtZUZvcihlcnJvclR5cGUpIDogJ2FuIGV4Y2VwdGlvbicsXFxuICAgICAgICB0aHJvd25EZXNjcmlwdGlvbjogZnVuY3Rpb24odGhyb3duKSB7XFxuICAgICAgICAgIHZhciB0aHJvd25OYW1lID0gZXJyb3JUeXBlID8gaiQuZm5OYW1lRm9yKHRocm93bi5jb25zdHJ1Y3RvcikgOiAnYW4gZXhjZXB0aW9uJyxcXG4gICAgICAgICAgICAgIHRocm93bk1lc3NhZ2UgPSAnJztcXG5cXG4gICAgICAgICAgaWYgKGV4cGVjdGVkKSB7XFxuICAgICAgICAgICAgdGhyb3duTWVzc2FnZSA9ICcgd2l0aCBtZXNzYWdlICcgKyBqJC5wcCh0aHJvd24ubWVzc2FnZSk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgcmV0dXJuIHRocm93bk5hbWUgKyB0aHJvd25NZXNzYWdlO1xcbiAgICAgICAgfSxcXG4gICAgICAgIG1lc3NhZ2VEZXNjcmlwdGlvbjogZnVuY3Rpb24oKSB7XFxuICAgICAgICAgIGlmIChleHBlY3RlZCA9PT0gbnVsbCkge1xcbiAgICAgICAgICAgIHJldHVybiAnJztcXG4gICAgICAgICAgfSBlbHNlIGlmIChleHBlY3RlZCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xcbiAgICAgICAgICAgIHJldHVybiAnIHdpdGggYSBtZXNzYWdlIG1hdGNoaW5nICcgKyBqJC5wcChleHBlY3RlZCk7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgcmV0dXJuICcgd2l0aCBtZXNzYWdlICcgKyBqJC5wcChleHBlY3RlZCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuICAgICAgICBoYXNOb1NwZWNpZmljczogZnVuY3Rpb24oKSB7XFxuICAgICAgICAgIHJldHVybiBleHBlY3RlZCA9PT0gbnVsbCAmJiBlcnJvclR5cGUgPT09IG51bGw7XFxuICAgICAgICB9LFxcbiAgICAgICAgbWF0Y2hlczogZnVuY3Rpb24oZXJyb3IpIHtcXG4gICAgICAgICAgcmV0dXJuIChlcnJvclR5cGUgPT09IG51bGwgfHwgZXJyb3IgaW5zdGFuY2VvZiBlcnJvclR5cGUpICYmXFxuICAgICAgICAgICAgKGV4cGVjdGVkID09PSBudWxsIHx8IG1lc3NhZ2VNYXRjaChlcnJvci5tZXNzYWdlKSk7XFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBpc1N0cmluZ09yUmVnRXhwKHBvdGVudGlhbCkge1xcbiAgICAgIHJldHVybiBwb3RlbnRpYWwgaW5zdGFuY2VvZiBSZWdFeHAgfHwgKHR5cGVvZiBwb3RlbnRpYWwgPT0gJ3N0cmluZycpO1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIGlzQW5FcnJvclR5cGUodHlwZSkge1xcbiAgICAgIGlmICh0eXBlb2YgdHlwZSAhPT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgU3Vycm9nYXRlID0gZnVuY3Rpb24oKSB7fTtcXG4gICAgICBTdXJyb2dhdGUucHJvdG90eXBlID0gdHlwZS5wcm90b3R5cGU7XFxuICAgICAgcmV0dXJuIChuZXcgU3Vycm9nYXRlKCkpIGluc3RhbmNlb2YgRXJyb3I7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiB0b1Rocm93RXJyb3I7XFxufTtcXG5cXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLmludGVyZmFjZSA9IGZ1bmN0aW9uKGphc21pbmUsIGVudikge1xcbiAgdmFyIGphc21pbmVJbnRlcmZhY2UgPSB7XFxuICAgIGRlc2NyaWJlOiBmdW5jdGlvbihkZXNjcmlwdGlvbiwgc3BlY0RlZmluaXRpb25zKSB7XFxuICAgICAgcmV0dXJuIGVudi5kZXNjcmliZShkZXNjcmlwdGlvbiwgc3BlY0RlZmluaXRpb25zKTtcXG4gICAgfSxcXG5cXG4gICAgeGRlc2NyaWJlOiBmdW5jdGlvbihkZXNjcmlwdGlvbiwgc3BlY0RlZmluaXRpb25zKSB7XFxuICAgICAgcmV0dXJuIGVudi54ZGVzY3JpYmUoZGVzY3JpcHRpb24sIHNwZWNEZWZpbml0aW9ucyk7XFxuICAgIH0sXFxuXFxuICAgIGZkZXNjcmliZTogZnVuY3Rpb24oZGVzY3JpcHRpb24sIHNwZWNEZWZpbml0aW9ucykge1xcbiAgICAgIHJldHVybiBlbnYuZmRlc2NyaWJlKGRlc2NyaXB0aW9uLCBzcGVjRGVmaW5pdGlvbnMpO1xcbiAgICB9LFxcblxcbiAgICBpdDogZnVuY3Rpb24oKSB7XFxuICAgICAgcmV0dXJuIGVudi5pdC5hcHBseShlbnYsIGFyZ3VtZW50cyk7XFxuICAgIH0sXFxuXFxuICAgIHhpdDogZnVuY3Rpb24oKSB7XFxuICAgICAgcmV0dXJuIGVudi54aXQuYXBwbHkoZW52LCBhcmd1bWVudHMpO1xcbiAgICB9LFxcblxcbiAgICBmaXQ6IGZ1bmN0aW9uKCkge1xcbiAgICAgIHJldHVybiBlbnYuZml0LmFwcGx5KGVudiwgYXJndW1lbnRzKTtcXG4gICAgfSxcXG5cXG4gICAgYmVmb3JlRWFjaDogZnVuY3Rpb24oKSB7XFxuICAgICAgcmV0dXJuIGVudi5iZWZvcmVFYWNoLmFwcGx5KGVudiwgYXJndW1lbnRzKTtcXG4gICAgfSxcXG5cXG4gICAgYWZ0ZXJFYWNoOiBmdW5jdGlvbigpIHtcXG4gICAgICByZXR1cm4gZW52LmFmdGVyRWFjaC5hcHBseShlbnYsIGFyZ3VtZW50cyk7XFxuICAgIH0sXFxuXFxuICAgIGJlZm9yZUFsbDogZnVuY3Rpb24oKSB7XFxuICAgICAgcmV0dXJuIGVudi5iZWZvcmVBbGwuYXBwbHkoZW52LCBhcmd1bWVudHMpO1xcbiAgICB9LFxcblxcbiAgICBhZnRlckFsbDogZnVuY3Rpb24oKSB7XFxuICAgICAgcmV0dXJuIGVudi5hZnRlckFsbC5hcHBseShlbnYsIGFyZ3VtZW50cyk7XFxuICAgIH0sXFxuXFxuICAgIGV4cGVjdDogZnVuY3Rpb24oYWN0dWFsKSB7XFxuICAgICAgcmV0dXJuIGVudi5leHBlY3QoYWN0dWFsKTtcXG4gICAgfSxcXG5cXG4gICAgcGVuZGluZzogZnVuY3Rpb24oKSB7XFxuICAgICAgcmV0dXJuIGVudi5wZW5kaW5nLmFwcGx5KGVudiwgYXJndW1lbnRzKTtcXG4gICAgfSxcXG5cXG4gICAgZmFpbDogZnVuY3Rpb24oKSB7XFxuICAgICAgcmV0dXJuIGVudi5mYWlsLmFwcGx5KGVudiwgYXJndW1lbnRzKTtcXG4gICAgfSxcXG5cXG4gICAgc3B5T246IGZ1bmN0aW9uKG9iaiwgbWV0aG9kTmFtZSkge1xcbiAgICAgIHJldHVybiBlbnYuc3B5T24ob2JqLCBtZXRob2ROYW1lKTtcXG4gICAgfSxcXG5cXG4gICAganNBcGlSZXBvcnRlcjogbmV3IGphc21pbmUuSnNBcGlSZXBvcnRlcih7XFxuICAgICAgdGltZXI6IG5ldyBqYXNtaW5lLlRpbWVyKClcXG4gICAgfSksXFxuXFxuICAgIGphc21pbmU6IGphc21pbmVcXG4gIH07XFxuXFxuICBqYXNtaW5lLmFkZEN1c3RvbUVxdWFsaXR5VGVzdGVyID0gZnVuY3Rpb24odGVzdGVyKSB7XFxuICAgIGVudi5hZGRDdXN0b21FcXVhbGl0eVRlc3Rlcih0ZXN0ZXIpO1xcbiAgfTtcXG5cXG4gIGphc21pbmUuYWRkTWF0Y2hlcnMgPSBmdW5jdGlvbihtYXRjaGVycykge1xcbiAgICByZXR1cm4gZW52LmFkZE1hdGNoZXJzKG1hdGNoZXJzKTtcXG4gIH07XFxuXFxuICBqYXNtaW5lLmNsb2NrID0gZnVuY3Rpb24oKSB7XFxuICAgIHJldHVybiBlbnYuY2xvY2s7XFxuICB9O1xcblxcbiAgcmV0dXJuIGphc21pbmVJbnRlcmZhY2U7XFxufTtcXG5cXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnZlcnNpb24gPSBmdW5jdGlvbigpIHtcXG4gIHJldHVybiAnMi40LjEnO1xcbn07XFxuXCJcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9saWIvamFzbWluZS0yLjQuMS9qYXNtaW5lLmpzXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIi8qXFxuQ29weXJpZ2h0IChjKSAyMDA4LTIwMTUgUGl2b3RhbCBMYWJzXFxuXFxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nXFxuYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXFxuXFxcIlNvZnR3YXJlXFxcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xcbndpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcXG5kaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cXG5wZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG9cXG50aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XFxuXFxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcXG5pbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cXG5cXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXFxcIkFTIElTXFxcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcXG5FWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcXG5NRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxcbk5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkVcXG5MSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OXFxuT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXFxuV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXFxuKi9cXG5qYXNtaW5lUmVxdWlyZS5odG1sID0gZnVuY3Rpb24oaiQpIHtcXG4gIGokLlJlc3VsdHNOb2RlID0gamFzbWluZVJlcXVpcmUuUmVzdWx0c05vZGUoKTtcXG4gIGokLkh0bWxSZXBvcnRlciA9IGphc21pbmVSZXF1aXJlLkh0bWxSZXBvcnRlcihqJCk7XFxuICBqJC5RdWVyeVN0cmluZyA9IGphc21pbmVSZXF1aXJlLlF1ZXJ5U3RyaW5nKCk7XFxuICBqJC5IdG1sU3BlY0ZpbHRlciA9IGphc21pbmVSZXF1aXJlLkh0bWxTcGVjRmlsdGVyKCk7XFxufTtcXG5cXG5qYXNtaW5lUmVxdWlyZS5IdG1sUmVwb3J0ZXIgPSBmdW5jdGlvbihqJCkge1xcblxcbiAgdmFyIG5vb3BUaW1lciA9IHtcXG4gICAgc3RhcnQ6IGZ1bmN0aW9uKCkge30sXFxuICAgIGVsYXBzZWQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfVxcbiAgfTtcXG5cXG4gIGZ1bmN0aW9uIEh0bWxSZXBvcnRlcihvcHRpb25zKSB7XFxuICAgIHZhciBlbnYgPSBvcHRpb25zLmVudiB8fCB7fSxcXG4gICAgICBnZXRDb250YWluZXIgPSBvcHRpb25zLmdldENvbnRhaW5lcixcXG4gICAgICBjcmVhdGVFbGVtZW50ID0gb3B0aW9ucy5jcmVhdGVFbGVtZW50LFxcbiAgICAgIGNyZWF0ZVRleHROb2RlID0gb3B0aW9ucy5jcmVhdGVUZXh0Tm9kZSxcXG4gICAgICBvblJhaXNlRXhjZXB0aW9uc0NsaWNrID0gb3B0aW9ucy5vblJhaXNlRXhjZXB0aW9uc0NsaWNrIHx8IGZ1bmN0aW9uKCkge30sXFxuICAgICAgb25UaHJvd0V4cGVjdGF0aW9uc0NsaWNrID0gb3B0aW9ucy5vblRocm93RXhwZWN0YXRpb25zQ2xpY2sgfHwgZnVuY3Rpb24oKSB7fSxcXG4gICAgICBvblJhbmRvbUNsaWNrID0gb3B0aW9ucy5vblJhbmRvbUNsaWNrIHx8IGZ1bmN0aW9uKCkge30sXFxuICAgICAgYWRkVG9FeGlzdGluZ1F1ZXJ5U3RyaW5nID0gb3B0aW9ucy5hZGRUb0V4aXN0aW5nUXVlcnlTdHJpbmcgfHwgZGVmYXVsdFF1ZXJ5U3RyaW5nLFxcbiAgICAgIHRpbWVyID0gb3B0aW9ucy50aW1lciB8fCBub29wVGltZXIsXFxuICAgICAgcmVzdWx0cyA9IFtdLFxcbiAgICAgIHNwZWNzRXhlY3V0ZWQgPSAwLFxcbiAgICAgIGZhaWx1cmVDb3VudCA9IDAsXFxuICAgICAgcGVuZGluZ1NwZWNDb3VudCA9IDAsXFxuICAgICAgaHRtbFJlcG9ydGVyTWFpbixcXG4gICAgICBzeW1ib2xzLFxcbiAgICAgIGZhaWxlZFN1aXRlcyA9IFtdO1xcblxcbiAgICB0aGlzLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHtcXG4gICAgICBjbGVhclByaW9yKCk7XFxuICAgICAgaHRtbFJlcG9ydGVyTWFpbiA9IGNyZWF0ZURvbSgnZGl2Jywge2NsYXNzTmFtZTogJ2phc21pbmVfaHRtbC1yZXBvcnRlcid9LFxcbiAgICAgICAgY3JlYXRlRG9tKCdkaXYnLCB7Y2xhc3NOYW1lOiAnamFzbWluZS1iYW5uZXInfSxcXG4gICAgICAgICAgY3JlYXRlRG9tKCdhJywge2NsYXNzTmFtZTogJ2phc21pbmUtdGl0bGUnLCBocmVmOiAnaHR0cDovL2phc21pbmUuZ2l0aHViLmlvLycsIHRhcmdldDogJ19ibGFuayd9KSxcXG4gICAgICAgICAgY3JlYXRlRG9tKCdzcGFuJywge2NsYXNzTmFtZTogJ2phc21pbmUtdmVyc2lvbid9LCBqJC52ZXJzaW9uKVxcbiAgICAgICAgKSxcXG4gICAgICAgIGNyZWF0ZURvbSgndWwnLCB7Y2xhc3NOYW1lOiAnamFzbWluZS1zeW1ib2wtc3VtbWFyeSd9KSxcXG4gICAgICAgIGNyZWF0ZURvbSgnZGl2Jywge2NsYXNzTmFtZTogJ2phc21pbmUtYWxlcnQnfSksXFxuICAgICAgICBjcmVhdGVEb20oJ2RpdicsIHtjbGFzc05hbWU6ICdqYXNtaW5lLXJlc3VsdHMnfSxcXG4gICAgICAgICAgY3JlYXRlRG9tKCdkaXYnLCB7Y2xhc3NOYW1lOiAnamFzbWluZS1mYWlsdXJlcyd9KVxcbiAgICAgICAgKVxcbiAgICAgICk7XFxuICAgICAgZ2V0Q29udGFpbmVyKCkuYXBwZW5kQ2hpbGQoaHRtbFJlcG9ydGVyTWFpbik7XFxuICAgIH07XFxuXFxuICAgIHZhciB0b3RhbFNwZWNzRGVmaW5lZDtcXG4gICAgdGhpcy5qYXNtaW5lU3RhcnRlZCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcXG4gICAgICB0b3RhbFNwZWNzRGVmaW5lZCA9IG9wdGlvbnMudG90YWxTcGVjc0RlZmluZWQgfHwgMDtcXG4gICAgICB0aW1lci5zdGFydCgpO1xcbiAgICB9O1xcblxcbiAgICB2YXIgc3VtbWFyeSA9IGNyZWF0ZURvbSgnZGl2Jywge2NsYXNzTmFtZTogJ2phc21pbmUtc3VtbWFyeSd9KTtcXG5cXG4gICAgdmFyIHRvcFJlc3VsdHMgPSBuZXcgaiQuUmVzdWx0c05vZGUoe30sICcnLCBudWxsKSxcXG4gICAgICBjdXJyZW50UGFyZW50ID0gdG9wUmVzdWx0cztcXG5cXG4gICAgdGhpcy5zdWl0ZVN0YXJ0ZWQgPSBmdW5jdGlvbihyZXN1bHQpIHtcXG4gICAgICBjdXJyZW50UGFyZW50LmFkZENoaWxkKHJlc3VsdCwgJ3N1aXRlJyk7XFxuICAgICAgY3VycmVudFBhcmVudCA9IGN1cnJlbnRQYXJlbnQubGFzdCgpO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLnN1aXRlRG9uZSA9IGZ1bmN0aW9uKHJlc3VsdCkge1xcbiAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09ICdmYWlsZWQnKSB7XFxuICAgICAgICBmYWlsZWRTdWl0ZXMucHVzaChyZXN1bHQpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoY3VycmVudFBhcmVudCA9PSB0b3BSZXN1bHRzKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGN1cnJlbnRQYXJlbnQgPSBjdXJyZW50UGFyZW50LnBhcmVudDtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5zcGVjU3RhcnRlZCA9IGZ1bmN0aW9uKHJlc3VsdCkge1xcbiAgICAgIGN1cnJlbnRQYXJlbnQuYWRkQ2hpbGQocmVzdWx0LCAnc3BlYycpO1xcbiAgICB9O1xcblxcbiAgICB2YXIgZmFpbHVyZXMgPSBbXTtcXG4gICAgdGhpcy5zcGVjRG9uZSA9IGZ1bmN0aW9uKHJlc3VsdCkge1xcbiAgICAgIGlmKG5vRXhwZWN0YXRpb25zKHJlc3VsdCkgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjb25zb2xlLmVycm9yICE9PSAndW5kZWZpbmVkJykge1xcbiAgICAgICAgY29uc29sZS5lcnJvcignU3BlYyBcXFxcJycgKyByZXN1bHQuZnVsbE5hbWUgKyAnXFxcXCcgaGFzIG5vIGV4cGVjdGF0aW9ucy4nKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgIT0gJ2Rpc2FibGVkJykge1xcbiAgICAgICAgc3BlY3NFeGVjdXRlZCsrO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIXN5bWJvbHMpe1xcbiAgICAgICAgc3ltYm9scyA9IGZpbmQoJy5qYXNtaW5lLXN5bWJvbC1zdW1tYXJ5Jyk7XFxuICAgICAgfVxcblxcbiAgICAgIHN5bWJvbHMuYXBwZW5kQ2hpbGQoY3JlYXRlRG9tKCdsaScsIHtcXG4gICAgICAgICAgY2xhc3NOYW1lOiBub0V4cGVjdGF0aW9ucyhyZXN1bHQpID8gJ2phc21pbmUtZW1wdHknIDogJ2phc21pbmUtJyArIHJlc3VsdC5zdGF0dXMsXFxuICAgICAgICAgIGlkOiAnc3BlY18nICsgcmVzdWx0LmlkLFxcbiAgICAgICAgICB0aXRsZTogcmVzdWx0LmZ1bGxOYW1lXFxuICAgICAgICB9XFxuICAgICAgKSk7XFxuXFxuICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT0gJ2ZhaWxlZCcpIHtcXG4gICAgICAgIGZhaWx1cmVDb3VudCsrO1xcblxcbiAgICAgICAgdmFyIGZhaWx1cmUgPVxcbiAgICAgICAgICBjcmVhdGVEb20oJ2RpdicsIHtjbGFzc05hbWU6ICdqYXNtaW5lLXNwZWMtZGV0YWlsIGphc21pbmUtZmFpbGVkJ30sXFxuICAgICAgICAgICAgY3JlYXRlRG9tKCdkaXYnLCB7Y2xhc3NOYW1lOiAnamFzbWluZS1kZXNjcmlwdGlvbid9LFxcbiAgICAgICAgICAgICAgY3JlYXRlRG9tKCdhJywge3RpdGxlOiByZXN1bHQuZnVsbE5hbWUsIGhyZWY6IHNwZWNIcmVmKHJlc3VsdCl9LCByZXN1bHQuZnVsbE5hbWUpXFxuICAgICAgICAgICAgKSxcXG4gICAgICAgICAgICBjcmVhdGVEb20oJ2RpdicsIHtjbGFzc05hbWU6ICdqYXNtaW5lLW1lc3NhZ2VzJ30pXFxuICAgICAgICAgICk7XFxuICAgICAgICB2YXIgbWVzc2FnZXMgPSBmYWlsdXJlLmNoaWxkTm9kZXNbMV07XFxuXFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdC5mYWlsZWRFeHBlY3RhdGlvbnMubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgdmFyIGV4cGVjdGF0aW9uID0gcmVzdWx0LmZhaWxlZEV4cGVjdGF0aW9uc1tpXTtcXG4gICAgICAgICAgbWVzc2FnZXMuYXBwZW5kQ2hpbGQoY3JlYXRlRG9tKCdkaXYnLCB7Y2xhc3NOYW1lOiAnamFzbWluZS1yZXN1bHQtbWVzc2FnZSd9LCBleHBlY3RhdGlvbi5tZXNzYWdlKSk7XFxuICAgICAgICAgIG1lc3NhZ2VzLmFwcGVuZENoaWxkKGNyZWF0ZURvbSgnZGl2Jywge2NsYXNzTmFtZTogJ2phc21pbmUtc3RhY2stdHJhY2UnfSwgZXhwZWN0YXRpb24uc3RhY2spKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGZhaWx1cmVzLnB1c2goZmFpbHVyZSk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09ICdwZW5kaW5nJykge1xcbiAgICAgICAgcGVuZGluZ1NwZWNDb3VudCsrO1xcbiAgICAgIH1cXG4gICAgfTtcXG5cXG4gICAgdGhpcy5qYXNtaW5lRG9uZSA9IGZ1bmN0aW9uKGRvbmVSZXN1bHQpIHtcXG4gICAgICB2YXIgYmFubmVyID0gZmluZCgnLmphc21pbmUtYmFubmVyJyk7XFxuICAgICAgdmFyIGFsZXJ0ID0gZmluZCgnLmphc21pbmUtYWxlcnQnKTtcXG4gICAgICB2YXIgb3JkZXIgPSBkb25lUmVzdWx0ICYmIGRvbmVSZXN1bHQub3JkZXI7XFxuICAgICAgYWxlcnQuYXBwZW5kQ2hpbGQoY3JlYXRlRG9tKCdzcGFuJywge2NsYXNzTmFtZTogJ2phc21pbmUtZHVyYXRpb24nfSwgJ2ZpbmlzaGVkIGluICcgKyB0aW1lci5lbGFwc2VkKCkgLyAxMDAwICsgJ3MnKSk7XFxuXFxuICAgICAgYmFubmVyLmFwcGVuZENoaWxkKFxcbiAgICAgICAgY3JlYXRlRG9tKCdkaXYnLCB7IGNsYXNzTmFtZTogJ2phc21pbmUtcnVuLW9wdGlvbnMnIH0sXFxuICAgICAgICAgIGNyZWF0ZURvbSgnc3BhbicsIHsgY2xhc3NOYW1lOiAnamFzbWluZS10cmlnZ2VyJyB9LCAnT3B0aW9ucycpLFxcbiAgICAgICAgICBjcmVhdGVEb20oJ2RpdicsIHsgY2xhc3NOYW1lOiAnamFzbWluZS1wYXlsb2FkJyB9LFxcbiAgICAgICAgICAgIGNyZWF0ZURvbSgnZGl2JywgeyBjbGFzc05hbWU6ICdqYXNtaW5lLWV4Y2VwdGlvbnMnIH0sXFxuICAgICAgICAgICAgICBjcmVhdGVEb20oJ2lucHV0Jywge1xcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdqYXNtaW5lLXJhaXNlJyxcXG4gICAgICAgICAgICAgICAgaWQ6ICdqYXNtaW5lLXJhaXNlLWV4Y2VwdGlvbnMnLFxcbiAgICAgICAgICAgICAgICB0eXBlOiAnY2hlY2tib3gnXFxuICAgICAgICAgICAgICB9KSxcXG4gICAgICAgICAgICAgIGNyZWF0ZURvbSgnbGFiZWwnLCB7IGNsYXNzTmFtZTogJ2phc21pbmUtbGFiZWwnLCAnZm9yJzogJ2phc21pbmUtcmFpc2UtZXhjZXB0aW9ucycgfSwgJ3JhaXNlIGV4Y2VwdGlvbnMnKSksXFxuICAgICAgICAgICAgY3JlYXRlRG9tKCdkaXYnLCB7IGNsYXNzTmFtZTogJ2phc21pbmUtdGhyb3ctZmFpbHVyZXMnIH0sXFxuICAgICAgICAgICAgICBjcmVhdGVEb20oJ2lucHV0Jywge1xcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdqYXNtaW5lLXRocm93JyxcXG4gICAgICAgICAgICAgICAgaWQ6ICdqYXNtaW5lLXRocm93LWZhaWx1cmVzJyxcXG4gICAgICAgICAgICAgICAgdHlwZTogJ2NoZWNrYm94J1xcbiAgICAgICAgICAgICAgfSksXFxuICAgICAgICAgICAgICBjcmVhdGVEb20oJ2xhYmVsJywgeyBjbGFzc05hbWU6ICdqYXNtaW5lLWxhYmVsJywgJ2Zvcic6ICdqYXNtaW5lLXRocm93LWZhaWx1cmVzJyB9LCAnc3RvcCBzcGVjIG9uIGV4cGVjdGF0aW9uIGZhaWx1cmUnKSksXFxuICAgICAgICAgICAgY3JlYXRlRG9tKCdkaXYnLCB7IGNsYXNzTmFtZTogJ2phc21pbmUtcmFuZG9tLW9yZGVyJyB9LFxcbiAgICAgICAgICAgICAgY3JlYXRlRG9tKCdpbnB1dCcsIHtcXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnamFzbWluZS1yYW5kb20nLFxcbiAgICAgICAgICAgICAgICBpZDogJ2phc21pbmUtcmFuZG9tLW9yZGVyJyxcXG4gICAgICAgICAgICAgICAgdHlwZTogJ2NoZWNrYm94J1xcbiAgICAgICAgICAgICAgfSksXFxuICAgICAgICAgICAgICBjcmVhdGVEb20oJ2xhYmVsJywgeyBjbGFzc05hbWU6ICdqYXNtaW5lLWxhYmVsJywgJ2Zvcic6ICdqYXNtaW5lLXJhbmRvbS1vcmRlcicgfSwgJ3J1biB0ZXN0cyBpbiByYW5kb20gb3JkZXInKSlcXG4gICAgICAgICAgKVxcbiAgICAgICAgKSk7XFxuXFxuICAgICAgdmFyIHJhaXNlQ2hlY2tib3ggPSBmaW5kKCcjamFzbWluZS1yYWlzZS1leGNlcHRpb25zJyk7XFxuXFxuICAgICAgcmFpc2VDaGVja2JveC5jaGVja2VkID0gIWVudi5jYXRjaGluZ0V4Y2VwdGlvbnMoKTtcXG4gICAgICByYWlzZUNoZWNrYm94Lm9uY2xpY2sgPSBvblJhaXNlRXhjZXB0aW9uc0NsaWNrO1xcblxcbiAgICAgIHZhciB0aHJvd0NoZWNrYm94ID0gZmluZCgnI2phc21pbmUtdGhyb3ctZmFpbHVyZXMnKTtcXG4gICAgICB0aHJvd0NoZWNrYm94LmNoZWNrZWQgPSBlbnYudGhyb3dpbmdFeHBlY3RhdGlvbkZhaWx1cmVzKCk7XFxuICAgICAgdGhyb3dDaGVja2JveC5vbmNsaWNrID0gb25UaHJvd0V4cGVjdGF0aW9uc0NsaWNrO1xcblxcbiAgICAgIHZhciByYW5kb21DaGVja2JveCA9IGZpbmQoJyNqYXNtaW5lLXJhbmRvbS1vcmRlcicpO1xcbiAgICAgIHJhbmRvbUNoZWNrYm94LmNoZWNrZWQgPSBlbnYucmFuZG9tVGVzdHMoKTtcXG4gICAgICByYW5kb21DaGVja2JveC5vbmNsaWNrID0gb25SYW5kb21DbGljaztcXG5cXG4gICAgICB2YXIgb3B0aW9uc01lbnUgPSBmaW5kKCcuamFzbWluZS1ydW4tb3B0aW9ucycpLFxcbiAgICAgICAgICBvcHRpb25zVHJpZ2dlciA9IG9wdGlvbnNNZW51LnF1ZXJ5U2VsZWN0b3IoJy5qYXNtaW5lLXRyaWdnZXInKSxcXG4gICAgICAgICAgb3B0aW9uc1BheWxvYWQgPSBvcHRpb25zTWVudS5xdWVyeVNlbGVjdG9yKCcuamFzbWluZS1wYXlsb2FkJyksXFxuICAgICAgICAgIGlzT3BlbiA9IC9cXFxcYmphc21pbmUtb3BlblxcXFxiLztcXG5cXG4gICAgICBvcHRpb25zVHJpZ2dlci5vbmNsaWNrID0gZnVuY3Rpb24oKSB7XFxuICAgICAgICBpZiAoaXNPcGVuLnRlc3Qob3B0aW9uc1BheWxvYWQuY2xhc3NOYW1lKSkge1xcbiAgICAgICAgICBvcHRpb25zUGF5bG9hZC5jbGFzc05hbWUgPSBvcHRpb25zUGF5bG9hZC5jbGFzc05hbWUucmVwbGFjZShpc09wZW4sICcnKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIG9wdGlvbnNQYXlsb2FkLmNsYXNzTmFtZSArPSAnIGphc21pbmUtb3Blbic7XFxuICAgICAgICB9XFxuICAgICAgfTtcXG5cXG4gICAgICBpZiAoc3BlY3NFeGVjdXRlZCA8IHRvdGFsU3BlY3NEZWZpbmVkKSB7XFxuICAgICAgICB2YXIgc2tpcHBlZE1lc3NhZ2UgPSAnUmFuICcgKyBzcGVjc0V4ZWN1dGVkICsgJyBvZiAnICsgdG90YWxTcGVjc0RlZmluZWQgKyAnIHNwZWNzIC0gcnVuIGFsbCc7XFxuICAgICAgICBhbGVydC5hcHBlbmRDaGlsZChcXG4gICAgICAgICAgY3JlYXRlRG9tKCdzcGFuJywge2NsYXNzTmFtZTogJ2phc21pbmUtYmFyIGphc21pbmUtc2tpcHBlZCd9LFxcbiAgICAgICAgICAgIGNyZWF0ZURvbSgnYScsIHtocmVmOiAnPycsIHRpdGxlOiAnUnVuIGFsbCBzcGVjcyd9LCBza2lwcGVkTWVzc2FnZSlcXG4gICAgICAgICAgKVxcbiAgICAgICAgKTtcXG4gICAgICB9XFxuICAgICAgdmFyIHN0YXR1c0Jhck1lc3NhZ2UgPSAnJztcXG4gICAgICB2YXIgc3RhdHVzQmFyQ2xhc3NOYW1lID0gJ2phc21pbmUtYmFyICc7XFxuXFxuICAgICAgaWYgKHRvdGFsU3BlY3NEZWZpbmVkID4gMCkge1xcbiAgICAgICAgc3RhdHVzQmFyTWVzc2FnZSArPSBwbHVyYWxpemUoJ3NwZWMnLCBzcGVjc0V4ZWN1dGVkKSArICcsICcgKyBwbHVyYWxpemUoJ2ZhaWx1cmUnLCBmYWlsdXJlQ291bnQpO1xcbiAgICAgICAgaWYgKHBlbmRpbmdTcGVjQ291bnQpIHsgc3RhdHVzQmFyTWVzc2FnZSArPSAnLCAnICsgcGx1cmFsaXplKCdwZW5kaW5nIHNwZWMnLCBwZW5kaW5nU3BlY0NvdW50KTsgfVxcbiAgICAgICAgc3RhdHVzQmFyQ2xhc3NOYW1lICs9IChmYWlsdXJlQ291bnQgPiAwKSA/ICdqYXNtaW5lLWZhaWxlZCcgOiAnamFzbWluZS1wYXNzZWQnO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBzdGF0dXNCYXJDbGFzc05hbWUgKz0gJ2phc21pbmUtc2tpcHBlZCc7XFxuICAgICAgICBzdGF0dXNCYXJNZXNzYWdlICs9ICdObyBzcGVjcyBmb3VuZCc7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBzZWVkQmFyO1xcbiAgICAgIGlmIChvcmRlciAmJiBvcmRlci5yYW5kb20pIHtcXG4gICAgICAgIHNlZWRCYXIgPSBjcmVhdGVEb20oJ3NwYW4nLCB7Y2xhc3NOYW1lOiAnamFzbWluZS1zZWVkLWJhcid9LFxcbiAgICAgICAgICAnLCByYW5kb21pemVkIHdpdGggc2VlZCAnLFxcbiAgICAgICAgICBjcmVhdGVEb20oJ2EnLCB7dGl0bGU6ICdyYW5kb21pemVkIHdpdGggc2VlZCAnICsgb3JkZXIuc2VlZCwgaHJlZjogc2VlZEhyZWYob3JkZXIuc2VlZCl9LCBvcmRlci5zZWVkKVxcbiAgICAgICAgKTtcXG4gICAgICB9XFxuXFxuICAgICAgYWxlcnQuYXBwZW5kQ2hpbGQoY3JlYXRlRG9tKCdzcGFuJywge2NsYXNzTmFtZTogc3RhdHVzQmFyQ2xhc3NOYW1lfSwgc3RhdHVzQmFyTWVzc2FnZSwgc2VlZEJhcikpO1xcblxcbiAgICAgIGZvcihpID0gMDsgaSA8IGZhaWxlZFN1aXRlcy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgdmFyIGZhaWxlZFN1aXRlID0gZmFpbGVkU3VpdGVzW2ldO1xcbiAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8IGZhaWxlZFN1aXRlLmZhaWxlZEV4cGVjdGF0aW9ucy5sZW5ndGg7IGorKykge1xcbiAgICAgICAgICB2YXIgZXJyb3JCYXJNZXNzYWdlID0gJ0FmdGVyQWxsICcgKyBmYWlsZWRTdWl0ZS5mYWlsZWRFeHBlY3RhdGlvbnNbal0ubWVzc2FnZTtcXG4gICAgICAgICAgdmFyIGVycm9yQmFyQ2xhc3NOYW1lID0gJ2phc21pbmUtYmFyIGphc21pbmUtZXJyb3JlZCc7XFxuICAgICAgICAgIGFsZXJ0LmFwcGVuZENoaWxkKGNyZWF0ZURvbSgnc3BhbicsIHtjbGFzc05hbWU6IGVycm9yQmFyQ2xhc3NOYW1lfSwgZXJyb3JCYXJNZXNzYWdlKSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHZhciByZXN1bHRzID0gZmluZCgnLmphc21pbmUtcmVzdWx0cycpO1xcbiAgICAgIHJlc3VsdHMuYXBwZW5kQ2hpbGQoc3VtbWFyeSk7XFxuXFxuICAgICAgc3VtbWFyeUxpc3QodG9wUmVzdWx0cywgc3VtbWFyeSk7XFxuXFxuICAgICAgZnVuY3Rpb24gc3VtbWFyeUxpc3QocmVzdWx0c1RyZWUsIGRvbVBhcmVudCkge1xcbiAgICAgICAgdmFyIHNwZWNMaXN0Tm9kZTtcXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0c1RyZWUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgdmFyIHJlc3VsdE5vZGUgPSByZXN1bHRzVHJlZS5jaGlsZHJlbltpXTtcXG4gICAgICAgICAgaWYgKHJlc3VsdE5vZGUudHlwZSA9PSAnc3VpdGUnKSB7XFxuICAgICAgICAgICAgdmFyIHN1aXRlTGlzdE5vZGUgPSBjcmVhdGVEb20oJ3VsJywge2NsYXNzTmFtZTogJ2phc21pbmUtc3VpdGUnLCBpZDogJ3N1aXRlLScgKyByZXN1bHROb2RlLnJlc3VsdC5pZH0sXFxuICAgICAgICAgICAgICBjcmVhdGVEb20oJ2xpJywge2NsYXNzTmFtZTogJ2phc21pbmUtc3VpdGUtZGV0YWlsJ30sXFxuICAgICAgICAgICAgICAgIGNyZWF0ZURvbSgnYScsIHtocmVmOiBzcGVjSHJlZihyZXN1bHROb2RlLnJlc3VsdCl9LCByZXN1bHROb2RlLnJlc3VsdC5kZXNjcmlwdGlvbilcXG4gICAgICAgICAgICAgIClcXG4gICAgICAgICAgICApO1xcblxcbiAgICAgICAgICAgIHN1bW1hcnlMaXN0KHJlc3VsdE5vZGUsIHN1aXRlTGlzdE5vZGUpO1xcbiAgICAgICAgICAgIGRvbVBhcmVudC5hcHBlbmRDaGlsZChzdWl0ZUxpc3ROb2RlKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpZiAocmVzdWx0Tm9kZS50eXBlID09ICdzcGVjJykge1xcbiAgICAgICAgICAgIGlmIChkb21QYXJlbnQuZ2V0QXR0cmlidXRlKCdjbGFzcycpICE9ICdqYXNtaW5lLXNwZWNzJykge1xcbiAgICAgICAgICAgICAgc3BlY0xpc3ROb2RlID0gY3JlYXRlRG9tKCd1bCcsIHtjbGFzc05hbWU6ICdqYXNtaW5lLXNwZWNzJ30pO1xcbiAgICAgICAgICAgICAgZG9tUGFyZW50LmFwcGVuZENoaWxkKHNwZWNMaXN0Tm9kZSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHZhciBzcGVjRGVzY3JpcHRpb24gPSByZXN1bHROb2RlLnJlc3VsdC5kZXNjcmlwdGlvbjtcXG4gICAgICAgICAgICBpZihub0V4cGVjdGF0aW9ucyhyZXN1bHROb2RlLnJlc3VsdCkpIHtcXG4gICAgICAgICAgICAgIHNwZWNEZXNjcmlwdGlvbiA9ICdTUEVDIEhBUyBOTyBFWFBFQ1RBVElPTlMgJyArIHNwZWNEZXNjcmlwdGlvbjtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYocmVzdWx0Tm9kZS5yZXN1bHQuc3RhdHVzID09PSAncGVuZGluZycgJiYgcmVzdWx0Tm9kZS5yZXN1bHQucGVuZGluZ1JlYXNvbiAhPT0gJycpIHtcXG4gICAgICAgICAgICAgIHNwZWNEZXNjcmlwdGlvbiA9IHNwZWNEZXNjcmlwdGlvbiArICcgUEVORElORyBXSVRIIE1FU1NBR0U6ICcgKyByZXN1bHROb2RlLnJlc3VsdC5wZW5kaW5nUmVhc29uO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBzcGVjTGlzdE5vZGUuYXBwZW5kQ2hpbGQoXFxuICAgICAgICAgICAgICBjcmVhdGVEb20oJ2xpJywge1xcbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ2phc21pbmUtJyArIHJlc3VsdE5vZGUucmVzdWx0LnN0YXR1cyxcXG4gICAgICAgICAgICAgICAgICBpZDogJ3NwZWMtJyArIHJlc3VsdE5vZGUucmVzdWx0LmlkXFxuICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgIGNyZWF0ZURvbSgnYScsIHtocmVmOiBzcGVjSHJlZihyZXN1bHROb2RlLnJlc3VsdCl9LCBzcGVjRGVzY3JpcHRpb24pXFxuICAgICAgICAgICAgICApXFxuICAgICAgICAgICAgKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoZmFpbHVyZXMubGVuZ3RoKSB7XFxuICAgICAgICBhbGVydC5hcHBlbmRDaGlsZChcXG4gICAgICAgICAgY3JlYXRlRG9tKCdzcGFuJywge2NsYXNzTmFtZTogJ2phc21pbmUtbWVudSBqYXNtaW5lLWJhciBqYXNtaW5lLXNwZWMtbGlzdCd9LFxcbiAgICAgICAgICAgIGNyZWF0ZURvbSgnc3BhbicsIHt9LCAnU3BlYyBMaXN0IHwgJyksXFxuICAgICAgICAgICAgY3JlYXRlRG9tKCdhJywge2NsYXNzTmFtZTogJ2phc21pbmUtZmFpbHVyZXMtbWVudScsIGhyZWY6ICcjJ30sICdGYWlsdXJlcycpKSk7XFxuICAgICAgICBhbGVydC5hcHBlbmRDaGlsZChcXG4gICAgICAgICAgY3JlYXRlRG9tKCdzcGFuJywge2NsYXNzTmFtZTogJ2phc21pbmUtbWVudSBqYXNtaW5lLWJhciBqYXNtaW5lLWZhaWx1cmUtbGlzdCd9LFxcbiAgICAgICAgICAgIGNyZWF0ZURvbSgnYScsIHtjbGFzc05hbWU6ICdqYXNtaW5lLXNwZWMtbGlzdC1tZW51JywgaHJlZjogJyMnfSwgJ1NwZWMgTGlzdCcpLFxcbiAgICAgICAgICAgIGNyZWF0ZURvbSgnc3BhbicsIHt9LCAnIHwgRmFpbHVyZXMgJykpKTtcXG5cXG4gICAgICAgIGZpbmQoJy5qYXNtaW5lLWZhaWx1cmVzLW1lbnUnKS5vbmNsaWNrID0gZnVuY3Rpb24oKSB7XFxuICAgICAgICAgIHNldE1lbnVNb2RlVG8oJ2phc21pbmUtZmFpbHVyZS1saXN0Jyk7XFxuICAgICAgICB9O1xcbiAgICAgICAgZmluZCgnLmphc21pbmUtc3BlYy1saXN0LW1lbnUnKS5vbmNsaWNrID0gZnVuY3Rpb24oKSB7XFxuICAgICAgICAgIHNldE1lbnVNb2RlVG8oJ2phc21pbmUtc3BlYy1saXN0Jyk7XFxuICAgICAgICB9O1xcblxcbiAgICAgICAgc2V0TWVudU1vZGVUbygnamFzbWluZS1mYWlsdXJlLWxpc3QnKTtcXG5cXG4gICAgICAgIHZhciBmYWlsdXJlTm9kZSA9IGZpbmQoJy5qYXNtaW5lLWZhaWx1cmVzJyk7XFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZhaWx1cmVzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgIGZhaWx1cmVOb2RlLmFwcGVuZENoaWxkKGZhaWx1cmVzW2ldKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH07XFxuXFxuICAgIHJldHVybiB0aGlzO1xcblxcbiAgICBmdW5jdGlvbiBmaW5kKHNlbGVjdG9yKSB7XFxuICAgICAgcmV0dXJuIGdldENvbnRhaW5lcigpLnF1ZXJ5U2VsZWN0b3IoJy5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgJyArIHNlbGVjdG9yKTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBjbGVhclByaW9yKCkge1xcbiAgICAgIC8vIHJldHVybiB0aGUgcmVwb3J0ZXJcXG4gICAgICB2YXIgb2xkUmVwb3J0ZXIgPSBmaW5kKCcnKTtcXG5cXG4gICAgICBpZihvbGRSZXBvcnRlcikge1xcbiAgICAgICAgZ2V0Q29udGFpbmVyKCkucmVtb3ZlQ2hpbGQob2xkUmVwb3J0ZXIpO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBjcmVhdGVEb20odHlwZSwgYXR0cnMsIGNoaWxkcmVuVmFyQXJncykge1xcbiAgICAgIHZhciBlbCA9IGNyZWF0ZUVsZW1lbnQodHlwZSk7XFxuXFxuICAgICAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgIHZhciBjaGlsZCA9IGFyZ3VtZW50c1tpXTtcXG5cXG4gICAgICAgIGlmICh0eXBlb2YgY2hpbGQgPT09ICdzdHJpbmcnKSB7XFxuICAgICAgICAgIGVsLmFwcGVuZENoaWxkKGNyZWF0ZVRleHROb2RlKGNoaWxkKSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBpZiAoY2hpbGQpIHtcXG4gICAgICAgICAgICBlbC5hcHBlbmRDaGlsZChjaGlsZCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgZm9yICh2YXIgYXR0ciBpbiBhdHRycykge1xcbiAgICAgICAgaWYgKGF0dHIgPT0gJ2NsYXNzTmFtZScpIHtcXG4gICAgICAgICAgZWxbYXR0cl0gPSBhdHRyc1thdHRyXTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZShhdHRyLCBhdHRyc1thdHRyXSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBlbDtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBwbHVyYWxpemUoc2luZ3VsYXIsIGNvdW50KSB7XFxuICAgICAgdmFyIHdvcmQgPSAoY291bnQgPT0gMSA/IHNpbmd1bGFyIDogc2luZ3VsYXIgKyAncycpO1xcblxcbiAgICAgIHJldHVybiAnJyArIGNvdW50ICsgJyAnICsgd29yZDtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBzcGVjSHJlZihyZXN1bHQpIHtcXG4gICAgICByZXR1cm4gYWRkVG9FeGlzdGluZ1F1ZXJ5U3RyaW5nKCdzcGVjJywgcmVzdWx0LmZ1bGxOYW1lKTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBzZWVkSHJlZihzZWVkKSB7XFxuICAgICAgcmV0dXJuIGFkZFRvRXhpc3RpbmdRdWVyeVN0cmluZygnc2VlZCcsIHNlZWQpO1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIGRlZmF1bHRRdWVyeVN0cmluZyhrZXksIHZhbHVlKSB7XFxuICAgICAgcmV0dXJuICc/JyArIGtleSArICc9JyArIHZhbHVlO1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIHNldE1lbnVNb2RlVG8obW9kZSkge1xcbiAgICAgIGh0bWxSZXBvcnRlck1haW4uc2V0QXR0cmlidXRlKCdjbGFzcycsICdqYXNtaW5lX2h0bWwtcmVwb3J0ZXIgJyArIG1vZGUpO1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIG5vRXhwZWN0YXRpb25zKHJlc3VsdCkge1xcbiAgICAgIHJldHVybiAocmVzdWx0LmZhaWxlZEV4cGVjdGF0aW9ucy5sZW5ndGggKyByZXN1bHQucGFzc2VkRXhwZWN0YXRpb25zLmxlbmd0aCkgPT09IDAgJiZcXG4gICAgICAgIHJlc3VsdC5zdGF0dXMgPT09ICdwYXNzZWQnO1xcbiAgICB9XFxuICB9XFxuXFxuICByZXR1cm4gSHRtbFJlcG9ydGVyO1xcbn07XFxuXFxuamFzbWluZVJlcXVpcmUuSHRtbFNwZWNGaWx0ZXIgPSBmdW5jdGlvbigpIHtcXG4gIGZ1bmN0aW9uIEh0bWxTcGVjRmlsdGVyKG9wdGlvbnMpIHtcXG4gICAgdmFyIGZpbHRlclN0cmluZyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5maWx0ZXJTdHJpbmcoKSAmJiBvcHRpb25zLmZpbHRlclN0cmluZygpLnJlcGxhY2UoL1stW1xcXFxde30oKSorPy4sXFxcXFxcXFxeJHwjXFxcXHNdL2csICdcXFxcXFxcXCQmJyk7XFxuICAgIHZhciBmaWx0ZXJQYXR0ZXJuID0gbmV3IFJlZ0V4cChmaWx0ZXJTdHJpbmcpO1xcblxcbiAgICB0aGlzLm1hdGNoZXMgPSBmdW5jdGlvbihzcGVjTmFtZSkge1xcbiAgICAgIHJldHVybiBmaWx0ZXJQYXR0ZXJuLnRlc3Qoc3BlY05hbWUpO1xcbiAgICB9O1xcbiAgfVxcblxcbiAgcmV0dXJuIEh0bWxTcGVjRmlsdGVyO1xcbn07XFxuXFxuamFzbWluZVJlcXVpcmUuUmVzdWx0c05vZGUgPSBmdW5jdGlvbigpIHtcXG4gIGZ1bmN0aW9uIFJlc3VsdHNOb2RlKHJlc3VsdCwgdHlwZSwgcGFyZW50KSB7XFxuICAgIHRoaXMucmVzdWx0ID0gcmVzdWx0O1xcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcXG5cXG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xcblxcbiAgICB0aGlzLmFkZENoaWxkID0gZnVuY3Rpb24ocmVzdWx0LCB0eXBlKSB7XFxuICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKG5ldyBSZXN1bHRzTm9kZShyZXN1bHQsIHR5cGUsIHRoaXMpKTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5sYXN0ID0gZnVuY3Rpb24oKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5bdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxXTtcXG4gICAgfTtcXG4gIH1cXG5cXG4gIHJldHVybiBSZXN1bHRzTm9kZTtcXG59O1xcblxcbmphc21pbmVSZXF1aXJlLlF1ZXJ5U3RyaW5nID0gZnVuY3Rpb24oKSB7XFxuICBmdW5jdGlvbiBRdWVyeVN0cmluZyhvcHRpb25zKSB7XFxuXFxuICAgIHRoaXMubmF2aWdhdGVXaXRoTmV3UGFyYW0gPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XFxuICAgICAgb3B0aW9ucy5nZXRXaW5kb3dMb2NhdGlvbigpLnNlYXJjaCA9IHRoaXMuZnVsbFN0cmluZ1dpdGhOZXdQYXJhbShrZXksIHZhbHVlKTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5mdWxsU3RyaW5nV2l0aE5ld1BhcmFtID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xcbiAgICAgIHZhciBwYXJhbU1hcCA9IHF1ZXJ5U3RyaW5nVG9QYXJhbU1hcCgpO1xcbiAgICAgIHBhcmFtTWFwW2tleV0gPSB2YWx1ZTtcXG4gICAgICByZXR1cm4gdG9RdWVyeVN0cmluZyhwYXJhbU1hcCk7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuZ2V0UGFyYW0gPSBmdW5jdGlvbihrZXkpIHtcXG4gICAgICByZXR1cm4gcXVlcnlTdHJpbmdUb1BhcmFtTWFwKClba2V5XTtcXG4gICAgfTtcXG5cXG4gICAgcmV0dXJuIHRoaXM7XFxuXFxuICAgIGZ1bmN0aW9uIHRvUXVlcnlTdHJpbmcocGFyYW1NYXApIHtcXG4gICAgICB2YXIgcVN0clBhaXJzID0gW107XFxuICAgICAgZm9yICh2YXIgcHJvcCBpbiBwYXJhbU1hcCkge1xcbiAgICAgICAgcVN0clBhaXJzLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KHByb3ApICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtTWFwW3Byb3BdKSk7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiAnPycgKyBxU3RyUGFpcnMuam9pbignJicpO1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIHF1ZXJ5U3RyaW5nVG9QYXJhbU1hcCgpIHtcXG4gICAgICB2YXIgcGFyYW1TdHIgPSBvcHRpb25zLmdldFdpbmRvd0xvY2F0aW9uKCkuc2VhcmNoLnN1YnN0cmluZygxKSxcXG4gICAgICAgIHBhcmFtcyA9IFtdLFxcbiAgICAgICAgcGFyYW1NYXAgPSB7fTtcXG5cXG4gICAgICBpZiAocGFyYW1TdHIubGVuZ3RoID4gMCkge1xcbiAgICAgICAgcGFyYW1zID0gcGFyYW1TdHIuc3BsaXQoJyYnKTtcXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgIHZhciBwID0gcGFyYW1zW2ldLnNwbGl0KCc9Jyk7XFxuICAgICAgICAgIHZhciB2YWx1ZSA9IGRlY29kZVVSSUNvbXBvbmVudChwWzFdKTtcXG4gICAgICAgICAgaWYgKHZhbHVlID09PSAndHJ1ZScgfHwgdmFsdWUgPT09ICdmYWxzZScpIHtcXG4gICAgICAgICAgICB2YWx1ZSA9IEpTT04ucGFyc2UodmFsdWUpO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIHBhcmFtTWFwW2RlY29kZVVSSUNvbXBvbmVudChwWzBdKV0gPSB2YWx1ZTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHBhcmFtTWFwO1xcbiAgICB9XFxuXFxuICB9XFxuXFxuICByZXR1cm4gUXVlcnlTdHJpbmc7XFxufTtcXG5cIlxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2xpYi9qYXNtaW5lLTIuNC4xL2phc21pbmUtaHRtbC5qc1xuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCIvKipcXG4gU3RhcnRpbmcgd2l0aCB2ZXJzaW9uIDIuMCwgdGhpcyBmaWxlIFxcXCJib290c1xcXCIgSmFzbWluZSwgcGVyZm9ybWluZyBhbGwgb2YgdGhlIG5lY2Vzc2FyeSBpbml0aWFsaXphdGlvbiBiZWZvcmUgZXhlY3V0aW5nIHRoZSBsb2FkZWQgZW52aXJvbm1lbnQgYW5kIGFsbCBvZiBhIHByb2plY3QncyBzcGVjcy4gVGhpcyBmaWxlIHNob3VsZCBiZSBsb2FkZWQgYWZ0ZXIgYGphc21pbmUuanNgIGFuZCBgamFzbWluZV9odG1sLmpzYCwgYnV0IGJlZm9yZSBhbnkgcHJvamVjdCBzb3VyY2UgZmlsZXMgb3Igc3BlYyBmaWxlcyBhcmUgbG9hZGVkLiBUaHVzIHRoaXMgZmlsZSBjYW4gYWxzbyBiZSB1c2VkIHRvIGN1c3RvbWl6ZSBKYXNtaW5lIGZvciBhIHByb2plY3QuXFxuXFxuIElmIGEgcHJvamVjdCBpcyB1c2luZyBKYXNtaW5lIHZpYSB0aGUgc3RhbmRhbG9uZSBkaXN0cmlidXRpb24sIHRoaXMgZmlsZSBjYW4gYmUgY3VzdG9taXplZCBkaXJlY3RseS4gSWYgYSBwcm9qZWN0IGlzIHVzaW5nIEphc21pbmUgdmlhIHRoZSBbUnVieSBnZW1dW2phc21pbmUtZ2VtXSwgdGhpcyBmaWxlIGNhbiBiZSBjb3BpZWQgaW50byB0aGUgc3VwcG9ydCBkaXJlY3RvcnkgdmlhIGBqYXNtaW5lIGNvcHlfYm9vdF9qc2AuIE90aGVyIGVudmlyb25tZW50cyAoZS5nLiwgUHl0aG9uKSB3aWxsIGhhdmUgZGlmZmVyZW50IG1lY2hhbmlzbXMuXFxuXFxuIFRoZSBsb2NhdGlvbiBvZiBgYm9vdC5qc2AgY2FuIGJlIHNwZWNpZmllZCBhbmQvb3Igb3ZlcnJpZGRlbiBpbiBgamFzbWluZS55bWxgLlxcblxcbiBbamFzbWluZS1nZW1dOiBodHRwOi8vZ2l0aHViLmNvbS9waXZvdGFsL2phc21pbmUtZ2VtXFxuICovXFxuXFxuKGZ1bmN0aW9uKCkge1xcblxcbiAgLyoqXFxuICAgKiAjIyBSZXF1aXJlICZhbXA7IEluc3RhbnRpYXRlXFxuICAgKlxcbiAgICogUmVxdWlyZSBKYXNtaW5lJ3MgY29yZSBmaWxlcy4gU3BlY2lmaWNhbGx5LCB0aGlzIHJlcXVpcmVzIGFuZCBhdHRhY2hlcyBhbGwgb2YgSmFzbWluZSdzIGNvZGUgdG8gdGhlIGBqYXNtaW5lYCByZWZlcmVuY2UuXFxuICAgKi9cXG4gIHdpbmRvdy5qYXNtaW5lID0gamFzbWluZVJlcXVpcmUuY29yZShqYXNtaW5lUmVxdWlyZSk7XFxuXFxuICAvKipcXG4gICAqIFNpbmNlIHRoaXMgaXMgYmVpbmcgcnVuIGluIGEgYnJvd3NlciBhbmQgdGhlIHJlc3VsdHMgc2hvdWxkIHBvcHVsYXRlIHRvIGFuIEhUTUwgcGFnZSwgcmVxdWlyZSB0aGUgSFRNTC1zcGVjaWZpYyBKYXNtaW5lIGNvZGUsIGluamVjdGluZyB0aGUgc2FtZSByZWZlcmVuY2UuXFxuICAgKi9cXG4gIGphc21pbmVSZXF1aXJlLmh0bWwoamFzbWluZSk7XFxuXFxuICAvKipcXG4gICAqIENyZWF0ZSB0aGUgSmFzbWluZSBlbnZpcm9ubWVudC4gVGhpcyBpcyB1c2VkIHRvIHJ1biBhbGwgc3BlY3MgaW4gYSBwcm9qZWN0LlxcbiAgICovXFxuICB2YXIgZW52ID0gamFzbWluZS5nZXRFbnYoKTtcXG5cXG4gIC8qKlxcbiAgICogIyMgVGhlIEdsb2JhbCBJbnRlcmZhY2VcXG4gICAqXFxuICAgKiBCdWlsZCB1cCB0aGUgZnVuY3Rpb25zIHRoYXQgd2lsbCBiZSBleHBvc2VkIGFzIHRoZSBKYXNtaW5lIHB1YmxpYyBpbnRlcmZhY2UuIEEgcHJvamVjdCBjYW4gY3VzdG9taXplLCByZW5hbWUgb3IgYWxpYXMgYW55IG9mIHRoZXNlIGZ1bmN0aW9ucyBhcyBkZXNpcmVkLCBwcm92aWRlZCB0aGUgaW1wbGVtZW50YXRpb24gcmVtYWlucyB1bmNoYW5nZWQuXFxuICAgKi9cXG4gIHZhciBqYXNtaW5lSW50ZXJmYWNlID0gamFzbWluZVJlcXVpcmUuaW50ZXJmYWNlKGphc21pbmUsIGVudik7XFxuXFxuICAvKipcXG4gICAqIEFkZCBhbGwgb2YgdGhlIEphc21pbmUgZ2xvYmFsL3B1YmxpYyBpbnRlcmZhY2UgdG8gdGhlIGdsb2JhbCBzY29wZSwgc28gYSBwcm9qZWN0IGNhbiB1c2UgdGhlIHB1YmxpYyBpbnRlcmZhY2UgZGlyZWN0bHkuIEZvciBleGFtcGxlLCBjYWxsaW5nIGBkZXNjcmliZWAgaW4gc3BlY3MgaW5zdGVhZCBvZiBgamFzbWluZS5nZXRFbnYoKS5kZXNjcmliZWAuXFxuICAgKi9cXG4gIGV4dGVuZCh3aW5kb3csIGphc21pbmVJbnRlcmZhY2UpO1xcblxcbiAgLyoqXFxuICAgKiAjIyBSdW5uZXIgUGFyYW1ldGVyc1xcbiAgICpcXG4gICAqIE1vcmUgYnJvd3NlciBzcGVjaWZpYyBjb2RlIC0gd3JhcCB0aGUgcXVlcnkgc3RyaW5nIGluIGFuIG9iamVjdCBhbmQgdG8gYWxsb3cgZm9yIGdldHRpbmcvc2V0dGluZyBwYXJhbWV0ZXJzIGZyb20gdGhlIHJ1bm5lciB1c2VyIGludGVyZmFjZS5cXG4gICAqL1xcblxcbiAgdmFyIHF1ZXJ5U3RyaW5nID0gbmV3IGphc21pbmUuUXVlcnlTdHJpbmcoe1xcbiAgICBnZXRXaW5kb3dMb2NhdGlvbjogZnVuY3Rpb24oKSB7IHJldHVybiB3aW5kb3cubG9jYXRpb247IH1cXG4gIH0pO1xcblxcbiAgdmFyIGNhdGNoaW5nRXhjZXB0aW9ucyA9IHF1ZXJ5U3RyaW5nLmdldFBhcmFtKFxcXCJjYXRjaFxcXCIpO1xcbiAgZW52LmNhdGNoRXhjZXB0aW9ucyh0eXBlb2YgY2F0Y2hpbmdFeGNlcHRpb25zID09PSBcXFwidW5kZWZpbmVkXFxcIiA/IHRydWUgOiBjYXRjaGluZ0V4Y2VwdGlvbnMpO1xcblxcbiAgdmFyIHRocm93aW5nRXhwZWN0YXRpb25GYWlsdXJlcyA9IHF1ZXJ5U3RyaW5nLmdldFBhcmFtKFxcXCJ0aHJvd0ZhaWx1cmVzXFxcIik7XFxuICBlbnYudGhyb3dPbkV4cGVjdGF0aW9uRmFpbHVyZSh0aHJvd2luZ0V4cGVjdGF0aW9uRmFpbHVyZXMpO1xcblxcbiAgdmFyIHJhbmRvbSA9IHF1ZXJ5U3RyaW5nLmdldFBhcmFtKFxcXCJyYW5kb21cXFwiKTtcXG4gIGVudi5yYW5kb21pemVUZXN0cyhyYW5kb20pO1xcblxcbiAgdmFyIHNlZWQgPSBxdWVyeVN0cmluZy5nZXRQYXJhbShcXFwic2VlZFxcXCIpO1xcbiAgaWYgKHNlZWQpIHtcXG4gICAgZW52LnNlZWQoc2VlZCk7XFxuICB9XFxuXFxuICAvKipcXG4gICAqICMjIFJlcG9ydGVyc1xcbiAgICogVGhlIGBIdG1sUmVwb3J0ZXJgIGJ1aWxkcyBhbGwgb2YgdGhlIEhUTUwgVUkgZm9yIHRoZSBydW5uZXIgcGFnZS4gVGhpcyByZXBvcnRlciBwYWludHMgdGhlIGRvdHMsIHN0YXJzLCBhbmQgeCdzIGZvciBzcGVjcywgYXMgd2VsbCBhcyBhbGwgc3BlYyBuYW1lcyBhbmQgYWxsIGZhaWx1cmVzIChpZiBhbnkpLlxcbiAgICovXFxuICB2YXIgaHRtbFJlcG9ydGVyID0gbmV3IGphc21pbmUuSHRtbFJlcG9ydGVyKHtcXG4gICAgZW52OiBlbnYsXFxuICAgIG9uUmFpc2VFeGNlcHRpb25zQ2xpY2s6IGZ1bmN0aW9uKCkgeyBxdWVyeVN0cmluZy5uYXZpZ2F0ZVdpdGhOZXdQYXJhbShcXFwiY2F0Y2hcXFwiLCAhZW52LmNhdGNoaW5nRXhjZXB0aW9ucygpKTsgfSxcXG4gICAgb25UaHJvd0V4cGVjdGF0aW9uc0NsaWNrOiBmdW5jdGlvbigpIHsgcXVlcnlTdHJpbmcubmF2aWdhdGVXaXRoTmV3UGFyYW0oXFxcInRocm93RmFpbHVyZXNcXFwiLCAhZW52LnRocm93aW5nRXhwZWN0YXRpb25GYWlsdXJlcygpKTsgfSxcXG4gICAgb25SYW5kb21DbGljazogZnVuY3Rpb24oKSB7IHF1ZXJ5U3RyaW5nLm5hdmlnYXRlV2l0aE5ld1BhcmFtKFxcXCJyYW5kb21cXFwiLCAhZW52LnJhbmRvbVRlc3RzKCkpOyB9LFxcbiAgICBhZGRUb0V4aXN0aW5nUXVlcnlTdHJpbmc6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHsgcmV0dXJuIHF1ZXJ5U3RyaW5nLmZ1bGxTdHJpbmdXaXRoTmV3UGFyYW0oa2V5LCB2YWx1ZSk7IH0sXFxuICAgIGdldENvbnRhaW5lcjogZnVuY3Rpb24oKSB7IHJldHVybiBkb2N1bWVudC5ib2R5OyB9LFxcbiAgICBjcmVhdGVFbGVtZW50OiBmdW5jdGlvbigpIHsgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQuYXBwbHkoZG9jdW1lbnQsIGFyZ3VtZW50cyk7IH0sXFxuICAgIGNyZWF0ZVRleHROb2RlOiBmdW5jdGlvbigpIHsgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlLmFwcGx5KGRvY3VtZW50LCBhcmd1bWVudHMpOyB9LFxcbiAgICB0aW1lcjogbmV3IGphc21pbmUuVGltZXIoKVxcbiAgfSk7XFxuXFxuICAvKipcXG4gICAqIFRoZSBganNBcGlSZXBvcnRlcmAgYWxzbyByZWNlaXZlcyBzcGVjIHJlc3VsdHMsIGFuZCBpcyB1c2VkIGJ5IGFueSBlbnZpcm9ubWVudCB0aGF0IG5lZWRzIHRvIGV4dHJhY3QgdGhlIHJlc3VsdHMgIGZyb20gSmF2YVNjcmlwdC5cXG4gICAqL1xcbiAgZW52LmFkZFJlcG9ydGVyKGphc21pbmVJbnRlcmZhY2UuanNBcGlSZXBvcnRlcik7XFxuICBlbnYuYWRkUmVwb3J0ZXIoaHRtbFJlcG9ydGVyKTtcXG5cXG4gIC8qKlxcbiAgICogRmlsdGVyIHdoaWNoIHNwZWNzIHdpbGwgYmUgcnVuIGJ5IG1hdGNoaW5nIHRoZSBzdGFydCBvZiB0aGUgZnVsbCBuYW1lIGFnYWluc3QgdGhlIGBzcGVjYCBxdWVyeSBwYXJhbS5cXG4gICAqL1xcbiAgdmFyIHNwZWNGaWx0ZXIgPSBuZXcgamFzbWluZS5IdG1sU3BlY0ZpbHRlcih7XFxuICAgIGZpbHRlclN0cmluZzogZnVuY3Rpb24oKSB7IHJldHVybiBxdWVyeVN0cmluZy5nZXRQYXJhbShcXFwic3BlY1xcXCIpOyB9XFxuICB9KTtcXG5cXG4gIGVudi5zcGVjRmlsdGVyID0gZnVuY3Rpb24oc3BlYykge1xcbiAgICByZXR1cm4gc3BlY0ZpbHRlci5tYXRjaGVzKHNwZWMuZ2V0RnVsbE5hbWUoKSk7XFxuICB9O1xcblxcbiAgLyoqXFxuICAgKiBTZXR0aW5nIHVwIHRpbWluZyBmdW5jdGlvbnMgdG8gYmUgYWJsZSB0byBiZSBvdmVycmlkZGVuLiBDZXJ0YWluIGJyb3dzZXJzIChTYWZhcmksIElFIDgsIHBoYW50b21qcykgcmVxdWlyZSB0aGlzIGhhY2suXFxuICAgKi9cXG4gIHdpbmRvdy5zZXRUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQ7XFxuICB3aW5kb3cuc2V0SW50ZXJ2YWwgPSB3aW5kb3cuc2V0SW50ZXJ2YWw7XFxuICB3aW5kb3cuY2xlYXJUaW1lb3V0ID0gd2luZG93LmNsZWFyVGltZW91dDtcXG4gIHdpbmRvdy5jbGVhckludGVydmFsID0gd2luZG93LmNsZWFySW50ZXJ2YWw7XFxuXFxuICAvKipcXG4gICAqICMjIEV4ZWN1dGlvblxcbiAgICpcXG4gICAqIFJlcGxhY2UgdGhlIGJyb3dzZXIgd2luZG93J3MgYG9ubG9hZGAsIGVuc3VyZSBpdCdzIGNhbGxlZCwgYW5kIHRoZW4gcnVuIGFsbCBvZiB0aGUgbG9hZGVkIHNwZWNzLiBUaGlzIGluY2x1ZGVzIGluaXRpYWxpemluZyB0aGUgYEh0bWxSZXBvcnRlcmAgaW5zdGFuY2UgYW5kIHRoZW4gZXhlY3V0aW5nIHRoZSBsb2FkZWQgSmFzbWluZSBlbnZpcm9ubWVudC4gQWxsIG9mIHRoaXMgd2lsbCBoYXBwZW4gYWZ0ZXIgYWxsIG9mIHRoZSBzcGVjcyBhcmUgbG9hZGVkLlxcbiAgICovXFxuICB2YXIgY3VycmVudFdpbmRvd09ubG9hZCA9IHdpbmRvdy5vbmxvYWQ7XFxuXFxuICB3aW5kb3cub25sb2FkID0gZnVuY3Rpb24oKSB7XFxuICAgIGlmIChjdXJyZW50V2luZG93T25sb2FkKSB7XFxuICAgICAgY3VycmVudFdpbmRvd09ubG9hZCgpO1xcbiAgICB9XFxuICAgIGh0bWxSZXBvcnRlci5pbml0aWFsaXplKCk7XFxuICAgIGVudi5leGVjdXRlKCk7XFxuICB9O1xcblxcbiAgLyoqXFxuICAgKiBIZWxwZXIgZnVuY3Rpb24gZm9yIHJlYWRhYmlsaXR5IGFib3ZlLlxcbiAgICovXFxuICBmdW5jdGlvbiBleHRlbmQoZGVzdGluYXRpb24sIHNvdXJjZSkge1xcbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBzb3VyY2UpIGRlc3RpbmF0aW9uW3Byb3BlcnR5XSA9IHNvdXJjZVtwcm9wZXJ0eV07XFxuICAgIHJldHVybiBkZXN0aW5hdGlvbjtcXG4gIH1cXG5cXG59KCkpO1xcblwiXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbGliL2phc21pbmUtMi40LjEvYm9vdC5qc1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=
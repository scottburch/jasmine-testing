/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	bindPolyfill();
	
	__webpack_require__(1);
	
	__webpack_require__(6);
	var scripts = [__webpack_require__(7), __webpack_require__(8), __webpack_require__(9), __webpack_require__(10)].join(';');
	
	eval.call(global, scripts);
	__webpack_require__(5);
	
	sourceMapSupport.install();
	
	// Needed for phantomJS which does not include Function.prototype.bind()
	function bindPolyfill() {
	    if (!Function.prototype.bind) {
	        Function.prototype.bind = function (oThis) {
	            if (typeof this !== 'function') {
	                // closest thing possible to the ECMAScript 5
	                // internal IsCallable function
	                throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
	            }
	
	            var aArgs = Array.prototype.slice.call(arguments, 1),
	                fToBind = this,
	                fNOP = function fNOP() {},
	                fBound = function fBound() {
	                return fToBind.apply(this instanceof fNOP ? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments)));
	            };
	
	            if (this.prototype) {
	                // native functions don't have a prototype
	                fNOP.prototype = this.prototype;
	            }
	            fBound.prototype = new fNOP();
	
	            return fBound;
	        };
	    }
	}
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(2);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(4)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../../../../node_modules/css-loader/index.js!./jasmine.css", function() {
				var newContent = require("!!./../../../../../../node_modules/css-loader/index.js!./jasmine.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(3)();
	// imports
	
	
	// module
	exports.push([module.id, "body { overflow-y: scroll; }\n\n.jasmine_html-reporter { background-color: #eee; padding: 5px; margin: -8px; font-size: 11px; font-family: Monaco, \"Lucida Console\", monospace; line-height: 14px; color: #333; }\n.jasmine_html-reporter a { text-decoration: none; }\n.jasmine_html-reporter a:hover { text-decoration: underline; }\n.jasmine_html-reporter p, .jasmine_html-reporter h1, .jasmine_html-reporter h2, .jasmine_html-reporter h3, .jasmine_html-reporter h4, .jasmine_html-reporter h5, .jasmine_html-reporter h6 { margin: 0; line-height: 14px; }\n.jasmine_html-reporter .jasmine-banner, .jasmine_html-reporter .jasmine-symbol-summary, .jasmine_html-reporter .jasmine-summary, .jasmine_html-reporter .jasmine-result-message, .jasmine_html-reporter .jasmine-spec .jasmine-description, .jasmine_html-reporter .jasmine-spec-detail .jasmine-description, .jasmine_html-reporter .jasmine-alert .jasmine-bar, .jasmine_html-reporter .jasmine-stack-trace { padding-left: 9px; padding-right: 9px; }\n.jasmine_html-reporter .jasmine-banner { position: relative; }\n.jasmine_html-reporter .jasmine-banner .jasmine-title { background: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAAAZCAMAAACGusnyAAACdlBMVEX/////AP+AgICqVaqAQICZM5mAVYCSSZKAQICOOY6ATYCLRouAQICJO4mSSYCIRIiPQICHPIeOR4CGQ4aMQICGPYaLRoCFQ4WKQICPPYWJRYCOQoSJQICNPoSIRICMQoSHQICHRICKQoOHQICKPoOJO4OJQYOMQICMQ4CIQYKLQICIPoKLQ4CKQICNPoKJQISMQ4KJQoSLQYKJQISLQ4KIQoSKQYKIQICIQISMQoSKQYKLQIOLQoOJQYGLQIOKQIOMQoGKQYOLQYGKQIOLQoGJQYOJQIOKQYGJQIOKQoGKQIGLQIKLQ4KKQoGLQYKJQIGKQYKJQIGKQIKJQoGKQYKLQIGKQYKLQIOJQoKKQoOJQYKKQIOJQoKKQoOKQIOLQoKKQYOLQYKJQIOKQoKKQYKKQoKJQYOKQYKLQIOKQoKLQYOKQYKLQIOJQoGKQYKJQYGJQoGKQYKLQoGLQYGKQoGJQYKKQYGJQIKKQoGJQYKLQIKKQYGLQYKKQYGKQYGKQYKJQYOKQoKJQYOKQYKLQYOLQYOKQYKLQYOKQoKKQYKKQYOKQYOJQYKKQYKLQYKKQIKKQoKKQYKKQYKKQoKJQIKKQYKLQYKKQYKKQIKKQYKKQYKKQYKKQIKKQYKJQYGLQYGKQYKKQYKKQYGKQIKKQYGKQYOJQoKKQYOLQYKKQYOKQoKKQYKKQoKKQYKKQYKJQYKLQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKJQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKLQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKmIDpEAAAA0XRSTlMAAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobHB0eHyAiIyQlJycoKissLS4wMTQ1Njc4OTo7PDw+P0BCQ0RISUpLTE1OUFNUVVdYWFlaW15fYGFiY2ZnaGlqa2xtb3BxcnN0dnh5ent8fX5/gIGChIWIioyNjo+QkZOUlZaYmZqbnJ2eoKGio6WmqKmsra6vsLGztre4ubq7vL2+wMHDxMjJysvNzs/Q0dLU1tfY2dvc3t/g4eLj5ebn6Onq6+zt7u/w8vP09fb3+Pn6+/z9/vkVQXAAAAMaSURBVHhe5dXxV1N1GMfxz2ABbDgIAm5VDJOyVDIJLUMaVpBWUZUaGbmqoGpZRSiGiRWp6KoZ5AB0ZY50RImZQIlahKkMYXv/R90dBvET/rJfOr3Ouc8v99zPec59zvf56j+vYKlViSf7250X4Mr3O29Tgq08BdGB4DhcekEJ5YkQKFsgWZdtj9JpV+I8xPjLFqkrsEIqO8PHSpis36jWazcqjEsfJjkvRssVU37SdIOu4XCf5vEJPsnwJpnRNU9JmxhMk8l1gehIrq7hTFjzOD+Vf88629qKMJVNltInFeRexRQyJlNeqd1iGDlSzrIUIyXbyFfm3RYprcQRe7lqtWyGYbfc6dT0R2vmdOOkX3u55C1rP37ftiH+tDby4r/RBT0w8TyEkr+epB9XgPDmSYYWbrhCuFYaIyw3fDQAXTnSkh+ANofiHmWf9l+FY1I90FdQTetstO00o23novzVsJ7uB3/C5TkbjRwZ5JerwV4iRWq9HFbFMaK/d0TYqayRiQPuIxxS3Bu8JWU90/60tKi7vkhaznez0a/TbVOKj5CaOZh6fWG6/Lyv9B/ZLR1gw/S/fpbeVD3MCW1li6SvWDOn65tr99/uvWtBS0XDm4s1t+sOHpG0kpBKx/l77wOSnxLpcx6TXmXLTPQOKYOf9Q1dfr8/SJ2mFdCvl1Yl93DiHUZvXeLJbGSzYu5gVJ2slbSakOR8dxCq5adQ2oFLqsE9Ex3L4qQO0eOPeU5x56bypXp4onSEb5OkICX6lDat55TeoztNKQcJaakrz9KCb95oD69IKq+yKW4XPjknaS52V0TZqE2cTtXjcHSCRmUO88e+85hj3EP74i9p8pylw7lxgMDyyl6OV7ZejnjNMfatu87LxRbH0IS35gt2a4ZjmGpVBdKK3Wr6INk8jWWSGqbA55CKgjBRC6E9w78ydTg3ABS3AFV1QN0Y4Aa2pgEjWnQURj9L0ayK6R2ysEqxHUKzYnLvvyU+i9KM2JHJzE4vyZOyDcOwOsySajeLPc8sNvPJkFlyJd20wpqAzZeAfZ3oWybxd+P/3j+SG3uSBdf2VQAAAABJRU5ErkJggg==') no-repeat; background: url('data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgoKPHN2ZwogICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgIHhtbG5zOmNjPSJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9ucyMiCiAgIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyIKICAgeG1sbnM6c3ZnPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxuczppbmtzY2FwZT0iaHR0cDovL3d3dy5pbmtzY2FwZS5vcmcvbmFtZXNwYWNlcy9pbmtzY2FwZSIKICAgdmVyc2lvbj0iMS4xIgogICB3aWR0aD0iNjgxLjk2MjUyIgogICBoZWlnaHQ9IjE4Ny41IgogICBpZD0ic3ZnMiIKICAgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+PG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhOCI+PHJkZjpSREY+PGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPjxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PjxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz48L2NjOldvcms+PC9yZGY6UkRGPjwvbWV0YWRhdGE+PGRlZnMKICAgICBpZD0iZGVmczYiPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoMTgiPjxwYXRoCiAgICAgICAgIGQ9Ik0gMCwxNTAwIDAsMCBsIDU0NTUuNzQsMCAwLDE1MDAgTCAwLDE1MDAgeiIKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgaWQ9InBhdGgyMCIgLz48L2NsaXBQYXRoPjwvZGVmcz48ZwogICAgIHRyYW5zZm9ybT0ibWF0cml4KDEuMjUsMCwwLC0xLjI1LDAsMTg3LjUpIgogICAgIGlkPSJnMTAiPjxnCiAgICAgICB0cmFuc2Zvcm09InNjYWxlKDAuMSwwLjEpIgogICAgICAgaWQ9ImcxMiI+PGcKICAgICAgICAgaWQ9ImcxNCI+PGcKICAgICAgICAgICBjbGlwLXBhdGg9InVybCgjY2xpcFBhdGgxOCkiCiAgICAgICAgICAgaWQ9ImcxNiI+PHBhdGgKICAgICAgICAgICAgIGQ9Im0gMTU0NCw1OTkuNDM0IGMgMC45MiwtNDAuMzUyIDI1LjY4LC04MS42MDIgNzEuNTMsLTgxLjYwMiAyNy41MSwwIDQ3LjY4LDEyLjgzMiA2MS40NCwzNS43NTQgMTIuODMsMjIuOTMgMTIuODMsNTYuODUyIDEyLjgzLDgyLjUyNyBsIDAsMzI5LjE4NCAtNzEuNTIsMCAwLDEwNC41NDMgMjY2LjgzLDAgMCwtMTA0LjU0MyAtNzAuNiwwIDAsLTM0NC43NyBjIDAsLTU4LjY5MSAtMy42OCwtMTA0LjUzMSAtNDQuOTMsLTE1Mi4yMTggLTM2LjY4LC00Mi4xOCAtOTYuMjgsLTY2LjAyIC0xNTMuMTQsLTY2LjAyIC0xMTcuMzcsMCAtMjA3LjI0LDc3Ljk0MSAtMjAyLjY0LDE5Ny4xNDUgbCAxMzAuMiwwIgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoMjIiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDIzMDEuNCw2NjIuNjk1IGMgMCw4MC43MDMgLTY2Ljk0LDE0NS44MTMgLTE0Ny42MywxNDUuODEzIC04My40NCwwIC0xNDcuNjMsLTY4Ljc4MSAtMTQ3LjYzLC0xNTEuMzAxIDAsLTc5Ljc4NSA2Ni45NCwtMTQ1LjgwMSAxNDUuOCwtMTQ1LjgwMSA4NC4zNSwwIDE0OS40Niw2Ny44NTIgMTQ5LjQ2LDE1MS4yODkgeiBtIC0xLjgzLC0xODEuNTQ3IGMgLTM1Ljc3LC01NC4wOTcgLTkzLjUzLC03OC44NTkgLTE1Ny43MiwtNzguODU5IC0xNDAuMywwIC0yNTEuMjQsMTE2LjQ0OSAtMjUxLjI0LDI1NC45MTggMCwxNDIuMTI5IDExMy43LDI2MC40MSAyNTYuNzQsMjYwLjQxIDYzLjI3LDAgMTE4LjI5LC0yOS4zMzYgMTUyLjIyLC04Mi41MjMgbCAwLDY5LjY4NyAxNzUuMTQsMCAwLC0xMDQuNTI3IC02MS40NCwwIDAsLTI4MC41OTggNjEuNDQsMCAwLC0xMDQuNTI3IC0xNzUuMTQsMCAwLDY2LjAxOSIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDI0IgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSAyNjIyLjMzLDU1Ny4yNTggYyAzLjY3LC00NC4wMTYgMzMuMDEsLTczLjM0OCA3OC44NiwtNzMuMzQ4IDMzLjkzLDAgNjYuOTMsMjMuODI0IDY2LjkzLDYwLjUwNCAwLDQ4LjYwNiAtNDUuODQsNTYuODU2IC04My40NCw2Ni45NDEgLTg1LjI4LDIyLjAwNCAtMTc4LjgxLDQ4LjYwNiAtMTc4LjgxLDE1NS44NzkgMCw5My41MzYgNzguODYsMTQ3LjYzMyAxNjUuOTgsMTQ3LjYzMyA0NCwwIDgzLjQzLC05LjE3NiAxMTAuOTQsLTQ0LjAwOCBsIDAsMzMuOTIyIDgyLjUzLDAgMCwtMTMyLjk2NSAtMTA4LjIxLDAgYyAtMS44MywzNC44NTYgLTI4LjQyLDU3Ljc3NCAtNjMuMjYsNTcuNzc0IC0zMC4yNiwwIC02Mi4zNSwtMTcuNDIyIC02Mi4zNSwtNTEuMzQ4IDAsLTQ1Ljg0NyA0NC45MywtNTUuOTMgODAuNjksLTY0LjE4IDg4LjAyLC0yMC4xNzUgMTgyLjQ3LC00Ny42OTUgMTgyLjQ3LC0xNTcuNzM0IDAsLTk5LjAyNyAtODMuNDQsLTE1NC4wMzkgLTE3NS4xMywtMTU0LjAzOSAtNDkuNTMsMCAtOTQuNDYsMTUuNTgyIC0xMjYuNTUsNTMuMTggbCAwLC00MC4zNCAtODUuMjcsMCAwLDE0Mi4xMjkgMTE0LjYyLDAiCiAgICAgICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgICAgICAgaWQ9InBhdGgyNiIKICAgICAgICAgICAgIHN0eWxlPSJmaWxsOiM4YTQxODI7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiIC8+PHBhdGgKICAgICAgICAgICAgIGQ9Im0gMjk4OC4xOCw4MDAuMjU0IC02My4yNiwwIDAsMTA0LjUyNyAxNjUuMDUsMCAwLC03My4zNTUgYyAzMS4xOCw1MS4zNDcgNzguODYsODUuMjc3IDE0MS4yMSw4NS4yNzcgNjcuODUsMCAxMjQuNzEsLTQxLjI1OCAxNTIuMjEsLTEwMi42OTkgMjYuNiw2Mi4zNTEgOTIuNjIsMTAyLjY5OSAxNjAuNDcsMTAyLjY5OSA1My4xOSwwIDEwNS40NiwtMjIgMTQxLjIxLC02Mi4zNTEgMzguNTIsLTQ0LjkzOCAzOC41MiwtOTMuNTMyIDM4LjUyLC0xNDkuNDU3IGwgMCwtMTg1LjIzOSA2My4yNywwIDAsLTEwNC41MjcgLTIzOC40MiwwIDAsMTA0LjUyNyA2My4yOCwwIDAsMTU3LjcxNSBjIDAsMzIuMTAyIDAsNjAuNTI3IC0xNC42Nyw4OC45NTcgLTE4LjM0LDI2LjU4MiAtNDguNjEsNDAuMzQ0IC03OS43Nyw0MC4zNDQgLTMwLjI2LDAgLTYzLjI4LC0xMi44NDQgLTgyLjUzLC0zNi42NzIgLTIyLjkzLC0yOS4zNTUgLTIyLjkzLC01Ni44NjMgLTIyLjkzLC05Mi42MjkgbCAwLC0xNTcuNzE1IDYzLjI3LDAgMCwtMTA0LjUyNyAtMjM4LjQxLDAgMCwxMDQuNTI3IDYzLjI4LDAgMCwxNTAuMzgzIGMgMCwyOS4zNDggMCw2Ni4wMjMgLTE0LjY3LDkxLjY5OSAtMTUuNTksMjkuMzM2IC00Ny42OSw0NC45MzQgLTgwLjcsNDQuOTM0IC0zMS4xOCwwIC01Ny43NywtMTEuMDA4IC03Ny45NCwtMzUuNzc0IC0yNC43NywtMzAuMjUzIC0yNi42LC02Mi4zNDMgLTI2LjYsLTk5Ljk0MSBsIDAsLTE1MS4zMDEgNjMuMjcsMCAwLC0xMDQuNTI3IC0yMzguNCwwIDAsMTA0LjUyNyA2My4yNiwwIDAsMjgwLjU5OCIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDI4IgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSAzOTk4LjY2LDk1MS41NDcgLTExMS44NywwIDAsMTE4LjI5MyAxMTEuODcsMCAwLC0xMTguMjkzIHogbSAwLC00MzEuODkxIDYzLjI3LDAgMCwtMTA0LjUyNyAtMjM5LjMzLDAgMCwxMDQuNTI3IDY0LjE5LDAgMCwyODAuNTk4IC02My4yNywwIDAsMTA0LjUyNyAxNzUuMTQsMCAwLC0zODUuMTI1IgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoMzAiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDQxNTkuMTIsODAwLjI1NCAtNjMuMjcsMCAwLDEwNC41MjcgMTc1LjE0LDAgMCwtNjkuNjg3IGMgMjkuMzUsNTQuMTAxIDg0LjM2LDgwLjY5OSAxNDQuODcsODAuNjk5IDUzLjE5LDAgMTA1LjQ1LC0yMi4wMTYgMTQxLjIyLC02MC41MjcgNDAuMzQsLTQ0LjkzNCA0MS4yNiwtODguMDMyIDQxLjI2LC0xNDMuOTU3IGwgMCwtMTkxLjY1MyA2My4yNywwIDAsLTEwNC41MjcgLTIzOC40LDAgMCwxMDQuNTI3IDYzLjI2LDAgMCwxNTguNjM3IGMgMCwzMC4yNjIgMCw2MS40MzQgLTE5LjI2LDg4LjAzNSAtMjAuMTcsMjYuNTgyIC01My4xOCwzOS40MTQgLTg2LjE5LDM5LjQxNCAtMzMuOTMsMCAtNjguNzcsLTEzLjc1IC04OC45NCwtNDEuMjUgLTIxLjA5LC0yNy41IC0yMS4wOSwtNjkuNjg3IC0yMS4wOSwtMTAyLjcwNyBsIDAsLTE0Mi4xMjkgNjMuMjYsMCAwLC0xMDQuNTI3IC0yMzguNCwwIDAsMTA0LjUyNyA2My4yNywwIDAsMjgwLjU5OCIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDMyIgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSA1MDgyLjQ4LDcwMy45NjUgYyAtMTkuMjQsNzAuNjA1IC04MS42LDExNS41NDcgLTE1NC4wNCwxMTUuNTQ3IC02Ni4wNCwwIC0xMjkuMywtNTEuMzQ4IC0xNDMuMDUsLTExNS41NDcgbCAyOTcuMDksMCB6IG0gODUuMjcsLTE0NC44ODMgYyAtMzguNTEsLTkzLjUyMyAtMTI5LjI3LC0xNTYuNzkzIC0yMzEuMDUsLTE1Ni43OTMgLTE0My4wNywwIC0yNTcuNjgsMTExLjg3MSAtMjU3LjY4LDI1NS44MzYgMCwxNDQuODgzIDEwOS4xMiwyNjEuMzI4IDI1NC45MSwyNjEuMzI4IDY3Ljg3LDAgMTM1LjcyLC0zMC4yNTggMTgzLjM5LC03OC44NjMgNDguNjIsLTUxLjM0NCA2OC43OSwtMTEzLjY5NSA2OC43OSwtMTgzLjM4MyBsIC0zLjY3LC0zOS40MzQgLTM5Ni4xMywwIGMgMTQuNjcsLTY3Ljg2MyA3Ny4wMywtMTE3LjM2MyAxNDYuNzIsLTExNy4zNjMgNDguNTksMCA5MC43NiwxOC4zMjggMTE4LjI4LDU4LjY3MiBsIDExNi40NCwwIgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoMzQiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDY5MC44OTUsODUwLjcwMyA5MC43NSwwIDIyLjU0MywzMS4wMzUgMCwyNDMuMTIyIC0xMzUuODI5LDAgMCwtMjQzLjE0MSAyMi41MzYsLTMxLjAxNiIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDM2IgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSA2MzIuMzk1LDc0Mi4yNTggMjguMDM5LDg2LjMwNCAtMjIuNTUxLDMxLjA0IC0yMzEuMjIzLDc1LjEyOCAtNDEuOTc2LC0xMjkuMTgzIDIzMS4yNTcsLTc1LjEzNyAzNi40NTQsMTEuODQ4IgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoMzgiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDcxNy40NDksNjUzLjEwNSAtNzMuNDEsNTMuMzYgLTM2LjQ4OCwtMTEuODc1IC0xNDIuOTAzLC0xOTYuNjkyIDEwOS44ODMsLTc5LjgyOCAxNDIuOTE4LDE5Ni43MDMgMCwzOC4zMzIiCiAgICAgICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgICAgICAgaWQ9InBhdGg0MCIKICAgICAgICAgICAgIHN0eWxlPSJmaWxsOiM4YTQxODI7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiIC8+PHBhdGgKICAgICAgICAgICAgIGQ9Im0gODI4LjUyLDcwNi40NjUgLTczLjQyNiwtNTMuMzQgMC4wMTEsLTM4LjM1OSBMIDg5OC4wMDQsNDE4LjA3IDEwMDcuOSw0OTcuODk4IDg2NC45NzMsNjk0LjYwOSA4MjguNTIsNzA2LjQ2NSIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDQyIgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSA4MTIuMDg2LDgyOC41ODYgMjguMDU1LC04Ni4zMiAzNi40ODQsLTExLjgzNiAyMzEuMjI1LDc1LjExNyAtNDEuOTcsMTI5LjE4MyAtMjMxLjIzOSwtNzUuMTQgLTIyLjU1NSwtMzEuMDA0IgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoNDQiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDczNi4zMDEsMTMzNS44OCBjIC0zMjMuMDQ3LDAgLTU4NS44NzUsLTI2Mi43OCAtNTg1Ljg3NSwtNTg1Ljc4MiAwLC0zMjMuMTE4IDI2Mi44MjgsLTU4NS45NzcgNTg1Ljg3NSwtNTg1Ljk3NyAzMjMuMDE5LDAgNTg1LjgwOSwyNjIuODU5IDU4NS44MDksNTg1Ljk3NyAwLDMyMy4wMDIgLTI2Mi43OSw1ODUuNzgyIC01ODUuODA5LDU4NS43ODIgbCAwLDAgeiBtIDAsLTExOC42MSBjIDI1Ny45NzIsMCA0NjcuMTg5LC0yMDkuMTMgNDY3LjE4OSwtNDY3LjE3MiAwLC0yNTguMTI5IC0yMDkuMjE3LC00NjcuMzQ4IC00NjcuMTg5LC00NjcuMzQ4IC0yNTguMDc0LDAgLTQ2Ny4yNTQsMjA5LjIxOSAtNDY3LjI1NCw0NjcuMzQ4IDAsMjU4LjA0MiAyMDkuMTgsNDY3LjE3MiA0NjcuMjU0LDQ2Ny4xNzIiCiAgICAgICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgICAgICAgaWQ9InBhdGg0NiIKICAgICAgICAgICAgIHN0eWxlPSJmaWxsOiM4YTQxODI7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiIC8+PHBhdGgKICAgICAgICAgICAgIGQ9Im0gMTA5MS4xMyw2MTkuODgzIC0xNzUuNzcxLDU3LjEyMSAxMS42MjksMzUuODA4IDE3NS43NjIsLTU3LjEyMSAtMTEuNjIsLTM1LjgwOCIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDQ4IgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0iTSA4NjYuOTU3LDkwMi4wNzQgODM2LjUsOTI0LjE5OSA5NDUuMTIxLDEwNzMuNzMgOTc1LjU4NiwxMDUxLjYxIDg2Ni45NTcsOTAyLjA3NCIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDUwIgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0iTSA2MDcuNDY1LDkwMy40NDUgNDk4Ljg1NSwxMDUyLjk3IDUyOS4zMiwxMDc1LjEgNjM3LjkzLDkyNS41NjYgNjA3LjQ2NSw5MDMuNDQ1IgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoNTIiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDM4MC42ODgsNjIyLjEyOSAtMTEuNjI2LDM1LjgwMSAxNzUuNzU4LDU3LjA5IDExLjYyMSwtMzUuODAxIC0xNzUuNzUzLC01Ny4wOSIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDU0IgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSA3MTYuMjg5LDM3Ni41OSAzNy42NDA2LDAgMCwxODQuODE2IC0zNy42NDA2LDAgMCwtMTg0LjgxNiB6IgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoNTYiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjwvZz48L2c+PC9nPjwvZz48L3N2Zz4=') no-repeat, none; -moz-background-size: 100%; -o-background-size: 100%; -webkit-background-size: 100%; background-size: 100%; display: block; float: left; width: 90px; height: 25px; }\n.jasmine_html-reporter .jasmine-banner .jasmine-version { margin-left: 14px; position: relative; top: 6px; }\n.jasmine_html-reporter #jasmine_content { position: fixed; right: 100%; }\n.jasmine_html-reporter .jasmine-version { color: #aaa; }\n.jasmine_html-reporter .jasmine-banner { margin-top: 14px; }\n.jasmine_html-reporter .jasmine-duration { color: #fff; float: right; line-height: 28px; padding-right: 9px; }\n.jasmine_html-reporter .jasmine-symbol-summary { overflow: hidden; *zoom: 1; margin: 14px 0; }\n.jasmine_html-reporter .jasmine-symbol-summary li { display: inline-block; height: 10px; width: 14px; font-size: 16px; }\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-passed { font-size: 14px; }\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-passed:before { color: #007069; content: \"\\2022\"; }\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-failed { line-height: 9px; }\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-failed:before { color: #ca3a11; content: \"\\D7\"; font-weight: bold; margin-left: -1px; }\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-disabled { font-size: 14px; }\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-disabled:before { color: #bababa; content: \"\\2022\"; }\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-pending { line-height: 17px; }\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-pending:before { color: #ba9d37; content: \"*\"; }\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-empty { font-size: 14px; }\n.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-empty:before { color: #ba9d37; content: \"\\2022\"; }\n.jasmine_html-reporter .jasmine-run-options { float: right; margin-right: 5px; border: 1px solid #8a4182; color: #8a4182; position: relative; line-height: 20px; }\n.jasmine_html-reporter .jasmine-run-options .jasmine-trigger { cursor: pointer; padding: 8px 16px; }\n.jasmine_html-reporter .jasmine-run-options .jasmine-payload { position: absolute; display: none; right: -1px; border: 1px solid #8a4182; background-color: #eee; white-space: nowrap; padding: 4px 8px; }\n.jasmine_html-reporter .jasmine-run-options .jasmine-payload.jasmine-open { display: block; }\n.jasmine_html-reporter .jasmine-bar { line-height: 28px; font-size: 14px; display: block; color: #eee; }\n.jasmine_html-reporter .jasmine-bar.jasmine-failed { background-color: #ca3a11; }\n.jasmine_html-reporter .jasmine-bar.jasmine-passed { background-color: #007069; }\n.jasmine_html-reporter .jasmine-bar.jasmine-skipped { background-color: #bababa; }\n.jasmine_html-reporter .jasmine-bar.jasmine-errored { background-color: #ca3a11; }\n.jasmine_html-reporter .jasmine-bar.jasmine-menu { background-color: #fff; color: #aaa; }\n.jasmine_html-reporter .jasmine-bar.jasmine-menu a { color: #333; }\n.jasmine_html-reporter .jasmine-bar a { color: white; }\n.jasmine_html-reporter.jasmine-spec-list .jasmine-bar.jasmine-menu.jasmine-failure-list, .jasmine_html-reporter.jasmine-spec-list .jasmine-results .jasmine-failures { display: none; }\n.jasmine_html-reporter.jasmine-failure-list .jasmine-bar.jasmine-menu.jasmine-spec-list, .jasmine_html-reporter.jasmine-failure-list .jasmine-summary { display: none; }\n.jasmine_html-reporter .jasmine-results { margin-top: 14px; }\n.jasmine_html-reporter .jasmine-summary { margin-top: 14px; }\n.jasmine_html-reporter .jasmine-summary ul { list-style-type: none; margin-left: 14px; padding-top: 0; padding-left: 0; }\n.jasmine_html-reporter .jasmine-summary ul.jasmine-suite { margin-top: 7px; margin-bottom: 7px; }\n.jasmine_html-reporter .jasmine-summary li.jasmine-passed a { color: #007069; }\n.jasmine_html-reporter .jasmine-summary li.jasmine-failed a { color: #ca3a11; }\n.jasmine_html-reporter .jasmine-summary li.jasmine-empty a { color: #ba9d37; }\n.jasmine_html-reporter .jasmine-summary li.jasmine-pending a { color: #ba9d37; }\n.jasmine_html-reporter .jasmine-summary li.jasmine-disabled a { color: #bababa; }\n.jasmine_html-reporter .jasmine-description + .jasmine-suite { margin-top: 0; }\n.jasmine_html-reporter .jasmine-suite { margin-top: 14px; }\n.jasmine_html-reporter .jasmine-suite a { color: #333; }\n.jasmine_html-reporter .jasmine-failures .jasmine-spec-detail { margin-bottom: 28px; }\n.jasmine_html-reporter .jasmine-failures .jasmine-spec-detail .jasmine-description { background-color: #ca3a11; }\n.jasmine_html-reporter .jasmine-failures .jasmine-spec-detail .jasmine-description a { color: white; }\n.jasmine_html-reporter .jasmine-result-message { padding-top: 14px; color: #333; white-space: pre; }\n.jasmine_html-reporter .jasmine-result-message span.jasmine-result { display: block; }\n.jasmine_html-reporter .jasmine-stack-trace { margin: 5px 0 0 0; max-height: 224px; overflow: auto; line-height: 18px; color: #666; border: 1px solid #ddd; background: white; white-space: pre; }\n", ""]);
	
	// exports


/***/ },
/* 3 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	// css base code, injected by the css-loader
	module.exports = function() {
		var list = [];
	
		// return the list of modules as css string
		list.toString = function toString() {
			var result = [];
			for(var i = 0; i < this.length; i++) {
				var item = this[i];
				if(item[2]) {
					result.push("@media " + item[2] + "{" + item[1] + "}");
				} else {
					result.push(item[1]);
				}
			}
			return result.join("");
		};
	
		// import a list of modules into the list
		list.i = function(modules, mediaQuery) {
			if(typeof modules === "string")
				modules = [[null, modules, ""]];
			var alreadyImportedModules = {};
			for(var i = 0; i < this.length; i++) {
				var id = this[i][0];
				if(typeof id === "number")
					alreadyImportedModules[id] = true;
			}
			for(i = 0; i < modules.length; i++) {
				var item = modules[i];
				// skip already imported module
				// this implementation is not 100% perfect for weird media query combinations
				//  when a module is imported multiple times with different media queries.
				//  I hope this will never occur (Hey this way we have smaller bundles)
				if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
					if(mediaQuery && !item[2]) {
						item[2] = mediaQuery;
					} else if(mediaQuery) {
						item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
					}
					list.push(item);
				}
			}
		};
		return list;
	};


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var stylesInDom = {},
		memoize = function(fn) {
			var memo;
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		},
		isOldIE = memoize(function() {
			return /msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase());
		}),
		getHeadElement = memoize(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		singletonElement = null,
		singletonCounter = 0,
		styleElementsInsertedAtTop = [];
	
	module.exports = function(list, options) {
		if(false) {
			if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}
	
		options = options || {};
		// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (typeof options.singleton === "undefined") options.singleton = isOldIE();
	
		// By default, add <style> tags to the bottom of <head>.
		if (typeof options.insertAt === "undefined") options.insertAt = "bottom";
	
		var styles = listToStyles(list);
		addStylesToDom(styles, options);
	
		return function update(newList) {
			var mayRemove = [];
			for(var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
			if(newList) {
				var newStyles = listToStyles(newList);
				addStylesToDom(newStyles, options);
			}
			for(var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
				if(domStyle.refs === 0) {
					for(var j = 0; j < domStyle.parts.length; j++)
						domStyle.parts[j]();
					delete stylesInDom[domStyle.id];
				}
			}
		};
	}
	
	function addStylesToDom(styles, options) {
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			if(domStyle) {
				domStyle.refs++;
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}
	
	function listToStyles(list) {
		var styles = [];
		var newStyles = {};
		for(var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
			if(!newStyles[id])
				styles.push(newStyles[id] = {id: id, parts: [part]});
			else
				newStyles[id].parts.push(part);
		}
		return styles;
	}
	
	function insertStyleElement(options, styleElement) {
		var head = getHeadElement();
		var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
		if (options.insertAt === "top") {
			if(!lastStyleElementInsertedAtTop) {
				head.insertBefore(styleElement, head.firstChild);
			} else if(lastStyleElementInsertedAtTop.nextSibling) {
				head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
			} else {
				head.appendChild(styleElement);
			}
			styleElementsInsertedAtTop.push(styleElement);
		} else if (options.insertAt === "bottom") {
			head.appendChild(styleElement);
		} else {
			throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
		}
	}
	
	function removeStyleElement(styleElement) {
		styleElement.parentNode.removeChild(styleElement);
		var idx = styleElementsInsertedAtTop.indexOf(styleElement);
		if(idx >= 0) {
			styleElementsInsertedAtTop.splice(idx, 1);
		}
	}
	
	function createStyleElement(options) {
		var styleElement = document.createElement("style");
		styleElement.type = "text/css";
		insertStyleElement(options, styleElement);
		return styleElement;
	}
	
	function createLinkElement(options) {
		var linkElement = document.createElement("link");
		linkElement.rel = "stylesheet";
		insertStyleElement(options, linkElement);
		return linkElement;
	}
	
	function addStyle(obj, options) {
		var styleElement, update, remove;
	
		if (options.singleton) {
			var styleIndex = singletonCounter++;
			styleElement = singletonElement || (singletonElement = createStyleElement(options));
			update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
			remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
		} else if(obj.sourceMap &&
			typeof URL === "function" &&
			typeof URL.createObjectURL === "function" &&
			typeof URL.revokeObjectURL === "function" &&
			typeof Blob === "function" &&
			typeof btoa === "function") {
			styleElement = createLinkElement(options);
			update = updateLink.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
				if(styleElement.href)
					URL.revokeObjectURL(styleElement.href);
			};
		} else {
			styleElement = createStyleElement(options);
			update = applyToTag.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
			};
		}
	
		update(obj);
	
		return function updateStyle(newObj) {
			if(newObj) {
				if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
					return;
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}
	
	var replaceText = (function () {
		var textStore = [];
	
		return function (index, replacement) {
			textStore[index] = replacement;
			return textStore.filter(Boolean).join('\n');
		};
	})();
	
	function applyToSingletonTag(styleElement, index, remove, obj) {
		var css = remove ? "" : obj.css;
	
		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = replaceText(index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = styleElement.childNodes;
			if (childNodes[index]) styleElement.removeChild(childNodes[index]);
			if (childNodes.length) {
				styleElement.insertBefore(cssNode, childNodes[index]);
			} else {
				styleElement.appendChild(cssNode);
			}
		}
	}
	
	function applyToTag(styleElement, obj) {
		var css = obj.css;
		var media = obj.media;
		var sourceMap = obj.sourceMap;
	
		if(media) {
			styleElement.setAttribute("media", media)
		}
	
		if(styleElement.styleSheet) {
			styleElement.styleSheet.cssText = css;
		} else {
			while(styleElement.firstChild) {
				styleElement.removeChild(styleElement.firstChild);
			}
			styleElement.appendChild(document.createTextNode(css));
		}
	}
	
	function updateLink(linkElement, obj) {
		var css = obj.css;
		var media = obj.media;
		var sourceMap = obj.sourceMap;
	
		if(sourceMap) {
			// http://stackoverflow.com/a/26603875
			css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
		}
	
		var blob = new Blob([css], { type: "text/css" });
	
		var oldSrc = linkElement.href;
	
		linkElement.href = URL.createObjectURL(blob);
	
		if(oldSrc)
			URL.revokeObjectURL(oldSrc);
	}


/***/ },
/* 5 */
/***/ function(module, exports) {

	"use strict";
	
	beforeEach(function () {
	    jasmine.addMatchers({
	        toHaveLength: makeMatcherFactory(function (actual) {
	            return actual.length;
	        })
	    });
	});
	
	function makeMatcherFactory(fn) {
	    return function (util, customEqualityTesters) {
	        return {
	            compare: function compare(actual, expected) {
	                return { pass: util.equals(fn(actual), expected, customEqualityTesters) };
	            }
	        };
	    };
	}

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * https://github.com/es-shims/es5-shim
	 * @license es5-shim Copyright 2009-2015 by contributors, MIT License
	 * see https://github.com/es-shims/es5-shim/blob/master/LICENSE
	 */
	
	// vim: ts=4 sts=4 sw=4 expandtab
	
	// Add semicolon to prevent IIFE from being passed as argument to concatenated code.
	;
	
	// UMD (Universal Module Definition)
	// see https://github.com/umdjs/umd/blob/master/returnExports.js
	(function (root, factory) {
	    'use strict';
	
	    /* global define, exports, module */
	    if (true) {
	        // AMD. Register as an anonymous module.
	        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof exports === 'object') {
	        // Node. Does not work with strict CommonJS, but
	        // only CommonJS-like enviroments that support module.exports,
	        // like Node.
	        module.exports = factory();
	    } else {
	        // Browser globals (root is window)
	        root.returnExports = factory();
	    }
	}(this, function () {
	
	/**
	 * Brings an environment as close to ECMAScript 5 compliance
	 * as is possible with the facilities of erstwhile engines.
	 *
	 * Annotated ES5: http://es5.github.com/ (specific links below)
	 * ES5 Spec: http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf
	 * Required reading: http://javascriptweblog.wordpress.com/2011/12/05/extending-javascript-natives/
	 */
	
	// Shortcut to an often accessed properties, in order to avoid multiple
	// dereference that costs universally. This also holds a reference to known-good
	// functions.
	var $Array = Array;
	var ArrayPrototype = $Array.prototype;
	var $Object = Object;
	var ObjectPrototype = $Object.prototype;
	var FunctionPrototype = Function.prototype;
	var $String = String;
	var StringPrototype = $String.prototype;
	var $Number = Number;
	var NumberPrototype = $Number.prototype;
	var array_slice = ArrayPrototype.slice;
	var array_splice = ArrayPrototype.splice;
	var array_push = ArrayPrototype.push;
	var array_unshift = ArrayPrototype.unshift;
	var array_concat = ArrayPrototype.concat;
	var call = FunctionPrototype.call;
	var max = Math.max;
	var min = Math.min;
	
	// Having a toString local variable name breaks in Opera so use to_string.
	var to_string = ObjectPrototype.toString;
	
	var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';
	var isCallable; /* inlined from https://npmjs.com/is-callable */ var fnToStr = Function.prototype.toString, tryFunctionObject = function tryFunctionObject(value) { try { fnToStr.call(value); return true; } catch (e) { return false; } }, fnClass = '[object Function]', genClass = '[object GeneratorFunction]'; isCallable = function isCallable(value) { if (typeof value !== 'function') { return false; } if (hasToStringTag) { return tryFunctionObject(value); } var strClass = to_string.call(value); return strClass === fnClass || strClass === genClass; };
	var isRegex; /* inlined from https://npmjs.com/is-regex */ var regexExec = RegExp.prototype.exec, tryRegexExec = function tryRegexExec(value) { try { regexExec.call(value); return true; } catch (e) { return false; } }, regexClass = '[object RegExp]'; isRegex = function isRegex(value) { if (typeof value !== 'object') { return false; } return hasToStringTag ? tryRegexExec(value) : to_string.call(value) === regexClass; };
	var isString; /* inlined from https://npmjs.com/is-string */ var strValue = String.prototype.valueOf, tryStringObject = function tryStringObject(value) { try { strValue.call(value); return true; } catch (e) { return false; } }, stringClass = '[object String]'; isString = function isString(value) { if (typeof value === 'string') { return true; } if (typeof value !== 'object') { return false; } return hasToStringTag ? tryStringObject(value) : to_string.call(value) === stringClass; };
	
	/* inlined from http://npmjs.com/define-properties */
	var defineProperties = (function (has) {
	  var supportsDescriptors = $Object.defineProperty && (function () {
	      try {
	          var obj = {};
	          $Object.defineProperty(obj, 'x', { enumerable: false, value: obj });
	          for (var _ in obj) { return false; }
	          return obj.x === obj;
	      } catch (e) { /* this is ES3 */
	          return false;
	      }
	  }());
	
	  // Define configurable, writable and non-enumerable props
	  // if they don't exist.
	  var defineProperty;
	  if (supportsDescriptors) {
	      defineProperty = function (object, name, method, forceAssign) {
	          if (!forceAssign && (name in object)) { return; }
	          $Object.defineProperty(object, name, {
	              configurable: true,
	              enumerable: false,
	              writable: true,
	              value: method
	          });
	      };
	  } else {
	      defineProperty = function (object, name, method, forceAssign) {
	          if (!forceAssign && (name in object)) { return; }
	          object[name] = method;
	      };
	  }
	  return function defineProperties(object, map, forceAssign) {
	      for (var name in map) {
	          if (has.call(map, name)) {
	            defineProperty(object, name, map[name], forceAssign);
	          }
	      }
	  };
	}(ObjectPrototype.hasOwnProperty));
	
	//
	// Util
	// ======
	//
	
	/* replaceable with https://npmjs.com/package/es-abstract /helpers/isPrimitive */
	var isPrimitive = function isPrimitive(input) {
	    var type = typeof input;
	    return input === null || (type !== 'object' && type !== 'function');
	};
	
	var isActualNaN = $Number.isNaN || function (x) { return x !== x; };
	
	var ES = {
	    // ES5 9.4
	    // http://es5.github.com/#x9.4
	    // http://jsperf.com/to-integer
	    /* replaceable with https://npmjs.com/package/es-abstract ES5.ToInteger */
	    ToInteger: function ToInteger(num) {
	        var n = +num;
	        if (isActualNaN(n)) {
	            n = 0;
	        } else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {
	            n = (n > 0 || -1) * Math.floor(Math.abs(n));
	        }
	        return n;
	    },
	
	    /* replaceable with https://npmjs.com/package/es-abstract ES5.ToPrimitive */
	    ToPrimitive: function ToPrimitive(input) {
	        var val, valueOf, toStr;
	        if (isPrimitive(input)) {
	            return input;
	        }
	        valueOf = input.valueOf;
	        if (isCallable(valueOf)) {
	            val = valueOf.call(input);
	            if (isPrimitive(val)) {
	                return val;
	            }
	        }
	        toStr = input.toString;
	        if (isCallable(toStr)) {
	            val = toStr.call(input);
	            if (isPrimitive(val)) {
	                return val;
	            }
	        }
	        throw new TypeError();
	    },
	
	    // ES5 9.9
	    // http://es5.github.com/#x9.9
	    /* replaceable with https://npmjs.com/package/es-abstract ES5.ToObject */
	    ToObject: function (o) {
	        /* jshint eqnull: true */
	        if (o == null) { // this matches both null and undefined
	            throw new TypeError("can't convert " + o + ' to object');
	        }
	        return $Object(o);
	    },
	
	    /* replaceable with https://npmjs.com/package/es-abstract ES5.ToUint32 */
	    ToUint32: function ToUint32(x) {
	        return x >>> 0;
	    }
	};
	
	//
	// Function
	// ========
	//
	
	// ES-5 15.3.4.5
	// http://es5.github.com/#x15.3.4.5
	
	var Empty = function Empty() {};
	
	defineProperties(FunctionPrototype, {
	    bind: function bind(that) { // .length is 1
	        // 1. Let Target be the this value.
	        var target = this;
	        // 2. If IsCallable(Target) is false, throw a TypeError exception.
	        if (!isCallable(target)) {
	            throw new TypeError('Function.prototype.bind called on incompatible ' + target);
	        }
	        // 3. Let A be a new (possibly empty) internal list of all of the
	        //   argument values provided after thisArg (arg1, arg2 etc), in order.
	        // XXX slicedArgs will stand in for "A" if used
	        var args = array_slice.call(arguments, 1); // for normal call
	        // 4. Let F be a new native ECMAScript object.
	        // 11. Set the [[Prototype]] internal property of F to the standard
	        //   built-in Function prototype object as specified in 15.3.3.1.
	        // 12. Set the [[Call]] internal property of F as described in
	        //   15.3.4.5.1.
	        // 13. Set the [[Construct]] internal property of F as described in
	        //   15.3.4.5.2.
	        // 14. Set the [[HasInstance]] internal property of F as described in
	        //   15.3.4.5.3.
	        var bound;
	        var binder = function () {
	
	            if (this instanceof bound) {
	                // 15.3.4.5.2 [[Construct]]
	                // When the [[Construct]] internal method of a function object,
	                // F that was created using the bind function is called with a
	                // list of arguments ExtraArgs, the following steps are taken:
	                // 1. Let target be the value of F's [[TargetFunction]]
	                //   internal property.
	                // 2. If target has no [[Construct]] internal method, a
	                //   TypeError exception is thrown.
	                // 3. Let boundArgs be the value of F's [[BoundArgs]] internal
	                //   property.
	                // 4. Let args be a new list containing the same values as the
	                //   list boundArgs in the same order followed by the same
	                //   values as the list ExtraArgs in the same order.
	                // 5. Return the result of calling the [[Construct]] internal
	                //   method of target providing args as the arguments.
	
	                var result = target.apply(
	                    this,
	                    array_concat.call(args, array_slice.call(arguments))
	                );
	                if ($Object(result) === result) {
	                    return result;
	                }
	                return this;
	
	            } else {
	                // 15.3.4.5.1 [[Call]]
	                // When the [[Call]] internal method of a function object, F,
	                // which was created using the bind function is called with a
	                // this value and a list of arguments ExtraArgs, the following
	                // steps are taken:
	                // 1. Let boundArgs be the value of F's [[BoundArgs]] internal
	                //   property.
	                // 2. Let boundThis be the value of F's [[BoundThis]] internal
	                //   property.
	                // 3. Let target be the value of F's [[TargetFunction]] internal
	                //   property.
	                // 4. Let args be a new list containing the same values as the
	                //   list boundArgs in the same order followed by the same
	                //   values as the list ExtraArgs in the same order.
	                // 5. Return the result of calling the [[Call]] internal method
	                //   of target providing boundThis as the this value and
	                //   providing args as the arguments.
	
	                // equiv: target.call(this, ...boundArgs, ...args)
	                return target.apply(
	                    that,
	                    array_concat.call(args, array_slice.call(arguments))
	                );
	
	            }
	
	        };
	
	        // 15. If the [[Class]] internal property of Target is "Function", then
	        //     a. Let L be the length property of Target minus the length of A.
	        //     b. Set the length own property of F to either 0 or L, whichever is
	        //       larger.
	        // 16. Else set the length own property of F to 0.
	
	        var boundLength = max(0, target.length - args.length);
	
	        // 17. Set the attributes of the length own property of F to the values
	        //   specified in 15.3.5.1.
	        var boundArgs = [];
	        for (var i = 0; i < boundLength; i++) {
	            array_push.call(boundArgs, '$' + i);
	        }
	
	        // XXX Build a dynamic function with desired amount of arguments is the only
	        // way to set the length property of a function.
	        // In environments where Content Security Policies enabled (Chrome extensions,
	        // for ex.) all use of eval or Function costructor throws an exception.
	        // However in all of these environments Function.prototype.bind exists
	        // and so this code will never be executed.
	        bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this, arguments); }')(binder);
	
	        if (target.prototype) {
	            Empty.prototype = target.prototype;
	            bound.prototype = new Empty();
	            // Clean up dangling references.
	            Empty.prototype = null;
	        }
	
	        // TODO
	        // 18. Set the [[Extensible]] internal property of F to true.
	
	        // TODO
	        // 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).
	        // 20. Call the [[DefineOwnProperty]] internal method of F with
	        //   arguments "caller", PropertyDescriptor {[[Get]]: thrower, [[Set]]:
	        //   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and
	        //   false.
	        // 21. Call the [[DefineOwnProperty]] internal method of F with
	        //   arguments "arguments", PropertyDescriptor {[[Get]]: thrower,
	        //   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},
	        //   and false.
	
	        // TODO
	        // NOTE Function objects created using Function.prototype.bind do not
	        // have a prototype property or the [[Code]], [[FormalParameters]], and
	        // [[Scope]] internal properties.
	        // XXX can't delete prototype in pure-js.
	
	        // 22. Return F.
	        return bound;
	    }
	});
	
	// _Please note: Shortcuts are defined after `Function.prototype.bind` as we
	// us it in defining shortcuts.
	var owns = call.bind(ObjectPrototype.hasOwnProperty);
	var toStr = call.bind(ObjectPrototype.toString);
	var strSlice = call.bind(StringPrototype.slice);
	var strSplit = call.bind(StringPrototype.split);
	var strIndexOf = call.bind(StringPrototype.indexOf);
	var push = call.bind(array_push);
	
	//
	// Array
	// =====
	//
	
	var isArray = $Array.isArray || function isArray(obj) {
	    return toStr(obj) === '[object Array]';
	};
	
	// ES5 15.4.4.12
	// http://es5.github.com/#x15.4.4.13
	// Return len+argCount.
	// [bugfix, ielt8]
	// IE < 8 bug: [].unshift(0) === undefined but should be "1"
	var hasUnshiftReturnValueBug = [].unshift(0) !== 1;
	defineProperties(ArrayPrototype, {
	    unshift: function () {
	        array_unshift.apply(this, arguments);
	        return this.length;
	    }
	}, hasUnshiftReturnValueBug);
	
	// ES5 15.4.3.2
	// http://es5.github.com/#x15.4.3.2
	// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray
	defineProperties($Array, { isArray: isArray });
	
	// The IsCallable() check in the Array functions
	// has been replaced with a strict check on the
	// internal class of the object to trap cases where
	// the provided function was actually a regular
	// expression literal, which in V8 and
	// JavaScriptCore is a typeof "function".  Only in
	// V8 are regular expression literals permitted as
	// reduce parameters, so it is desirable in the
	// general case for the shim to match the more
	// strict and common behavior of rejecting regular
	// expressions.
	
	// ES5 15.4.4.18
	// http://es5.github.com/#x15.4.4.18
	// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/array/forEach
	
	// Check failure of by-index access of string characters (IE < 9)
	// and failure of `0 in boxedString` (Rhino)
	var boxedString = $Object('a');
	var splitString = boxedString[0] !== 'a' || !(0 in boxedString);
	
	var properlyBoxesContext = function properlyBoxed(method) {
	    // Check node 0.6.21 bug where third parameter is not boxed
	    var properlyBoxesNonStrict = true;
	    var properlyBoxesStrict = true;
	    if (method) {
	        method.call('foo', function (_, __, context) {
	            if (typeof context !== 'object') { properlyBoxesNonStrict = false; }
	        });
	
	        method.call([1], function () {
	            'use strict';
	
	            properlyBoxesStrict = typeof this === 'string';
	        }, 'x');
	    }
	    return !!method && properlyBoxesNonStrict && properlyBoxesStrict;
	};
	
	defineProperties(ArrayPrototype, {
	    forEach: function forEach(callbackfn/*, thisArg*/) {
	        var object = ES.ToObject(this);
	        var self = splitString && isString(this) ? strSplit(this, '') : object;
	        var i = -1;
	        var length = ES.ToUint32(self.length);
	        var T;
	        if (arguments.length > 1) {
	          T = arguments[1];
	        }
	
	        // If no callback function or if callback is not a callable function
	        if (!isCallable(callbackfn)) {
	            throw new TypeError('Array.prototype.forEach callback must be a function');
	        }
	
	        while (++i < length) {
	            if (i in self) {
	                // Invoke the callback function with call, passing arguments:
	                // context, property value, property key, thisArg object
	                if (typeof T === 'undefined') {
	                    callbackfn(self[i], i, object);
	                } else {
	                    callbackfn.call(T, self[i], i, object);
	                }
	            }
	        }
	    }
	}, !properlyBoxesContext(ArrayPrototype.forEach));
	
	// ES5 15.4.4.19
	// http://es5.github.com/#x15.4.4.19
	// https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map
	defineProperties(ArrayPrototype, {
	    map: function map(callbackfn/*, thisArg*/) {
	        var object = ES.ToObject(this);
	        var self = splitString && isString(this) ? strSplit(this, '') : object;
	        var length = ES.ToUint32(self.length);
	        var result = $Array(length);
	        var T;
	        if (arguments.length > 1) {
	            T = arguments[1];
	        }
	
	        // If no callback function or if callback is not a callable function
	        if (!isCallable(callbackfn)) {
	            throw new TypeError('Array.prototype.map callback must be a function');
	        }
	
	        for (var i = 0; i < length; i++) {
	            if (i in self) {
	                if (typeof T === 'undefined') {
	                    result[i] = callbackfn(self[i], i, object);
	                } else {
	                    result[i] = callbackfn.call(T, self[i], i, object);
	                }
	            }
	        }
	        return result;
	    }
	}, !properlyBoxesContext(ArrayPrototype.map));
	
	// ES5 15.4.4.20
	// http://es5.github.com/#x15.4.4.20
	// https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter
	defineProperties(ArrayPrototype, {
	    filter: function filter(callbackfn/*, thisArg*/) {
	        var object = ES.ToObject(this);
	        var self = splitString && isString(this) ? strSplit(this, '') : object;
	        var length = ES.ToUint32(self.length);
	        var result = [];
	        var value;
	        var T;
	        if (arguments.length > 1) {
	            T = arguments[1];
	        }
	
	        // If no callback function or if callback is not a callable function
	        if (!isCallable(callbackfn)) {
	            throw new TypeError('Array.prototype.filter callback must be a function');
	        }
	
	        for (var i = 0; i < length; i++) {
	            if (i in self) {
	                value = self[i];
	                if (typeof T === 'undefined' ? callbackfn(value, i, object) : callbackfn.call(T, value, i, object)) {
	                    push(result, value);
	                }
	            }
	        }
	        return result;
	    }
	}, !properlyBoxesContext(ArrayPrototype.filter));
	
	// ES5 15.4.4.16
	// http://es5.github.com/#x15.4.4.16
	// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/every
	defineProperties(ArrayPrototype, {
	    every: function every(callbackfn/*, thisArg*/) {
	        var object = ES.ToObject(this);
	        var self = splitString && isString(this) ? strSplit(this, '') : object;
	        var length = ES.ToUint32(self.length);
	        var T;
	        if (arguments.length > 1) {
	            T = arguments[1];
	        }
	
	        // If no callback function or if callback is not a callable function
	        if (!isCallable(callbackfn)) {
	            throw new TypeError('Array.prototype.every callback must be a function');
	        }
	
	        for (var i = 0; i < length; i++) {
	            if (i in self && !(typeof T === 'undefined' ? callbackfn(self[i], i, object) : callbackfn.call(T, self[i], i, object))) {
	                return false;
	            }
	        }
	        return true;
	    }
	}, !properlyBoxesContext(ArrayPrototype.every));
	
	// ES5 15.4.4.17
	// http://es5.github.com/#x15.4.4.17
	// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/some
	defineProperties(ArrayPrototype, {
	    some: function some(callbackfn/*, thisArg */) {
	        var object = ES.ToObject(this);
	        var self = splitString && isString(this) ? strSplit(this, '') : object;
	        var length = ES.ToUint32(self.length);
	        var T;
	        if (arguments.length > 1) {
	            T = arguments[1];
	        }
	
	        // If no callback function or if callback is not a callable function
	        if (!isCallable(callbackfn)) {
	            throw new TypeError('Array.prototype.some callback must be a function');
	        }
	
	        for (var i = 0; i < length; i++) {
	            if (i in self && (typeof T === 'undefined' ? callbackfn(self[i], i, object) : callbackfn.call(T, self[i], i, object))) {
	                return true;
	            }
	        }
	        return false;
	    }
	}, !properlyBoxesContext(ArrayPrototype.some));
	
	// ES5 15.4.4.21
	// http://es5.github.com/#x15.4.4.21
	// https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/reduce
	var reduceCoercesToObject = false;
	if (ArrayPrototype.reduce) {
	    reduceCoercesToObject = typeof ArrayPrototype.reduce.call('es5', function (_, __, ___, list) { return list; }) === 'object';
	}
	defineProperties(ArrayPrototype, {
	    reduce: function reduce(callbackfn/*, initialValue*/) {
	        var object = ES.ToObject(this);
	        var self = splitString && isString(this) ? strSplit(this, '') : object;
	        var length = ES.ToUint32(self.length);
	
	        // If no callback function or if callback is not a callable function
	        if (!isCallable(callbackfn)) {
	            throw new TypeError('Array.prototype.reduce callback must be a function');
	        }
	
	        // no value to return if no initial value and an empty array
	        if (length === 0 && arguments.length === 1) {
	            throw new TypeError('reduce of empty array with no initial value');
	        }
	
	        var i = 0;
	        var result;
	        if (arguments.length >= 2) {
	            result = arguments[1];
	        } else {
	            do {
	                if (i in self) {
	                    result = self[i++];
	                    break;
	                }
	
	                // if array contains no values, no initial value to return
	                if (++i >= length) {
	                    throw new TypeError('reduce of empty array with no initial value');
	                }
	            } while (true);
	        }
	
	        for (; i < length; i++) {
	            if (i in self) {
	                result = callbackfn(result, self[i], i, object);
	            }
	        }
	
	        return result;
	    }
	}, !reduceCoercesToObject);
	
	// ES5 15.4.4.22
	// http://es5.github.com/#x15.4.4.22
	// https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/reduceRight
	var reduceRightCoercesToObject = false;
	if (ArrayPrototype.reduceRight) {
	    reduceRightCoercesToObject = typeof ArrayPrototype.reduceRight.call('es5', function (_, __, ___, list) { return list; }) === 'object';
	}
	defineProperties(ArrayPrototype, {
	    reduceRight: function reduceRight(callbackfn/*, initial*/) {
	        var object = ES.ToObject(this);
	        var self = splitString && isString(this) ? strSplit(this, '') : object;
	        var length = ES.ToUint32(self.length);
	
	        // If no callback function or if callback is not a callable function
	        if (!isCallable(callbackfn)) {
	            throw new TypeError('Array.prototype.reduceRight callback must be a function');
	        }
	
	        // no value to return if no initial value, empty array
	        if (length === 0 && arguments.length === 1) {
	            throw new TypeError('reduceRight of empty array with no initial value');
	        }
	
	        var result;
	        var i = length - 1;
	        if (arguments.length >= 2) {
	            result = arguments[1];
	        } else {
	            do {
	                if (i in self) {
	                    result = self[i--];
	                    break;
	                }
	
	                // if array contains no values, no initial value to return
	                if (--i < 0) {
	                    throw new TypeError('reduceRight of empty array with no initial value');
	                }
	            } while (true);
	        }
	
	        if (i < 0) {
	            return result;
	        }
	
	        do {
	            if (i in self) {
	                result = callbackfn(result, self[i], i, object);
	            }
	        } while (i--);
	
	        return result;
	    }
	}, !reduceRightCoercesToObject);
	
	// ES5 15.4.4.14
	// http://es5.github.com/#x15.4.4.14
	// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf
	var hasFirefox2IndexOfBug = ArrayPrototype.indexOf && [0, 1].indexOf(1, 2) !== -1;
	defineProperties(ArrayPrototype, {
	    indexOf: function indexOf(searchElement/*, fromIndex */) {
	        var self = splitString && isString(this) ? strSplit(this, '') : ES.ToObject(this);
	        var length = ES.ToUint32(self.length);
	
	        if (length === 0) {
	            return -1;
	        }
	
	        var i = 0;
	        if (arguments.length > 1) {
	            i = ES.ToInteger(arguments[1]);
	        }
	
	        // handle negative indices
	        i = i >= 0 ? i : max(0, length + i);
	        for (; i < length; i++) {
	            if (i in self && self[i] === searchElement) {
	                return i;
	            }
	        }
	        return -1;
	    }
	}, hasFirefox2IndexOfBug);
	
	// ES5 15.4.4.15
	// http://es5.github.com/#x15.4.4.15
	// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/lastIndexOf
	var hasFirefox2LastIndexOfBug = ArrayPrototype.lastIndexOf && [0, 1].lastIndexOf(0, -3) !== -1;
	defineProperties(ArrayPrototype, {
	    lastIndexOf: function lastIndexOf(searchElement/*, fromIndex */) {
	        var self = splitString && isString(this) ? strSplit(this, '') : ES.ToObject(this);
	        var length = ES.ToUint32(self.length);
	
	        if (length === 0) {
	            return -1;
	        }
	        var i = length - 1;
	        if (arguments.length > 1) {
	            i = min(i, ES.ToInteger(arguments[1]));
	        }
	        // handle negative indices
	        i = i >= 0 ? i : length - Math.abs(i);
	        for (; i >= 0; i--) {
	            if (i in self && searchElement === self[i]) {
	                return i;
	            }
	        }
	        return -1;
	    }
	}, hasFirefox2LastIndexOfBug);
	
	// ES5 15.4.4.12
	// http://es5.github.com/#x15.4.4.12
	var spliceNoopReturnsEmptyArray = (function () {
	    var a = [1, 2];
	    var result = a.splice();
	    return a.length === 2 && isArray(result) && result.length === 0;
	}());
	defineProperties(ArrayPrototype, {
	    // Safari 5.0 bug where .splice() returns undefined
	    splice: function splice(start, deleteCount) {
	        if (arguments.length === 0) {
	            return [];
	        } else {
	            return array_splice.apply(this, arguments);
	        }
	    }
	}, !spliceNoopReturnsEmptyArray);
	
	var spliceWorksWithEmptyObject = (function () {
	    var obj = {};
	    ArrayPrototype.splice.call(obj, 0, 0, 1);
	    return obj.length === 1;
	}());
	defineProperties(ArrayPrototype, {
	    splice: function splice(start, deleteCount) {
	        if (arguments.length === 0) { return []; }
	        var args = arguments;
	        this.length = max(ES.ToInteger(this.length), 0);
	        if (arguments.length > 0 && typeof deleteCount !== 'number') {
	            args = array_slice.call(arguments);
	            if (args.length < 2) {
	                push(args, this.length - start);
	            } else {
	                args[1] = ES.ToInteger(deleteCount);
	            }
	        }
	        return array_splice.apply(this, args);
	    }
	}, !spliceWorksWithEmptyObject);
	var spliceWorksWithLargeSparseArrays = (function () {
	    // Per https://github.com/es-shims/es5-shim/issues/295
	    // Safari 7/8 breaks with sparse arrays of size 1e5 or greater
	    var arr = new $Array(1e5);
	    // note: the index MUST be 8 or larger or the test will false pass
	    arr[8] = 'x';
	    arr.splice(1, 1);
	    // note: this test must be defined *after* the indexOf shim
	    // per https://github.com/es-shims/es5-shim/issues/313
	    return arr.indexOf('x') === 7;
	}());
	var spliceWorksWithSmallSparseArrays = (function () {
	    // Per https://github.com/es-shims/es5-shim/issues/295
	    // Opera 12.15 breaks on this, no idea why.
	    var n = 256;
	    var arr = [];
	    arr[n] = 'a';
	    arr.splice(n + 1, 0, 'b');
	    return arr[n] === 'a';
	}());
	defineProperties(ArrayPrototype, {
	    splice: function splice(start, deleteCount) {
	        var O = ES.ToObject(this);
	        var A = [];
	        var len = ES.ToUint32(O.length);
	        var relativeStart = ES.ToInteger(start);
	        var actualStart = relativeStart < 0 ? max((len + relativeStart), 0) : min(relativeStart, len);
	        var actualDeleteCount = min(max(ES.ToInteger(deleteCount), 0), len - actualStart);
	
	        var k = 0;
	        var from;
	        while (k < actualDeleteCount) {
	            from = $String(actualStart + k);
	            if (owns(O, from)) {
	                A[k] = O[from];
	            }
	            k += 1;
	        }
	
	        var items = array_slice.call(arguments, 2);
	        var itemCount = items.length;
	        var to;
	        if (itemCount < actualDeleteCount) {
	            k = actualStart;
	            while (k < (len - actualDeleteCount)) {
	                from = $String(k + actualDeleteCount);
	                to = $String(k + itemCount);
	                if (owns(O, from)) {
	                    O[to] = O[from];
	                } else {
	                    delete O[to];
	                }
	                k += 1;
	            }
	            k = len;
	            while (k > (len - actualDeleteCount + itemCount)) {
	                delete O[k - 1];
	                k -= 1;
	            }
	        } else if (itemCount > actualDeleteCount) {
	            k = len - actualDeleteCount;
	            while (k > actualStart) {
	                from = $String(k + actualDeleteCount - 1);
	                to = $String(k + itemCount - 1);
	                if (owns(O, from)) {
	                    O[to] = O[from];
	                } else {
	                    delete O[to];
	                }
	                k -= 1;
	            }
	        }
	        k = actualStart;
	        for (var i = 0; i < items.length; ++i) {
	            O[k] = items[i];
	            k += 1;
	        }
	        O.length = len - actualDeleteCount + itemCount;
	
	        return A;
	    }
	}, !spliceWorksWithLargeSparseArrays || !spliceWorksWithSmallSparseArrays);
	
	var hasJoinUndefinedBug = [1, 2].join(undefined) !== '1,2';
	var originalJoin = ArrayPrototype.join;
	defineProperties(ArrayPrototype, {
	    join: function join(separator) {
	        return originalJoin.call(this, typeof separator === 'undefined' ? ',' : separator);
	    }
	}, hasJoinUndefinedBug);
	
	var pushShim = function push(item) {
	    var O = ES.ToObject(this);
	    var n = ES.ToUint32(O.length);
	    var i = 0;
	    while (i < arguments.length) {
	        O[n + i] = arguments[i];
	        i += 1;
	    }
	    O.length = n + i;
	    return n + i;
	};
	
	var pushIsNotGeneric = (function () {
	    var obj = {};
	    var result = Array.prototype.push.call(obj, undefined);
	    return result !== 1 || obj.length !== 1 || typeof obj[0] !== 'undefined' || !owns(obj, 0);
	}());
	defineProperties(ArrayPrototype, {
	    push: function push(item) {
	        if (isArray(this)) {
	            return array_push.apply(this, arguments);
	        }
	        return pushShim.apply(this, arguments);
	    }
	}, pushIsNotGeneric);
	
	// This fixes a very weird bug in Opera 10.6 when pushing `undefined
	var pushUndefinedIsWeird = (function () {
	    var arr = [];
	    var result = arr.push(undefined);
	    return result !== 1 || arr.length !== 1 || typeof arr[0] !== 'undefined' || !owns(arr, 0);
	}());
	defineProperties(ArrayPrototype, { push: pushShim }, pushUndefinedIsWeird);
	
	//
	// Object
	// ======
	//
	
	// ES5 15.2.3.14
	// http://es5.github.com/#x15.2.3.14
	
	// http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation
	var hasDontEnumBug = !({ 'toString': null }).propertyIsEnumerable('toString');
	var hasProtoEnumBug = function () {}.propertyIsEnumerable('prototype');
	var hasStringEnumBug = !owns('x', '0');
	var equalsConstructorPrototype = function (o) {
	    var ctor = o.constructor;
	    return ctor && ctor.prototype === o;
	};
	var blacklistedKeys = {
	    $window: true,
	    $console: true,
	    $parent: true,
	    $self: true,
	    $frame: true,
	    $frames: true,
	    $frameElement: true,
	    $webkitIndexedDB: true,
	    $webkitStorageInfo: true
	};
	var hasAutomationEqualityBug = (function () {
	    /* globals window */
	    if (typeof window === 'undefined') { return false; }
	    for (var k in window) {
	        try {
	            if (!blacklistedKeys['$' + k] && owns(window, k) && window[k] !== null && typeof window[k] === 'object') {
	                equalsConstructorPrototype(window[k]);
	            }
	        } catch (e) {
	            return true;
	        }
	    }
	    return false;
	}());
	var equalsConstructorPrototypeIfNotBuggy = function (object) {
	    if (typeof window === 'undefined' || !hasAutomationEqualityBug) { return equalsConstructorPrototype(object); }
	    try {
	        return equalsConstructorPrototype(object);
	    } catch (e) {
	        return false;
	    }
	};
	var dontEnums = [
	    'toString',
	    'toLocaleString',
	    'valueOf',
	    'hasOwnProperty',
	    'isPrototypeOf',
	    'propertyIsEnumerable',
	    'constructor'
	];
	var dontEnumsLength = dontEnums.length;
	
	// taken directly from https://github.com/ljharb/is-arguments/blob/master/index.js
	// can be replaced with require('is-arguments') if we ever use a build process instead
	var isStandardArguments = function isArguments(value) {
	    return toStr(value) === '[object Arguments]';
	};
	var isLegacyArguments = function isArguments(value) {
	    return value !== null &&
	        typeof value === 'object' &&
	        typeof value.length === 'number' &&
	        value.length >= 0 &&
	        !isArray(value) &&
	        isCallable(value.callee);
	};
	var isArguments = isStandardArguments(arguments) ? isStandardArguments : isLegacyArguments;
	
	defineProperties($Object, {
	    keys: function keys(object) {
	        var isFn = isCallable(object);
	        var isArgs = isArguments(object);
	        var isObject = object !== null && typeof object === 'object';
	        var isStr = isObject && isString(object);
	
	        if (!isObject && !isFn && !isArgs) {
	            throw new TypeError('Object.keys called on a non-object');
	        }
	
	        var theKeys = [];
	        var skipProto = hasProtoEnumBug && isFn;
	        if ((isStr && hasStringEnumBug) || isArgs) {
	            for (var i = 0; i < object.length; ++i) {
	                push(theKeys, $String(i));
	            }
	        }
	
	        if (!isArgs) {
	            for (var name in object) {
	                if (!(skipProto && name === 'prototype') && owns(object, name)) {
	                    push(theKeys, $String(name));
	                }
	            }
	        }
	
	        if (hasDontEnumBug) {
	            var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
	            for (var j = 0; j < dontEnumsLength; j++) {
	                var dontEnum = dontEnums[j];
	                if (!(skipConstructor && dontEnum === 'constructor') && owns(object, dontEnum)) {
	                    push(theKeys, dontEnum);
	                }
	            }
	        }
	        return theKeys;
	    }
	});
	
	var keysWorksWithArguments = $Object.keys && (function () {
	    // Safari 5.0 bug
	    return $Object.keys(arguments).length === 2;
	}(1, 2));
	var keysHasArgumentsLengthBug = $Object.keys && (function () {
	    var argKeys = $Object.keys(arguments);
	    return arguments.length !== 1 || argKeys.length !== 1 || argKeys[0] !== 1;
	}(1));
	var originalKeys = $Object.keys;
	defineProperties($Object, {
	    keys: function keys(object) {
	        if (isArguments(object)) {
	            return originalKeys(array_slice.call(object));
	        } else {
	            return originalKeys(object);
	        }
	    }
	}, !keysWorksWithArguments || keysHasArgumentsLengthBug);
	
	//
	// Date
	// ====
	//
	
	// ES5 15.9.5.43
	// http://es5.github.com/#x15.9.5.43
	// This function returns a String value represent the instance in time
	// represented by this Date object. The format of the String is the Date Time
	// string format defined in 15.9.1.15. All fields are present in the String.
	// The time zone is always UTC, denoted by the suffix Z. If the time value of
	// this object is not a finite Number a RangeError exception is thrown.
	var negativeDate = -62198755200000;
	var negativeYearString = '-000001';
	var hasNegativeDateBug = Date.prototype.toISOString && new Date(negativeDate).toISOString().indexOf(negativeYearString) === -1;
	var hasSafari51DateBug = Date.prototype.toISOString && new Date(-1).toISOString() !== '1969-12-31T23:59:59.999Z';
	
	defineProperties(Date.prototype, {
	    toISOString: function toISOString() {
	        var result, length, value, year, month;
	        if (!isFinite(this)) {
	            throw new RangeError('Date.prototype.toISOString called on non-finite value.');
	        }
	
	        year = this.getUTCFullYear();
	
	        month = this.getUTCMonth();
	        // see https://github.com/es-shims/es5-shim/issues/111
	        year += Math.floor(month / 12);
	        month = (month % 12 + 12) % 12;
	
	        // the date time string format is specified in 15.9.1.15.
	        result = [month + 1, this.getUTCDate(), this.getUTCHours(), this.getUTCMinutes(), this.getUTCSeconds()];
	        year = (
	            (year < 0 ? '-' : (year > 9999 ? '+' : '')) +
	            strSlice('00000' + Math.abs(year), (0 <= year && year <= 9999) ? -4 : -6)
	        );
	
	        length = result.length;
	        while (length--) {
	            value = result[length];
	            // pad months, days, hours, minutes, and seconds to have two
	            // digits.
	            if (value < 10) {
	                result[length] = '0' + value;
	            }
	        }
	        // pad milliseconds to have three digits.
	        return (
	            year + '-' + array_slice.call(result, 0, 2).join('-') +
	            'T' + array_slice.call(result, 2).join(':') + '.' +
	            strSlice('000' + this.getUTCMilliseconds(), -3) + 'Z'
	        );
	    }
	}, hasNegativeDateBug || hasSafari51DateBug);
	
	// ES5 15.9.5.44
	// http://es5.github.com/#x15.9.5.44
	// This function provides a String representation of a Date object for use by
	// JSON.stringify (15.12.3).
	var dateToJSONIsSupported = (function () {
	    try {
	        return Date.prototype.toJSON &&
	            new Date(NaN).toJSON() === null &&
	            new Date(negativeDate).toJSON().indexOf(negativeYearString) !== -1 &&
	            Date.prototype.toJSON.call({ // generic
	                toISOString: function () { return true; }
	            });
	    } catch (e) {
	        return false;
	    }
	}());
	if (!dateToJSONIsSupported) {
	    Date.prototype.toJSON = function toJSON(key) {
	        // When the toJSON method is called with argument key, the following
	        // steps are taken:
	
	        // 1.  Let O be the result of calling ToObject, giving it the this
	        // value as its argument.
	        // 2. Let tv be ES.ToPrimitive(O, hint Number).
	        var O = $Object(this);
	        var tv = ES.ToPrimitive(O);
	        // 3. If tv is a Number and is not finite, return null.
	        if (typeof tv === 'number' && !isFinite(tv)) {
	            return null;
	        }
	        // 4. Let toISO be the result of calling the [[Get]] internal method of
	        // O with argument "toISOString".
	        var toISO = O.toISOString;
	        // 5. If IsCallable(toISO) is false, throw a TypeError exception.
	        if (!isCallable(toISO)) {
	            throw new TypeError('toISOString property is not callable');
	        }
	        // 6. Return the result of calling the [[Call]] internal method of
	        //  toISO with O as the this value and an empty argument list.
	        return toISO.call(O);
	
	        // NOTE 1 The argument is ignored.
	
	        // NOTE 2 The toJSON function is intentionally generic; it does not
	        // require that its this value be a Date object. Therefore, it can be
	        // transferred to other kinds of objects for use as a method. However,
	        // it does require that any such object have a toISOString method. An
	        // object is free to use the argument key to filter its
	        // stringification.
	    };
	}
	
	// ES5 15.9.4.2
	// http://es5.github.com/#x15.9.4.2
	// based on work shared by Daniel Friesen (dantman)
	// http://gist.github.com/303249
	var supportsExtendedYears = Date.parse('+033658-09-27T01:46:40.000Z') === 1e15;
	var acceptsInvalidDates = !isNaN(Date.parse('2012-04-04T24:00:00.500Z')) || !isNaN(Date.parse('2012-11-31T23:59:59.000Z')) || !isNaN(Date.parse('2012-12-31T23:59:60.000Z'));
	var doesNotParseY2KNewYear = isNaN(Date.parse('2000-01-01T00:00:00.000Z'));
	if (doesNotParseY2KNewYear || acceptsInvalidDates || !supportsExtendedYears) {
	    // XXX global assignment won't work in embeddings that use
	    // an alternate object for the context.
	    /* global Date: true */
	    /* eslint-disable no-undef */
	    var maxSafeUnsigned32Bit = Math.pow(2, 31) - 1;
	    var secondsWithinMaxSafeUnsigned32Bit = Math.floor(maxSafeUnsigned32Bit / 1e3);
	    var hasSafariSignedIntBug = isActualNaN(new Date(1970, 0, 1, 0, 0, 0, maxSafeUnsigned32Bit + 1).getTime());
	    Date = (function (NativeDate) {
	    /* eslint-enable no-undef */
	        // Date.length === 7
	        var DateShim = function Date(Y, M, D, h, m, s, ms) {
	            var length = arguments.length;
	            var date;
	            if (this instanceof NativeDate) {
	                var seconds = s;
	                var millis = ms;
	                if (hasSafariSignedIntBug && length >= 7 && ms > maxSafeUnsigned32Bit) {
	                    // work around a Safari 8/9 bug where it treats the seconds as signed
	                    var msToShift = Math.floor(ms / maxSafeUnsigned32Bit) * maxSafeUnsigned32Bit;
	                    var sToShift = Math.floor(msToShift / 1e3);
	                    seconds += sToShift;
	                    millis -= sToShift * 1e3;
	                }
	                date = length === 1 && $String(Y) === Y ? // isString(Y)
	                    // We explicitly pass it through parse:
	                    new NativeDate(DateShim.parse(Y)) :
	                    // We have to manually make calls depending on argument
	                    // length here
	                    length >= 7 ? new NativeDate(Y, M, D, h, m, seconds, millis) :
	                    length >= 6 ? new NativeDate(Y, M, D, h, m, seconds) :
	                    length >= 5 ? new NativeDate(Y, M, D, h, m) :
	                    length >= 4 ? new NativeDate(Y, M, D, h) :
	                    length >= 3 ? new NativeDate(Y, M, D) :
	                    length >= 2 ? new NativeDate(Y, M) :
	                    length >= 1 ? new NativeDate(Y) :
	                                  new NativeDate();
	            } else {
	                date = NativeDate.apply(this, arguments);
	            }
	            if (!isPrimitive(date)) {
	              // Prevent mixups with unfixed Date object
	              defineProperties(date, { constructor: DateShim }, true);
	            }
	            return date;
	        };
	
	        // 15.9.1.15 Date Time String Format.
	        var isoDateExpression = new RegExp('^' +
	            '(\\d{4}|[+-]\\d{6})' + // four-digit year capture or sign +
	                                      // 6-digit extended year
	            '(?:-(\\d{2})' + // optional month capture
	            '(?:-(\\d{2})' + // optional day capture
	            '(?:' + // capture hours:minutes:seconds.milliseconds
	                'T(\\d{2})' + // hours capture
	                ':(\\d{2})' + // minutes capture
	                '(?:' + // optional :seconds.milliseconds
	                    ':(\\d{2})' + // seconds capture
	                    '(?:(\\.\\d{1,}))?' + // milliseconds capture
	                ')?' +
	            '(' + // capture UTC offset component
	                'Z|' + // UTC capture
	                '(?:' + // offset specifier +/-hours:minutes
	                    '([-+])' + // sign capture
	                    '(\\d{2})' + // hours offset capture
	                    ':(\\d{2})' + // minutes offset capture
	                ')' +
	            ')?)?)?)?' +
	        '$');
	
	        var months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365];
	
	        var dayFromMonth = function dayFromMonth(year, month) {
	            var t = month > 1 ? 1 : 0;
	            return (
	                months[month] +
	                Math.floor((year - 1969 + t) / 4) -
	                Math.floor((year - 1901 + t) / 100) +
	                Math.floor((year - 1601 + t) / 400) +
	                365 * (year - 1970)
	            );
	        };
	
	        var toUTC = function toUTC(t) {
	            var s = 0;
	            var ms = t;
	            if (hasSafariSignedIntBug && ms > maxSafeUnsigned32Bit) {
	                // work around a Safari 8/9 bug where it treats the seconds as signed
	                var msToShift = Math.floor(ms / maxSafeUnsigned32Bit) * maxSafeUnsigned32Bit;
	                var sToShift = Math.floor(msToShift / 1e3);
	                s += sToShift;
	                ms -= sToShift * 1e3;
	            }
	            return $Number(new NativeDate(1970, 0, 1, 0, 0, s, ms));
	        };
	
	        // Copy any custom methods a 3rd party library may have added
	        for (var key in NativeDate) {
	            if (owns(NativeDate, key)) {
	                DateShim[key] = NativeDate[key];
	            }
	        }
	
	        // Copy "native" methods explicitly; they may be non-enumerable
	        defineProperties(DateShim, {
	            now: NativeDate.now,
	            UTC: NativeDate.UTC
	        }, true);
	        DateShim.prototype = NativeDate.prototype;
	        defineProperties(DateShim.prototype, {
	            constructor: DateShim
	        }, true);
	
	        // Upgrade Date.parse to handle simplified ISO 8601 strings
	        var parseShim = function parse(string) {
	            var match = isoDateExpression.exec(string);
	            if (match) {
	                // parse months, days, hours, minutes, seconds, and milliseconds
	                // provide default values if necessary
	                // parse the UTC offset component
	                var year = $Number(match[1]),
	                    month = $Number(match[2] || 1) - 1,
	                    day = $Number(match[3] || 1) - 1,
	                    hour = $Number(match[4] || 0),
	                    minute = $Number(match[5] || 0),
	                    second = $Number(match[6] || 0),
	                    millisecond = Math.floor($Number(match[7] || 0) * 1000),
	                    // When time zone is missed, local offset should be used
	                    // (ES 5.1 bug)
	                    // see https://bugs.ecmascript.org/show_bug.cgi?id=112
	                    isLocalTime = Boolean(match[4] && !match[8]),
	                    signOffset = match[9] === '-' ? 1 : -1,
	                    hourOffset = $Number(match[10] || 0),
	                    minuteOffset = $Number(match[11] || 0),
	                    result;
	                var hasMinutesOrSecondsOrMilliseconds = minute > 0 || second > 0 || millisecond > 0;
	                if (
	                    hour < (hasMinutesOrSecondsOrMilliseconds ? 24 : 25) &&
	                    minute < 60 && second < 60 && millisecond < 1000 &&
	                    month > -1 && month < 12 && hourOffset < 24 &&
	                    minuteOffset < 60 && // detect invalid offsets
	                    day > -1 &&
	                    day < (dayFromMonth(year, month + 1) - dayFromMonth(year, month))
	                ) {
	                    result = (
	                        (dayFromMonth(year, month) + day) * 24 +
	                        hour +
	                        hourOffset * signOffset
	                    ) * 60;
	                    result = (
	                        (result + minute + minuteOffset * signOffset) * 60 +
	                        second
	                    ) * 1000 + millisecond;
	                    if (isLocalTime) {
	                        result = toUTC(result);
	                    }
	                    if (-8.64e15 <= result && result <= 8.64e15) {
	                        return result;
	                    }
	                }
	                return NaN;
	            }
	            return NativeDate.parse.apply(this, arguments);
	        };
	        defineProperties(DateShim, { parse: parseShim });
	
	        return DateShim;
	    }(Date));
	    /* global Date: false */
	}
	
	// ES5 15.9.4.4
	// http://es5.github.com/#x15.9.4.4
	if (!Date.now) {
	    Date.now = function now() {
	        return new Date().getTime();
	    };
	}
	
	//
	// Number
	// ======
	//
	
	// ES5.1 15.7.4.5
	// http://es5.github.com/#x15.7.4.5
	var hasToFixedBugs = NumberPrototype.toFixed && (
	  (0.00008).toFixed(3) !== '0.000' ||
	  (0.9).toFixed(0) !== '1' ||
	  (1.255).toFixed(2) !== '1.25' ||
	  (1000000000000000128).toFixed(0) !== '1000000000000000128'
	);
	
	var toFixedHelpers = {
	  base: 1e7,
	  size: 6,
	  data: [0, 0, 0, 0, 0, 0],
	  multiply: function multiply(n, c) {
	      var i = -1;
	      var c2 = c;
	      while (++i < toFixedHelpers.size) {
	          c2 += n * toFixedHelpers.data[i];
	          toFixedHelpers.data[i] = c2 % toFixedHelpers.base;
	          c2 = Math.floor(c2 / toFixedHelpers.base);
	      }
	  },
	  divide: function divide(n) {
	      var i = toFixedHelpers.size, c = 0;
	      while (--i >= 0) {
	          c += toFixedHelpers.data[i];
	          toFixedHelpers.data[i] = Math.floor(c / n);
	          c = (c % n) * toFixedHelpers.base;
	      }
	  },
	  numToString: function numToString() {
	      var i = toFixedHelpers.size;
	      var s = '';
	      while (--i >= 0) {
	          if (s !== '' || i === 0 || toFixedHelpers.data[i] !== 0) {
	              var t = $String(toFixedHelpers.data[i]);
	              if (s === '') {
	                  s = t;
	              } else {
	                  s += strSlice('0000000', 0, 7 - t.length) + t;
	              }
	          }
	      }
	      return s;
	  },
	  pow: function pow(x, n, acc) {
	      return (n === 0 ? acc : (n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc)));
	  },
	  log: function log(x) {
	      var n = 0;
	      var x2 = x;
	      while (x2 >= 4096) {
	          n += 12;
	          x2 /= 4096;
	      }
	      while (x2 >= 2) {
	          n += 1;
	          x2 /= 2;
	      }
	      return n;
	  }
	};
	
	var toFixedShim = function toFixed(fractionDigits) {
	    var f, x, s, m, e, z, j, k;
	
	    // Test for NaN and round fractionDigits down
	    f = $Number(fractionDigits);
	    f = isActualNaN(f) ? 0 : Math.floor(f);
	
	    if (f < 0 || f > 20) {
	        throw new RangeError('Number.toFixed called with invalid number of decimals');
	    }
	
	    x = $Number(this);
	
	    if (isActualNaN(x)) {
	        return 'NaN';
	    }
	
	    // If it is too big or small, return the string value of the number
	    if (x <= -1e21 || x >= 1e21) {
	        return $String(x);
	    }
	
	    s = '';
	
	    if (x < 0) {
	        s = '-';
	        x = -x;
	    }
	
	    m = '0';
	
	    if (x > 1e-21) {
	        // 1e-21 < x < 1e21
	        // -70 < log2(x) < 70
	        e = toFixedHelpers.log(x * toFixedHelpers.pow(2, 69, 1)) - 69;
	        z = (e < 0 ? x * toFixedHelpers.pow(2, -e, 1) : x / toFixedHelpers.pow(2, e, 1));
	        z *= 0x10000000000000; // Math.pow(2, 52);
	        e = 52 - e;
	
	        // -18 < e < 122
	        // x = z / 2 ^ e
	        if (e > 0) {
	            toFixedHelpers.multiply(0, z);
	            j = f;
	
	            while (j >= 7) {
	                toFixedHelpers.multiply(1e7, 0);
	                j -= 7;
	            }
	
	            toFixedHelpers.multiply(toFixedHelpers.pow(10, j, 1), 0);
	            j = e - 1;
	
	            while (j >= 23) {
	                toFixedHelpers.divide(1 << 23);
	                j -= 23;
	            }
	
	            toFixedHelpers.divide(1 << j);
	            toFixedHelpers.multiply(1, 1);
	            toFixedHelpers.divide(2);
	            m = toFixedHelpers.numToString();
	        } else {
	            toFixedHelpers.multiply(0, z);
	            toFixedHelpers.multiply(1 << (-e), 0);
	            m = toFixedHelpers.numToString() + strSlice('0.00000000000000000000', 2, 2 + f);
	        }
	    }
	
	    if (f > 0) {
	        k = m.length;
	
	        if (k <= f) {
	            m = s + strSlice('0.0000000000000000000', 0, f - k + 2) + m;
	        } else {
	            m = s + strSlice(m, 0, k - f) + '.' + strSlice(m, k - f);
	        }
	    } else {
	        m = s + m;
	    }
	
	    return m;
	};
	defineProperties(NumberPrototype, { toFixed: toFixedShim }, hasToFixedBugs);
	
	var hasToPrecisionUndefinedBug = (function () {
	    try {
	        return 1.0.toPrecision(undefined) === '1';
	    } catch (e) {
	        return true;
	    }
	}());
	var originalToPrecision = NumberPrototype.toPrecision;
	defineProperties(NumberPrototype, {
	    toPrecision: function toPrecision(precision) {
	        return typeof precision === 'undefined' ? originalToPrecision.call(this) : originalToPrecision.call(this, precision);
	    }
	}, hasToPrecisionUndefinedBug);
	
	//
	// String
	// ======
	//
	
	// ES5 15.5.4.14
	// http://es5.github.com/#x15.5.4.14
	
	// [bugfix, IE lt 9, firefox 4, Konqueror, Opera, obscure browsers]
	// Many browsers do not split properly with regular expressions or they
	// do not perform the split correctly under obscure conditions.
	// See http://blog.stevenlevithan.com/archives/cross-browser-split
	// I've tested in many browsers and this seems to cover the deviant ones:
	//    'ab'.split(/(?:ab)*/) should be ["", ""], not [""]
	//    '.'.split(/(.?)(.?)/) should be ["", ".", "", ""], not ["", ""]
	//    'tesst'.split(/(s)*/) should be ["t", undefined, "e", "s", "t"], not
	//       [undefined, "t", undefined, "e", ...]
	//    ''.split(/.?/) should be [], not [""]
	//    '.'.split(/()()/) should be ["."], not ["", "", "."]
	
	if (
	    'ab'.split(/(?:ab)*/).length !== 2 ||
	    '.'.split(/(.?)(.?)/).length !== 4 ||
	    'tesst'.split(/(s)*/)[1] === 't' ||
	    'test'.split(/(?:)/, -1).length !== 4 ||
	    ''.split(/.?/).length ||
	    '.'.split(/()()/).length > 1
	) {
	    (function () {
	        var compliantExecNpcg = typeof (/()??/).exec('')[1] === 'undefined'; // NPCG: nonparticipating capturing group
	        var maxSafe32BitInt = Math.pow(2, 32) - 1;
	
	        StringPrototype.split = function (separator, limit) {
	            var string = this;
	            if (typeof separator === 'undefined' && limit === 0) {
	                return [];
	            }
	
	            // If `separator` is not a regex, use native split
	            if (!isRegex(separator)) {
	                return strSplit(this, separator, limit);
	            }
	
	            var output = [];
	            var flags = (separator.ignoreCase ? 'i' : '') +
	                        (separator.multiline ? 'm' : '') +
	                        (separator.unicode ? 'u' : '') + // in ES6
	                        (separator.sticky ? 'y' : ''), // Firefox 3+ and ES6
	                lastLastIndex = 0,
	                // Make `global` and avoid `lastIndex` issues by working with a copy
	                separator2, match, lastIndex, lastLength;
	            var separatorCopy = new RegExp(separator.source, flags + 'g');
	            string += ''; // Type-convert
	            if (!compliantExecNpcg) {
	                // Doesn't need flags gy, but they don't hurt
	                separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);
	            }
	            /* Values for `limit`, per the spec:
	             * If undefined: 4294967295 // maxSafe32BitInt
	             * If 0, Infinity, or NaN: 0
	             * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
	             * If negative number: 4294967296 - Math.floor(Math.abs(limit))
	             * If other: Type-convert, then use the above rules
	             */
	            var splitLimit = typeof limit === 'undefined' ? maxSafe32BitInt : ES.ToUint32(limit);
	            match = separatorCopy.exec(string);
	            while (match) {
	                // `separatorCopy.lastIndex` is not reliable cross-browser
	                lastIndex = match.index + match[0].length;
	                if (lastIndex > lastLastIndex) {
	                    push(output, strSlice(string, lastLastIndex, match.index));
	                    // Fix browsers whose `exec` methods don't consistently return `undefined` for
	                    // nonparticipating capturing groups
	                    if (!compliantExecNpcg && match.length > 1) {
	                        /* eslint-disable no-loop-func */
	                        match[0].replace(separator2, function () {
	                            for (var i = 1; i < arguments.length - 2; i++) {
	                                if (typeof arguments[i] === 'undefined') {
	                                    match[i] = void 0;
	                                }
	                            }
	                        });
	                        /* eslint-enable no-loop-func */
	                    }
	                    if (match.length > 1 && match.index < string.length) {
	                        array_push.apply(output, array_slice.call(match, 1));
	                    }
	                    lastLength = match[0].length;
	                    lastLastIndex = lastIndex;
	                    if (output.length >= splitLimit) {
	                        break;
	                    }
	                }
	                if (separatorCopy.lastIndex === match.index) {
	                    separatorCopy.lastIndex++; // Avoid an infinite loop
	                }
	                match = separatorCopy.exec(string);
	            }
	            if (lastLastIndex === string.length) {
	                if (lastLength || !separatorCopy.test('')) {
	                    push(output, '');
	                }
	            } else {
	                push(output, strSlice(string, lastLastIndex));
	            }
	            return output.length > splitLimit ? strSlice(output, 0, splitLimit) : output;
	        };
	    }());
	
	// [bugfix, chrome]
	// If separator is undefined, then the result array contains just one String,
	// which is the this value (converted to a String). If limit is not undefined,
	// then the output array is truncated so that it contains no more than limit
	// elements.
	// "0".split(undefined, 0) -> []
	} else if ('0'.split(void 0, 0).length) {
	    StringPrototype.split = function split(separator, limit) {
	        if (typeof separator === 'undefined' && limit === 0) { return []; }
	        return strSplit(this, separator, limit);
	    };
	}
	
	var str_replace = StringPrototype.replace;
	var replaceReportsGroupsCorrectly = (function () {
	    var groups = [];
	    'x'.replace(/x(.)?/g, function (match, group) {
	        push(groups, group);
	    });
	    return groups.length === 1 && typeof groups[0] === 'undefined';
	}());
	
	if (!replaceReportsGroupsCorrectly) {
	    StringPrototype.replace = function replace(searchValue, replaceValue) {
	        var isFn = isCallable(replaceValue);
	        var hasCapturingGroups = isRegex(searchValue) && (/\)[*?]/).test(searchValue.source);
	        if (!isFn || !hasCapturingGroups) {
	            return str_replace.call(this, searchValue, replaceValue);
	        } else {
	            var wrappedReplaceValue = function (match) {
	                var length = arguments.length;
	                var originalLastIndex = searchValue.lastIndex;
	                searchValue.lastIndex = 0;
	                var args = searchValue.exec(match) || [];
	                searchValue.lastIndex = originalLastIndex;
	                push(args, arguments[length - 2], arguments[length - 1]);
	                return replaceValue.apply(this, args);
	            };
	            return str_replace.call(this, searchValue, wrappedReplaceValue);
	        }
	    };
	}
	
	// ECMA-262, 3rd B.2.3
	// Not an ECMAScript standard, although ECMAScript 3rd Edition has a
	// non-normative section suggesting uniform semantics and it should be
	// normalized across all browsers
	// [bugfix, IE lt 9] IE < 9 substr() with negative value not working in IE
	var string_substr = StringPrototype.substr;
	var hasNegativeSubstrBug = ''.substr && '0b'.substr(-1) !== 'b';
	defineProperties(StringPrototype, {
	    substr: function substr(start, length) {
	        var normalizedStart = start;
	        if (start < 0) {
	            normalizedStart = max(this.length + start, 0);
	        }
	        return string_substr.call(this, normalizedStart, length);
	    }
	}, hasNegativeSubstrBug);
	
	// ES5 15.5.4.20
	// whitespace from: http://es5.github.io/#x15.5.4.20
	var ws = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
	    '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028' +
	    '\u2029\uFEFF';
	var zeroWidth = '\u200b';
	var wsRegexChars = '[' + ws + ']';
	var trimBeginRegexp = new RegExp('^' + wsRegexChars + wsRegexChars + '*');
	var trimEndRegexp = new RegExp(wsRegexChars + wsRegexChars + '*$');
	var hasTrimWhitespaceBug = StringPrototype.trim && (ws.trim() || !zeroWidth.trim());
	defineProperties(StringPrototype, {
	    // http://blog.stevenlevithan.com/archives/faster-trim-javascript
	    // http://perfectionkills.com/whitespace-deviations/
	    trim: function trim() {
	        if (typeof this === 'undefined' || this === null) {
	            throw new TypeError("can't convert " + this + ' to object');
	        }
	        return $String(this).replace(trimBeginRegexp, '').replace(trimEndRegexp, '');
	    }
	}, hasTrimWhitespaceBug);
	
	var hasLastIndexBug = StringPrototype.lastIndexOf && 'abc'.lastIndexOf('', 2) !== -1;
	defineProperties(StringPrototype, {
	    lastIndexOf: function lastIndexOf(searchString) {
	        if (typeof this === 'undefined' || this === null) {
	            throw new TypeError("can't convert " + this + ' to object');
	        }
	        var S = $String(this);
	        var searchStr = $String(searchString);
	        var numPos = arguments.length > 1 ? $Number(arguments[1]) : NaN;
	        var pos = isActualNaN(numPos) ? Infinity : ES.ToInteger(numPos);
	        var start = min(max(pos, 0), S.length);
	        var searchLen = searchStr.length;
	        var k = start + searchLen;
	        while (k > 0) {
	            k = max(0, k - searchLen);
	            var index = strIndexOf(strSlice(S, k, start + searchLen), searchStr);
	            if (index !== -1) {
	                return k + index;
	            }
	        }
	        return -1;
	    }
	}, hasLastIndexBug);
	
	var originalLastIndexOf = StringPrototype.lastIndexOf;
	defineProperties(StringPrototype, {
	    lastIndexOf: function lastIndexOf(searchString) {
	        return originalLastIndexOf.apply(this, arguments);
	    }
	}, StringPrototype.lastIndexOf.length !== 1);
	
	// ES-5 15.1.2.2
	/* eslint-disable radix */
	if (parseInt(ws + '08') !== 8 || parseInt(ws + '0x16') !== 22) {
	/* eslint-enable radix */
	    /* global parseInt: true */
	    parseInt = (function (origParseInt) {
	        var hexRegex = /^[\-+]?0[xX]/;
	        return function parseInt(str, radix) {
	            var string = $String(str).trim();
	            var defaultedRadix = $Number(radix) || (hexRegex.test(string) ? 16 : 10);
	            return origParseInt(string, defaultedRadix);
	        };
	    }(parseInt));
	}
	
	if (String(new RangeError('test')) !== 'RangeError: test') {
	    var originalErrorToString = Error.prototype.toString;
	    var errorToStringShim = function toString() {
	        if (typeof this === 'undefined' || this === null) {
	            throw new TypeError("can't convert " + this + ' to object');
	        }
	        var name = this.name;
	        if (typeof name === 'undefined') {
	            name = 'Error';
	        } else if (typeof name !== 'string') {
	            name = $String(name);
	        }
	        var msg = this.message;
	        if (typeof msg === 'undefined') {
	            msg = '';
	        } else if (typeof msg !== 'string') {
	            msg = $String(msg);
	        }
	        if (!name) {
	            return msg;
	        }
	        if (!msg) {
	            return name;
	        }
	        return name + ': ' + msg;
	    };
	    // can't use defineProperties here because of toString enumeration issue in IE <= 8
	    Error.prototype.toString = errorToStringShim;
	}
	
	}));


/***/ },
/* 7 */
/***/ function(module, exports) {

	module.exports = "/*\n * Support for source maps in V8 stack traces\n * https://github.com/evanw/node-source-map-support\n */\n(this.define||function(K,N){this.sourceMapSupport=N()})(\"browser-source-map-support\",function(K){(function n(w,t,e){function r(g,b){if(!t[g]){if(!w[g]){var f=\"function\"==typeof require&&require;if(!b&&f)return f(g,!0);if(l)return l(g,!0);throw Error(\"Cannot find module '\"+g+\"'\");}f=t[g]={exports:{}};w[g][0].call(f.exports,function(b){var a=w[g][1][b];return r(a?a:b)},f,f.exports,n,w,t,e)}return t[g].exports}for(var l=\"function\"==typeof require&&require,m=0;m<e.length;m++)r(e[m]);return r})({1:[function(n,\nw,t){K=n(\"./source-map-support\")},{\"./source-map-support\":18}],2:[function(n,w,t){(function(e,r){w.exports=function(l,m){function g(c,d){var a;if(c&&\".\"===c.charAt(0)&&d){a=d.split(\"/\");a=a.slice(0,a.length-1);var b=a=a.concat(c.split(\"/\")),f,k;for(f=0;b[f];f+=1)if(k=b[f],\".\"===k)b.splice(f,1),--f;else if(\"..\"===k)if(1!==f||\"..\"!==b[2]&&\"..\"!==b[0])0<f&&(b.splice(f-1,2),f-=2);else break;c=a.join(\"/\")}return c}function b(c){return function(a){return g(a,c)}}function f(c){function a(b){d[c]=b}a.fromText=\nfunction(c,a){throw Error(\"amdefine does not implement load.fromText\");};return a}function k(c,a,b){var f,k,g;if(c)k=d[c]={},g={id:c,uri:r,exports:k},f=A(m,k,g,c);else{if(y)throw Error(\"amdefine with no module ID cannot be called more than once per file.\");y=!0;k=l.exports;g=l;f=A(m,k,g,l.id)}a&&(a=a.map(function(c){return f(c)}));a=\"function\"===typeof b?b.apply(g.exports,a):b;void 0!==a&&(g.exports=a,c&&(d[c]=g.exports))}function a(a,d,b){Array.isArray(a)?(b=d,d=a,a=void 0):\"string\"!==typeof a&&\n(b=a,a=d=void 0);d&&!Array.isArray(d)&&(b=d,d=void 0);d||(d=[\"require\",\"exports\",\"module\"]);a?c[a]=[a,d,b]:k(a,d,b)}var c={},d={},y=!1,x=n(\"path\"),A,B;A=function(c,a,d,b){function f(k,g){if(\"string\"===typeof k)return B(c,a,d,k,b);k=k.map(function(f){return B(c,a,d,f,b)});g&&e.nextTick(function(){g.apply(null,k)})}f.toUrl=function(c){return 0===c.indexOf(\".\")?g(c,x.dirname(d.filename)):c};return f};m=m||function(){return l.require.apply(l,arguments)};B=function(a,e,y,m,x){var l=m.indexOf(\"!\"),r=m;\nif(-1===l){m=g(m,x);if(\"require\"===m)return A(a,e,y,x);if(\"exports\"===m)return e;if(\"module\"===m)return y;if(d.hasOwnProperty(m))return d[m];if(c[m])return k.apply(null,c[m]),d[m];if(a)return a(r);throw Error(\"No module with ID: \"+m);}r=m.substring(0,l);m=m.substring(l+1,m.length);l=B(a,e,y,r,x);m=l.normalize?l.normalize(m,b(x)):g(m,x);d[m]||l.load(m,A(a,e,y,x),f(m),{});return d[m]};a.require=function(a){if(d[a])return d[a];if(c[a])return k.apply(null,c[a]),d[a]};a.amd={};return a}}).call(this,n(\"node_modules/process/browser.js\"),\n\"/node_modules/amdefine/amdefine.js\")},{\"node_modules/process/browser.js\":8,path:7}],3:[function(n,w,t){(function(e){function r(e){e=e.charCodeAt(0);if(43===e||45===e)return 62;if(47===e||95===e)return 63;if(48>e)return-1;if(58>e)return e-48+52;if(91>e)return e-65;if(123>e)return e-97+26}var l=\"undefined\"!==typeof Uint8Array?Uint8Array:Array;e.toByteArray=function(e){function g(a){c[d++]=a}var b,f,k,a,c;if(0<e.length%4)throw Error(\"Invalid string. Length must be a multiple of 4\");b=e.length;a=\"=\"===\ne.charAt(b-2)?2:\"=\"===e.charAt(b-1)?1:0;c=new l(3*e.length/4-a);f=0<a?e.length-4:e.length;var d=0;for(b=0;b<f;b+=4)k=r(e.charAt(b))<<18|r(e.charAt(b+1))<<12|r(e.charAt(b+2))<<6|r(e.charAt(b+3)),g((k&16711680)>>16),g((k&65280)>>8),g(k&255);2===a?(k=r(e.charAt(b))<<2|r(e.charAt(b+1))>>4,g(k&255)):1===a&&(k=r(e.charAt(b))<<10|r(e.charAt(b+1))<<4|r(e.charAt(b+2))>>2,g(k>>8&255),g(k&255));return c};e.fromByteArray=function(e){var g,b=e.length%3,f=\"\",k,a;g=0;for(a=e.length-b;g<a;g+=3)k=(e[g]<<16)+(e[g+\n1]<<8)+e[g+2],k=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".charAt(k>>18&63)+\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".charAt(k>>12&63)+\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".charAt(k>>6&63)+\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".charAt(k&63),f+=k;switch(b){case 1:k=e[e.length-1];f+=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".charAt(k>>2);f+=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".charAt(k<<\n4&63);f+=\"==\";break;case 2:k=(e[e.length-2]<<8)+e[e.length-1],f+=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".charAt(k>>10),f+=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".charAt(k>>4&63),f+=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".charAt(k<<2&63),f+=\"=\"}return f}})(\"undefined\"===typeof t?this.base64js={}:t)},{}],4:[function(n,w,t){},{}],5:[function(n,w,t){function e(h,q,c){if(!(this instanceof e))return new e(h,q,c);var a=typeof h;\nif(\"base64\"===q&&\"string\"===a)for(h=h.trim?h.trim():h.replace(/^\\s+|\\s+$/g,\"\");0!==h.length%4;)h+=\"=\";var d;if(\"number\"===a)d=F(h);else if(\"string\"===a)d=e.byteLength(h,q);else if(\"object\"===a)d=F(h.length);else throw Error(\"First argument needs to be a number, array or string.\");var b;e._useTypedArrays?b=e._augment(new Uint8Array(d)):(b=this,b.length=d,b._isBuffer=!0);if(e._useTypedArrays&&\"number\"===typeof h.byteLength)b._set(h);else{var f=h;if(E(f)||e.isBuffer(f)||f&&\"object\"===typeof f&&\"number\"===\ntypeof f.length)for(q=0;q<d;q++)e.isBuffer(h)?b[q]=h.readUInt8(q):b[q]=h[q];else if(\"string\"===a)b.write(h,0,q);else if(\"number\"===a&&!e._useTypedArrays&&!c)for(q=0;q<d;q++)b[q]=0}return b}function r(h,q,c){var a=\"\";for(c=Math.min(h.length,c);q<c;q++)a+=String.fromCharCode(h[q]);return a}function l(h,q,c,a){a||(p(\"boolean\"===typeof c,\"missing or invalid endian\"),p(void 0!==q&&null!==q,\"missing offset\"),p(q+1<h.length,\"Trying to read beyond buffer length\"));a=h.length;if(!(q>=a))return c?(c=h[q],q+\n1<a&&(c|=h[q+1]<<8)):(c=h[q]<<8,q+1<a&&(c|=h[q+1])),c}function m(h,q,c,a){a||(p(\"boolean\"===typeof c,\"missing or invalid endian\"),p(void 0!==q&&null!==q,\"missing offset\"),p(q+3<h.length,\"Trying to read beyond buffer length\"));a=h.length;if(!(q>=a)){var d;c?(q+2<a&&(d=h[q+2]<<16),q+1<a&&(d|=h[q+1]<<8),d|=h[q],q+3<a&&(d+=h[q+3]<<24>>>0)):(q+1<a&&(d=h[q+1]<<16),q+2<a&&(d|=h[q+2]<<8),q+3<a&&(d|=h[q+3]),d+=h[q]<<24>>>0);return d}}function g(h,q,a,c){c||(p(\"boolean\"===typeof a,\"missing or invalid endian\"),\np(void 0!==q&&null!==q,\"missing offset\"),p(q+1<h.length,\"Trying to read beyond buffer length\"));if(!(q>=h.length))return h=l(h,q,a,!0),h&32768?-1*(65535-h+1):h}function b(h,q,a,c){c||(p(\"boolean\"===typeof a,\"missing or invalid endian\"),p(void 0!==q&&null!==q,\"missing offset\"),p(q+3<h.length,\"Trying to read beyond buffer length\"));if(!(q>=h.length))return h=m(h,q,a,!0),h&2147483648?-1*(4294967295-h+1):h}function f(h,q,a,c){c||(p(\"boolean\"===typeof a,\"missing or invalid endian\"),p(q+3<h.length,\"Trying to read beyond buffer length\"));\nreturn I.read(h,q,a,23,4)}function k(h,q,a,c){c||(p(\"boolean\"===typeof a,\"missing or invalid endian\"),p(q+7<h.length,\"Trying to read beyond buffer length\"));return I.read(h,q,a,52,8)}function a(h,a,c,d,b){b||(p(void 0!==a&&null!==a,\"missing value\"),p(\"boolean\"===typeof d,\"missing or invalid endian\"),p(void 0!==c&&null!==c,\"missing offset\"),p(c+1<h.length,\"trying to write beyond buffer length\"),H(a,65535));var f=h.length;if(!(c>=f))for(b=0,f=Math.min(f-c,2);b<f;b++)h[c+b]=(a&255<<8*(d?b:1-b))>>>8*\n(d?b:1-b)}function c(h,a,c,d,b){b||(p(void 0!==a&&null!==a,\"missing value\"),p(\"boolean\"===typeof d,\"missing or invalid endian\"),p(void 0!==c&&null!==c,\"missing offset\"),p(c+3<h.length,\"trying to write beyond buffer length\"),H(a,4294967295));var f=h.length;if(!(c>=f))for(b=0,f=Math.min(f-c,4);b<f;b++)h[c+b]=a>>>8*(d?b:3-b)&255}function d(h,c,d,b,f){f||(p(void 0!==c&&null!==c,\"missing value\"),p(\"boolean\"===typeof b,\"missing or invalid endian\"),p(void 0!==d&&null!==d,\"missing offset\"),p(d+1<h.length,\n\"Trying to write beyond buffer length\"),L(c,32767,-32768));d>=h.length||(0<=c?a(h,c,d,b,f):a(h,65535+c+1,d,b,f))}function y(h,a,d,b,f){f||(p(void 0!==a&&null!==a,\"missing value\"),p(\"boolean\"===typeof b,\"missing or invalid endian\"),p(void 0!==d&&null!==d,\"missing offset\"),p(d+3<h.length,\"Trying to write beyond buffer length\"),L(a,2147483647,-2147483648));d>=h.length||(0<=a?c(h,a,d,b,f):c(h,4294967295+a+1,d,b,f))}function x(h,a,c,d,b){b||(p(void 0!==a&&null!==a,\"missing value\"),p(\"boolean\"===typeof d,\n\"missing or invalid endian\"),p(void 0!==c&&null!==c,\"missing offset\"),p(c+3<h.length,\"Trying to write beyond buffer length\"),M(a,3.4028234663852886E38,-3.4028234663852886E38));c>=h.length||I.write(h,a,c,d,23,4)}function A(h,c,a,d,b){b||(p(void 0!==c&&null!==c,\"missing value\"),p(\"boolean\"===typeof d,\"missing or invalid endian\"),p(void 0!==a&&null!==a,\"missing offset\"),p(a+7<h.length,\"Trying to write beyond buffer length\"),M(c,1.7976931348623157E308,-1.7976931348623157E308));a>=h.length||I.write(h,\nc,a,d,52,8)}function B(h,a,c){if(\"number\"!==typeof h)return c;h=~~h;if(h>=a)return a;if(0<=h)return h;h+=a;return 0<=h?h:0}function F(h){h=~~Math.ceil(+h);return 0>h?0:h}function E(h){return(Array.isArray||function(h){return\"[object Array]\"===Object.prototype.toString.call(h)})(h)}function G(h){return 16>h?\"0\"+h.toString(16):h.toString(16)}function u(h){for(var a=[],c=0;c<h.length;c++){var d=h.charCodeAt(c);if(127>=d)a.push(h.charCodeAt(c));else{var b=c;55296<=d&&57343>=d&&c++;d=encodeURIComponent(h.slice(b,\nc+1)).substr(1).split(\"%\");for(b=0;b<d.length;b++)a.push(parseInt(d[b],16))}}return a}function C(h){for(var c=[],a=0;a<h.length;a++)c.push(h.charCodeAt(a)&255);return c}function z(h,c,a,d){for(var b=0;b<d&&!(b+a>=c.length||b>=h.length);b++)c[b+a]=h[b];return b}function D(h){try{return decodeURIComponent(h)}catch(c){return String.fromCharCode(65533)}}function H(h,c){p(\"number\"===typeof h,\"cannot write a non-number as a number\");p(0<=h,\"specified a negative value for writing an unsigned value\");p(h<=\nc,\"value is larger than maximum value for type\");p(Math.floor(h)===h,\"value has a fractional component\")}function L(h,c,a){p(\"number\"===typeof h,\"cannot write a non-number as a number\");p(h<=c,\"value larger than maximum allowed value\");p(h>=a,\"value smaller than minimum allowed value\");p(Math.floor(h)===h,\"value has a fractional component\")}function M(h,c,a){p(\"number\"===typeof h,\"cannot write a non-number as a number\");p(h<=c,\"value larger than maximum allowed value\");p(h>=a,\"value smaller than minimum allowed value\")}\nfunction p(h,c){if(!h)throw Error(c||\"Failed assertion\");}var J=n(\"base64-js\"),I=n(\"ieee754\");t.Buffer=e;t.SlowBuffer=e;t.INSPECT_MAX_BYTES=50;e.poolSize=8192;e._useTypedArrays=function(){try{var h=new ArrayBuffer(0),c=new Uint8Array(h);c.foo=function(){return 42};return 42===c.foo()&&\"function\"===typeof c.subarray}catch(a){return!1}}();e.isEncoding=function(h){switch(String(h).toLowerCase()){case \"hex\":case \"utf8\":case \"utf-8\":case \"ascii\":case \"binary\":case \"base64\":case \"raw\":case \"ucs2\":case \"ucs-2\":case \"utf16le\":case \"utf-16le\":return!0;\ndefault:return!1}};e.isBuffer=function(h){return!(null===h||void 0===h||!h._isBuffer)};e.byteLength=function(h,c){var a;h+=\"\";switch(c||\"utf8\"){case \"hex\":a=h.length/2;break;case \"utf8\":case \"utf-8\":a=u(h).length;break;case \"ascii\":case \"binary\":case \"raw\":a=h.length;break;case \"base64\":a=J.toByteArray(h).length;break;case \"ucs2\":case \"ucs-2\":case \"utf16le\":case \"utf-16le\":a=2*h.length;break;default:throw Error(\"Unknown encoding\");}return a};e.concat=function(h,c){p(E(h),\"Usage: Buffer.concat(list, [totalLength])\\nlist should be an Array.\");\nif(0===h.length)return new e(0);if(1===h.length)return h[0];var a;if(\"number\"!==typeof c)for(a=c=0;a<h.length;a++)c+=h[a].length;var d=new e(c),b=0;for(a=0;a<h.length;a++){var f=h[a];f.copy(d,b);b+=f.length}return d};e.prototype.write=function(h,c,a,d){if(isFinite(c))isFinite(a)||(d=a,a=void 0);else{var b=d;d=c;c=a;a=b}c=Number(c)||0;b=this.length-c;a?(a=Number(a),a>b&&(a=b)):a=b;d=String(d||\"utf8\").toLowerCase();switch(d){case \"hex\":c=Number(c)||0;d=this.length-c;a?(a=Number(a),a>d&&(a=d)):a=d;d=\nh.length;p(0===d%2,\"Invalid hex string\");a>d/2&&(a=d/2);for(d=0;d<a;d++)b=parseInt(h.substr(2*d,2),16),p(!isNaN(b),\"Invalid hex string\"),this[c+d]=b;e._charsWritten=2*d;h=d;break;case \"utf8\":case \"utf-8\":h=e._charsWritten=z(u(h),this,c,a);break;case \"ascii\":h=e._charsWritten=z(C(h),this,c,a);break;case \"binary\":h=e._charsWritten=z(C(h),this,c,a);break;case \"base64\":h=e._charsWritten=z(J.toByteArray(h),this,c,a);break;case \"ucs2\":case \"ucs-2\":case \"utf16le\":case \"utf-16le\":for(var f,b=[],k=0;k<h.length;k++)f=\nh.charCodeAt(k),d=f>>8,f%=256,b.push(f),b.push(d);h=e._charsWritten=z(b,this,c,a);break;default:throw Error(\"Unknown encoding\");}return h};e.prototype.toString=function(a,c,d){a=String(a||\"utf8\").toLowerCase();c=Number(c)||0;d=void 0!==d?Number(d):d=this.length;if(d===c)return\"\";switch(a){case \"hex\":a=this.length;if(!c||0>c)c=0;if(!d||0>d||d>a)d=a;for(a=\"\";c<d;c++)a+=G(this[c]);d=a;break;case \"utf8\":case \"utf-8\":var b=a=\"\";for(d=Math.min(this.length,d);c<d;c++)127>=this[c]?(a+=D(b)+String.fromCharCode(this[c]),\nb=\"\"):b+=\"%\"+this[c].toString(16);d=a+D(b);break;case \"ascii\":d=r(this,c,d);break;case \"binary\":d=r(this,c,d);break;case \"base64\":d=0===c&&d===this.length?J.fromByteArray(this):J.fromByteArray(this.slice(c,d));break;case \"ucs2\":case \"ucs-2\":case \"utf16le\":case \"utf-16le\":d=this.slice(c,d);c=\"\";for(a=0;a<d.length;a+=2)c+=String.fromCharCode(d[a]+256*d[a+1]);d=c;break;default:throw Error(\"Unknown encoding\");}return d};e.prototype.toJSON=function(){return{type:\"Buffer\",data:Array.prototype.slice.call(this._arr||\nthis,0)}};e.prototype.copy=function(a,c,d,b){d||(d=0);b||0===b||(b=this.length);c||(c=0);if(b!==d&&0!==a.length&&0!==this.length)if(p(b>=d,\"sourceEnd < sourceStart\"),p(0<=c&&c<a.length,\"targetStart out of bounds\"),p(0<=d&&d<this.length,\"sourceStart out of bounds\"),p(0<=b&&b<=this.length,\"sourceEnd out of bounds\"),b>this.length&&(b=this.length),a.length-c<b-d&&(b=a.length-c+d),b-=d,100>b||!e._useTypedArrays)for(var f=0;f<b;f++)a[f+c]=this[f+d];else a._set(this.subarray(d,d+b),c)};e.prototype.slice=\nfunction(a,c){var d=this.length;a=B(a,d,0);c=B(c,d,d);if(e._useTypedArrays)return e._augment(this.subarray(a,c));for(var d=c-a,b=new e(d,void 0,!0),f=0;f<d;f++)b[f]=this[f+a];return b};e.prototype.get=function(a){console.log(\".get() is deprecated. Access using array indexes instead.\");return this.readUInt8(a)};e.prototype.set=function(a,c){console.log(\".set() is deprecated. Access using array indexes instead.\");return this.writeUInt8(a,c)};e.prototype.readUInt8=function(a,c){c||(p(void 0!==a&&null!==\na,\"missing offset\"),p(a<this.length,\"Trying to read beyond buffer length\"));if(!(a>=this.length))return this[a]};e.prototype.readUInt16LE=function(a,c){return l(this,a,!0,c)};e.prototype.readUInt16BE=function(a,c){return l(this,a,!1,c)};e.prototype.readUInt32LE=function(a,c){return m(this,a,!0,c)};e.prototype.readUInt32BE=function(a,c){return m(this,a,!1,c)};e.prototype.readInt8=function(a,c){c||(p(void 0!==a&&null!==a,\"missing offset\"),p(a<this.length,\"Trying to read beyond buffer length\"));if(!(a>=\nthis.length))return this[a]&128?-1*(255-this[a]+1):this[a]};e.prototype.readInt16LE=function(a,c){return g(this,a,!0,c)};e.prototype.readInt16BE=function(a,c){return g(this,a,!1,c)};e.prototype.readInt32LE=function(a,c){return b(this,a,!0,c)};e.prototype.readInt32BE=function(a,c){return b(this,a,!1,c)};e.prototype.readFloatLE=function(a,c){return f(this,a,!0,c)};e.prototype.readFloatBE=function(a,c){return f(this,a,!1,c)};e.prototype.readDoubleLE=function(a,c){return k(this,a,!0,c)};e.prototype.readDoubleBE=\nfunction(a,c){return k(this,a,!1,c)};e.prototype.writeUInt8=function(a,c,d){d||(p(void 0!==a&&null!==a,\"missing value\"),p(void 0!==c&&null!==c,\"missing offset\"),p(c<this.length,\"trying to write beyond buffer length\"),H(a,255));c>=this.length||(this[c]=a)};e.prototype.writeUInt16LE=function(c,d,b){a(this,c,d,!0,b)};e.prototype.writeUInt16BE=function(c,d,b){a(this,c,d,!1,b)};e.prototype.writeUInt32LE=function(a,d,b){c(this,a,d,!0,b)};e.prototype.writeUInt32BE=function(a,d,b){c(this,a,d,!1,b)};e.prototype.writeInt8=\nfunction(a,c,d){d||(p(void 0!==a&&null!==a,\"missing value\"),p(void 0!==c&&null!==c,\"missing offset\"),p(c<this.length,\"Trying to write beyond buffer length\"),L(a,127,-128));c>=this.length||(0<=a?this.writeUInt8(a,c,d):this.writeUInt8(255+a+1,c,d))};e.prototype.writeInt16LE=function(a,c,b){d(this,a,c,!0,b)};e.prototype.writeInt16BE=function(a,c,b){d(this,a,c,!1,b)};e.prototype.writeInt32LE=function(a,c,d){y(this,a,c,!0,d)};e.prototype.writeInt32BE=function(a,c,d){y(this,a,c,!1,d)};e.prototype.writeFloatLE=\nfunction(a,c,d){x(this,a,c,!0,d)};e.prototype.writeFloatBE=function(a,c,d){x(this,a,c,!1,d)};e.prototype.writeDoubleLE=function(a,c,d){A(this,a,c,!0,d)};e.prototype.writeDoubleBE=function(a,c,d){A(this,a,c,!1,d)};e.prototype.fill=function(a,c,d){a||(a=0);c||(c=0);d||(d=this.length);\"string\"===typeof a&&(a=a.charCodeAt(0));p(\"number\"===typeof a&&!isNaN(a),\"value is not a number\");p(d>=c,\"end < start\");if(d!==c&&0!==this.length)for(p(0<=c&&c<this.length,\"start out of bounds\"),p(0<=d&&d<=this.length,\n\"end out of bounds\");c<d;c++)this[c]=a};e.prototype.inspect=function(){for(var a=[],c=this.length,d=0;d<c;d++)if(a[d]=G(this[d]),d===t.INSPECT_MAX_BYTES){a[d+1]=\"...\";break}return\"<Buffer \"+a.join(\" \")+\">\"};e.prototype.toArrayBuffer=function(){if(\"undefined\"!==typeof Uint8Array){if(e._useTypedArrays)return(new e(this)).buffer;for(var a=new Uint8Array(this.length),c=0,d=a.length;c<d;c+=1)a[c]=this[c];return a.buffer}throw Error(\"Buffer.toArrayBuffer not supported in this browser\");};var v=e.prototype;\ne._augment=function(a){a._isBuffer=!0;a._get=a.get;a._set=a.set;a.get=v.get;a.set=v.set;a.write=v.write;a.toString=v.toString;a.toLocaleString=v.toString;a.toJSON=v.toJSON;a.copy=v.copy;a.slice=v.slice;a.readUInt8=v.readUInt8;a.readUInt16LE=v.readUInt16LE;a.readUInt16BE=v.readUInt16BE;a.readUInt32LE=v.readUInt32LE;a.readUInt32BE=v.readUInt32BE;a.readInt8=v.readInt8;a.readInt16LE=v.readInt16LE;a.readInt16BE=v.readInt16BE;a.readInt32LE=v.readInt32LE;a.readInt32BE=v.readInt32BE;a.readFloatLE=v.readFloatLE;\na.readFloatBE=v.readFloatBE;a.readDoubleLE=v.readDoubleLE;a.readDoubleBE=v.readDoubleBE;a.writeUInt8=v.writeUInt8;a.writeUInt16LE=v.writeUInt16LE;a.writeUInt16BE=v.writeUInt16BE;a.writeUInt32LE=v.writeUInt32LE;a.writeUInt32BE=v.writeUInt32BE;a.writeInt8=v.writeInt8;a.writeInt16LE=v.writeInt16LE;a.writeInt16BE=v.writeInt16BE;a.writeInt32LE=v.writeInt32LE;a.writeInt32BE=v.writeInt32BE;a.writeFloatLE=v.writeFloatLE;a.writeFloatBE=v.writeFloatBE;a.writeDoubleLE=v.writeDoubleLE;a.writeDoubleBE=v.writeDoubleBE;\na.fill=v.fill;a.inspect=v.inspect;a.toArrayBuffer=v.toArrayBuffer;return a}},{\"base64-js\":3,ieee754:6}],6:[function(n,w,t){t.read=function(e,r,l,m,g){var b;b=8*g-m-1;var f=(1<<b)-1,k=f>>1,a=-7;g=l?g-1:0;var c=l?-1:1,d=e[r+g];g+=c;l=d&(1<<-a)-1;d>>=-a;for(a+=b;0<a;l=256*l+e[r+g],g+=c,a-=8);b=l&(1<<-a)-1;l>>=-a;for(a+=m;0<a;b=256*b+e[r+g],g+=c,a-=8);if(0===l)l=1-k;else{if(l===f)return b?NaN:Infinity*(d?-1:1);b+=Math.pow(2,m);l-=k}return(d?-1:1)*b*Math.pow(2,l-m)};t.write=function(e,r,l,m,g,b){var f,\nk=8*b-g-1,a=(1<<k)-1,c=a>>1,d=23===g?Math.pow(2,-24)-Math.pow(2,-77):0;b=m?0:b-1;var y=m?1:-1,x=0>r||0===r&&0>1/r?1:0;r=Math.abs(r);isNaN(r)||Infinity===r?(r=isNaN(r)?1:0,m=a):(m=Math.floor(Math.log(r)/Math.LN2),1>r*(f=Math.pow(2,-m))&&(m--,f*=2),r=1<=m+c?r+d/f:r+d*Math.pow(2,1-c),2<=r*f&&(m++,f/=2),m+c>=a?(r=0,m=a):1<=m+c?(r=(r*f-1)*Math.pow(2,g),m+=c):(r=r*Math.pow(2,c-1)*Math.pow(2,g),m=0));for(;8<=g;e[l+b]=r&255,b+=y,r/=256,g-=8);m=m<<g|r;for(k+=g;0<k;e[l+b]=m&255,b+=y,m/=256,k-=8);e[l+b-y]|=\n128*x}},{}],7:[function(n,w,t){(function(e){function r(b,f){for(var e=0,a=b.length-1;0<=a;a--){var c=b[a];\".\"===c?b.splice(a,1):\"..\"===c?(b.splice(a,1),e++):e&&(b.splice(a,1),e--)}if(f)for(;e--;e)b.unshift(\"..\");return b}function l(b,f){if(b.filter)return b.filter(f);for(var e=[],a=0;a<b.length;a++)f(b[a],a,b)&&e.push(b[a]);return e}var m=/^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;t.resolve=function(){for(var b=\"\",f=!1,k=arguments.length-1;-1<=k&&!f;k--){var a=0<=k?arguments[k]:\ne.cwd();if(\"string\"!==typeof a)throw new TypeError(\"Arguments to path.resolve must be strings\");a&&(b=a+\"/\"+b,f=\"/\"===a.charAt(0))}b=r(l(b.split(\"/\"),function(a){return!!a}),!f).join(\"/\");return(f?\"/\":\"\")+b||\".\"};t.normalize=function(b){var f=t.isAbsolute(b),e=\"/\"===g(b,-1);(b=r(l(b.split(\"/\"),function(a){return!!a}),!f).join(\"/\"))||f||(b=\".\");b&&e&&(b+=\"/\");return(f?\"/\":\"\")+b};t.isAbsolute=function(b){return\"/\"===b.charAt(0)};t.join=function(){var b=Array.prototype.slice.call(arguments,0);return t.normalize(l(b,\nfunction(b,e){if(\"string\"!==typeof b)throw new TypeError(\"Arguments to path.join must be strings\");return b}).join(\"/\"))};t.relative=function(b,f){function e(a){for(var c=0;c<a.length&&\"\"===a[c];c++);for(var d=a.length-1;0<=d&&\"\"===a[d];d--);return c>d?[]:a.slice(c,d-c+1)}b=t.resolve(b).substr(1);f=t.resolve(f).substr(1);for(var a=e(b.split(\"/\")),c=e(f.split(\"/\")),d=Math.min(a.length,c.length),g=d,x=0;x<d;x++)if(a[x]!==c[x]){g=x;break}d=[];for(x=g;x<a.length;x++)d.push(\"..\");d=d.concat(c.slice(g));\nreturn d.join(\"/\")};t.sep=\"/\";t.delimiter=\":\";t.dirname=function(b){var f=m.exec(b).slice(1);b=f[0];f=f[1];if(!b&&!f)return\".\";f&&(f=f.substr(0,f.length-1));return b+f};t.basename=function(b,f){var e=m.exec(b).slice(1)[2];f&&e.substr(-1*f.length)===f&&(e=e.substr(0,e.length-f.length));return e};t.extname=function(b){return m.exec(b).slice(1)[3]};var g=\"b\"===\"ab\".substr(-1)?function(b,f,e){return b.substr(f,e)}:function(b,f,e){0>f&&(f=b.length+f);return b.substr(f,e)}}).call(this,n(\"node_modules/process/browser.js\"))},\n{\"node_modules/process/browser.js\":8}],8:[function(n,w,t){function e(){}n=w.exports={};n.nextTick=function(){if(\"undefined\"!==typeof window&&window.setImmediate)return function(e){return window.setImmediate(e)};if(\"undefined\"!==typeof window&&window.postMessage&&window.addEventListener){var e=[];window.addEventListener(\"message\",function(l){var m=l.source;m!==window&&null!==m||\"process-tick\"!==l.data||(l.stopPropagation(),0<e.length&&e.shift()())},!0);return function(l){e.push(l);window.postMessage(\"process-tick\",\n\"*\")}}return function(e){setTimeout(e,0)}}();n.title=\"browser\";n.browser=!0;n.env={};n.argv=[];n.on=e;n.once=e;n.off=e;n.emit=e;n.binding=function(e){throw Error(\"process.binding is not supported\");};n.cwd=function(){return\"/\"};n.chdir=function(e){throw Error(\"process.chdir is not supported\");}},{}],9:[function(n,w,t){t.SourceMapGenerator=n(\"./source-map/source-map-generator\").SourceMapGenerator;t.SourceMapConsumer=n(\"./source-map/source-map-consumer\").SourceMapConsumer;t.SourceNode=n(\"./source-map/source-node\").SourceNode},\n{\"./source-map/source-map-consumer\":14,\"./source-map/source-map-generator\":15,\"./source-map/source-node\":16}],10:[function(n,w,t){if(\"function\"!==typeof e)var e=n(\"amdefine\")(w,n);e(function(e,l,m){function g(){this._array=[];this._set={}}var b=e(\"./util\");g.fromArray=function(b,e){for(var a=new g,c=0,d=b.length;c<d;c++)a.add(b[c],e);return a};g.prototype.add=function(f,e){var a=this.has(f),c=this._array.length;a&&!e||this._array.push(f);a||(this._set[b.toSetString(f)]=c)};g.prototype.has=function(f){return Object.prototype.hasOwnProperty.call(this._set,\nb.toSetString(f))};g.prototype.indexOf=function(f){if(this.has(f))return this._set[b.toSetString(f)];throw Error('\"'+f+'\" is not in the set.');};g.prototype.at=function(b){if(0<=b&&b<this._array.length)return this._array[b];throw Error(\"No element indexed by \"+b);};g.prototype.toArray=function(){return this._array.slice()};l.ArraySet=g})},{\"./util\":17,amdefine:2}],11:[function(n,w,t){if(\"function\"!==typeof e)var e=n(\"amdefine\")(w,n);e(function(e,l,m){var g=e(\"./base64\");l.encode=function(b){var e=\n\"\",k=0>b?(-b<<1)+1:(b<<1)+0;do b=k&31,k>>>=5,0<k&&(b|=32),e+=g.encode(b);while(0<k);return e};l.decode=function(b){var e=0,k=b.length,a=0,c=0,d,y;do{if(e>=k)throw Error(\"Expected more digits in base 64 VLQ value.\");y=g.decode(b.charAt(e++));d=!!(y&32);y&=31;a+=y<<c;c+=5}while(d);k=a>>1;return{value:1===(a&1)?-k:k,rest:b.slice(e)}}})},{\"./base64\":12,amdefine:2}],12:[function(n,w,t){if(\"function\"!==typeof e)var e=n(\"amdefine\")(w,n);e(function(e,l,m){var g={},b={};\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".split(\"\").forEach(function(e,\nk){g[e]=k;b[k]=e});l.encode=function(e){if(e in b)return b[e];throw new TypeError(\"Must be between 0 and 63: \"+e);};l.decode=function(b){if(b in g)return g[b];throw new TypeError(\"Not a valid base 64 digit: \"+b);}})},{amdefine:2}],13:[function(n,w,t){if(\"function\"!==typeof e)var e=n(\"amdefine\")(w,n);e(function(e,l,m){function g(b,e,k,a,c){var d=Math.floor((e-b)/2)+b,y=c(k,a[d],!0);return 0===y?a[d]:0<y?1<e-d?g(d,e,k,a,c):a[d]:1<d-b?g(b,d,k,a,c):0>b?null:a[b]}l.search=function(b,e,k){return 0<e.length?\ng(-1,e.length,b,e,k):null}})},{amdefine:2}],14:[function(n,w,t){if(\"function\"!==typeof e)var e=n(\"amdefine\")(w,n);e(function(e,l,m){function g(a){var d=a;\"string\"===typeof a&&(d=JSON.parse(a.replace(/^\\)\\]\\}'/,\"\")));a=b.getArg(d,\"version\");var e=b.getArg(d,\"sources\"),f=b.getArg(d,\"names\",[]),g=b.getArg(d,\"sourceRoot\",null),l=b.getArg(d,\"sourcesContent\",null),m=b.getArg(d,\"mappings\"),d=b.getArg(d,\"file\",null);if(a!=this._version)throw Error(\"Unsupported version: \"+a);this._names=k.fromArray(f,!0);\nthis._sources=k.fromArray(e,!0);this.sourceRoot=g;this.sourcesContent=l;this._mappings=m;this.file=d}var b=e(\"./util\"),f=e(\"./binary-search\"),k=e(\"./array-set\").ArraySet,a=e(\"./base64-vlq\");g.fromSourceMap=function(a){var d=Object.create(g.prototype);d._names=k.fromArray(a._names.toArray(),!0);d._sources=k.fromArray(a._sources.toArray(),!0);d.sourceRoot=a._sourceRoot;d.sourcesContent=a._generateSourcesContent(d._sources.toArray(),d.sourceRoot);d.file=a._file;d.__generatedMappings=a._mappings.slice().sort(b.compareByGeneratedPositions);\nd.__originalMappings=a._mappings.slice().sort(b.compareByOriginalPositions);return d};g.prototype._version=3;Object.defineProperty(g.prototype,\"sources\",{get:function(){return this._sources.toArray().map(function(a){return this.sourceRoot?b.join(this.sourceRoot,a):a},this)}});g.prototype.__generatedMappings=null;Object.defineProperty(g.prototype,\"_generatedMappings\",{get:function(){this.__generatedMappings||(this.__generatedMappings=[],this.__originalMappings=[],this._parseMappings(this._mappings,\nthis.sourceRoot));return this.__generatedMappings}});g.prototype.__originalMappings=null;Object.defineProperty(g.prototype,\"_originalMappings\",{get:function(){this.__originalMappings||(this.__generatedMappings=[],this.__originalMappings=[],this._parseMappings(this._mappings,this.sourceRoot));return this.__originalMappings}});g.prototype._parseMappings=function(c,d){for(var e=1,f=0,g=0,k=0,l=0,m=0,r=/^[,;]/,u=c,n;0<u.length;)if(\";\"===u.charAt(0))e++,u=u.slice(1),f=0;else if(\",\"===u.charAt(0))u=u.slice(1);\nelse{n={};n.generatedLine=e;u=a.decode(u);n.generatedColumn=f+u.value;f=n.generatedColumn;u=u.rest;if(0<u.length&&!r.test(u.charAt(0))){u=a.decode(u);n.source=this._sources.at(l+u.value);l+=u.value;u=u.rest;if(0===u.length||r.test(u.charAt(0)))throw Error(\"Found a source, but no line and column\");u=a.decode(u);n.originalLine=g+u.value;g=n.originalLine;n.originalLine+=1;u=u.rest;if(0===u.length||r.test(u.charAt(0)))throw Error(\"Found a source and line, but no column\");u=a.decode(u);n.originalColumn=\nk+u.value;k=n.originalColumn;u=u.rest;0<u.length&&!r.test(u.charAt(0))&&(u=a.decode(u),n.name=this._names.at(m+u.value),m+=u.value,u=u.rest)}this.__generatedMappings.push(n);\"number\"===typeof n.originalLine&&this.__originalMappings.push(n)}this.__generatedMappings.sort(b.compareByGeneratedPositions);this.__originalMappings.sort(b.compareByOriginalPositions)};g.prototype._findMapping=function(a,d,b,e,g){if(0>=a[b])throw new TypeError(\"Line must be greater than or equal to 1, got \"+a[b]);if(0>a[e])throw new TypeError(\"Column must be greater than or equal to 0, got \"+\na[e]);return f.search(a,d,g)};g.prototype.originalPositionFor=function(a){a={generatedLine:b.getArg(a,\"line\"),generatedColumn:b.getArg(a,\"column\")};if(a=this._findMapping(a,this._generatedMappings,\"generatedLine\",\"generatedColumn\",b.compareByGeneratedPositions)){var d=b.getArg(a,\"source\",null);d&&this.sourceRoot&&(d=b.join(this.sourceRoot,d));return{source:d,line:b.getArg(a,\"originalLine\",null),column:b.getArg(a,\"originalColumn\",null),name:b.getArg(a,\"name\",null)}}return{source:null,line:null,column:null,\nname:null}};g.prototype.sourceContentFor=function(a){if(!this.sourcesContent)return null;this.sourceRoot&&(a=b.relative(this.sourceRoot,a));if(this._sources.has(a))return this.sourcesContent[this._sources.indexOf(a)];var d;if(this.sourceRoot&&(d=b.urlParse(this.sourceRoot))){var e=a.replace(/^file:\\/\\//,\"\");if(\"file\"==d.scheme&&this._sources.has(e))return this.sourcesContent[this._sources.indexOf(e)];if((!d.path||\"/\"==d.path)&&this._sources.has(\"/\"+a))return this.sourcesContent[this._sources.indexOf(\"/\"+\na)]}throw Error('\"'+a+'\" is not in the SourceMap.');};g.prototype.generatedPositionFor=function(a){a={source:b.getArg(a,\"source\"),originalLine:b.getArg(a,\"line\"),originalColumn:b.getArg(a,\"column\")};this.sourceRoot&&(a.source=b.relative(this.sourceRoot,a.source));return(a=this._findMapping(a,this._originalMappings,\"originalLine\",\"originalColumn\",b.compareByOriginalPositions))?{line:b.getArg(a,\"generatedLine\",null),column:b.getArg(a,\"generatedColumn\",null)}:{line:null,column:null}};g.GENERATED_ORDER=\n1;g.ORIGINAL_ORDER=2;g.prototype.eachMapping=function(a,d,e){d=d||null;switch(e||g.GENERATED_ORDER){case g.GENERATED_ORDER:e=this._generatedMappings;break;case g.ORIGINAL_ORDER:e=this._originalMappings;break;default:throw Error(\"Unknown order of iteration.\");}var f=this.sourceRoot;e.map(function(a){var c=a.source;c&&f&&(c=b.join(f,c));return{source:c,generatedLine:a.generatedLine,generatedColumn:a.generatedColumn,originalLine:a.originalLine,originalColumn:a.originalColumn,name:a.name}}).forEach(a,\nd)};l.SourceMapConsumer=g})},{\"./array-set\":10,\"./base64-vlq\":11,\"./binary-search\":13,\"./util\":17,amdefine:2}],15:[function(n,w,t){if(\"function\"!==typeof e)var e=n(\"amdefine\")(w,n);e(function(e,l,m){function g(a){this._file=f.getArg(a,\"file\");this._sourceRoot=f.getArg(a,\"sourceRoot\",null);this._sources=new k;this._names=new k;this._mappings=[];this._sourcesContents=null}var b=e(\"./base64-vlq\"),f=e(\"./util\"),k=e(\"./array-set\").ArraySet;g.prototype._version=3;g.fromSourceMap=function(a){var c=a.sourceRoot,\nd=new g({file:a.file,sourceRoot:c});a.eachMapping(function(a){var b={generated:{line:a.generatedLine,column:a.generatedColumn}};a.source&&(b.source=a.source,c&&(b.source=f.relative(c,b.source)),b.original={line:a.originalLine,column:a.originalColumn},a.name&&(b.name=a.name));d.addMapping(b)});a.sources.forEach(function(c){var b=a.sourceContentFor(c);b&&d.setSourceContent(c,b)});return d};g.prototype.addMapping=function(a){var c=f.getArg(a,\"generated\"),d=f.getArg(a,\"original\",null),b=f.getArg(a,\"source\",\nnull);a=f.getArg(a,\"name\",null);this._validateMapping(c,d,b,a);b&&!this._sources.has(b)&&this._sources.add(b);a&&!this._names.has(a)&&this._names.add(a);this._mappings.push({generatedLine:c.line,generatedColumn:c.column,originalLine:null!=d&&d.line,originalColumn:null!=d&&d.column,source:b,name:a})};g.prototype.setSourceContent=function(a,c){var d=a;this._sourceRoot&&(d=f.relative(this._sourceRoot,d));null!==c?(this._sourcesContents||(this._sourcesContents={}),this._sourcesContents[f.toSetString(d)]=\nc):(delete this._sourcesContents[f.toSetString(d)],0===Object.keys(this._sourcesContents).length&&(this._sourcesContents=null))};g.prototype.applySourceMap=function(a,c){c||(c=a.file);var d=this._sourceRoot;d&&(c=f.relative(d,c));var b=new k,e=new k;this._mappings.forEach(function(g){if(g.source===c&&g.originalLine){var k=a.originalPositionFor({line:g.originalLine,column:g.originalColumn});null!==k.source&&(g.source=d?f.relative(d,k.source):k.source,g.originalLine=k.line,g.originalColumn=k.column,\nnull!==k.name&&null!==g.name&&(g.name=k.name))}(k=g.source)&&!b.has(k)&&b.add(k);(g=g.name)&&!e.has(g)&&e.add(g)},this);this._sources=b;this._names=e;a.sources.forEach(function(c){var b=a.sourceContentFor(c);b&&(d&&(c=f.relative(d,c)),this.setSourceContent(c,b))},this)};g.prototype._validateMapping=function(a,c,d,b){if(!(a&&\"line\"in a&&\"column\"in a&&0<a.line&&0<=a.column&&!c&&!d&&!b||a&&\"line\"in a&&\"column\"in a&&c&&\"line\"in c&&\"column\"in c&&0<a.line&&0<=a.column&&0<c.line&&0<=c.column&&d))throw Error(\"Invalid mapping: \"+\nJSON.stringify({generated:a,source:d,original:c,name:b}));};g.prototype._serializeMappings=function(){var a=0,c=1,d=0,e=0,g=0,k=0,l=\"\",m;this._mappings.sort(f.compareByGeneratedPositions);for(var n=0,r=this._mappings.length;n<r;n++){m=this._mappings[n];if(m.generatedLine!==c)for(a=0;m.generatedLine!==c;)l+=\";\",c++;else if(0<n){if(!f.compareByGeneratedPositions(m,this._mappings[n-1]))continue;l+=\",\"}l+=b.encode(m.generatedColumn-a);a=m.generatedColumn;m.source&&(l+=b.encode(this._sources.indexOf(m.source)-\nk),k=this._sources.indexOf(m.source),l+=b.encode(m.originalLine-1-e),e=m.originalLine-1,l+=b.encode(m.originalColumn-d),d=m.originalColumn,m.name&&(l+=b.encode(this._names.indexOf(m.name)-g),g=this._names.indexOf(m.name)))}return l};g.prototype._generateSourcesContent=function(a,c){return a.map(function(a){if(!this._sourcesContents)return null;c&&(a=f.relative(c,a));a=f.toSetString(a);return Object.prototype.hasOwnProperty.call(this._sourcesContents,a)?this._sourcesContents[a]:null},this)};g.prototype.toJSON=\nfunction(){var a={version:this._version,file:this._file,sources:this._sources.toArray(),names:this._names.toArray(),mappings:this._serializeMappings()};this._sourceRoot&&(a.sourceRoot=this._sourceRoot);this._sourcesContents&&(a.sourcesContent=this._generateSourcesContent(a.sources,a.sourceRoot));return a};g.prototype.toString=function(){return JSON.stringify(this)};l.SourceMapGenerator=g})},{\"./array-set\":10,\"./base64-vlq\":11,\"./util\":17,amdefine:2}],16:[function(n,w,t){if(\"function\"!==typeof e)var e=\nn(\"amdefine\")(w,n);e(function(e,l,m){function g(b,a,c,d,e){this.children=[];this.sourceContents={};this.line=void 0===b?null:b;this.column=void 0===a?null:a;this.source=void 0===c?null:c;this.name=void 0===e?null:e;null!=d&&this.add(d)}var b=e(\"./source-map-generator\").SourceMapGenerator,f=e(\"./util\");g.fromStringWithSourceMap=function(b,a){function c(a,c){null===a||void 0===a.source?d.add(c):d.add(new g(a.originalLine,a.originalColumn,a.source,c,a.name))}var d=new g,e=b.split(\"\\n\"),f=1,l=0,m=null;\na.eachMapping(function(a){if(null===m){for(;f<a.generatedLine;)d.add(e.shift()+\"\\n\"),f++;if(l<a.generatedColumn){var b=e[0];d.add(b.substr(0,a.generatedColumn));e[0]=b.substr(a.generatedColumn);l=a.generatedColumn}}else{if(f<a.generatedLine){var g=\"\";do g+=e.shift()+\"\\n\",f++,l=0;while(f<a.generatedLine);l<a.generatedColumn&&(b=e[0],g+=b.substr(0,a.generatedColumn),e[0]=b.substr(a.generatedColumn),l=a.generatedColumn)}else b=e[0],g=b.substr(0,a.generatedColumn-l),e[0]=b.substr(a.generatedColumn-l),\nl=a.generatedColumn;c(m,g)}m=a},this);c(m,e.join(\"\\n\"));a.sources.forEach(function(c){var b=a.sourceContentFor(c);b&&d.setSourceContent(c,b)});return d};g.prototype.add=function(b){if(Array.isArray(b))b.forEach(function(a){this.add(a)},this);else if(b instanceof g||\"string\"===typeof b)b&&this.children.push(b);else throw new TypeError(\"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \"+b);return this};g.prototype.prepend=function(b){if(Array.isArray(b))for(var a=b.length-\n1;0<=a;a--)this.prepend(b[a]);else if(b instanceof g||\"string\"===typeof b)this.children.unshift(b);else throw new TypeError(\"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \"+b);return this};g.prototype.walk=function(b){for(var a,c=0,d=this.children.length;c<d;c++)a=this.children[c],a instanceof g?a.walk(b):\"\"!==a&&b(a,{source:this.source,line:this.line,column:this.column,name:this.name})};g.prototype.join=function(b){var a,c,d=this.children.length;if(0<d){a=[];for(c=0;c<\nd-1;c++)a.push(this.children[c]),a.push(b);a.push(this.children[c]);this.children=a}return this};g.prototype.replaceRight=function(b,a){var c=this.children[this.children.length-1];c instanceof g?c.replaceRight(b,a):\"string\"===typeof c?this.children[this.children.length-1]=c.replace(b,a):this.children.push(\"\".replace(b,a));return this};g.prototype.setSourceContent=function(b,a){this.sourceContents[f.toSetString(b)]=a};g.prototype.walkSourceContents=function(b){for(var a=0,c=this.children.length;a<\nc;a++)this.children[a]instanceof g&&this.children[a].walkSourceContents(b);for(var d=Object.keys(this.sourceContents),a=0,c=d.length;a<c;a++)b(f.fromSetString(d[a]),this.sourceContents[d[a]])};g.prototype.toString=function(){var b=\"\";this.walk(function(a){b+=a});return b};g.prototype.toStringWithSourceMap=function(e){var a=\"\",c=1,d=0,f=new b(e),g=!1,l=null,m=null,n=null,r=null;this.walk(function(b,e){a+=b;null!==e.source&&null!==e.line&&null!==e.column?(l===e.source&&m===e.line&&n===e.column&&r===\ne.name||f.addMapping({source:e.source,original:{line:e.line,column:e.column},generated:{line:c,column:d},name:e.name}),l=e.source,m=e.line,n=e.column,r=e.name,g=!0):g&&(f.addMapping({generated:{line:c,column:d}}),l=null,g=!1);b.split(\"\").forEach(function(a){\"\\n\"===a?(c++,d=0):d++})});this.walkSourceContents(function(a,c){f.setSourceContent(a,c)});return{code:a,map:f}};l.SourceNode=g})},{\"./source-map-generator\":15,\"./util\":17,amdefine:2}],17:[function(n,w,t){if(\"function\"!==typeof e)var e=n(\"amdefine\")(w,\nn);e(function(e,l,m){function g(a){return(a=a.match(k))?{scheme:a[1],auth:a[3],host:a[4],port:a[6],path:a[7]}:null}function b(a){var b=a.scheme+\"://\";a.auth&&(b+=a.auth+\"@\");a.host&&(b+=a.host);a.port&&(b+=\":\"+a.port);a.path&&(b+=a.path);return b}function f(a,b){var e=a||\"\",f=b||\"\";return(e>f)-(e<f)}l.getArg=function(a,b,e){if(b in a)return a[b];if(3===arguments.length)return e;throw Error('\"'+b+'\" is a required argument.');};var k=/([\\w+\\-.]+):\\/\\/((\\w+:\\w+)@)?([\\w.]+)?(:(\\d+))?(\\S+)?/,a=/^data:.+\\,.+/;\nl.urlParse=g;l.urlGenerate=b;l.join=function(c,d){var e;return d.match(k)||d.match(a)?d:\"/\"===d.charAt(0)&&(e=g(c))?(e.path=d,b(e)):c.replace(/\\/$/,\"\")+\"/\"+d};l.toSetString=function(a){return\"$\"+a};l.fromSetString=function(a){return a.substr(1)};l.relative=function(a,b){a=a.replace(/\\/$/,\"\");var e=g(a);return\"/\"==b.charAt(0)&&e&&\"/\"==e.path?b.slice(1):0===b.indexOf(a+\"/\")?b.substr(a.length+1):b};l.compareByOriginalPositions=function(a,b,e){var g;return(g=f(a.source,b.source))||(g=a.originalLine-b.originalLine)||\n(g=a.originalColumn-b.originalColumn)||e||(g=f(a.name,b.name))?g:(g=a.generatedLine-b.generatedLine)?g:a.generatedColumn-b.generatedColumn};l.compareByGeneratedPositions=function(a,b,e){var g;return(g=a.generatedLine-b.generatedLine)||(g=a.generatedColumn-b.generatedColumn)||e||(g=f(a.source,b.source))||(g=a.originalLine-b.originalLine)?g:(g=a.originalColumn-b.originalColumn)?g:f(a.name,b.name)}})},{amdefine:2}],18:[function(n,w,t){(function(e,r){function l(){return\"browser\"===C?!0:\"node\"===C?!1:\n\"undefined\"!==typeof window&&\"function\"===typeof XMLHttpRequest}function m(a){a=a.trim();if(a in z)return z[a];try{if(l()){var b=new XMLHttpRequest;b.open(\"GET\",a,!1);b.send(null);var c=null;4===b.readyState&&200===b.status&&(c=b.responseText)}else c=E.readFileSync(a,\"utf8\")}catch(d){c=null}return z[a]=c}function g(a,b){if(!a)return b;var c=F.dirname(a),d=/^\\w+:\\/\\/[^\\/]*/.exec(c),d=d?d[0]:\"\";return d+F.resolve(c.slice(d.length),b)}function b(a){var b;a:{var c;if(l()&&(c=new XMLHttpRequest,c.open(\"GET\",\na,!1),c.send(null),c=c.getResponseHeader(\"SourceMap\")||c.getResponseHeader(\"X-SourceMap\"))){b=c;break a}c=m(a);for(var d=/(?:\\/\\/[@#][ \\t]+sourceMappingURL=([^\\s'\"]+?)[ \\t]*$)|(?:\\/\\*[@#][ \\t]+sourceMappingURL=([^\\*]+?)[ \\t]*(?:\\*\\/)[ \\t]*$)/mg,e;e=d.exec(c);)b=e;b=b?b[1]:null}if(!b)return null;H.test(b)?(a=b.slice(b.indexOf(\",\")+1),a=(new r(a,\"base64\")).toString(),b=null):(b=g(a,b),a=m(b));return a?{url:b,map:a}:null}function f(a){var c=D[a.source];if(!c){var d=b(a.source);d?(c=D[a.source]={url:d.url,\nmap:new B(d.map)},c.map.sourcesContent&&c.map.sources.forEach(function(a,b){var d=c.map.sourcesContent[b];if(d){var e=g(c.url,a);z[e]=d}})):c=D[a.source]={url:null,map:null}}return c&&c.map&&(d=c.map.originalPositionFor(a),null!==d.source)?(d.source=g(c.url,d.source),d):a}function k(a){var b=/^eval at ([^(]+) \\((.+):(\\d+):(\\d+)\\)$/.exec(a);return b?(a=f({source:b[2],line:b[3],column:b[4]-1}),\"eval at \"+b[1]+\" (\"+a.source+\":\"+a.line+\":\"+(a.column+1)+\")\"):(b=/^eval at ([^(]+) \\((.+)\\)$/.exec(a))?\"eval at \"+\nb[1]+\" (\"+k(b[2])+\")\":a}function a(){var a,b=\"\";this.isNative()?b=\"native\":(a=this.getScriptNameOrSourceURL(),!a&&this.isEval()&&(b=this.getEvalOrigin(),b+=\", \"),b=a?b+a:b+\"<anonymous>\",a=this.getLineNumber(),null!=a&&(b+=\":\"+a,(a=this.getColumnNumber())&&(b+=\":\"+a)));a=\"\";var c=this.getFunctionName(),d=!0,e=this.isConstructor();if(this.isToplevel()||e)e?a+=\"new \"+(c||\"<anonymous>\"):c?a+=c:(a+=b,d=!1);else{var e=this.getTypeName(),f=this.getMethodName();c?(e&&0!=c.indexOf(e)&&(a+=e+\".\"),a+=c,f&&c.indexOf(\".\"+\nf)!=c.length-f.length-1&&(a+=\" [as \"+f+\"]\")):a+=e+\".\"+(f||\"<anonymous>\")}d&&(a+=\" (\"+b+\")\");return a}function c(b){var c={};Object.getOwnPropertyNames(Object.getPrototypeOf(b)).forEach(function(a){c[a]=/^(?:is|get)/.test(a)?function(){return b[a].call(b)}:b[a]});c.toString=a;return c}function d(a){var b=a.getFileName()||a.getScriptNameOrSourceURL();if(b){var d=a.getLineNumber(),e=a.getColumnNumber()-1;1!==d||l()||a.isEval()||(e-=62);var g=f({source:b,line:d,column:e});a=c(a);a.getFileName=function(){return g.source};\na.getLineNumber=function(){return g.line};a.getColumnNumber=function(){return g.column+1};a.getScriptNameOrSourceURL=function(){return g.source};return a}var m=a.isEval()&&a.getEvalOrigin();m&&(m=k(m),a=c(a),a.getEvalOrigin=function(){return m});return a}function w(a,b){u&&(z={},D={});return a+b.map(function(a){return\"\\n    at \"+d(a)}).join(\"\")}function x(a){var b=/\\n    at [^(]+ \\((.*):(\\d+):(\\d+)\\)/.exec(a.stack);if(b){a=b[1];var c=+b[2],b=+b[3],d=z[a];!d&&E.existsSync(a)&&(d=E.readFileSync(a,\"utf8\"));\nif(d&&(d=d.split(/(?:\\r\\n|\\r|\\n)/)[c-1]))return a+\":\"+c+\"\\n\"+d+\"\\n\"+Array(b).join(\" \")+\"^\"}return null}function A(){var a=e.emit;e.emit=function(b){if(\"uncaughtException\"===b){var c=arguments[1]&&arguments[1].stack,d=0<this.listeners(b).length;if(c&&!d){c=arguments[1];if(d=x(c))console.error(),console.error(d);console.error(c.stack);e.exit(1);return}}return a.apply(this,arguments)}}var B=n(\"source-map\").SourceMapConsumer,F=n(\"path\"),E=n(\"fs\"),G=!1,u=!1,C=\"auto\",z={},D={},H=/^data:application\\/json[^,]+base64,/;\nt.wrapCallSite=d;t.getErrorSource=x;t.mapSourcePosition=f;t.retrieveSourceMap=b;t.install=function(a){if(!G){G=!0;Error.prepareStackTrace=w;a=a||{};var c=\"handleUncaughtExceptions\"in a?a.handleUncaughtExceptions:!0;u=\"emptyCacheBetweenOperations\"in a?a.emptyCacheBetweenOperations:!1;if(a.environment&&(C=a.environment,-1===[\"node\",\"browser\",\"auto\"].indexOf(C)))throw Error(\"environment \"+C+\" was unknown. Available options are {auto, browser, node}\");a.retrieveFile&&(m=a.retrieveFile);a.retrieveSourceMap&&\n(b=a.retrieveSourceMap);c&&\"object\"===typeof e&&null!==e&&\"function\"===typeof e.on&&A()}}}).call(this,n(\"node_modules/process/browser.js\"),n(\"buffer\").Buffer)},{\"node_modules/process/browser.js\":8,buffer:5,fs:4,path:7,\"source-map\":9}]},{},[1]);return K});\n"

/***/ },
/* 8 */
/***/ function(module, exports) {

	"use strict";
	
	module.exports = "/*\nCopyright (c) 2008-2015 Pivotal Labs\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\nvar getJasmineRequireObj = (function (jasmineGlobal) {\n  var jasmineRequire;\n\n  if (typeof module !== 'undefined' && module.exports) {\n    if (typeof global !== 'undefined') {\n      jasmineGlobal = global;\n    } else {\n      jasmineGlobal = {};\n    }\n    jasmineRequire = exports;\n  } else {\n    if (typeof window !== 'undefined' && typeof window.toString === 'function' && window.toString() === '[object GjsGlobal]') {\n      jasmineGlobal = window;\n    }\n    jasmineRequire = jasmineGlobal.jasmineRequire = jasmineGlobal.jasmineRequire || {};\n  }\n\n  function getJasmineRequire() {\n    return jasmineRequire;\n  }\n\n  getJasmineRequire().core = function(jRequire) {\n    var j$ = {};\n\n    jRequire.base(j$, jasmineGlobal);\n    j$.util = jRequire.util();\n    j$.errors = jRequire.errors();\n    j$.Any = jRequire.Any(j$);\n    j$.Anything = jRequire.Anything(j$);\n    j$.CallTracker = jRequire.CallTracker();\n    j$.MockDate = jRequire.MockDate();\n    j$.Clock = jRequire.Clock();\n    j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler();\n    j$.Env = jRequire.Env(j$);\n    j$.ExceptionFormatter = jRequire.ExceptionFormatter();\n    j$.Expectation = jRequire.Expectation();\n    j$.buildExpectationResult = jRequire.buildExpectationResult();\n    j$.JsApiReporter = jRequire.JsApiReporter();\n    j$.matchersUtil = jRequire.matchersUtil(j$);\n    j$.ObjectContaining = jRequire.ObjectContaining(j$);\n    j$.ArrayContaining = jRequire.ArrayContaining(j$);\n    j$.pp = jRequire.pp(j$);\n    j$.QueueRunner = jRequire.QueueRunner(j$);\n    j$.ReportDispatcher = jRequire.ReportDispatcher();\n    j$.Spec = jRequire.Spec(j$);\n    j$.SpyRegistry = jRequire.SpyRegistry(j$);\n    j$.SpyStrategy = jRequire.SpyStrategy();\n    j$.StringMatching = jRequire.StringMatching(j$);\n    j$.Suite = jRequire.Suite(j$);\n    j$.Timer = jRequire.Timer();\n    j$.TreeProcessor = jRequire.TreeProcessor();\n    j$.version = jRequire.version();\n    j$.Order = jRequire.Order();\n\n    j$.matchers = jRequire.requireMatchers(jRequire, j$);\n\n    return j$;\n  };\n\n  return getJasmineRequire;\n})(this);\n\ngetJasmineRequireObj().requireMatchers = function(jRequire, j$) {\n  var availableMatchers = [\n      'toBe',\n      'toBeCloseTo',\n      'toBeDefined',\n      'toBeFalsy',\n      'toBeGreaterThan',\n      'toBeLessThan',\n      'toBeNaN',\n      'toBeNull',\n      'toBeTruthy',\n      'toBeUndefined',\n      'toContain',\n      'toEqual',\n      'toHaveBeenCalled',\n      'toHaveBeenCalledWith',\n      'toHaveBeenCalledTimes',\n      'toMatch',\n      'toThrow',\n      'toThrowError'\n    ],\n    matchers = {};\n\n  for (var i = 0; i < availableMatchers.length; i++) {\n    var name = availableMatchers[i];\n    matchers[name] = jRequire[name](j$);\n  }\n\n  return matchers;\n};\n\ngetJasmineRequireObj().base = function(j$, jasmineGlobal) {\n  j$.unimplementedMethod_ = function() {\n    throw new Error('unimplemented method');\n  };\n\n  j$.MAX_PRETTY_PRINT_DEPTH = 40;\n  j$.MAX_PRETTY_PRINT_ARRAY_LENGTH = 100;\n  j$.DEFAULT_TIMEOUT_INTERVAL = 5000;\n\n  j$.getGlobal = function() {\n    return jasmineGlobal;\n  };\n\n  j$.getEnv = function(options) {\n    var env = j$.currentEnv_ = j$.currentEnv_ || new j$.Env(options);\n    //jasmine. singletons in here (setTimeout blah blah).\n    return env;\n  };\n\n  j$.isArray_ = function(value) {\n    return j$.isA_('Array', value);\n  };\n\n  j$.isString_ = function(value) {\n    return j$.isA_('String', value);\n  };\n\n  j$.isNumber_ = function(value) {\n    return j$.isA_('Number', value);\n  };\n\n  j$.isA_ = function(typeName, value) {\n    return Object.prototype.toString.apply(value) === '[object ' + typeName + ']';\n  };\n\n  j$.isDomNode = function(obj) {\n    return obj.nodeType > 0;\n  };\n\n  j$.fnNameFor = function(func) {\n    return func.name || func.toString().match(/^\\s*function\\s*(\\w*)\\s*\\(/)[1];\n  };\n\n  j$.any = function(clazz) {\n    return new j$.Any(clazz);\n  };\n\n  j$.anything = function() {\n    return new j$.Anything();\n  };\n\n  j$.objectContaining = function(sample) {\n    return new j$.ObjectContaining(sample);\n  };\n\n  j$.stringMatching = function(expected) {\n    return new j$.StringMatching(expected);\n  };\n\n  j$.arrayContaining = function(sample) {\n    return new j$.ArrayContaining(sample);\n  };\n\n  j$.createSpy = function(name, originalFn) {\n\n    var spyStrategy = new j$.SpyStrategy({\n        name: name,\n        fn: originalFn,\n        getSpy: function() { return spy; }\n      }),\n      callTracker = new j$.CallTracker(),\n      spy = function() {\n        var callData = {\n          object: this,\n          args: Array.prototype.slice.apply(arguments)\n        };\n\n        callTracker.track(callData);\n        var returnValue = spyStrategy.exec.apply(this, arguments);\n        callData.returnValue = returnValue;\n\n        return returnValue;\n      };\n\n    for (var prop in originalFn) {\n      if (prop === 'and' || prop === 'calls') {\n        throw new Error('Jasmine spies would overwrite the \\'and\\' and \\'calls\\' properties on the object being spied upon');\n      }\n\n      spy[prop] = originalFn[prop];\n    }\n\n    spy.and = spyStrategy;\n    spy.calls = callTracker;\n\n    return spy;\n  };\n\n  j$.isSpy = function(putativeSpy) {\n    if (!putativeSpy) {\n      return false;\n    }\n    return putativeSpy.and instanceof j$.SpyStrategy &&\n      putativeSpy.calls instanceof j$.CallTracker;\n  };\n\n  j$.createSpyObj = function(baseName, methodNames) {\n    if (j$.isArray_(baseName) && j$.util.isUndefined(methodNames)) {\n      methodNames = baseName;\n      baseName = 'unknown';\n    }\n\n    if (!j$.isArray_(methodNames) || methodNames.length === 0) {\n      throw 'createSpyObj requires a non-empty array of method names to create spies for';\n    }\n    var obj = {};\n    for (var i = 0; i < methodNames.length; i++) {\n      obj[methodNames[i]] = j$.createSpy(baseName + '.' + methodNames[i]);\n    }\n    return obj;\n  };\n};\n\ngetJasmineRequireObj().util = function() {\n\n  var util = {};\n\n  util.inherit = function(childClass, parentClass) {\n    var Subclass = function() {\n    };\n    Subclass.prototype = parentClass.prototype;\n    childClass.prototype = new Subclass();\n  };\n\n  util.htmlEscape = function(str) {\n    if (!str) {\n      return str;\n    }\n    return str.replace(/&/g, '&amp;')\n      .replace(/</g, '&lt;')\n      .replace(/>/g, '&gt;');\n  };\n\n  util.argsToArray = function(args) {\n    var arrayOfArgs = [];\n    for (var i = 0; i < args.length; i++) {\n      arrayOfArgs.push(args[i]);\n    }\n    return arrayOfArgs;\n  };\n\n  util.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  util.arrayContains = function(array, search) {\n    var i = array.length;\n    while (i--) {\n      if (array[i] === search) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  util.clone = function(obj) {\n    if (Object.prototype.toString.apply(obj) === '[object Array]') {\n      return obj.slice();\n    }\n\n    var cloned = {};\n    for (var prop in obj) {\n      if (obj.hasOwnProperty(prop)) {\n        cloned[prop] = obj[prop];\n      }\n    }\n\n    return cloned;\n  };\n\n  return util;\n};\n\ngetJasmineRequireObj().Spec = function(j$) {\n  function Spec(attrs) {\n    this.expectationFactory = attrs.expectationFactory;\n    this.resultCallback = attrs.resultCallback || function() {};\n    this.id = attrs.id;\n    this.description = attrs.description || '';\n    this.queueableFn = attrs.queueableFn;\n    this.beforeAndAfterFns = attrs.beforeAndAfterFns || function() { return {befores: [], afters: []}; };\n    this.userContext = attrs.userContext || function() { return {}; };\n    this.onStart = attrs.onStart || function() {};\n    this.getSpecName = attrs.getSpecName || function() { return ''; };\n    this.expectationResultFactory = attrs.expectationResultFactory || function() { };\n    this.queueRunnerFactory = attrs.queueRunnerFactory || function() {};\n    this.catchingExceptions = attrs.catchingExceptions || function() { return true; };\n    this.throwOnExpectationFailure = !!attrs.throwOnExpectationFailure;\n\n    if (!this.queueableFn.fn) {\n      this.pend();\n    }\n\n    this.result = {\n      id: this.id,\n      description: this.description,\n      fullName: this.getFullName(),\n      failedExpectations: [],\n      passedExpectations: [],\n      pendingReason: ''\n    };\n  }\n\n  Spec.prototype.addExpectationResult = function(passed, data, isError) {\n    var expectationResult = this.expectationResultFactory(data);\n    if (passed) {\n      this.result.passedExpectations.push(expectationResult);\n    } else {\n      this.result.failedExpectations.push(expectationResult);\n\n      if (this.throwOnExpectationFailure && !isError) {\n        throw new j$.errors.ExpectationFailed();\n      }\n    }\n  };\n\n  Spec.prototype.expect = function(actual) {\n    return this.expectationFactory(actual, this);\n  };\n\n  Spec.prototype.execute = function(onComplete, enabled) {\n    var self = this;\n\n    this.onStart(this);\n\n    if (!this.isExecutable() || this.markedPending || enabled === false) {\n      complete(enabled);\n      return;\n    }\n\n    var fns = this.beforeAndAfterFns();\n    var allFns = fns.befores.concat(this.queueableFn).concat(fns.afters);\n\n    this.queueRunnerFactory({\n      queueableFns: allFns,\n      onException: function() { self.onException.apply(self, arguments); },\n      onComplete: complete,\n      userContext: this.userContext()\n    });\n\n    function complete(enabledAgain) {\n      self.result.status = self.status(enabledAgain);\n      self.resultCallback(self.result);\n\n      if (onComplete) {\n        onComplete();\n      }\n    }\n  };\n\n  Spec.prototype.onException = function onException(e) {\n    if (Spec.isPendingSpecException(e)) {\n      this.pend(extractCustomPendingMessage(e));\n      return;\n    }\n\n    if (e instanceof j$.errors.ExpectationFailed) {\n      return;\n    }\n\n    this.addExpectationResult(false, {\n      matcherName: '',\n      passed: false,\n      expected: '',\n      actual: '',\n      error: e\n    }, true);\n  };\n\n  Spec.prototype.disable = function() {\n    this.disabled = true;\n  };\n\n  Spec.prototype.pend = function(message) {\n    this.markedPending = true;\n    if (message) {\n      this.result.pendingReason = message;\n    }\n  };\n\n  Spec.prototype.getResult = function() {\n    this.result.status = this.status();\n    return this.result;\n  };\n\n  Spec.prototype.status = function(enabled) {\n    if (this.disabled || enabled === false) {\n      return 'disabled';\n    }\n\n    if (this.markedPending) {\n      return 'pending';\n    }\n\n    if (this.result.failedExpectations.length > 0) {\n      return 'failed';\n    } else {\n      return 'passed';\n    }\n  };\n\n  Spec.prototype.isExecutable = function() {\n    return !this.disabled;\n  };\n\n  Spec.prototype.getFullName = function() {\n    return this.getSpecName(this);\n  };\n\n  var extractCustomPendingMessage = function(e) {\n    var fullMessage = e.toString(),\n        boilerplateStart = fullMessage.indexOf(Spec.pendingSpecExceptionMessage),\n        boilerplateEnd = boilerplateStart + Spec.pendingSpecExceptionMessage.length;\n\n    return fullMessage.substr(boilerplateEnd);\n  };\n\n  Spec.pendingSpecExceptionMessage = '=> marked Pending';\n\n  Spec.isPendingSpecException = function(e) {\n    return !!(e && e.toString && e.toString().indexOf(Spec.pendingSpecExceptionMessage) !== -1);\n  };\n\n  return Spec;\n};\n\nif (typeof window == void 0 && typeof exports == 'object') {\n  exports.Spec = jasmineRequire.Spec;\n}\n\n/*jshint bitwise: false*/\n\ngetJasmineRequireObj().Order = function() {\n  function Order(options) {\n    this.random = 'random' in options ? options.random : true;\n    var seed = this.seed = options.seed || generateSeed();\n    this.sort = this.random ? randomOrder : naturalOrder;\n\n    function naturalOrder(items) {\n      return items;\n    }\n\n    function randomOrder(items) {\n      var copy = items.slice();\n      copy.sort(function(a, b) {\n        return jenkinsHash(seed + a.id) - jenkinsHash(seed + b.id);\n      });\n      return copy;\n    }\n\n    function generateSeed() {\n      return String(Math.random()).slice(-5);\n    }\n\n    // Bob Jenkins One-at-a-Time Hash algorithm is a non-cryptographic hash function\n    // used to get a different output when the key changes slighly.\n    // We use your return to sort the children randomly in a consistent way when\n    // used in conjunction with a seed\n\n    function jenkinsHash(key) {\n      var hash, i;\n      for(hash = i = 0; i < key.length; ++i) {\n        hash += key.charCodeAt(i);\n        hash += (hash << 10);\n        hash ^= (hash >> 6);\n      }\n      hash += (hash << 3);\n      hash ^= (hash >> 11);\n      hash += (hash << 15);\n      return hash;\n    }\n\n  }\n\n  return Order;\n};\n\ngetJasmineRequireObj().Env = function(j$) {\n  function Env(options) {\n    options = options || {};\n\n    var self = this;\n    var global = options.global || j$.getGlobal();\n\n    var totalSpecsDefined = 0;\n\n    var catchExceptions = true;\n\n    var realSetTimeout = j$.getGlobal().setTimeout;\n    var realClearTimeout = j$.getGlobal().clearTimeout;\n    this.clock = new j$.Clock(global, function () { return new j$.DelayedFunctionScheduler(); }, new j$.MockDate(global));\n\n    var runnableLookupTable = {};\n    var runnableResources = {};\n\n    var currentSpec = null;\n    var currentlyExecutingSuites = [];\n    var currentDeclarationSuite = null;\n    var throwOnExpectationFailure = false;\n    var random = false;\n    var seed = null;\n\n    var currentSuite = function() {\n      return currentlyExecutingSuites[currentlyExecutingSuites.length - 1];\n    };\n\n    var currentRunnable = function() {\n      return currentSpec || currentSuite();\n    };\n\n    var reporter = new j$.ReportDispatcher([\n      'jasmineStarted',\n      'jasmineDone',\n      'suiteStarted',\n      'suiteDone',\n      'specStarted',\n      'specDone'\n    ]);\n\n    this.specFilter = function() {\n      return true;\n    };\n\n    this.addCustomEqualityTester = function(tester) {\n      if(!currentRunnable()) {\n        throw new Error('Custom Equalities must be added in a before function or a spec');\n      }\n      runnableResources[currentRunnable().id].customEqualityTesters.push(tester);\n    };\n\n    this.addMatchers = function(matchersToAdd) {\n      if(!currentRunnable()) {\n        throw new Error('Matchers must be added in a before function or a spec');\n      }\n      var customMatchers = runnableResources[currentRunnable().id].customMatchers;\n      for (var matcherName in matchersToAdd) {\n        customMatchers[matcherName] = matchersToAdd[matcherName];\n      }\n    };\n\n    j$.Expectation.addCoreMatchers(j$.matchers);\n\n    var nextSpecId = 0;\n    var getNextSpecId = function() {\n      return 'spec' + nextSpecId++;\n    };\n\n    var nextSuiteId = 0;\n    var getNextSuiteId = function() {\n      return 'suite' + nextSuiteId++;\n    };\n\n    var expectationFactory = function(actual, spec) {\n      return j$.Expectation.Factory({\n        util: j$.matchersUtil,\n        customEqualityTesters: runnableResources[spec.id].customEqualityTesters,\n        customMatchers: runnableResources[spec.id].customMatchers,\n        actual: actual,\n        addExpectationResult: addExpectationResult\n      });\n\n      function addExpectationResult(passed, result) {\n        return spec.addExpectationResult(passed, result);\n      }\n    };\n\n    var defaultResourcesForRunnable = function(id, parentRunnableId) {\n      var resources = {spies: [], customEqualityTesters: [], customMatchers: {}};\n\n      if(runnableResources[parentRunnableId]){\n        resources.customEqualityTesters = j$.util.clone(runnableResources[parentRunnableId].customEqualityTesters);\n        resources.customMatchers = j$.util.clone(runnableResources[parentRunnableId].customMatchers);\n      }\n\n      runnableResources[id] = resources;\n    };\n\n    var clearResourcesForRunnable = function(id) {\n        spyRegistry.clearSpies();\n        delete runnableResources[id];\n    };\n\n    var beforeAndAfterFns = function(suite) {\n      return function() {\n        var befores = [],\n          afters = [];\n\n        while(suite) {\n          befores = befores.concat(suite.beforeFns);\n          afters = afters.concat(suite.afterFns);\n\n          suite = suite.parentSuite;\n        }\n\n        return {\n          befores: befores.reverse(),\n          afters: afters\n        };\n      };\n    };\n\n    var getSpecName = function(spec, suite) {\n      return suite.getFullName() + ' ' + spec.description;\n    };\n\n    // TODO: we may just be able to pass in the fn instead of wrapping here\n    var buildExpectationResult = j$.buildExpectationResult,\n        exceptionFormatter = new j$.ExceptionFormatter(),\n        expectationResultFactory = function(attrs) {\n          attrs.messageFormatter = exceptionFormatter.message;\n          attrs.stackFormatter = exceptionFormatter.stack;\n\n          return buildExpectationResult(attrs);\n        };\n\n    // TODO: fix this naming, and here's where the value comes in\n    this.catchExceptions = function(value) {\n      catchExceptions = !!value;\n      return catchExceptions;\n    };\n\n    this.catchingExceptions = function() {\n      return catchExceptions;\n    };\n\n    var maximumSpecCallbackDepth = 20;\n    var currentSpecCallbackDepth = 0;\n\n    function clearStack(fn) {\n      currentSpecCallbackDepth++;\n      if (currentSpecCallbackDepth >= maximumSpecCallbackDepth) {\n        currentSpecCallbackDepth = 0;\n        realSetTimeout(fn, 0);\n      } else {\n        fn();\n      }\n    }\n\n    var catchException = function(e) {\n      return j$.Spec.isPendingSpecException(e) || catchExceptions;\n    };\n\n    this.throwOnExpectationFailure = function(value) {\n      throwOnExpectationFailure = !!value;\n    };\n\n    this.throwingExpectationFailures = function() {\n      return throwOnExpectationFailure;\n    };\n\n    this.randomizeTests = function(value) {\n      random = !!value;\n    };\n\n    this.randomTests = function() {\n      return random;\n    };\n\n    this.seed = function(value) {\n      if (value) {\n        seed = value;\n      }\n      return seed;\n    };\n\n    var queueRunnerFactory = function(options) {\n      options.catchException = catchException;\n      options.clearStack = options.clearStack || clearStack;\n      options.timeout = {setTimeout: realSetTimeout, clearTimeout: realClearTimeout};\n      options.fail = self.fail;\n\n      new j$.QueueRunner(options).execute();\n    };\n\n    var topSuite = new j$.Suite({\n      env: this,\n      id: getNextSuiteId(),\n      description: 'Jasmine__TopLevel__Suite',\n      queueRunner: queueRunnerFactory\n    });\n    runnableLookupTable[topSuite.id] = topSuite;\n    defaultResourcesForRunnable(topSuite.id);\n    currentDeclarationSuite = topSuite;\n\n    this.topSuite = function() {\n      return topSuite;\n    };\n\n    this.execute = function(runnablesToRun) {\n      if(!runnablesToRun) {\n        if (focusedRunnables.length) {\n          runnablesToRun = focusedRunnables;\n        } else {\n          runnablesToRun = [topSuite.id];\n        }\n      }\n\n      var order = new j$.Order({\n        random: random,\n        seed: seed\n      });\n\n      var processor = new j$.TreeProcessor({\n        tree: topSuite,\n        runnableIds: runnablesToRun,\n        queueRunnerFactory: queueRunnerFactory,\n        nodeStart: function(suite) {\n          currentlyExecutingSuites.push(suite);\n          defaultResourcesForRunnable(suite.id, suite.parentSuite.id);\n          reporter.suiteStarted(suite.result);\n        },\n        nodeComplete: function(suite, result) {\n          if (!suite.disabled) {\n            clearResourcesForRunnable(suite.id);\n          }\n          currentlyExecutingSuites.pop();\n          reporter.suiteDone(result);\n        },\n        orderChildren: function(node) {\n          return order.sort(node.children);\n        }\n      });\n\n      if(!processor.processTree().valid) {\n        throw new Error('Invalid order: would cause a beforeAll or afterAll to be run multiple times');\n      }\n\n      reporter.jasmineStarted({\n        totalSpecsDefined: totalSpecsDefined\n      });\n\n      processor.execute(function() {\n        reporter.jasmineDone({\n          order: order\n        });\n      });\n    };\n\n    this.addReporter = function(reporterToAdd) {\n      reporter.addReporter(reporterToAdd);\n    };\n\n    var spyRegistry = new j$.SpyRegistry({currentSpies: function() {\n      if(!currentRunnable()) {\n        throw new Error('Spies must be created in a before function or a spec');\n      }\n      return runnableResources[currentRunnable().id].spies;\n    }});\n\n    this.spyOn = function() {\n      return spyRegistry.spyOn.apply(spyRegistry, arguments);\n    };\n\n    var suiteFactory = function(description) {\n      var suite = new j$.Suite({\n        env: self,\n        id: getNextSuiteId(),\n        description: description,\n        parentSuite: currentDeclarationSuite,\n        expectationFactory: expectationFactory,\n        expectationResultFactory: expectationResultFactory,\n        throwOnExpectationFailure: throwOnExpectationFailure\n      });\n\n      runnableLookupTable[suite.id] = suite;\n      return suite;\n    };\n\n    this.describe = function(description, specDefinitions) {\n      var suite = suiteFactory(description);\n      if (specDefinitions.length > 0) {\n        throw new Error('describe does not expect a done parameter');\n      }\n      if (currentDeclarationSuite.markedPending) {\n        suite.pend();\n      }\n      addSpecsToSuite(suite, specDefinitions);\n      return suite;\n    };\n\n    this.xdescribe = function(description, specDefinitions) {\n      var suite = suiteFactory(description);\n      suite.pend();\n      addSpecsToSuite(suite, specDefinitions);\n      return suite;\n    };\n\n    var focusedRunnables = [];\n\n    this.fdescribe = function(description, specDefinitions) {\n      var suite = suiteFactory(description);\n      suite.isFocused = true;\n\n      focusedRunnables.push(suite.id);\n      unfocusAncestor();\n      addSpecsToSuite(suite, specDefinitions);\n\n      return suite;\n    };\n\n    function addSpecsToSuite(suite, specDefinitions) {\n      var parentSuite = currentDeclarationSuite;\n      parentSuite.addChild(suite);\n      currentDeclarationSuite = suite;\n\n      var declarationError = null;\n      try {\n        specDefinitions.call(suite);\n      } catch (e) {\n        declarationError = e;\n      }\n\n      if (declarationError) {\n        self.it('encountered a declaration exception', function() {\n          throw declarationError;\n        });\n      }\n\n      currentDeclarationSuite = parentSuite;\n    }\n\n    function findFocusedAncestor(suite) {\n      while (suite) {\n        if (suite.isFocused) {\n          return suite.id;\n        }\n        suite = suite.parentSuite;\n      }\n\n      return null;\n    }\n\n    function unfocusAncestor() {\n      var focusedAncestor = findFocusedAncestor(currentDeclarationSuite);\n      if (focusedAncestor) {\n        for (var i = 0; i < focusedRunnables.length; i++) {\n          if (focusedRunnables[i] === focusedAncestor) {\n            focusedRunnables.splice(i, 1);\n            break;\n          }\n        }\n      }\n    }\n\n    var specFactory = function(description, fn, suite, timeout) {\n      totalSpecsDefined++;\n      var spec = new j$.Spec({\n        id: getNextSpecId(),\n        beforeAndAfterFns: beforeAndAfterFns(suite),\n        expectationFactory: expectationFactory,\n        resultCallback: specResultCallback,\n        getSpecName: function(spec) {\n          return getSpecName(spec, suite);\n        },\n        onStart: specStarted,\n        description: description,\n        expectationResultFactory: expectationResultFactory,\n        queueRunnerFactory: queueRunnerFactory,\n        userContext: function() { return suite.clonedSharedUserContext(); },\n        queueableFn: {\n          fn: fn,\n          timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\n        },\n        throwOnExpectationFailure: throwOnExpectationFailure\n      });\n\n      runnableLookupTable[spec.id] = spec;\n\n      if (!self.specFilter(spec)) {\n        spec.disable();\n      }\n\n      return spec;\n\n      function specResultCallback(result) {\n        clearResourcesForRunnable(spec.id);\n        currentSpec = null;\n        reporter.specDone(result);\n      }\n\n      function specStarted(spec) {\n        currentSpec = spec;\n        defaultResourcesForRunnable(spec.id, suite.id);\n        reporter.specStarted(spec.result);\n      }\n    };\n\n    this.it = function(description, fn, timeout) {\n      var spec = specFactory(description, fn, currentDeclarationSuite, timeout);\n      if (currentDeclarationSuite.markedPending) {\n        spec.pend();\n      }\n      currentDeclarationSuite.addChild(spec);\n      return spec;\n    };\n\n    this.xit = function() {\n      var spec = this.it.apply(this, arguments);\n      spec.pend('Temporarily disabled with xit');\n      return spec;\n    };\n\n    this.fit = function(description, fn, timeout){\n      var spec = specFactory(description, fn, currentDeclarationSuite, timeout);\n      currentDeclarationSuite.addChild(spec);\n      focusedRunnables.push(spec.id);\n      unfocusAncestor();\n      return spec;\n    };\n\n    this.expect = function(actual) {\n      if (!currentRunnable()) {\n        throw new Error('\\'expect\\' was used when there was no current spec, this could be because an asynchronous test timed out');\n      }\n\n      return currentRunnable().expect(actual);\n    };\n\n    this.beforeEach = function(beforeEachFunction, timeout) {\n      currentDeclarationSuite.beforeEach({\n        fn: beforeEachFunction,\n        timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\n      });\n    };\n\n    this.beforeAll = function(beforeAllFunction, timeout) {\n      currentDeclarationSuite.beforeAll({\n        fn: beforeAllFunction,\n        timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\n      });\n    };\n\n    this.afterEach = function(afterEachFunction, timeout) {\n      currentDeclarationSuite.afterEach({\n        fn: afterEachFunction,\n        timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\n      });\n    };\n\n    this.afterAll = function(afterAllFunction, timeout) {\n      currentDeclarationSuite.afterAll({\n        fn: afterAllFunction,\n        timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\n      });\n    };\n\n    this.pending = function(message) {\n      var fullMessage = j$.Spec.pendingSpecExceptionMessage;\n      if(message) {\n        fullMessage += message;\n      }\n      throw fullMessage;\n    };\n\n    this.fail = function(error) {\n      var message = 'Failed';\n      if (error) {\n        message += ': ';\n        message += error.message || error;\n      }\n\n      currentRunnable().addExpectationResult(false, {\n        matcherName: '',\n        passed: false,\n        expected: '',\n        actual: '',\n        message: message,\n        error: error && error.message ? error : null\n      });\n    };\n  }\n\n  return Env;\n};\n\ngetJasmineRequireObj().JsApiReporter = function() {\n\n  var noopTimer = {\n    start: function(){},\n    elapsed: function(){ return 0; }\n  };\n\n  function JsApiReporter(options) {\n    var timer = options.timer || noopTimer,\n        status = 'loaded';\n\n    this.started = false;\n    this.finished = false;\n    this.runDetails = {};\n\n    this.jasmineStarted = function() {\n      this.started = true;\n      status = 'started';\n      timer.start();\n    };\n\n    var executionTime;\n\n    this.jasmineDone = function(runDetails) {\n      this.finished = true;\n      this.runDetails = runDetails;\n      executionTime = timer.elapsed();\n      status = 'done';\n    };\n\n    this.status = function() {\n      return status;\n    };\n\n    var suites = [],\n      suites_hash = {};\n\n    this.suiteStarted = function(result) {\n      suites_hash[result.id] = result;\n    };\n\n    this.suiteDone = function(result) {\n      storeSuite(result);\n    };\n\n    this.suiteResults = function(index, length) {\n      return suites.slice(index, index + length);\n    };\n\n    function storeSuite(result) {\n      suites.push(result);\n      suites_hash[result.id] = result;\n    }\n\n    this.suites = function() {\n      return suites_hash;\n    };\n\n    var specs = [];\n\n    this.specDone = function(result) {\n      specs.push(result);\n    };\n\n    this.specResults = function(index, length) {\n      return specs.slice(index, index + length);\n    };\n\n    this.specs = function() {\n      return specs;\n    };\n\n    this.executionTime = function() {\n      return executionTime;\n    };\n\n  }\n\n  return JsApiReporter;\n};\n\ngetJasmineRequireObj().CallTracker = function() {\n\n  function CallTracker() {\n    var calls = [];\n\n    this.track = function(context) {\n      calls.push(context);\n    };\n\n    this.any = function() {\n      return !!calls.length;\n    };\n\n    this.count = function() {\n      return calls.length;\n    };\n\n    this.argsFor = function(index) {\n      var call = calls[index];\n      return call ? call.args : [];\n    };\n\n    this.all = function() {\n      return calls;\n    };\n\n    this.allArgs = function() {\n      var callArgs = [];\n      for(var i = 0; i < calls.length; i++){\n        callArgs.push(calls[i].args);\n      }\n\n      return callArgs;\n    };\n\n    this.first = function() {\n      return calls[0];\n    };\n\n    this.mostRecent = function() {\n      return calls[calls.length - 1];\n    };\n\n    this.reset = function() {\n      calls = [];\n    };\n  }\n\n  return CallTracker;\n};\n\ngetJasmineRequireObj().Clock = function() {\n  function Clock(global, delayedFunctionSchedulerFactory, mockDate) {\n    var self = this,\n      realTimingFunctions = {\n        setTimeout: global.setTimeout,\n        clearTimeout: global.clearTimeout,\n        setInterval: global.setInterval,\n        clearInterval: global.clearInterval\n      },\n      fakeTimingFunctions = {\n        setTimeout: setTimeout,\n        clearTimeout: clearTimeout,\n        setInterval: setInterval,\n        clearInterval: clearInterval\n      },\n      installed = false,\n      delayedFunctionScheduler,\n      timer;\n\n\n    self.install = function() {\n      if(!originalTimingFunctionsIntact()) {\n        throw new Error('Jasmine Clock was unable to install over custom global timer functions. Is the clock already installed?');\n      }\n      replace(global, fakeTimingFunctions);\n      timer = fakeTimingFunctions;\n      delayedFunctionScheduler = delayedFunctionSchedulerFactory();\n      installed = true;\n\n      return self;\n    };\n\n    self.uninstall = function() {\n      delayedFunctionScheduler = null;\n      mockDate.uninstall();\n      replace(global, realTimingFunctions);\n\n      timer = realTimingFunctions;\n      installed = false;\n    };\n\n    self.withMock = function(closure) {\n      this.install();\n      try {\n        closure();\n      } finally {\n        this.uninstall();\n      }\n    };\n\n    self.mockDate = function(initialDate) {\n      mockDate.install(initialDate);\n    };\n\n    self.setTimeout = function(fn, delay, params) {\n      if (legacyIE()) {\n        if (arguments.length > 2) {\n          throw new Error('IE < 9 cannot support extra params to setTimeout without a polyfill');\n        }\n        return timer.setTimeout(fn, delay);\n      }\n      return Function.prototype.apply.apply(timer.setTimeout, [global, arguments]);\n    };\n\n    self.setInterval = function(fn, delay, params) {\n      if (legacyIE()) {\n        if (arguments.length > 2) {\n          throw new Error('IE < 9 cannot support extra params to setInterval without a polyfill');\n        }\n        return timer.setInterval(fn, delay);\n      }\n      return Function.prototype.apply.apply(timer.setInterval, [global, arguments]);\n    };\n\n    self.clearTimeout = function(id) {\n      return Function.prototype.call.apply(timer.clearTimeout, [global, id]);\n    };\n\n    self.clearInterval = function(id) {\n      return Function.prototype.call.apply(timer.clearInterval, [global, id]);\n    };\n\n    self.tick = function(millis) {\n      if (installed) {\n        mockDate.tick(millis);\n        delayedFunctionScheduler.tick(millis);\n      } else {\n        throw new Error('Mock clock is not installed, use jasmine.clock().install()');\n      }\n    };\n\n    return self;\n\n    function originalTimingFunctionsIntact() {\n      return global.setTimeout === realTimingFunctions.setTimeout &&\n        global.clearTimeout === realTimingFunctions.clearTimeout &&\n        global.setInterval === realTimingFunctions.setInterval &&\n        global.clearInterval === realTimingFunctions.clearInterval;\n    }\n\n    function legacyIE() {\n      //if these methods are polyfilled, apply will be present\n      return !(realTimingFunctions.setTimeout || realTimingFunctions.setInterval).apply;\n    }\n\n    function replace(dest, source) {\n      for (var prop in source) {\n        dest[prop] = source[prop];\n      }\n    }\n\n    function setTimeout(fn, delay) {\n      return delayedFunctionScheduler.scheduleFunction(fn, delay, argSlice(arguments, 2));\n    }\n\n    function clearTimeout(id) {\n      return delayedFunctionScheduler.removeFunctionWithId(id);\n    }\n\n    function setInterval(fn, interval) {\n      return delayedFunctionScheduler.scheduleFunction(fn, interval, argSlice(arguments, 2), true);\n    }\n\n    function clearInterval(id) {\n      return delayedFunctionScheduler.removeFunctionWithId(id);\n    }\n\n    function argSlice(argsObj, n) {\n      return Array.prototype.slice.call(argsObj, n);\n    }\n  }\n\n  return Clock;\n};\n\ngetJasmineRequireObj().DelayedFunctionScheduler = function() {\n  function DelayedFunctionScheduler() {\n    var self = this;\n    var scheduledLookup = [];\n    var scheduledFunctions = {};\n    var currentTime = 0;\n    var delayedFnCount = 0;\n\n    self.tick = function(millis) {\n      millis = millis || 0;\n      var endTime = currentTime + millis;\n\n      runScheduledFunctions(endTime);\n      currentTime = endTime;\n    };\n\n    self.scheduleFunction = function(funcToCall, millis, params, recurring, timeoutKey, runAtMillis) {\n      var f;\n      if (typeof(funcToCall) === 'string') {\n        /* jshint evil: true */\n        f = function() { return eval(funcToCall); };\n        /* jshint evil: false */\n      } else {\n        f = funcToCall;\n      }\n\n      millis = millis || 0;\n      timeoutKey = timeoutKey || ++delayedFnCount;\n      runAtMillis = runAtMillis || (currentTime + millis);\n\n      var funcToSchedule = {\n        runAtMillis: runAtMillis,\n        funcToCall: f,\n        recurring: recurring,\n        params: params,\n        timeoutKey: timeoutKey,\n        millis: millis\n      };\n\n      if (runAtMillis in scheduledFunctions) {\n        scheduledFunctions[runAtMillis].push(funcToSchedule);\n      } else {\n        scheduledFunctions[runAtMillis] = [funcToSchedule];\n        scheduledLookup.push(runAtMillis);\n        scheduledLookup.sort(function (a, b) {\n          return a - b;\n        });\n      }\n\n      return timeoutKey;\n    };\n\n    self.removeFunctionWithId = function(timeoutKey) {\n      for (var runAtMillis in scheduledFunctions) {\n        var funcs = scheduledFunctions[runAtMillis];\n        var i = indexOfFirstToPass(funcs, function (func) {\n          return func.timeoutKey === timeoutKey;\n        });\n\n        if (i > -1) {\n          if (funcs.length === 1) {\n            delete scheduledFunctions[runAtMillis];\n            deleteFromLookup(runAtMillis);\n          } else {\n            funcs.splice(i, 1);\n          }\n\n          // intervals get rescheduled when executed, so there's never more\n          // than a single scheduled function with a given timeoutKey\n          break;\n        }\n      }\n    };\n\n    return self;\n\n    function indexOfFirstToPass(array, testFn) {\n      var index = -1;\n\n      for (var i = 0; i < array.length; ++i) {\n        if (testFn(array[i])) {\n          index = i;\n          break;\n        }\n      }\n\n      return index;\n    }\n\n    function deleteFromLookup(key) {\n      var value = Number(key);\n      var i = indexOfFirstToPass(scheduledLookup, function (millis) {\n        return millis === value;\n      });\n\n      if (i > -1) {\n        scheduledLookup.splice(i, 1);\n      }\n    }\n\n    function reschedule(scheduledFn) {\n      self.scheduleFunction(scheduledFn.funcToCall,\n        scheduledFn.millis,\n        scheduledFn.params,\n        true,\n        scheduledFn.timeoutKey,\n        scheduledFn.runAtMillis + scheduledFn.millis);\n    }\n\n    function forEachFunction(funcsToRun, callback) {\n      for (var i = 0; i < funcsToRun.length; ++i) {\n        callback(funcsToRun[i]);\n      }\n    }\n\n    function runScheduledFunctions(endTime) {\n      if (scheduledLookup.length === 0 || scheduledLookup[0] > endTime) {\n        return;\n      }\n\n      do {\n        currentTime = scheduledLookup.shift();\n\n        var funcsToRun = scheduledFunctions[currentTime];\n        delete scheduledFunctions[currentTime];\n\n        forEachFunction(funcsToRun, function(funcToRun) {\n          if (funcToRun.recurring) {\n            reschedule(funcToRun);\n          }\n        });\n\n        forEachFunction(funcsToRun, function(funcToRun) {\n          funcToRun.funcToCall.apply(null, funcToRun.params || []);\n        });\n      } while (scheduledLookup.length > 0 &&\n              // checking first if we're out of time prevents setTimeout(0)\n              // scheduled in a funcToRun from forcing an extra iteration\n                 currentTime !== endTime  &&\n                 scheduledLookup[0] <= endTime);\n    }\n  }\n\n  return DelayedFunctionScheduler;\n};\n\ngetJasmineRequireObj().ExceptionFormatter = function() {\n  function ExceptionFormatter() {\n    this.message = function(error) {\n      var message = '';\n\n      if (error.name && error.message) {\n        message += error.name + ': ' + error.message;\n      } else {\n        message += error.toString() + ' thrown';\n      }\n\n      if (error.fileName || error.sourceURL) {\n        message += ' in ' + (error.fileName || error.sourceURL);\n      }\n\n      if (error.line || error.lineNumber) {\n        message += ' (line ' + (error.line || error.lineNumber) + ')';\n      }\n\n      return message;\n    };\n\n    this.stack = function(error) {\n      return error ? error.stack : null;\n    };\n  }\n\n  return ExceptionFormatter;\n};\n\ngetJasmineRequireObj().Expectation = function() {\n\n  function Expectation(options) {\n    this.util = options.util || { buildFailureMessage: function() {} };\n    this.customEqualityTesters = options.customEqualityTesters || [];\n    this.actual = options.actual;\n    this.addExpectationResult = options.addExpectationResult || function(){};\n    this.isNot = options.isNot;\n\n    var customMatchers = options.customMatchers || {};\n    for (var matcherName in customMatchers) {\n      this[matcherName] = Expectation.prototype.wrapCompare(matcherName, customMatchers[matcherName]);\n    }\n  }\n\n  Expectation.prototype.wrapCompare = function(name, matcherFactory) {\n    return function() {\n      var args = Array.prototype.slice.call(arguments, 0),\n        expected = args.slice(0),\n        message = '';\n\n      args.unshift(this.actual);\n\n      var matcher = matcherFactory(this.util, this.customEqualityTesters),\n          matcherCompare = matcher.compare;\n\n      function defaultNegativeCompare() {\n        var result = matcher.compare.apply(null, args);\n        result.pass = !result.pass;\n        return result;\n      }\n\n      if (this.isNot) {\n        matcherCompare = matcher.negativeCompare || defaultNegativeCompare;\n      }\n\n      var result = matcherCompare.apply(null, args);\n\n      if (!result.pass) {\n        if (!result.message) {\n          args.unshift(this.isNot);\n          args.unshift(name);\n          message = this.util.buildFailureMessage.apply(null, args);\n        } else {\n          if (Object.prototype.toString.apply(result.message) === '[object Function]') {\n            message = result.message();\n          } else {\n            message = result.message;\n          }\n        }\n      }\n\n      if (expected.length == 1) {\n        expected = expected[0];\n      }\n\n      // TODO: how many of these params are needed?\n      this.addExpectationResult(\n        result.pass,\n        {\n          matcherName: name,\n          passed: result.pass,\n          message: message,\n          actual: this.actual,\n          expected: expected // TODO: this may need to be arrayified/sliced\n        }\n      );\n    };\n  };\n\n  Expectation.addCoreMatchers = function(matchers) {\n    var prototype = Expectation.prototype;\n    for (var matcherName in matchers) {\n      var matcher = matchers[matcherName];\n      prototype[matcherName] = prototype.wrapCompare(matcherName, matcher);\n    }\n  };\n\n  Expectation.Factory = function(options) {\n    options = options || {};\n\n    var expect = new Expectation(options);\n\n    // TODO: this would be nice as its own Object - NegativeExpectation\n    // TODO: copy instead of mutate options\n    options.isNot = true;\n    expect.not = new Expectation(options);\n\n    return expect;\n  };\n\n  return Expectation;\n};\n\n//TODO: expectation result may make more sense as a presentation of an expectation.\ngetJasmineRequireObj().buildExpectationResult = function() {\n  function buildExpectationResult(options) {\n    var messageFormatter = options.messageFormatter || function() {},\n      stackFormatter = options.stackFormatter || function() {};\n\n    var result = {\n      matcherName: options.matcherName,\n      message: message(),\n      stack: stack(),\n      passed: options.passed\n    };\n\n    if(!result.passed) {\n      result.expected = options.expected;\n      result.actual = options.actual;\n    }\n\n    return result;\n\n    function message() {\n      if (options.passed) {\n        return 'Passed.';\n      } else if (options.message) {\n        return options.message;\n      } else if (options.error) {\n        return messageFormatter(options.error);\n      }\n      return '';\n    }\n\n    function stack() {\n      if (options.passed) {\n        return '';\n      }\n\n      var error = options.error;\n      if (!error) {\n        try {\n          throw new Error(message());\n        } catch (e) {\n          error = e;\n        }\n      }\n      return stackFormatter(error);\n    }\n  }\n\n  return buildExpectationResult;\n};\n\ngetJasmineRequireObj().MockDate = function() {\n  function MockDate(global) {\n    var self = this;\n    var currentTime = 0;\n\n    if (!global || !global.Date) {\n      self.install = function() {};\n      self.tick = function() {};\n      self.uninstall = function() {};\n      return self;\n    }\n\n    var GlobalDate = global.Date;\n\n    self.install = function(mockDate) {\n      if (mockDate instanceof GlobalDate) {\n        currentTime = mockDate.getTime();\n      } else {\n        currentTime = new GlobalDate().getTime();\n      }\n\n      global.Date = FakeDate;\n    };\n\n    self.tick = function(millis) {\n      millis = millis || 0;\n      currentTime = currentTime + millis;\n    };\n\n    self.uninstall = function() {\n      currentTime = 0;\n      global.Date = GlobalDate;\n    };\n\n    createDateProperties();\n\n    return self;\n\n    function FakeDate() {\n      switch(arguments.length) {\n        case 0:\n          return new GlobalDate(currentTime);\n        case 1:\n          return new GlobalDate(arguments[0]);\n        case 2:\n          return new GlobalDate(arguments[0], arguments[1]);\n        case 3:\n          return new GlobalDate(arguments[0], arguments[1], arguments[2]);\n        case 4:\n          return new GlobalDate(arguments[0], arguments[1], arguments[2], arguments[3]);\n        case 5:\n          return new GlobalDate(arguments[0], arguments[1], arguments[2], arguments[3],\n                                arguments[4]);\n        case 6:\n          return new GlobalDate(arguments[0], arguments[1], arguments[2], arguments[3],\n                                arguments[4], arguments[5]);\n        default:\n          return new GlobalDate(arguments[0], arguments[1], arguments[2], arguments[3],\n                                arguments[4], arguments[5], arguments[6]);\n      }\n    }\n\n    function createDateProperties() {\n      FakeDate.prototype = GlobalDate.prototype;\n\n      FakeDate.now = function() {\n        if (GlobalDate.now) {\n          return currentTime;\n        } else {\n          throw new Error('Browser does not support Date.now()');\n        }\n      };\n\n      FakeDate.toSource = GlobalDate.toSource;\n      FakeDate.toString = GlobalDate.toString;\n      FakeDate.parse = GlobalDate.parse;\n      FakeDate.UTC = GlobalDate.UTC;\n    }\n\t}\n\n  return MockDate;\n};\n\ngetJasmineRequireObj().pp = function(j$) {\n\n  function PrettyPrinter() {\n    this.ppNestLevel_ = 0;\n    this.seen = [];\n  }\n\n  PrettyPrinter.prototype.format = function(value) {\n    this.ppNestLevel_++;\n    try {\n      if (j$.util.isUndefined(value)) {\n        this.emitScalar('undefined');\n      } else if (value === null) {\n        this.emitScalar('null');\n      } else if (value === 0 && 1/value === -Infinity) {\n        this.emitScalar('-0');\n      } else if (value === j$.getGlobal()) {\n        this.emitScalar('<global>');\n      } else if (value.jasmineToString) {\n        this.emitScalar(value.jasmineToString());\n      } else if (typeof value === 'string') {\n        this.emitString(value);\n      } else if (j$.isSpy(value)) {\n        this.emitScalar('spy on ' + value.and.identity());\n      } else if (value instanceof RegExp) {\n        this.emitScalar(value.toString());\n      } else if (typeof value === 'function') {\n        this.emitScalar('Function');\n      } else if (typeof value.nodeType === 'number') {\n        this.emitScalar('HTMLNode');\n      } else if (value instanceof Date) {\n        this.emitScalar('Date(' + value + ')');\n      } else if (value.toString && typeof value === 'object' && !(value instanceof Array) && value.toString !== Object.prototype.toString) {\n        this.emitScalar(value.toString());\n      } else if (j$.util.arrayContains(this.seen, value)) {\n        this.emitScalar('<circular reference: ' + (j$.isArray_(value) ? 'Array' : 'Object') + '>');\n      } else if (j$.isArray_(value) || j$.isA_('Object', value)) {\n        this.seen.push(value);\n        if (j$.isArray_(value)) {\n          this.emitArray(value);\n        } else {\n          this.emitObject(value);\n        }\n        this.seen.pop();\n      } else {\n        this.emitScalar(value.toString());\n      }\n    } finally {\n      this.ppNestLevel_--;\n    }\n  };\n\n  PrettyPrinter.prototype.iterateObject = function(obj, fn) {\n    for (var property in obj) {\n      if (!Object.prototype.hasOwnProperty.call(obj, property)) { continue; }\n      fn(property, obj.__lookupGetter__ ? (!j$.util.isUndefined(obj.__lookupGetter__(property)) &&\n          obj.__lookupGetter__(property) !== null) : false);\n    }\n  };\n\n  PrettyPrinter.prototype.emitArray = j$.unimplementedMethod_;\n  PrettyPrinter.prototype.emitObject = j$.unimplementedMethod_;\n  PrettyPrinter.prototype.emitScalar = j$.unimplementedMethod_;\n  PrettyPrinter.prototype.emitString = j$.unimplementedMethod_;\n\n  function StringPrettyPrinter() {\n    PrettyPrinter.call(this);\n\n    this.string = '';\n  }\n\n  j$.util.inherit(StringPrettyPrinter, PrettyPrinter);\n\n  StringPrettyPrinter.prototype.emitScalar = function(value) {\n    this.append(value);\n  };\n\n  StringPrettyPrinter.prototype.emitString = function(value) {\n    this.append('\\'' + value + '\\'');\n  };\n\n  StringPrettyPrinter.prototype.emitArray = function(array) {\n    if (this.ppNestLevel_ > j$.MAX_PRETTY_PRINT_DEPTH) {\n      this.append('Array');\n      return;\n    }\n    var length = Math.min(array.length, j$.MAX_PRETTY_PRINT_ARRAY_LENGTH);\n    this.append('[ ');\n    for (var i = 0; i < length; i++) {\n      if (i > 0) {\n        this.append(', ');\n      }\n      this.format(array[i]);\n    }\n    if(array.length > length){\n      this.append(', ...');\n    }\n\n    var self = this;\n    var first = array.length === 0;\n    this.iterateObject(array, function(property, isGetter) {\n      if (property.match(/^\\d+$/)) {\n        return;\n      }\n\n      if (first) {\n        first = false;\n      } else {\n        self.append(', ');\n      }\n\n      self.formatProperty(array, property, isGetter);\n    });\n\n    this.append(' ]');\n  };\n\n  StringPrettyPrinter.prototype.emitObject = function(obj) {\n    var constructorName = obj.constructor ? j$.fnNameFor(obj.constructor) : 'null';\n    this.append(constructorName);\n\n    if (this.ppNestLevel_ > j$.MAX_PRETTY_PRINT_DEPTH) {\n      return;\n    }\n\n    var self = this;\n    this.append('({ ');\n    var first = true;\n\n    this.iterateObject(obj, function(property, isGetter) {\n      if (first) {\n        first = false;\n      } else {\n        self.append(', ');\n      }\n\n      self.formatProperty(obj, property, isGetter);\n    });\n\n    this.append(' })');\n  };\n\n  StringPrettyPrinter.prototype.formatProperty = function(obj, property, isGetter) {\n      this.append(property);\n      this.append(': ');\n      if (isGetter) {\n        this.append('<getter>');\n      } else {\n        this.format(obj[property]);\n      }\n  };\n\n  StringPrettyPrinter.prototype.append = function(value) {\n    this.string += value;\n  };\n\n  return function(value) {\n    var stringPrettyPrinter = new StringPrettyPrinter();\n    stringPrettyPrinter.format(value);\n    return stringPrettyPrinter.string;\n  };\n};\n\ngetJasmineRequireObj().QueueRunner = function(j$) {\n\n  function once(fn) {\n    var called = false;\n    return function() {\n      if (!called) {\n        called = true;\n        fn();\n      }\n    };\n  }\n\n  function QueueRunner(attrs) {\n    this.queueableFns = attrs.queueableFns || [];\n    this.onComplete = attrs.onComplete || function() {};\n    this.clearStack = attrs.clearStack || function(fn) {fn();};\n    this.onException = attrs.onException || function() {};\n    this.catchException = attrs.catchException || function() { return true; };\n    this.userContext = attrs.userContext || {};\n    this.timeout = attrs.timeout || {setTimeout: setTimeout, clearTimeout: clearTimeout};\n    this.fail = attrs.fail || function() {};\n  }\n\n  QueueRunner.prototype.execute = function() {\n    this.run(this.queueableFns, 0);\n  };\n\n  QueueRunner.prototype.run = function(queueableFns, recursiveIndex) {\n    var length = queueableFns.length,\n      self = this,\n      iterativeIndex;\n\n\n    for(iterativeIndex = recursiveIndex; iterativeIndex < length; iterativeIndex++) {\n      var queueableFn = queueableFns[iterativeIndex];\n      if (queueableFn.fn.length > 0) {\n        attemptAsync(queueableFn);\n        return;\n      } else {\n        attemptSync(queueableFn);\n      }\n    }\n\n    var runnerDone = iterativeIndex >= length;\n\n    if (runnerDone) {\n      this.clearStack(this.onComplete);\n    }\n\n    function attemptSync(queueableFn) {\n      try {\n        queueableFn.fn.call(self.userContext);\n      } catch (e) {\n        handleException(e, queueableFn);\n      }\n    }\n\n    function attemptAsync(queueableFn) {\n      var clearTimeout = function () {\n          Function.prototype.apply.apply(self.timeout.clearTimeout, [j$.getGlobal(), [timeoutId]]);\n        },\n        next = once(function () {\n          clearTimeout(timeoutId);\n          self.run(queueableFns, iterativeIndex + 1);\n        }),\n        timeoutId;\n\n      next.fail = function() {\n        self.fail.apply(null, arguments);\n        next();\n      };\n\n      if (queueableFn.timeout) {\n        timeoutId = Function.prototype.apply.apply(self.timeout.setTimeout, [j$.getGlobal(), [function() {\n          var error = new Error('Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL.');\n          onException(error);\n          next();\n        }, queueableFn.timeout()]]);\n      }\n\n      try {\n        queueableFn.fn.call(self.userContext, next);\n      } catch (e) {\n        handleException(e, queueableFn);\n        next();\n      }\n    }\n\n    function onException(e) {\n      self.onException(e);\n    }\n\n    function handleException(e, queueableFn) {\n      onException(e);\n      if (!self.catchException(e)) {\n        //TODO: set a var when we catch an exception and\n        //use a finally block to close the loop in a nice way..\n        throw e;\n      }\n    }\n  };\n\n  return QueueRunner;\n};\n\ngetJasmineRequireObj().ReportDispatcher = function() {\n  function ReportDispatcher(methods) {\n\n    var dispatchedMethods = methods || [];\n\n    for (var i = 0; i < dispatchedMethods.length; i++) {\n      var method = dispatchedMethods[i];\n      this[method] = (function(m) {\n        return function() {\n          dispatch(m, arguments);\n        };\n      }(method));\n    }\n\n    var reporters = [];\n\n    this.addReporter = function(reporter) {\n      reporters.push(reporter);\n    };\n\n    return this;\n\n    function dispatch(method, args) {\n      for (var i = 0; i < reporters.length; i++) {\n        var reporter = reporters[i];\n        if (reporter[method]) {\n          reporter[method].apply(reporter, args);\n        }\n      }\n    }\n  }\n\n  return ReportDispatcher;\n};\n\n\ngetJasmineRequireObj().SpyRegistry = function(j$) {\n\n  function SpyRegistry(options) {\n    options = options || {};\n    var currentSpies = options.currentSpies || function() { return []; };\n\n    this.spyOn = function(obj, methodName) {\n      if (j$.util.isUndefined(obj)) {\n        throw new Error('spyOn could not find an object to spy upon for ' + methodName + '()');\n      }\n\n      if (j$.util.isUndefined(methodName)) {\n        throw new Error('No method name supplied');\n      }\n\n      if (j$.util.isUndefined(obj[methodName])) {\n        throw new Error(methodName + '() method does not exist');\n      }\n\n      if (obj[methodName] && j$.isSpy(obj[methodName])) {\n        //TODO?: should this return the current spy? Downside: may cause user confusion about spy state\n        throw new Error(methodName + ' has already been spied upon');\n      }\n\n      var descriptor;\n      try {\n        descriptor = Object.getOwnPropertyDescriptor(obj, methodName);\n      } catch(e) {\n        // IE 8 doesn't support `definePropery` on non-DOM nodes\n      }\n\n      if (descriptor && !(descriptor.writable || descriptor.set)) {\n        throw new Error(methodName + ' is not declared writable or has no setter');\n      }\n\n      var spy = j$.createSpy(methodName, obj[methodName]);\n\n      currentSpies().push({\n        spy: spy,\n        baseObj: obj,\n        methodName: methodName,\n        originalValue: obj[methodName]\n      });\n\n      obj[methodName] = spy;\n\n      return spy;\n    };\n\n    this.clearSpies = function() {\n      var spies = currentSpies();\n      for (var i = 0; i < spies.length; i++) {\n        var spyEntry = spies[i];\n        spyEntry.baseObj[spyEntry.methodName] = spyEntry.originalValue;\n      }\n    };\n  }\n\n  return SpyRegistry;\n};\n\ngetJasmineRequireObj().SpyStrategy = function() {\n\n  function SpyStrategy(options) {\n    options = options || {};\n\n    var identity = options.name || 'unknown',\n        originalFn = options.fn || function() {},\n        getSpy = options.getSpy || function() {},\n        plan = function() {};\n\n    this.identity = function() {\n      return identity;\n    };\n\n    this.exec = function() {\n      return plan.apply(this, arguments);\n    };\n\n    this.callThrough = function() {\n      plan = originalFn;\n      return getSpy();\n    };\n\n    this.returnValue = function(value) {\n      plan = function() {\n        return value;\n      };\n      return getSpy();\n    };\n\n    this.returnValues = function() {\n      var values = Array.prototype.slice.call(arguments);\n      plan = function () {\n        return values.shift();\n      };\n      return getSpy();\n    };\n\n    this.throwError = function(something) {\n      var error = (something instanceof Error) ? something : new Error(something);\n      plan = function() {\n        throw error;\n      };\n      return getSpy();\n    };\n\n    this.callFake = function(fn) {\n      plan = fn;\n      return getSpy();\n    };\n\n    this.stub = function(fn) {\n      plan = function() {};\n      return getSpy();\n    };\n  }\n\n  return SpyStrategy;\n};\n\ngetJasmineRequireObj().Suite = function(j$) {\n  function Suite(attrs) {\n    this.env = attrs.env;\n    this.id = attrs.id;\n    this.parentSuite = attrs.parentSuite;\n    this.description = attrs.description;\n    this.expectationFactory = attrs.expectationFactory;\n    this.expectationResultFactory = attrs.expectationResultFactory;\n    this.throwOnExpectationFailure = !!attrs.throwOnExpectationFailure;\n\n    this.beforeFns = [];\n    this.afterFns = [];\n    this.beforeAllFns = [];\n    this.afterAllFns = [];\n    this.disabled = false;\n\n    this.children = [];\n\n    this.result = {\n      id: this.id,\n      description: this.description,\n      fullName: this.getFullName(),\n      failedExpectations: []\n    };\n  }\n\n  Suite.prototype.expect = function(actual) {\n    return this.expectationFactory(actual, this);\n  };\n\n  Suite.prototype.getFullName = function() {\n    var fullName = this.description;\n    for (var parentSuite = this.parentSuite; parentSuite; parentSuite = parentSuite.parentSuite) {\n      if (parentSuite.parentSuite) {\n        fullName = parentSuite.description + ' ' + fullName;\n      }\n    }\n    return fullName;\n  };\n\n  Suite.prototype.disable = function() {\n    this.disabled = true;\n  };\n\n  Suite.prototype.pend = function(message) {\n    this.markedPending = true;\n  };\n\n  Suite.prototype.beforeEach = function(fn) {\n    this.beforeFns.unshift(fn);\n  };\n\n  Suite.prototype.beforeAll = function(fn) {\n    this.beforeAllFns.push(fn);\n  };\n\n  Suite.prototype.afterEach = function(fn) {\n    this.afterFns.unshift(fn);\n  };\n\n  Suite.prototype.afterAll = function(fn) {\n    this.afterAllFns.push(fn);\n  };\n\n  Suite.prototype.addChild = function(child) {\n    this.children.push(child);\n  };\n\n  Suite.prototype.status = function() {\n    if (this.disabled) {\n      return 'disabled';\n    }\n\n    if (this.markedPending) {\n      return 'pending';\n    }\n\n    if (this.result.failedExpectations.length > 0) {\n      return 'failed';\n    } else {\n      return 'finished';\n    }\n  };\n\n  Suite.prototype.isExecutable = function() {\n    return !this.disabled;\n  };\n\n  Suite.prototype.canBeReentered = function() {\n    return this.beforeAllFns.length === 0 && this.afterAllFns.length === 0;\n  };\n\n  Suite.prototype.getResult = function() {\n    this.result.status = this.status();\n    return this.result;\n  };\n\n  Suite.prototype.sharedUserContext = function() {\n    if (!this.sharedContext) {\n      this.sharedContext = this.parentSuite ? clone(this.parentSuite.sharedUserContext()) : {};\n    }\n\n    return this.sharedContext;\n  };\n\n  Suite.prototype.clonedSharedUserContext = function() {\n    return clone(this.sharedUserContext());\n  };\n\n  Suite.prototype.onException = function() {\n    if (arguments[0] instanceof j$.errors.ExpectationFailed) {\n      return;\n    }\n\n    if(isAfterAll(this.children)) {\n      var data = {\n        matcherName: '',\n        passed: false,\n        expected: '',\n        actual: '',\n        error: arguments[0]\n      };\n      this.result.failedExpectations.push(this.expectationResultFactory(data));\n    } else {\n      for (var i = 0; i < this.children.length; i++) {\n        var child = this.children[i];\n        child.onException.apply(child, arguments);\n      }\n    }\n  };\n\n  Suite.prototype.addExpectationResult = function () {\n    if(isAfterAll(this.children) && isFailure(arguments)){\n      var data = arguments[1];\n      this.result.failedExpectations.push(this.expectationResultFactory(data));\n      if(this.throwOnExpectationFailure) {\n        throw new j$.errors.ExpectationFailed();\n      }\n    } else {\n      for (var i = 0; i < this.children.length; i++) {\n        var child = this.children[i];\n        try {\n          child.addExpectationResult.apply(child, arguments);\n        } catch(e) {\n          // keep going\n        }\n      }\n    }\n  };\n\n  function isAfterAll(children) {\n    return children && children[0].result.status;\n  }\n\n  function isFailure(args) {\n    return !args[0];\n  }\n\n  function clone(obj) {\n    var clonedObj = {};\n    for (var prop in obj) {\n      if (obj.hasOwnProperty(prop)) {\n        clonedObj[prop] = obj[prop];\n      }\n    }\n\n    return clonedObj;\n  }\n\n  return Suite;\n};\n\nif (typeof window == void 0 && typeof exports == 'object') {\n  exports.Suite = jasmineRequire.Suite;\n}\n\ngetJasmineRequireObj().Timer = function() {\n  var defaultNow = (function(Date) {\n    return function() { return new Date().getTime(); };\n  })(Date);\n\n  function Timer(options) {\n    options = options || {};\n\n    var now = options.now || defaultNow,\n      startTime;\n\n    this.start = function() {\n      startTime = now();\n    };\n\n    this.elapsed = function() {\n      return now() - startTime;\n    };\n  }\n\n  return Timer;\n};\n\ngetJasmineRequireObj().TreeProcessor = function() {\n  function TreeProcessor(attrs) {\n    var tree = attrs.tree,\n        runnableIds = attrs.runnableIds,\n        queueRunnerFactory = attrs.queueRunnerFactory,\n        nodeStart = attrs.nodeStart || function() {},\n        nodeComplete = attrs.nodeComplete || function() {},\n        orderChildren = attrs.orderChildren || function(node) { return node.children; },\n        stats = { valid: true },\n        processed = false,\n        defaultMin = Infinity,\n        defaultMax = 1 - Infinity;\n\n    this.processTree = function() {\n      processNode(tree, false);\n      processed = true;\n      return stats;\n    };\n\n    this.execute = function(done) {\n      if (!processed) {\n        this.processTree();\n      }\n\n      if (!stats.valid) {\n        throw 'invalid order';\n      }\n\n      var childFns = wrapChildren(tree, 0);\n\n      queueRunnerFactory({\n        queueableFns: childFns,\n        userContext: tree.sharedUserContext(),\n        onException: function() {\n          tree.onException.apply(tree, arguments);\n        },\n        onComplete: done\n      });\n    };\n\n    function runnableIndex(id) {\n      for (var i = 0; i < runnableIds.length; i++) {\n        if (runnableIds[i] === id) {\n          return i;\n        }\n      }\n    }\n\n    function processNode(node, parentEnabled) {\n      var executableIndex = runnableIndex(node.id);\n\n      if (executableIndex !== undefined) {\n        parentEnabled = true;\n      }\n\n      parentEnabled = parentEnabled && node.isExecutable();\n\n      if (!node.children) {\n        stats[node.id] = {\n          executable: parentEnabled && node.isExecutable(),\n          segments: [{\n            index: 0,\n            owner: node,\n            nodes: [node],\n            min: startingMin(executableIndex),\n            max: startingMax(executableIndex)\n          }]\n        };\n      } else {\n        var hasExecutableChild = false;\n\n        var orderedChildren = orderChildren(node);\n\n        for (var i = 0; i < orderedChildren.length; i++) {\n          var child = orderedChildren[i];\n\n          processNode(child, parentEnabled);\n\n          if (!stats.valid) {\n            return;\n          }\n\n          var childStats = stats[child.id];\n\n          hasExecutableChild = hasExecutableChild || childStats.executable;\n        }\n\n        stats[node.id] = {\n          executable: hasExecutableChild\n        };\n\n        segmentChildren(node, orderedChildren, stats[node.id], executableIndex);\n\n        if (!node.canBeReentered() && stats[node.id].segments.length > 1) {\n          stats = { valid: false };\n        }\n      }\n    }\n\n    function startingMin(executableIndex) {\n      return executableIndex === undefined ? defaultMin : executableIndex;\n    }\n\n    function startingMax(executableIndex) {\n      return executableIndex === undefined ? defaultMax : executableIndex;\n    }\n\n    function segmentChildren(node, orderedChildren, nodeStats, executableIndex) {\n      var currentSegment = { index: 0, owner: node, nodes: [], min: startingMin(executableIndex), max: startingMax(executableIndex) },\n          result = [currentSegment],\n          lastMax = defaultMax,\n          orderedChildSegments = orderChildSegments(orderedChildren);\n\n      function isSegmentBoundary(minIndex) {\n        return lastMax !== defaultMax && minIndex !== defaultMin && lastMax < minIndex - 1;\n      }\n\n      for (var i = 0; i < orderedChildSegments.length; i++) {\n        var childSegment = orderedChildSegments[i],\n          maxIndex = childSegment.max,\n          minIndex = childSegment.min;\n\n        if (isSegmentBoundary(minIndex)) {\n          currentSegment = {index: result.length, owner: node, nodes: [], min: defaultMin, max: defaultMax};\n          result.push(currentSegment);\n        }\n\n        currentSegment.nodes.push(childSegment);\n        currentSegment.min = Math.min(currentSegment.min, minIndex);\n        currentSegment.max = Math.max(currentSegment.max, maxIndex);\n        lastMax = maxIndex;\n      }\n\n      nodeStats.segments = result;\n    }\n\n    function orderChildSegments(children) {\n      var specifiedOrder = [],\n          unspecifiedOrder = [];\n\n      for (var i = 0; i < children.length; i++) {\n        var child = children[i],\n            segments = stats[child.id].segments;\n\n        for (var j = 0; j < segments.length; j++) {\n          var seg = segments[j];\n\n          if (seg.min === defaultMin) {\n            unspecifiedOrder.push(seg);\n          } else {\n            specifiedOrder.push(seg);\n          }\n        }\n      }\n\n      specifiedOrder.sort(function(a, b) {\n        return a.min - b.min;\n      });\n\n      return specifiedOrder.concat(unspecifiedOrder);\n    }\n\n    function executeNode(node, segmentNumber) {\n      if (node.children) {\n        return {\n          fn: function(done) {\n            nodeStart(node);\n\n            queueRunnerFactory({\n              onComplete: function() {\n                nodeComplete(node, node.getResult());\n                done();\n              },\n              queueableFns: wrapChildren(node, segmentNumber),\n              userContext: node.sharedUserContext(),\n              onException: function() {\n                node.onException.apply(node, arguments);\n              }\n            });\n          }\n        };\n      } else {\n        return {\n          fn: function(done) { node.execute(done, stats[node.id].executable); }\n        };\n      }\n    }\n\n    function wrapChildren(node, segmentNumber) {\n      var result = [],\n          segmentChildren = stats[node.id].segments[segmentNumber].nodes;\n\n      for (var i = 0; i < segmentChildren.length; i++) {\n        result.push(executeNode(segmentChildren[i].owner, segmentChildren[i].index));\n      }\n\n      if (!stats[node.id].executable) {\n        return result;\n      }\n\n      return node.beforeAllFns.concat(result).concat(node.afterAllFns);\n    }\n  }\n\n  return TreeProcessor;\n};\n\ngetJasmineRequireObj().Any = function(j$) {\n\n  function Any(expectedObject) {\n    if (typeof expectedObject === 'undefined') {\n      throw new TypeError(\n        'jasmine.any() expects to be passed a constructor function. ' +\n        'Please pass one or use jasmine.anything() to match any object.'\n      );\n    }\n    this.expectedObject = expectedObject;\n  }\n\n  Any.prototype.asymmetricMatch = function(other) {\n    if (this.expectedObject == String) {\n      return typeof other == 'string' || other instanceof String;\n    }\n\n    if (this.expectedObject == Number) {\n      return typeof other == 'number' || other instanceof Number;\n    }\n\n    if (this.expectedObject == Function) {\n      return typeof other == 'function' || other instanceof Function;\n    }\n\n    if (this.expectedObject == Object) {\n      return typeof other == 'object';\n    }\n\n    if (this.expectedObject == Boolean) {\n      return typeof other == 'boolean';\n    }\n\n    return other instanceof this.expectedObject;\n  };\n\n  Any.prototype.jasmineToString = function() {\n    return '<jasmine.any(' + j$.fnNameFor(this.expectedObject) + ')>';\n  };\n\n  return Any;\n};\n\ngetJasmineRequireObj().Anything = function(j$) {\n\n  function Anything() {}\n\n  Anything.prototype.asymmetricMatch = function(other) {\n    return !j$.util.isUndefined(other) && other !== null;\n  };\n\n  Anything.prototype.jasmineToString = function() {\n    return '<jasmine.anything>';\n  };\n\n  return Anything;\n};\n\ngetJasmineRequireObj().ArrayContaining = function(j$) {\n  function ArrayContaining(sample) {\n    this.sample = sample;\n  }\n\n  ArrayContaining.prototype.asymmetricMatch = function(other) {\n    var className = Object.prototype.toString.call(this.sample);\n    if (className !== '[object Array]') { throw new Error('You must provide an array to arrayContaining, not \\'' + this.sample + '\\'.'); }\n\n    for (var i = 0; i < this.sample.length; i++) {\n      var item = this.sample[i];\n      if (!j$.matchersUtil.contains(other, item)) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  ArrayContaining.prototype.jasmineToString = function () {\n    return '<jasmine.arrayContaining(' + jasmine.pp(this.sample) +')>';\n  };\n\n  return ArrayContaining;\n};\n\ngetJasmineRequireObj().ObjectContaining = function(j$) {\n\n  function ObjectContaining(sample) {\n    this.sample = sample;\n  }\n\n  function getPrototype(obj) {\n    if (Object.getPrototypeOf) {\n      return Object.getPrototypeOf(obj);\n    }\n\n    if (obj.constructor.prototype == obj) {\n      return null;\n    }\n\n    return obj.constructor.prototype;\n  }\n\n  function hasProperty(obj, property) {\n    if (!obj) {\n      return false;\n    }\n\n    if (Object.prototype.hasOwnProperty.call(obj, property)) {\n      return true;\n    }\n\n    return hasProperty(getPrototype(obj), property);\n  }\n\n  ObjectContaining.prototype.asymmetricMatch = function(other) {\n    if (typeof(this.sample) !== 'object') { throw new Error('You must provide an object to objectContaining, not \\''+this.sample+'\\'.'); }\n\n    for (var property in this.sample) {\n      if (!hasProperty(other, property) ||\n          !j$.matchersUtil.equals(this.sample[property], other[property])) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  ObjectContaining.prototype.jasmineToString = function() {\n    return '<jasmine.objectContaining(' + j$.pp(this.sample) + ')>';\n  };\n\n  return ObjectContaining;\n};\n\ngetJasmineRequireObj().StringMatching = function(j$) {\n\n  function StringMatching(expected) {\n    if (!j$.isString_(expected) && !j$.isA_('RegExp', expected)) {\n      throw new Error('Expected is not a String or a RegExp');\n    }\n\n    this.regexp = new RegExp(expected);\n  }\n\n  StringMatching.prototype.asymmetricMatch = function(other) {\n    return this.regexp.test(other);\n  };\n\n  StringMatching.prototype.jasmineToString = function() {\n    return '<jasmine.stringMatching(' + this.regexp + ')>';\n  };\n\n  return StringMatching;\n};\n\ngetJasmineRequireObj().errors = function() {\n  function ExpectationFailed() {}\n\n  ExpectationFailed.prototype = new Error();\n  ExpectationFailed.prototype.constructor = ExpectationFailed;\n\n  return {\n    ExpectationFailed: ExpectationFailed\n  };\n};\ngetJasmineRequireObj().matchersUtil = function(j$) {\n  // TODO: what to do about jasmine.pp not being inject? move to JSON.stringify? gut PrettyPrinter?\n\n  return {\n    equals: function(a, b, customTesters) {\n      customTesters = customTesters || [];\n\n      return eq(a, b, [], [], customTesters);\n    },\n\n    contains: function(haystack, needle, customTesters) {\n      customTesters = customTesters || [];\n\n      if ((Object.prototype.toString.apply(haystack) === '[object Array]') ||\n        (!!haystack && !haystack.indexOf))\n      {\n        for (var i = 0; i < haystack.length; i++) {\n          if (eq(haystack[i], needle, [], [], customTesters)) {\n            return true;\n          }\n        }\n        return false;\n      }\n\n      return !!haystack && haystack.indexOf(needle) >= 0;\n    },\n\n    buildFailureMessage: function() {\n      var args = Array.prototype.slice.call(arguments, 0),\n        matcherName = args[0],\n        isNot = args[1],\n        actual = args[2],\n        expected = args.slice(3),\n        englishyPredicate = matcherName.replace(/[A-Z]/g, function(s) { return ' ' + s.toLowerCase(); });\n\n      var message = 'Expected ' +\n        j$.pp(actual) +\n        (isNot ? ' not ' : ' ') +\n        englishyPredicate;\n\n      if (expected.length > 0) {\n        for (var i = 0; i < expected.length; i++) {\n          if (i > 0) {\n            message += ',';\n          }\n          message += ' ' + j$.pp(expected[i]);\n        }\n      }\n\n      return message + '.';\n    }\n  };\n\n  function isAsymmetric(obj) {\n    return obj && j$.isA_('Function', obj.asymmetricMatch);\n  }\n\n  function asymmetricMatch(a, b) {\n    var asymmetricA = isAsymmetric(a),\n        asymmetricB = isAsymmetric(b);\n\n    if (asymmetricA && asymmetricB) {\n      return undefined;\n    }\n\n    if (asymmetricA) {\n      return a.asymmetricMatch(b);\n    }\n\n    if (asymmetricB) {\n      return b.asymmetricMatch(a);\n    }\n  }\n\n  // Equality function lovingly adapted from isEqual in\n  //   [Underscore](http://underscorejs.org)\n  function eq(a, b, aStack, bStack, customTesters) {\n    var result = true;\n\n    var asymmetricResult = asymmetricMatch(a, b);\n    if (!j$.util.isUndefined(asymmetricResult)) {\n      return asymmetricResult;\n    }\n\n    for (var i = 0; i < customTesters.length; i++) {\n      var customTesterResult = customTesters[i](a, b);\n      if (!j$.util.isUndefined(customTesterResult)) {\n        return customTesterResult;\n      }\n    }\n\n    if (a instanceof Error && b instanceof Error) {\n      return a.message == b.message;\n    }\n\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\n    if (a === b) { return a !== 0 || 1 / a == 1 / b; }\n    // A strict comparison is necessary because `null == undefined`.\n    if (a === null || b === null) { return a === b; }\n    var className = Object.prototype.toString.call(a);\n    if (className != Object.prototype.toString.call(b)) { return false; }\n    switch (className) {\n      // Strings, numbers, dates, and booleans are compared by value.\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return a == String(b);\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\n        // other numeric values.\n        return a != +a ? b != +b : (a === 0 ? 1 / a == 1 / b : a == +b);\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a == +b;\n      // RegExps are compared by their source patterns and flags.\n      case '[object RegExp]':\n        return a.source == b.source &&\n          a.global == b.global &&\n          a.multiline == b.multiline &&\n          a.ignoreCase == b.ignoreCase;\n    }\n    if (typeof a != 'object' || typeof b != 'object') { return false; }\n\n    var aIsDomNode = j$.isDomNode(a);\n    var bIsDomNode = j$.isDomNode(b);\n    if (aIsDomNode && bIsDomNode) {\n      // At first try to use DOM3 method isEqualNode\n      if (a.isEqualNode) {\n        return a.isEqualNode(b);\n      }\n      // IE8 doesn't support isEqualNode, try to use outerHTML && innerText\n      var aIsElement = a instanceof Element;\n      var bIsElement = b instanceof Element;\n      if (aIsElement && bIsElement) {\n        return a.outerHTML == b.outerHTML;\n      }\n      if (aIsElement || bIsElement) {\n        return false;\n      }\n      return a.innerText == b.innerText && a.textContent == b.textContent;\n    }\n    if (aIsDomNode || bIsDomNode) {\n      return false;\n    }\n\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n    var length = aStack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (aStack[length] == a) { return bStack[length] == b; }\n    }\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n    var size = 0;\n    // Recursively compare objects and arrays.\n    // Compare array lengths to determine if a deep comparison is necessary.\n    if (className == '[object Array]' && a.length !== b.length) {\n      result = false;\n    }\n\n    if (result) {\n      // Objects with different constructors are not equivalent, but `Object`s\n      // or `Array`s from different frames are.\n      if (className !== '[object Array]') {\n        var aCtor = a.constructor, bCtor = b.constructor;\n        if (aCtor !== bCtor && !(isFunction(aCtor) && aCtor instanceof aCtor &&\n               isFunction(bCtor) && bCtor instanceof bCtor)) {\n          return false;\n        }\n      }\n      // Deep compare objects.\n      for (var key in a) {\n        if (has(a, key)) {\n          // Count the expected number of properties.\n          size++;\n          // Deep compare each member.\n          if (!(result = has(b, key) && eq(a[key], b[key], aStack, bStack, customTesters))) { break; }\n        }\n      }\n      // Ensure that both objects contain the same number of properties.\n      if (result) {\n        for (key in b) {\n          if (has(b, key) && !(size--)) { break; }\n        }\n        result = !size;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n\n    return result;\n\n    function has(obj, key) {\n      return Object.prototype.hasOwnProperty.call(obj, key);\n    }\n\n    function isFunction(obj) {\n      return typeof obj === 'function';\n    }\n  }\n};\n\ngetJasmineRequireObj().toBe = function() {\n  function toBe() {\n    return {\n      compare: function(actual, expected) {\n        return {\n          pass: actual === expected\n        };\n      }\n    };\n  }\n\n  return toBe;\n};\n\ngetJasmineRequireObj().toBeCloseTo = function() {\n\n  function toBeCloseTo() {\n    return {\n      compare: function(actual, expected, precision) {\n        if (precision !== 0) {\n          precision = precision || 2;\n        }\n\n        return {\n          pass: Math.abs(expected - actual) < (Math.pow(10, -precision) / 2)\n        };\n      }\n    };\n  }\n\n  return toBeCloseTo;\n};\n\ngetJasmineRequireObj().toBeDefined = function() {\n  function toBeDefined() {\n    return {\n      compare: function(actual) {\n        return {\n          pass: (void 0 !== actual)\n        };\n      }\n    };\n  }\n\n  return toBeDefined;\n};\n\ngetJasmineRequireObj().toBeFalsy = function() {\n  function toBeFalsy() {\n    return {\n      compare: function(actual) {\n        return {\n          pass: !!!actual\n        };\n      }\n    };\n  }\n\n  return toBeFalsy;\n};\n\ngetJasmineRequireObj().toBeGreaterThan = function() {\n\n  function toBeGreaterThan() {\n    return {\n      compare: function(actual, expected) {\n        return {\n          pass: actual > expected\n        };\n      }\n    };\n  }\n\n  return toBeGreaterThan;\n};\n\n\ngetJasmineRequireObj().toBeLessThan = function() {\n  function toBeLessThan() {\n    return {\n\n      compare: function(actual, expected) {\n        return {\n          pass: actual < expected\n        };\n      }\n    };\n  }\n\n  return toBeLessThan;\n};\ngetJasmineRequireObj().toBeNaN = function(j$) {\n\n  function toBeNaN() {\n    return {\n      compare: function(actual) {\n        var result = {\n          pass: (actual !== actual)\n        };\n\n        if (result.pass) {\n          result.message = 'Expected actual not to be NaN.';\n        } else {\n          result.message = function() { return 'Expected ' + j$.pp(actual) + ' to be NaN.'; };\n        }\n\n        return result;\n      }\n    };\n  }\n\n  return toBeNaN;\n};\n\ngetJasmineRequireObj().toBeNull = function() {\n\n  function toBeNull() {\n    return {\n      compare: function(actual) {\n        return {\n          pass: actual === null\n        };\n      }\n    };\n  }\n\n  return toBeNull;\n};\n\ngetJasmineRequireObj().toBeTruthy = function() {\n\n  function toBeTruthy() {\n    return {\n      compare: function(actual) {\n        return {\n          pass: !!actual\n        };\n      }\n    };\n  }\n\n  return toBeTruthy;\n};\n\ngetJasmineRequireObj().toBeUndefined = function() {\n\n  function toBeUndefined() {\n    return {\n      compare: function(actual) {\n        return {\n          pass: void 0 === actual\n        };\n      }\n    };\n  }\n\n  return toBeUndefined;\n};\n\ngetJasmineRequireObj().toContain = function() {\n  function toContain(util, customEqualityTesters) {\n    customEqualityTesters = customEqualityTesters || [];\n\n    return {\n      compare: function(actual, expected) {\n\n        return {\n          pass: util.contains(actual, expected, customEqualityTesters)\n        };\n      }\n    };\n  }\n\n  return toContain;\n};\n\ngetJasmineRequireObj().toEqual = function() {\n\n  function toEqual(util, customEqualityTesters) {\n    customEqualityTesters = customEqualityTesters || [];\n\n    return {\n      compare: function(actual, expected) {\n        var result = {\n          pass: false\n        };\n\n        result.pass = util.equals(actual, expected, customEqualityTesters);\n\n        return result;\n      }\n    };\n  }\n\n  return toEqual;\n};\n\ngetJasmineRequireObj().toHaveBeenCalled = function(j$) {\n\n  function toHaveBeenCalled() {\n    return {\n      compare: function(actual) {\n        var result = {};\n\n        if (!j$.isSpy(actual)) {\n          throw new Error('Expected a spy, but got ' + j$.pp(actual) + '.');\n        }\n\n        if (arguments.length > 1) {\n          throw new Error('toHaveBeenCalled does not take arguments, use toHaveBeenCalledWith');\n        }\n\n        result.pass = actual.calls.any();\n\n        result.message = result.pass ?\n          'Expected spy ' + actual.and.identity() + ' not to have been called.' :\n          'Expected spy ' + actual.and.identity() + ' to have been called.';\n\n        return result;\n      }\n    };\n  }\n\n  return toHaveBeenCalled;\n};\n\ngetJasmineRequireObj().toHaveBeenCalledTimes = function(j$) {\n\n  function toHaveBeenCalledTimes() {\n    return {\n      compare: function(actual, expected) {\n        if (!j$.isSpy(actual)) {\n          throw new Error('Expected a spy, but got ' + j$.pp(actual) + '.');\n        }\n\n        var args = Array.prototype.slice.call(arguments, 0),\n          result = { pass: false };\n\n        if(!expected){\n          throw new Error('Expected times failed is required as an argument.');\n        }\n\n        actual = args[0];\n        var calls = actual.calls.count();\n        var timesMessage = expected === 1 ? 'once' : expected + ' times';\n        result.pass = calls === expected;\n        result.message = result.pass ?\n          'Expected spy ' + actual.and.identity() + ' not to have been called ' + timesMessage + '. It was called ' +  calls + ' times.' :\n          'Expected spy ' + actual.and.identity() + ' to have been called ' + timesMessage + '. It was called ' +  calls + ' times.';\n        return result;\n      }\n    };\n  }\n\n  return toHaveBeenCalledTimes;\n};\n\ngetJasmineRequireObj().toHaveBeenCalledWith = function(j$) {\n\n  function toHaveBeenCalledWith(util, customEqualityTesters) {\n    return {\n      compare: function() {\n        var args = Array.prototype.slice.call(arguments, 0),\n          actual = args[0],\n          expectedArgs = args.slice(1),\n          result = { pass: false };\n\n        if (!j$.isSpy(actual)) {\n          throw new Error('Expected a spy, but got ' + j$.pp(actual) + '.');\n        }\n\n        if (!actual.calls.any()) {\n          result.message = function() { return 'Expected spy ' + actual.and.identity() + ' to have been called with ' + j$.pp(expectedArgs) + ' but it was never called.'; };\n          return result;\n        }\n\n        if (util.contains(actual.calls.allArgs(), expectedArgs, customEqualityTesters)) {\n          result.pass = true;\n          result.message = function() { return 'Expected spy ' + actual.and.identity() + ' not to have been called with ' + j$.pp(expectedArgs) + ' but it was.'; };\n        } else {\n          result.message = function() { return 'Expected spy ' + actual.and.identity() + ' to have been called with ' + j$.pp(expectedArgs) + ' but actual calls were ' + j$.pp(actual.calls.allArgs()).replace(/^\\[ | \\]$/g, '') + '.'; };\n        }\n\n        return result;\n      }\n    };\n  }\n\n  return toHaveBeenCalledWith;\n};\n\ngetJasmineRequireObj().toMatch = function(j$) {\n\n  function toMatch() {\n    return {\n      compare: function(actual, expected) {\n        if (!j$.isString_(expected) && !j$.isA_('RegExp', expected)) {\n          throw new Error('Expected is not a String or a RegExp');\n        }\n\n        var regexp = new RegExp(expected);\n\n        return {\n          pass: regexp.test(actual)\n        };\n      }\n    };\n  }\n\n  return toMatch;\n};\n\ngetJasmineRequireObj().toThrow = function(j$) {\n\n  function toThrow(util) {\n    return {\n      compare: function(actual, expected) {\n        var result = { pass: false },\n          threw = false,\n          thrown;\n\n        if (typeof actual != 'function') {\n          throw new Error('Actual is not a Function');\n        }\n\n        try {\n          actual();\n        } catch (e) {\n          threw = true;\n          thrown = e;\n        }\n\n        if (!threw) {\n          result.message = 'Expected function to throw an exception.';\n          return result;\n        }\n\n        if (arguments.length == 1) {\n          result.pass = true;\n          result.message = function() { return 'Expected function not to throw, but it threw ' + j$.pp(thrown) + '.'; };\n\n          return result;\n        }\n\n        if (util.equals(thrown, expected)) {\n          result.pass = true;\n          result.message = function() { return 'Expected function not to throw ' + j$.pp(expected) + '.'; };\n        } else {\n          result.message = function() { return 'Expected function to throw ' + j$.pp(expected) + ', but it threw ' +  j$.pp(thrown) + '.'; };\n        }\n\n        return result;\n      }\n    };\n  }\n\n  return toThrow;\n};\n\ngetJasmineRequireObj().toThrowError = function(j$) {\n  function toThrowError () {\n    return {\n      compare: function(actual) {\n        var threw = false,\n          pass = {pass: true},\n          fail = {pass: false},\n          thrown;\n\n        if (typeof actual != 'function') {\n          throw new Error('Actual is not a Function');\n        }\n\n        var errorMatcher = getMatcher.apply(null, arguments);\n\n        try {\n          actual();\n        } catch (e) {\n          threw = true;\n          thrown = e;\n        }\n\n        if (!threw) {\n          fail.message = 'Expected function to throw an Error.';\n          return fail;\n        }\n\n        if (!(thrown instanceof Error)) {\n          fail.message = function() { return 'Expected function to throw an Error, but it threw ' + j$.pp(thrown) + '.'; };\n          return fail;\n        }\n\n        if (errorMatcher.hasNoSpecifics()) {\n          pass.message = 'Expected function not to throw an Error, but it threw ' + j$.fnNameFor(thrown) + '.';\n          return pass;\n        }\n\n        if (errorMatcher.matches(thrown)) {\n          pass.message = function() {\n            return 'Expected function not to throw ' + errorMatcher.errorTypeDescription + errorMatcher.messageDescription() + '.';\n          };\n          return pass;\n        } else {\n          fail.message = function() {\n            return 'Expected function to throw ' + errorMatcher.errorTypeDescription + errorMatcher.messageDescription() +\n              ', but it threw ' + errorMatcher.thrownDescription(thrown) + '.';\n          };\n          return fail;\n        }\n      }\n    };\n\n    function getMatcher() {\n      var expected = null,\n          errorType = null;\n\n      if (arguments.length == 2) {\n        expected = arguments[1];\n        if (isAnErrorType(expected)) {\n          errorType = expected;\n          expected = null;\n        }\n      } else if (arguments.length > 2) {\n        errorType = arguments[1];\n        expected = arguments[2];\n        if (!isAnErrorType(errorType)) {\n          throw new Error('Expected error type is not an Error.');\n        }\n      }\n\n      if (expected && !isStringOrRegExp(expected)) {\n        if (errorType) {\n          throw new Error('Expected error message is not a string or RegExp.');\n        } else {\n          throw new Error('Expected is not an Error, string, or RegExp.');\n        }\n      }\n\n      function messageMatch(message) {\n        if (typeof expected == 'string') {\n          return expected == message;\n        } else {\n          return expected.test(message);\n        }\n      }\n\n      return {\n        errorTypeDescription: errorType ? j$.fnNameFor(errorType) : 'an exception',\n        thrownDescription: function(thrown) {\n          var thrownName = errorType ? j$.fnNameFor(thrown.constructor) : 'an exception',\n              thrownMessage = '';\n\n          if (expected) {\n            thrownMessage = ' with message ' + j$.pp(thrown.message);\n          }\n\n          return thrownName + thrownMessage;\n        },\n        messageDescription: function() {\n          if (expected === null) {\n            return '';\n          } else if (expected instanceof RegExp) {\n            return ' with a message matching ' + j$.pp(expected);\n          } else {\n            return ' with message ' + j$.pp(expected);\n          }\n        },\n        hasNoSpecifics: function() {\n          return expected === null && errorType === null;\n        },\n        matches: function(error) {\n          return (errorType === null || error instanceof errorType) &&\n            (expected === null || messageMatch(error.message));\n        }\n      };\n    }\n\n    function isStringOrRegExp(potential) {\n      return potential instanceof RegExp || (typeof potential == 'string');\n    }\n\n    function isAnErrorType(type) {\n      if (typeof type !== 'function') {\n        return false;\n      }\n\n      var Surrogate = function() {};\n      Surrogate.prototype = type.prototype;\n      return (new Surrogate()) instanceof Error;\n    }\n  }\n\n  return toThrowError;\n};\n\ngetJasmineRequireObj().interface = function(jasmine, env) {\n  var jasmineInterface = {\n    describe: function(description, specDefinitions) {\n      return env.describe(description, specDefinitions);\n    },\n\n    xdescribe: function(description, specDefinitions) {\n      return env.xdescribe(description, specDefinitions);\n    },\n\n    fdescribe: function(description, specDefinitions) {\n      return env.fdescribe(description, specDefinitions);\n    },\n\n    it: function() {\n      return env.it.apply(env, arguments);\n    },\n\n    xit: function() {\n      return env.xit.apply(env, arguments);\n    },\n\n    fit: function() {\n      return env.fit.apply(env, arguments);\n    },\n\n    beforeEach: function() {\n      return env.beforeEach.apply(env, arguments);\n    },\n\n    afterEach: function() {\n      return env.afterEach.apply(env, arguments);\n    },\n\n    beforeAll: function() {\n      return env.beforeAll.apply(env, arguments);\n    },\n\n    afterAll: function() {\n      return env.afterAll.apply(env, arguments);\n    },\n\n    expect: function(actual) {\n      return env.expect(actual);\n    },\n\n    pending: function() {\n      return env.pending.apply(env, arguments);\n    },\n\n    fail: function() {\n      return env.fail.apply(env, arguments);\n    },\n\n    spyOn: function(obj, methodName) {\n      return env.spyOn(obj, methodName);\n    },\n\n    jsApiReporter: new jasmine.JsApiReporter({\n      timer: new jasmine.Timer()\n    }),\n\n    jasmine: jasmine\n  };\n\n  jasmine.addCustomEqualityTester = function(tester) {\n    env.addCustomEqualityTester(tester);\n  };\n\n  jasmine.addMatchers = function(matchers) {\n    return env.addMatchers(matchers);\n  };\n\n  jasmine.clock = function() {\n    return env.clock;\n  };\n\n  return jasmineInterface;\n};\n\ngetJasmineRequireObj().version = function() {\n  return '2.4.1';\n};\n";

/***/ },
/* 9 */
/***/ function(module, exports) {

	"use strict";
	
	module.exports = "/*\nCopyright (c) 2008-2015 Pivotal Labs\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\njasmineRequire.html = function(j$) {\n  j$.ResultsNode = jasmineRequire.ResultsNode();\n  j$.HtmlReporter = jasmineRequire.HtmlReporter(j$);\n  j$.QueryString = jasmineRequire.QueryString();\n  j$.HtmlSpecFilter = jasmineRequire.HtmlSpecFilter();\n};\n\njasmineRequire.HtmlReporter = function(j$) {\n\n  var noopTimer = {\n    start: function() {},\n    elapsed: function() { return 0; }\n  };\n\n  function HtmlReporter(options) {\n    var env = options.env || {},\n      getContainer = options.getContainer,\n      createElement = options.createElement,\n      createTextNode = options.createTextNode,\n      onRaiseExceptionsClick = options.onRaiseExceptionsClick || function() {},\n      onThrowExpectationsClick = options.onThrowExpectationsClick || function() {},\n      onRandomClick = options.onRandomClick || function() {},\n      addToExistingQueryString = options.addToExistingQueryString || defaultQueryString,\n      timer = options.timer || noopTimer,\n      results = [],\n      specsExecuted = 0,\n      failureCount = 0,\n      pendingSpecCount = 0,\n      htmlReporterMain,\n      symbols,\n      failedSuites = [];\n\n    this.initialize = function() {\n      clearPrior();\n      htmlReporterMain = createDom('div', {className: 'jasmine_html-reporter'},\n        createDom('div', {className: 'jasmine-banner'},\n          createDom('a', {className: 'jasmine-title', href: 'http://jasmine.github.io/', target: '_blank'}),\n          createDom('span', {className: 'jasmine-version'}, j$.version)\n        ),\n        createDom('ul', {className: 'jasmine-symbol-summary'}),\n        createDom('div', {className: 'jasmine-alert'}),\n        createDom('div', {className: 'jasmine-results'},\n          createDom('div', {className: 'jasmine-failures'})\n        )\n      );\n      getContainer().appendChild(htmlReporterMain);\n    };\n\n    var totalSpecsDefined;\n    this.jasmineStarted = function(options) {\n      totalSpecsDefined = options.totalSpecsDefined || 0;\n      timer.start();\n    };\n\n    var summary = createDom('div', {className: 'jasmine-summary'});\n\n    var topResults = new j$.ResultsNode({}, '', null),\n      currentParent = topResults;\n\n    this.suiteStarted = function(result) {\n      currentParent.addChild(result, 'suite');\n      currentParent = currentParent.last();\n    };\n\n    this.suiteDone = function(result) {\n      if (result.status == 'failed') {\n        failedSuites.push(result);\n      }\n\n      if (currentParent == topResults) {\n        return;\n      }\n\n      currentParent = currentParent.parent;\n    };\n\n    this.specStarted = function(result) {\n      currentParent.addChild(result, 'spec');\n    };\n\n    var failures = [];\n    this.specDone = function(result) {\n      if(noExpectations(result) && typeof console !== 'undefined' && typeof console.error !== 'undefined') {\n        console.error('Spec \\'' + result.fullName + '\\' has no expectations.');\n      }\n\n      if (result.status != 'disabled') {\n        specsExecuted++;\n      }\n\n      if (!symbols){\n        symbols = find('.jasmine-symbol-summary');\n      }\n\n      symbols.appendChild(createDom('li', {\n          className: noExpectations(result) ? 'jasmine-empty' : 'jasmine-' + result.status,\n          id: 'spec_' + result.id,\n          title: result.fullName\n        }\n      ));\n\n      if (result.status == 'failed') {\n        failureCount++;\n\n        var failure =\n          createDom('div', {className: 'jasmine-spec-detail jasmine-failed'},\n            createDom('div', {className: 'jasmine-description'},\n              createDom('a', {title: result.fullName, href: specHref(result)}, result.fullName)\n            ),\n            createDom('div', {className: 'jasmine-messages'})\n          );\n        var messages = failure.childNodes[1];\n\n        for (var i = 0; i < result.failedExpectations.length; i++) {\n          var expectation = result.failedExpectations[i];\n          messages.appendChild(createDom('div', {className: 'jasmine-result-message'}, expectation.message));\n          messages.appendChild(createDom('div', {className: 'jasmine-stack-trace'}, expectation.stack));\n        }\n\n        failures.push(failure);\n      }\n\n      if (result.status == 'pending') {\n        pendingSpecCount++;\n      }\n    };\n\n    this.jasmineDone = function(doneResult) {\n      var banner = find('.jasmine-banner');\n      var alert = find('.jasmine-alert');\n      var order = doneResult && doneResult.order;\n      alert.appendChild(createDom('span', {className: 'jasmine-duration'}, 'finished in ' + timer.elapsed() / 1000 + 's'));\n\n      banner.appendChild(\n        createDom('div', { className: 'jasmine-run-options' },\n          createDom('span', { className: 'jasmine-trigger' }, 'Options'),\n          createDom('div', { className: 'jasmine-payload' },\n            createDom('div', { className: 'jasmine-exceptions' },\n              createDom('input', {\n                className: 'jasmine-raise',\n                id: 'jasmine-raise-exceptions',\n                type: 'checkbox'\n              }),\n              createDom('label', { className: 'jasmine-label', 'for': 'jasmine-raise-exceptions' }, 'raise exceptions')),\n            createDom('div', { className: 'jasmine-throw-failures' },\n              createDom('input', {\n                className: 'jasmine-throw',\n                id: 'jasmine-throw-failures',\n                type: 'checkbox'\n              }),\n              createDom('label', { className: 'jasmine-label', 'for': 'jasmine-throw-failures' }, 'stop spec on expectation failure')),\n            createDom('div', { className: 'jasmine-random-order' },\n              createDom('input', {\n                className: 'jasmine-random',\n                id: 'jasmine-random-order',\n                type: 'checkbox'\n              }),\n              createDom('label', { className: 'jasmine-label', 'for': 'jasmine-random-order' }, 'run tests in random order'))\n          )\n        ));\n\n      var raiseCheckbox = find('#jasmine-raise-exceptions');\n\n      raiseCheckbox.checked = !env.catchingExceptions();\n      raiseCheckbox.onclick = onRaiseExceptionsClick;\n\n      var throwCheckbox = find('#jasmine-throw-failures');\n      throwCheckbox.checked = env.throwingExpectationFailures();\n      throwCheckbox.onclick = onThrowExpectationsClick;\n\n      var randomCheckbox = find('#jasmine-random-order');\n      randomCheckbox.checked = env.randomTests();\n      randomCheckbox.onclick = onRandomClick;\n\n      var optionsMenu = find('.jasmine-run-options'),\n          optionsTrigger = optionsMenu.querySelector('.jasmine-trigger'),\n          optionsPayload = optionsMenu.querySelector('.jasmine-payload'),\n          isOpen = /\\bjasmine-open\\b/;\n\n      optionsTrigger.onclick = function() {\n        if (isOpen.test(optionsPayload.className)) {\n          optionsPayload.className = optionsPayload.className.replace(isOpen, '');\n        } else {\n          optionsPayload.className += ' jasmine-open';\n        }\n      };\n\n      if (specsExecuted < totalSpecsDefined) {\n        var skippedMessage = 'Ran ' + specsExecuted + ' of ' + totalSpecsDefined + ' specs - run all';\n        alert.appendChild(\n          createDom('span', {className: 'jasmine-bar jasmine-skipped'},\n            createDom('a', {href: '?', title: 'Run all specs'}, skippedMessage)\n          )\n        );\n      }\n      var statusBarMessage = '';\n      var statusBarClassName = 'jasmine-bar ';\n\n      if (totalSpecsDefined > 0) {\n        statusBarMessage += pluralize('spec', specsExecuted) + ', ' + pluralize('failure', failureCount);\n        if (pendingSpecCount) { statusBarMessage += ', ' + pluralize('pending spec', pendingSpecCount); }\n        statusBarClassName += (failureCount > 0) ? 'jasmine-failed' : 'jasmine-passed';\n      } else {\n        statusBarClassName += 'jasmine-skipped';\n        statusBarMessage += 'No specs found';\n      }\n\n      var seedBar;\n      if (order && order.random) {\n        seedBar = createDom('span', {className: 'jasmine-seed-bar'},\n          ', randomized with seed ',\n          createDom('a', {title: 'randomized with seed ' + order.seed, href: seedHref(order.seed)}, order.seed)\n        );\n      }\n\n      alert.appendChild(createDom('span', {className: statusBarClassName}, statusBarMessage, seedBar));\n\n      for(i = 0; i < failedSuites.length; i++) {\n        var failedSuite = failedSuites[i];\n        for(var j = 0; j < failedSuite.failedExpectations.length; j++) {\n          var errorBarMessage = 'AfterAll ' + failedSuite.failedExpectations[j].message;\n          var errorBarClassName = 'jasmine-bar jasmine-errored';\n          alert.appendChild(createDom('span', {className: errorBarClassName}, errorBarMessage));\n        }\n      }\n\n      var results = find('.jasmine-results');\n      results.appendChild(summary);\n\n      summaryList(topResults, summary);\n\n      function summaryList(resultsTree, domParent) {\n        var specListNode;\n        for (var i = 0; i < resultsTree.children.length; i++) {\n          var resultNode = resultsTree.children[i];\n          if (resultNode.type == 'suite') {\n            var suiteListNode = createDom('ul', {className: 'jasmine-suite', id: 'suite-' + resultNode.result.id},\n              createDom('li', {className: 'jasmine-suite-detail'},\n                createDom('a', {href: specHref(resultNode.result)}, resultNode.result.description)\n              )\n            );\n\n            summaryList(resultNode, suiteListNode);\n            domParent.appendChild(suiteListNode);\n          }\n          if (resultNode.type == 'spec') {\n            if (domParent.getAttribute('class') != 'jasmine-specs') {\n              specListNode = createDom('ul', {className: 'jasmine-specs'});\n              domParent.appendChild(specListNode);\n            }\n            var specDescription = resultNode.result.description;\n            if(noExpectations(resultNode.result)) {\n              specDescription = 'SPEC HAS NO EXPECTATIONS ' + specDescription;\n            }\n            if(resultNode.result.status === 'pending' && resultNode.result.pendingReason !== '') {\n              specDescription = specDescription + ' PENDING WITH MESSAGE: ' + resultNode.result.pendingReason;\n            }\n            specListNode.appendChild(\n              createDom('li', {\n                  className: 'jasmine-' + resultNode.result.status,\n                  id: 'spec-' + resultNode.result.id\n                },\n                createDom('a', {href: specHref(resultNode.result)}, specDescription)\n              )\n            );\n          }\n        }\n      }\n\n      if (failures.length) {\n        alert.appendChild(\n          createDom('span', {className: 'jasmine-menu jasmine-bar jasmine-spec-list'},\n            createDom('span', {}, 'Spec List | '),\n            createDom('a', {className: 'jasmine-failures-menu', href: '#'}, 'Failures')));\n        alert.appendChild(\n          createDom('span', {className: 'jasmine-menu jasmine-bar jasmine-failure-list'},\n            createDom('a', {className: 'jasmine-spec-list-menu', href: '#'}, 'Spec List'),\n            createDom('span', {}, ' | Failures ')));\n\n        find('.jasmine-failures-menu').onclick = function() {\n          setMenuModeTo('jasmine-failure-list');\n        };\n        find('.jasmine-spec-list-menu').onclick = function() {\n          setMenuModeTo('jasmine-spec-list');\n        };\n\n        setMenuModeTo('jasmine-failure-list');\n\n        var failureNode = find('.jasmine-failures');\n        for (var i = 0; i < failures.length; i++) {\n          failureNode.appendChild(failures[i]);\n        }\n      }\n    };\n\n    return this;\n\n    function find(selector) {\n      return getContainer().querySelector('.jasmine_html-reporter ' + selector);\n    }\n\n    function clearPrior() {\n      // return the reporter\n      var oldReporter = find('');\n\n      if(oldReporter) {\n        getContainer().removeChild(oldReporter);\n      }\n    }\n\n    function createDom(type, attrs, childrenVarArgs) {\n      var el = createElement(type);\n\n      for (var i = 2; i < arguments.length; i++) {\n        var child = arguments[i];\n\n        if (typeof child === 'string') {\n          el.appendChild(createTextNode(child));\n        } else {\n          if (child) {\n            el.appendChild(child);\n          }\n        }\n      }\n\n      for (var attr in attrs) {\n        if (attr == 'className') {\n          el[attr] = attrs[attr];\n        } else {\n          el.setAttribute(attr, attrs[attr]);\n        }\n      }\n\n      return el;\n    }\n\n    function pluralize(singular, count) {\n      var word = (count == 1 ? singular : singular + 's');\n\n      return '' + count + ' ' + word;\n    }\n\n    function specHref(result) {\n      return addToExistingQueryString('spec', result.fullName);\n    }\n\n    function seedHref(seed) {\n      return addToExistingQueryString('seed', seed);\n    }\n\n    function defaultQueryString(key, value) {\n      return '?' + key + '=' + value;\n    }\n\n    function setMenuModeTo(mode) {\n      htmlReporterMain.setAttribute('class', 'jasmine_html-reporter ' + mode);\n    }\n\n    function noExpectations(result) {\n      return (result.failedExpectations.length + result.passedExpectations.length) === 0 &&\n        result.status === 'passed';\n    }\n  }\n\n  return HtmlReporter;\n};\n\njasmineRequire.HtmlSpecFilter = function() {\n  function HtmlSpecFilter(options) {\n    var filterString = options && options.filterString() && options.filterString().replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n    var filterPattern = new RegExp(filterString);\n\n    this.matches = function(specName) {\n      return filterPattern.test(specName);\n    };\n  }\n\n  return HtmlSpecFilter;\n};\n\njasmineRequire.ResultsNode = function() {\n  function ResultsNode(result, type, parent) {\n    this.result = result;\n    this.type = type;\n    this.parent = parent;\n\n    this.children = [];\n\n    this.addChild = function(result, type) {\n      this.children.push(new ResultsNode(result, type, this));\n    };\n\n    this.last = function() {\n      return this.children[this.children.length - 1];\n    };\n  }\n\n  return ResultsNode;\n};\n\njasmineRequire.QueryString = function() {\n  function QueryString(options) {\n\n    this.navigateWithNewParam = function(key, value) {\n      options.getWindowLocation().search = this.fullStringWithNewParam(key, value);\n    };\n\n    this.fullStringWithNewParam = function(key, value) {\n      var paramMap = queryStringToParamMap();\n      paramMap[key] = value;\n      return toQueryString(paramMap);\n    };\n\n    this.getParam = function(key) {\n      return queryStringToParamMap()[key];\n    };\n\n    return this;\n\n    function toQueryString(paramMap) {\n      var qStrPairs = [];\n      for (var prop in paramMap) {\n        qStrPairs.push(encodeURIComponent(prop) + '=' + encodeURIComponent(paramMap[prop]));\n      }\n      return '?' + qStrPairs.join('&');\n    }\n\n    function queryStringToParamMap() {\n      var paramStr = options.getWindowLocation().search.substring(1),\n        params = [],\n        paramMap = {};\n\n      if (paramStr.length > 0) {\n        params = paramStr.split('&');\n        for (var i = 0; i < params.length; i++) {\n          var p = params[i].split('=');\n          var value = decodeURIComponent(p[1]);\n          if (value === 'true' || value === 'false') {\n            value = JSON.parse(value);\n          }\n          paramMap[decodeURIComponent(p[0])] = value;\n        }\n      }\n\n      return paramMap;\n    }\n\n  }\n\n  return QueryString;\n};\n";

/***/ },
/* 10 */
/***/ function(module, exports) {

	"use strict";
	
	module.exports = "/**\n Starting with version 2.0, this file \"boots\" Jasmine, performing all of the necessary initialization before executing the loaded environment and all of a project's specs. This file should be loaded after `jasmine.js` and `jasmine_html.js`, but before any project source files or spec files are loaded. Thus this file can also be used to customize Jasmine for a project.\n\n If a project is using Jasmine via the standalone distribution, this file can be customized directly. If a project is using Jasmine via the [Ruby gem][jasmine-gem], this file can be copied into the support directory via `jasmine copy_boot_js`. Other environments (e.g., Python) will have different mechanisms.\n\n The location of `boot.js` can be specified and/or overridden in `jasmine.yml`.\n\n [jasmine-gem]: http://github.com/pivotal/jasmine-gem\n */\n\n(function() {\n\n  /**\n   * ## Require &amp; Instantiate\n   *\n   * Require Jasmine's core files. Specifically, this requires and attaches all of Jasmine's code to the `jasmine` reference.\n   */\n  window.jasmine = jasmineRequire.core(jasmineRequire);\n\n  /**\n   * Since this is being run in a browser and the results should populate to an HTML page, require the HTML-specific Jasmine code, injecting the same reference.\n   */\n  jasmineRequire.html(jasmine);\n\n  /**\n   * Create the Jasmine environment. This is used to run all specs in a project.\n   */\n  var env = jasmine.getEnv();\n\n  /**\n   * ## The Global Interface\n   *\n   * Build up the functions that will be exposed as the Jasmine public interface. A project can customize, rename or alias any of these functions as desired, provided the implementation remains unchanged.\n   */\n  var jasmineInterface = jasmineRequire.interface(jasmine, env);\n\n  /**\n   * Add all of the Jasmine global/public interface to the global scope, so a project can use the public interface directly. For example, calling `describe` in specs instead of `jasmine.getEnv().describe`.\n   */\n  extend(window, jasmineInterface);\n\n  /**\n   * ## Runner Parameters\n   *\n   * More browser specific code - wrap the query string in an object and to allow for getting/setting parameters from the runner user interface.\n   */\n\n  var queryString = new jasmine.QueryString({\n    getWindowLocation: function() { return window.location; }\n  });\n\n  var catchingExceptions = queryString.getParam(\"catch\");\n  env.catchExceptions(typeof catchingExceptions === \"undefined\" ? true : catchingExceptions);\n\n  var throwingExpectationFailures = queryString.getParam(\"throwFailures\");\n  env.throwOnExpectationFailure(throwingExpectationFailures);\n\n  var random = queryString.getParam(\"random\");\n  env.randomizeTests(random);\n\n  var seed = queryString.getParam(\"seed\");\n  if (seed) {\n    env.seed(seed);\n  }\n\n  /**\n   * ## Reporters\n   * The `HtmlReporter` builds all of the HTML UI for the runner page. This reporter paints the dots, stars, and x's for specs, as well as all spec names and all failures (if any).\n   */\n  var htmlReporter = new jasmine.HtmlReporter({\n    env: env,\n    onRaiseExceptionsClick: function() { queryString.navigateWithNewParam(\"catch\", !env.catchingExceptions()); },\n    onThrowExpectationsClick: function() { queryString.navigateWithNewParam(\"throwFailures\", !env.throwingExpectationFailures()); },\n    onRandomClick: function() { queryString.navigateWithNewParam(\"random\", !env.randomTests()); },\n    addToExistingQueryString: function(key, value) { return queryString.fullStringWithNewParam(key, value); },\n    getContainer: function() { return document.body; },\n    createElement: function() { return document.createElement.apply(document, arguments); },\n    createTextNode: function() { return document.createTextNode.apply(document, arguments); },\n    timer: new jasmine.Timer()\n  });\n\n  /**\n   * The `jsApiReporter` also receives spec results, and is used by any environment that needs to extract the results  from JavaScript.\n   */\n  env.addReporter(jasmineInterface.jsApiReporter);\n  env.addReporter(htmlReporter);\n\n  /**\n   * Filter which specs will be run by matching the start of the full name against the `spec` query param.\n   */\n  var specFilter = new jasmine.HtmlSpecFilter({\n    filterString: function() { return queryString.getParam(\"spec\"); }\n  });\n\n  env.specFilter = function(spec) {\n    return specFilter.matches(spec.getFullName());\n  };\n\n  /**\n   * Setting up timing functions to be able to be overridden. Certain browsers (Safari, IE 8, phantomjs) require this hack.\n   */\n  window.setTimeout = window.setTimeout;\n  window.setInterval = window.setInterval;\n  window.clearTimeout = window.clearTimeout;\n  window.clearInterval = window.clearInterval;\n\n  /**\n   * ## Execution\n   *\n   * Replace the browser window's `onload`, ensure it's called, and then run all of the loaded specs. This includes initializing the `HtmlReporter` instance and then executing the loaded Jasmine environment. All of this will happen after all of the specs are loaded.\n   */\n  var currentWindowOnload = window.onload;\n\n  window.onload = function() {\n    if (currentWindowOnload) {\n      currentWindowOnload();\n    }\n    htmlReporter.initialize();\n    env.execute();\n  };\n\n  /**\n   * Helper function for readability above.\n   */\n  function extend(destination, source) {\n    for (var property in source) destination[property] = source[property];\n    return destination;\n  }\n\n}());\n";

/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgMzcwMGNjZTliZjEyMmUzNTdiMTMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Jyb3dzZXItamFzbWluZS10ZXN0aW5nLmpzIiwid2VicGFjazovLy8uL3NyYy9saWIvamFzbWluZS0yLjQuMS9qYXNtaW5lLmNzcz80ZWVmIiwid2VicGFjazovLy8uL3NyYy9saWIvamFzbWluZS0yLjQuMS9qYXNtaW5lLmNzcyIsIndlYnBhY2s6Ly8vL2hvbWUvc2NvdHQvd29yay9hc3VyaW9uL3JldGFpbGVycG9ydGFsL2NsaWVudC9+L2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzIiwid2VicGFjazovLy8vaG9tZS9zY290dC93b3JrL2FzdXJpb24vcmV0YWlsZXJwb3J0YWwvY2xpZW50L34vc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbWF0Y2hlcnMuanMiLCJ3ZWJwYWNrOi8vLy4uL2VzNS1zaGltL2VzNS1zaGltLmpzIiwid2VicGFjazovLy8uLi9zb3VyY2UtbWFwLXN1cHBvcnQvYnJvd3Nlci1zb3VyY2UtbWFwLXN1cHBvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi9qYXNtaW5lLTIuNC4xL2phc21pbmUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpYi9qYXNtaW5lLTIuNC4xL2phc21pbmUtaHRtbC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbGliL2phc21pbmUtMi40LjEvYm9vdC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7O0FDdENBLGFBQVksRUFBRSxDQUFDOztBQUVmLG9CQUFPLENBQUMsQ0FBaUMsQ0FBQyxDQUFDOztBQUUzQyxvQkFBTyxDQUFDLENBQVUsQ0FBQyxDQUFDO0FBQ3BCLEtBQUksT0FBTyxHQUFHLENBQ1YsbUJBQU8sQ0FBQyxDQUFrRCxDQUFDLEVBQzNELG1CQUFPLENBQUMsQ0FBZ0MsQ0FBQyxFQUN6QyxtQkFBTyxDQUFDLENBQXFDLENBQUMsRUFDOUMsbUJBQU8sQ0FBQyxFQUE2QixDQUFDLENBQ3pDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDOztBQUdaLEtBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0FBQzNCLG9CQUFPLENBQUMsQ0FBWSxDQUFDLENBQUM7O0FBR3RCLGlCQUFnQixDQUFDLE9BQU8sRUFBRTs7O0FBRzFCLFVBQVMsWUFBWSxHQUFHO0FBQ3BCLFNBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRTtBQUMxQixpQkFBUSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEdBQUcsVUFBUyxLQUFLLEVBQUU7QUFDdEMsaUJBQUksT0FBTyxJQUFJLEtBQUssVUFBVSxFQUFFOzs7QUFHNUIsdUJBQU0sSUFBSSxTQUFTLENBQUMsc0VBQXNFLENBQUMsQ0FBQztjQUMvRjs7QUFFRCxpQkFBSSxLQUFLLEdBQUssS0FBSyxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDLENBQUM7aUJBQ2xELE9BQU8sR0FBRyxJQUFJO2lCQUNkLElBQUksR0FBTSxTQUFWLElBQUksR0FBaUIsRUFBRTtpQkFDdkIsTUFBTSxHQUFJLFNBQVYsTUFBTSxHQUFlO0FBQ2pCLHdCQUFPLE9BQU8sQ0FBQyxLQUFLLENBQUMsSUFBSSxZQUFZLElBQUksR0FDL0IsSUFBSSxHQUNKLEtBQUssRUFDWCxLQUFLLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7Y0FDNUQsQ0FBQzs7QUFFTixpQkFBSSxJQUFJLENBQUMsU0FBUyxFQUFFOztBQUVoQixxQkFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDO2NBQ25DO0FBQ0QsbUJBQU0sQ0FBQyxTQUFTLEdBQUcsSUFBSSxJQUFJLEVBQUUsQ0FBQzs7QUFFOUIsb0JBQU8sTUFBTSxDQUFDO1VBQ2pCLENBQUM7TUFDTDs7Ozs7Ozs7QUMvQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBK0Y7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxpQ0FBZ0MsVUFBVSxFQUFFO0FBQzVDLEU7Ozs7OztBQ3BCQTtBQUNBOzs7QUFHQTtBQUNBLGlDQUFnQyxvQkFBb0IsRUFBRSw0QkFBNEIsd0JBQXdCLGNBQWMsY0FBYyxpQkFBaUIsb0RBQW9ELG1CQUFtQixhQUFhLEVBQUUsNEJBQTRCLHVCQUF1QixFQUFFLGtDQUFrQyw0QkFBNEIsRUFBRSw4TEFBOEwsV0FBVyxtQkFBbUIsRUFBRSxpWkFBaVosbUJBQW1CLG9CQUFvQixFQUFFLDBDQUEwQyxvQkFBb0IsRUFBRSx5REFBeUQsaUNBQWlDLG93RUFBb3dFLHFDQUFxQyw4aFhBQThoWCw0QkFBNEIsMEJBQTBCLCtCQUErQix1QkFBdUIsZ0JBQWdCLGFBQWEsYUFBYSxjQUFjLEVBQUUsMkRBQTJELG1CQUFtQixvQkFBb0IsVUFBVSxFQUFFLDJDQUEyQyxpQkFBaUIsYUFBYSxFQUFFLDJDQUEyQyxhQUFhLEVBQUUsMENBQTBDLGtCQUFrQixFQUFFLDRDQUE0QyxhQUFhLGNBQWMsbUJBQW1CLG9CQUFvQixFQUFFLGtEQUFrRCxrQkFBa0IsVUFBVSxnQkFBZ0IsRUFBRSxxREFBcUQsdUJBQXVCLGNBQWMsYUFBYSxpQkFBaUIsRUFBRSxvRUFBb0UsaUJBQWlCLEVBQUUsMkVBQTJFLGdCQUFnQixxQkFBcUIsRUFBRSxvRUFBb0Usa0JBQWtCLEVBQUUsMkVBQTJFLGdCQUFnQixtQkFBbUIsbUJBQW1CLG1CQUFtQixFQUFFLHNFQUFzRSxpQkFBaUIsRUFBRSw2RUFBNkUsZ0JBQWdCLHFCQUFxQixFQUFFLHFFQUFxRSxtQkFBbUIsRUFBRSw0RUFBNEUsZ0JBQWdCLGdCQUFnQixFQUFFLG1FQUFtRSxpQkFBaUIsRUFBRSwwRUFBMEUsZ0JBQWdCLHFCQUFxQixFQUFFLCtDQUErQyxjQUFjLG1CQUFtQiwyQkFBMkIsZ0JBQWdCLG9CQUFvQixtQkFBbUIsRUFBRSxnRUFBZ0UsaUJBQWlCLG1CQUFtQixFQUFFLGdFQUFnRSxvQkFBb0IsZUFBZSxhQUFhLDJCQUEyQix3QkFBd0IscUJBQXFCLGtCQUFrQixFQUFFLDZFQUE2RSxnQkFBZ0IsRUFBRSx1Q0FBdUMsbUJBQW1CLGlCQUFpQixnQkFBZ0IsYUFBYSxFQUFFLHNEQUFzRCwyQkFBMkIsRUFBRSxzREFBc0QsMkJBQTJCLEVBQUUsdURBQXVELDJCQUEyQixFQUFFLHVEQUF1RCwyQkFBMkIsRUFBRSxvREFBb0Qsd0JBQXdCLGFBQWEsRUFBRSxzREFBc0QsYUFBYSxFQUFFLHlDQUF5QyxjQUFjLEVBQUUsd0tBQXdLLGVBQWUsRUFBRSx5SkFBeUosZUFBZSxFQUFFLDJDQUEyQyxrQkFBa0IsRUFBRSwyQ0FBMkMsa0JBQWtCLEVBQUUsOENBQThDLHVCQUF1QixtQkFBbUIsZ0JBQWdCLGlCQUFpQixFQUFFLDREQUE0RCxpQkFBaUIsb0JBQW9CLEVBQUUsK0RBQStELGdCQUFnQixFQUFFLCtEQUErRCxnQkFBZ0IsRUFBRSw4REFBOEQsZ0JBQWdCLEVBQUUsZ0VBQWdFLGdCQUFnQixFQUFFLGlFQUFpRSxnQkFBZ0IsRUFBRSxnRUFBZ0UsZUFBZSxFQUFFLHlDQUF5QyxrQkFBa0IsRUFBRSwyQ0FBMkMsYUFBYSxFQUFFLGlFQUFpRSxxQkFBcUIsRUFBRSxzRkFBc0YsMkJBQTJCLEVBQUUsd0ZBQXdGLGNBQWMsRUFBRSxrREFBa0QsbUJBQW1CLGFBQWEsa0JBQWtCLEVBQUUsc0VBQXNFLGdCQUFnQixFQUFFLCtDQUErQyxtQkFBbUIsbUJBQW1CLGdCQUFnQixtQkFBbUIsYUFBYSx3QkFBd0IsbUJBQW1CLGtCQUFrQixFQUFFOztBQUV4Nm5COzs7Ozs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0EseUNBQXdDLGdCQUFnQjtBQUN4RCxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCLHNCQUFzQjtBQUN0QztBQUNBO0FBQ0EsbUJBQWtCLDJCQUEyQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZSxtQkFBbUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUIsMkJBQTJCO0FBQzVDO0FBQ0E7QUFDQSxTQUFRLHVCQUF1QjtBQUMvQjtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0Esa0JBQWlCLHVCQUF1QjtBQUN4QztBQUNBO0FBQ0EsNEJBQTJCO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBLGlDQUFnQyxzQkFBc0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3REFBdUQ7QUFDdkQ7O0FBRUEsOEJBQTZCLG1CQUFtQjs7QUFFaEQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7QUN2UEEsV0FBVSxDQUFDLFlBQU07QUFDYixZQUFPLENBQUMsV0FBVyxDQUFDO0FBQ2hCLHFCQUFZLEVBQUUsa0JBQWtCLENBQUMsZ0JBQU07b0JBQUksTUFBTSxDQUFDLE1BQU07VUFBQSxDQUFDO01BQzVELENBQUMsQ0FBQztFQUNOLENBQUMsQ0FBQzs7QUFHSCxVQUFTLGtCQUFrQixDQUFDLEVBQUUsRUFBRTtBQUM1QixZQUFPLFVBQUMsSUFBSSxFQUFFLHFCQUFxQjtnQkFBTTtBQUNyQyxvQkFBTyxFQUFFLGlCQUFDLE1BQU0sRUFBRSxRQUFRO3dCQUFNLEVBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxFQUFFLFFBQVEsRUFBRSxxQkFBcUIsQ0FBQyxFQUFDO2NBQUM7VUFDcEc7TUFBQyxDQUFDOzs7Ozs7O0FDVlA7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZSxvSkFBb0osTUFBTSxxQkFBcUIsYUFBYSxFQUFFLFlBQVksY0FBYyxFQUFFLEVBQUUseUVBQXlFLDBDQUEwQyxtQ0FBbUMsY0FBYyxFQUFFLHNCQUFzQixpQ0FBaUMsRUFBRSxzQ0FBc0Msc0RBQXNEO0FBQ3RpQixhQUFZLG1JQUFtSSxNQUFNLHVCQUF1QixhQUFhLEVBQUUsWUFBWSxjQUFjLEVBQUUsRUFBRSxpQ0FBaUMsb0NBQW9DLGlDQUFpQyxjQUFjLEVBQUUsb0ZBQW9GO0FBQ25hLGNBQWEsNElBQTRJLE1BQU0sc0JBQXNCLGFBQWEsRUFBRSxZQUFZLGNBQWMsRUFBRSxFQUFFLGtDQUFrQyxzQ0FBc0MsaUNBQWlDLGFBQWEsRUFBRSxpQ0FBaUMsY0FBYyxFQUFFLHdGQUF3Rjs7QUFFbmU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE0QyxnQ0FBZ0M7QUFDNUUsK0JBQThCLGNBQWM7QUFDNUM7QUFDQSxRQUFPLFlBQVk7QUFDbkI7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFpRCxRQUFRO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQSxJQUFHO0FBQ0g7QUFDQSxrREFBaUQsUUFBUTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrREFBaUQsZ0JBQWdCOztBQUVqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxnQ0FBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLGlCQUFpQjtBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFrRixzQ0FBc0MsRUFBRTs7QUFFMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0RBQXFEO0FBQ3JELHNFQUFxRTtBQUNyRTtBQUNBO0FBQ0EseURBQXdEO0FBQ3hELCtFQUE4RTtBQUM5RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsMkJBQTBCLG1CQUFtQjs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQThDLGdDQUFnQztBQUM5RSxVQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBdUIsWUFBWTtBQUNuQztBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF1QixZQUFZO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF1QixZQUFZO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF1QixZQUFZO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFrRyxhQUFhLEVBQUU7QUFDakg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7O0FBRUEsZUFBYyxZQUFZO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2R0FBNEcsYUFBYSxFQUFFO0FBQzNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWMsWUFBWTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0Esc0NBQXFDLFdBQVc7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1QixrQkFBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNELG1DQUFrQyxpQkFBaUI7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBd0IsbUJBQW1CO0FBQzNDLHFDQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0Esc0VBQXFFLDJDQUEyQztBQUNoSDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBMkIsbUJBQW1CO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTJCLHFCQUFxQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF3QztBQUN4QywyQ0FBMEMsYUFBYTtBQUN2RCxjQUFhO0FBQ2IsTUFBSztBQUNMO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZ0VBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBc0Msd0JBQXdCO0FBQzlEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQWtCLEVBQUUsU0FBUyxFQUFFO0FBQy9CO0FBQ0EsdUJBQXNCLEVBQUU7QUFDeEIsdUJBQXNCLEVBQUU7QUFDeEI7QUFDQSx3QkFBdUIsRUFBRTtBQUN6Qix3QkFBdUIsRUFBRTtBQUN6QjtBQUNBLDRCQUEyQixFQUFFO0FBQzdCLGlDQUFnQyxHQUFHO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMEIsRUFBRTtBQUM1Qiw0QkFBMkIsRUFBRTtBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQW9DLG1CQUFtQjs7QUFFdkQ7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBOEI7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW1DLHVCQUF1Qjs7QUFFMUQ7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE0RTtBQUM1RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBMkMsMEJBQTBCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0EsK0RBQThELFdBQVc7QUFDekU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUM7Ozs7Ozs7QUNwc0RELDRKQUEySiwwQkFBMEIsNkNBQTZDLG1CQUFtQixnQkFBZ0IsVUFBVSxVQUFVLDRDQUE0Qyx3QkFBd0Isb0JBQW9CLCtDQUErQyxRQUFRLFlBQVksbUNBQW1DLGlCQUFpQixnQkFBZ0Isc0JBQXNCLG9CQUFvQixvREFBb0QsV0FBVyxZQUFZLFNBQVMsR0FBRyxxQkFBcUIsOEJBQThCLEVBQUUsNEJBQTRCLHFCQUFxQixlQUFlLHdCQUF3QixnQkFBZ0IsTUFBTSw4QkFBOEIsaUJBQWlCLHdCQUF3QixxQ0FBcUMsUUFBUSxLQUFLLDJDQUEyQyxzRkFBc0YsV0FBVyxnQkFBZ0IsU0FBUyxjQUFjLG1CQUFtQixlQUFlLGNBQWMsY0FBYyxPQUFPLDJCQUEyQiw2REFBNkQsU0FBUyxrQkFBa0IsVUFBVSxjQUFjLElBQUkscUJBQXFCLGNBQWMsS0FBSywyRkFBMkYsS0FBSyxZQUFZLElBQUksZ0JBQWdCLHdCQUF3QixZQUFZLEdBQUcsaURBQWlELDhDQUE4QyxrQkFBa0IsOEVBQThFLHFDQUFxQyw0Q0FBNEMsd0JBQXdCLFFBQVEsS0FBSyx3QkFBd0Isb0JBQW9CLGdCQUFnQiw2Q0FBNkMsb0JBQW9CLG9CQUFvQixFQUFFLHlCQUF5QixnQkFBZ0IsRUFBRSxvQkFBb0IsMERBQTBELFVBQVUsZ0JBQWdCLHFDQUFxQyxzQkFBc0IsMkJBQTJCLGFBQWEsU0FBUyxxQ0FBcUMsNEJBQTRCLDJCQUEyQixtQ0FBbUMsdUNBQXVDLGlCQUFpQix3Q0FBd0MsbUJBQW1CLDRCQUE0QixlQUFlLHlDQUF5QyxpQ0FBaUMsRUFBRSxhQUFhLHNCQUFzQixvQkFBb0Isd0NBQXdDLFNBQVMsVUFBVSw2RkFBNkYsRUFBRSw2Q0FBNkMscUJBQXFCLGFBQWEsY0FBYyxrQkFBa0IsNEJBQTRCLDRCQUE0QixpQkFBaUIsdUJBQXVCLG9CQUFvQix3QkFBd0IseURBQXlELDBCQUEwQixjQUFjLFNBQVMsY0FBYyxnRkFBZ0YsV0FBVyxzREFBc0Qsd0JBQXdCLDBCQUEwQixRQUFRLFFBQVEsSUFBSSxpSUFBaUksb0pBQW9KLFVBQVUsNEJBQTRCLDhCQUE4QixJQUFJLGlCQUFpQixJQUFJLGlZQUFpWSxVQUFVLHVCQUF1QixxRkFBcUYsMEZBQTBGLFVBQVUsTUFBTSx5VEFBeVQsVUFBVSwyQ0FBMkMsSUFBSSxHQUFHLHNCQUFzQixHQUFHLHFCQUFxQixrQkFBa0IsNENBQTRDLGVBQWUseUZBQXlGLGVBQWUsVUFBVSxNQUFNLHlCQUF5QiwyQ0FBMkMscUNBQXFDLDRFQUE0RSxNQUFNLHFGQUFxRixpRUFBaUUsS0FBSyxRQUFRLHlGQUF5RixJQUFJLGdEQUFnRCxzQ0FBc0MsdURBQXVELElBQUksV0FBVyxTQUFTLGtCQUFrQixXQUFXLDJCQUEyQixJQUFJLGlDQUFpQyxTQUFTLG9CQUFvQixnS0FBZ0ssV0FBVyxzRkFBc0Ysb0JBQW9CLGdLQUFnSyxXQUFXLFlBQVksTUFBTSxvS0FBb0ssVUFBVSxvQkFBb0Isa0tBQWtLLGdFQUFnRSxvQkFBb0IsZ0tBQWdLLDBFQUEwRSxvQkFBb0IscUhBQXFILDRCQUE0QixvQkFBb0IscUhBQXFILDBCQUEwQixzQkFBc0Isc05BQXNOLGVBQWUscUNBQXFDLElBQUksZ0RBQWdELHNCQUFzQiwyTkFBMk4sZUFBZSxxQ0FBcUMsSUFBSSwrQkFBK0Isc0JBQXNCLCtOQUErTixzREFBc0Qsc0JBQXNCLHVPQUF1TywyREFBMkQsc0JBQXNCLCtQQUErUCxtQ0FBbUMsc0JBQXNCLCtQQUErUCxxQ0FBcUMsa0JBQWtCLGtDQUFrQyxNQUFNLGlCQUFpQixpQkFBaUIsS0FBSyxnQkFBZ0IsY0FBYyxrQkFBa0IsZUFBZSxjQUFjLGtDQUFrQyw2REFBNkQsS0FBSyxjQUFjLGdEQUFnRCxjQUFjLGlCQUFpQixXQUFXLEtBQUssc0JBQXNCLGtDQUFrQyxLQUFLLFFBQVEsd0JBQXdCLDhEQUE4RCxRQUFRLFdBQVcsK0JBQStCLFNBQVMsY0FBYyxpQkFBaUIsV0FBVyxnQ0FBZ0MsU0FBUyxvQkFBb0IsWUFBWSxtQ0FBbUMsZ0JBQWdCLFNBQVMsY0FBYyxJQUFJLDZCQUE2QixTQUFTLG1DQUFtQyxnQkFBZ0IsbUVBQW1FLHFFQUFxRSwwREFBMEQsMERBQTBELGtCQUFrQixtRUFBbUUsb0RBQW9ELHFEQUFxRCwwREFBMEQsa0JBQWtCLG1FQUFtRSxvREFBb0QscURBQXFELGtCQUFrQiw0Q0FBNEMsd0NBQXdDLFdBQVcsZUFBZSx1QkFBdUIsZ0JBQWdCLDZCQUE2QixJQUFJLDZDQUE2QyxpQkFBaUIsV0FBVyxzREFBc0QsU0FBUyxVQUFVLEdBQUcseUJBQXlCLGdDQUFnQywrS0FBK0sscUJBQXFCLHVCQUF1Qiw2Q0FBNkMsMkJBQTJCLE1BQU0sUUFBUSxvQkFBb0IsMEJBQTBCLE1BQU0sMkNBQTJDLE1BQU0sdURBQXVELE1BQU0sMENBQTBDLE1BQU0sNkVBQTZFLE1BQU0sMkNBQTJDLFVBQVUsdUJBQXVCLGlGQUFpRixrQ0FBa0MsNEJBQTRCLE1BQU0sbUNBQW1DLFdBQVcsbUJBQW1CLG1CQUFtQixRQUFRLFdBQVcsS0FBSyxXQUFXLFlBQVksWUFBWSxVQUFVLG9DQUFvQywyQ0FBMkMsS0FBSyxRQUFRLElBQUksSUFBSSxJQUFJLGVBQWUsZ0JBQWdCLCtCQUErQixvQ0FBb0MsVUFBVSw0QkFBNEIsZ0JBQWdCLCtCQUErQixhQUFhLGtDQUFrQyxlQUFlLFFBQVEsSUFBSSxtRkFBbUYsb0JBQW9CLElBQUksTUFBTSxnRUFBZ0UsTUFBTSxrREFBa0QsTUFBTSxtREFBbUQsTUFBTSwrREFBK0QsTUFBTSxtRkFBbUYsV0FBVywwREFBMEQsZ0NBQWdDLE1BQU0sMkNBQTJDLFVBQVUscUNBQXFDLG9DQUFvQyxlQUFlLHFDQUFxQyxvQkFBb0IsVUFBVSwyQkFBMkIsZUFBZSxvQkFBb0IsV0FBVyxJQUFJLGtCQUFrQixJQUFJLE1BQU0sMENBQTBDLDhCQUE4QixJQUFJLCtGQUErRixTQUFTLE1BQU0sNkJBQTZCLE1BQU0sOEJBQThCLE1BQU0sZ0dBQWdHLE1BQU0sa0ZBQWtGLE9BQU8sUUFBUSxXQUFXLDZDQUE2QyxJQUFJLE1BQU0sMkNBQTJDLFVBQVUsOEJBQThCLE9BQU8sdUVBQXVFLG1DQUFtQyxTQUFTLDBCQUEwQixTQUFTLHFWQUFxVixJQUFJLHFCQUFxQixxQ0FBcUMsa0NBQWtDLGtCQUFrQixXQUFXLFdBQVcsMkRBQTJELHVDQUF1QyxJQUFJLG1CQUFtQixVQUFVLDRCQUE0QiwyRUFBMkUsMEJBQTBCLDhCQUE4QiwyRUFBMkUsNkJBQTZCLG9DQUFvQywyR0FBMkcscUNBQXFDLHVDQUF1Qyx1QkFBdUIsdUNBQXVDLHVCQUF1Qix1Q0FBdUMsdUJBQXVCLHVDQUF1Qyx1QkFBdUIsbUNBQW1DLHlHQUF5RyxzRUFBc0Usc0NBQXNDLHVCQUF1QixzQ0FBc0MsdUJBQXVCLHNDQUFzQyx1QkFBdUIsc0NBQXNDLHVCQUF1QixzQ0FBc0MsdUJBQXVCLHNDQUFzQyx1QkFBdUIsdUNBQXVDLHVCQUF1Qix5Q0FBeUMsdUJBQXVCLHVDQUF1Qyw2SkFBNkosNkJBQTZCLDBDQUEwQyxrQkFBa0IsMENBQTBDLGtCQUFrQiwwQ0FBMEMsa0JBQWtCLDBDQUEwQyxrQkFBa0Isd0NBQXdDLGtLQUFrSyw0RUFBNEUseUNBQXlDLGtCQUFrQix5Q0FBeUMsa0JBQWtCLHlDQUF5QyxrQkFBa0IseUNBQXlDLGtCQUFrQiwyQ0FBMkMsa0JBQWtCLHlDQUF5QyxrQkFBa0IsMENBQTBDLGtCQUFrQiwwQ0FBMEMsa0JBQWtCLGlDQUFpQyxTQUFTLFNBQVMsbUJBQW1CLDJDQUEyQyw4REFBOEQsd0JBQXdCLDZIQUE2SCxJQUFJLGVBQWUsK0JBQStCLCtCQUErQixJQUFJLGdEQUFnRCxlQUFlLE1BQU0sd0NBQXdDLHFDQUFxQyxzQ0FBc0MsZ0RBQWdELHFEQUFxRCxJQUFJLGtCQUFrQixnQkFBZ0Isc0VBQXNFLGtCQUFrQix5QkFBeUIsZUFBZSxhQUFhLGFBQWEsWUFBWSxZQUFZLGdCQUFnQixzQkFBc0IsNEJBQTRCLGtCQUFrQixjQUFjLGdCQUFnQix3QkFBd0IsOEJBQThCLDhCQUE4Qiw4QkFBOEIsOEJBQThCLHNCQUFzQiw0QkFBNEIsNEJBQTRCLDRCQUE0Qiw0QkFBNEIsNEJBQTRCLDhCQUE4Qiw4QkFBOEIsOEJBQThCLDBCQUEwQixnQ0FBZ0MsZ0NBQWdDLGdDQUFnQyxnQ0FBZ0Msd0JBQXdCLDhCQUE4Qiw4QkFBOEIsOEJBQThCLDhCQUE4Qiw4QkFBOEIsOEJBQThCLGdDQUFnQyxnQ0FBZ0MsZ0JBQWdCLG9CQUFvQixnQ0FBZ0MsVUFBVSxFQUFFLDBCQUEwQixxQkFBcUIsMkJBQTJCLE1BQU0sVUFBVSwyQkFBMkIsVUFBVSxzQkFBc0IsS0FBSyxjQUFjLE9BQU8sU0FBUyxJQUFJLDBCQUEwQixjQUFjLE9BQU8sU0FBUyxJQUFJLDBCQUEwQixlQUFlLEtBQUssd0NBQXdDLGlCQUFpQixLQUFLLGtDQUFrQyw4QkFBOEIsK0VBQStFLFVBQVUscUNBQXFDLGNBQWMseVFBQXlRLEtBQUssS0FBSywrQkFBK0IsU0FBUyxTQUFTLElBQUksK0JBQStCLG1CQUFtQixHQUFHLHFCQUFxQixhQUFhLGdCQUFnQix5QkFBeUIsS0FBSyxLQUFLLFdBQVcsOEVBQThFLFVBQVUsSUFBSSxvQkFBb0IsU0FBUyxnQkFBZ0IsK0JBQStCLGlCQUFpQixXQUFXLDhCQUE4QixTQUFTLG1DQUFtQyxJQUFJLHVDQUF1QyxxQkFBcUIseUNBQXlDLFVBQVUsS0FBSyxrQ0FBa0MsNEZBQTRGLHVDQUF1QyxpQ0FBaUMsVUFBVSxrQkFBa0IsK0JBQStCLHdCQUF3Qix3Q0FBd0Msa0NBQWtDLFVBQVUsaUNBQWlDLGlCQUFpQix3QkFBd0IseUJBQXlCLDJCQUEyQixrQkFBa0IsOENBQThDLHVDQUF1Qyx5RkFBeUYsU0FBUyxnQkFBZ0IseUJBQXlCLGNBQWMsWUFBWSx3QkFBd0IsS0FBSyxxQkFBcUIsa0JBQWtCLEtBQUssK0JBQStCLHlCQUF5Qix5QkFBeUIsc0ZBQXNGLElBQUksb0JBQW9CLElBQUksTUFBTSxLQUFLLFFBQVEsV0FBVyxtQkFBbUIsdUJBQXVCLHdCQUF3QixZQUFZLGtCQUFrQixzQkFBc0IseUJBQXlCLE9BQU8sT0FBTyxzQkFBc0IsOEJBQThCLFlBQVkseUJBQXlCLDRCQUE0QixnRUFBZ0UsVUFBVSxzQkFBc0IsOEJBQThCLGdEQUFnRCxxQkFBcUIsaUJBQWlCLG9CQUFvQixzQkFBc0Isb0RBQW9ELElBQUksc0NBQXNDLHFCQUFxQixjQUFjLGVBQWUsc0JBQXNCLHlFQUF5RSwrQkFBK0IsK0VBQStFLFNBQVMsZ0RBQWdELGVBQWUsK0ZBQStGLEtBQUssbUJBQW1CLFVBQVUsOENBQThDLG1CQUFtQixpQkFBaUIsR0FBRyxvQkFBb0IsYUFBYSxTQUFTLFVBQVUsT0FBTyxTQUFTLFFBQVEsU0FBUyxzQkFBc0Isb0RBQW9ELGlCQUFpQixhQUFhLG9CQUFvQixrREFBa0QsR0FBRyxxQkFBcUIsaUZBQWlGLDhFQUE4RSx3REFBd0QsSUFBSSxpSEFBaUgsc0JBQXNCLHNEQUFzRCxrQkFBa0IsYUFBYSxlQUFlLGFBQWEsb0JBQW9CLDBCQUEwQiwrQkFBK0IsSUFBSSxrQkFBa0IsVUFBVSw4QkFBOEIsdUNBQXVDLDJCQUEyQixvQ0FBb0MsNEJBQTRCLDJFQUEyRSxnQ0FBZ0Msa0RBQWtELDhDQUE4QywyQkFBMkIsb0RBQW9ELDRDQUE0QywrQkFBK0IsNEJBQTRCLGFBQWEsRUFBRSxFQUFFLHlCQUF5QixzQkFBc0Isc0RBQXNELGtCQUFrQixzQkFBc0IscUJBQXFCLHNDQUFzQyw2Q0FBNkMsV0FBVyxVQUFVLHFCQUFxQiwrQkFBK0IsR0FBRyxvRUFBb0UsMEJBQTBCLFdBQVcsTUFBTSxRQUFRLEtBQUssU0FBUyxPQUFPLE9BQU8sdUNBQXVDLEVBQUUsRUFBRSwyQkFBMkIsc0JBQXNCLHNEQUFzRCxrQkFBa0IsUUFBUSxNQUFNLHlHQUF5RyxPQUFPLE9BQU8sRUFBRSxxQkFBcUIsc0JBQXNCLHdEQUF3RCxxQkFBcUIsc0JBQXNCLHlEQUF5RCxFQUFFLEVBQUUsV0FBVyxzQkFBc0Isc0RBQXNELGtCQUFrQixzQkFBc0IsMkNBQTJDLCtFQUErRSx5QkFBeUIsK0NBQStDLEVBQUUsRUFBRSxXQUFXLHNCQUFzQixzREFBc0Qsa0JBQWtCLGNBQWMsUUFBUSwwREFBMEQsV0FBVywwQkFBMEIsd0xBQXdMLDZEQUE2RCw4QkFBOEIsa0NBQWtDLGtCQUFrQixzQkFBc0IsaUJBQWlCLFlBQVksaUdBQWlHLDRCQUE0QixpQ0FBaUMsNENBQTRDLGdEQUFnRCwyQkFBMkIsOEVBQThFLGVBQWUsOEVBQThFLDhFQUE4RSxVQUFVLHVCQUF1QiwrQ0FBK0MsZUFBZSwrQ0FBK0MsbURBQW1ELFFBQVEsRUFBRSxxQ0FBcUMsMERBQTBELGVBQWUseUlBQXlJLGlDQUFpQyxFQUFFLG9DQUFvQyx5REFBeUQsZUFBZSxzSUFBc0ksZ0NBQWdDLEVBQUUseUNBQXlDLHVDQUF1QyxTQUFTLFdBQVcsT0FBTyxzQ0FBc0MseUNBQXlDLE9BQU8sS0FBSyxrQkFBa0IsY0FBYyw0QkFBNEIsb0JBQW9CLFNBQVMscUNBQXFDLGNBQWMscUNBQXFDLFdBQVcsU0FBUyw2RkFBNkYsY0FBYyx5QkFBeUIsaUJBQWlCLGtCQUFrQixTQUFTLDZGQUE2RixjQUFjLDZCQUE2QixtQkFBbUIsU0FBUyx1R0FBdUcsaUNBQWlDLG9FQUFvRSw2REFBNkQsNERBQTRELDZDQUE2Qyx1RkFBdUYsMEZBQTBGLHdCQUF3Qiw0Q0FBNEMsR0FBRywyRUFBMkUsdUhBQXVILGtDQUFrQyxrREFBa0QsT0FBTywySEFBMkgsT0FBTyxnREFBZ0QseUNBQXlDLG9DQUFvQyxtREFBbUQsNkVBQTZFLE1BQU0scURBQXFELHFDQUFxQyxpR0FBaUcscUhBQXFILG9EQUFvRCw2Q0FBNkMsR0FBRyx1R0FBdUcsaUVBQWlFLHdIQUF3SCxvRkFBb0YsRUFBRSx3QkFBd0Isc0JBQXNCLG1CQUFtQix3Q0FBd0MsVUFBVSw2QkFBNkIsaURBQWlELE1BQU0sK0NBQStDLE1BQU0sc0RBQXNELHNCQUFzQixrQkFBa0IsZUFBZSxzQkFBc0IsT0FBTyxrSkFBa0osa0JBQWtCLHNCQUFzQixFQUFFLEVBQUUsdUZBQXVGLHNCQUFzQixzREFBc0Qsa0JBQWtCLGNBQWMsZ0NBQWdDLGlEQUFpRCxvQkFBb0Isa0JBQWtCLGtCQUFrQiwyQkFBMkIsd0VBQXdFLHVCQUF1Qiw0QkFBNEIsOEJBQThCLHlCQUF5QixFQUFFLDBCQUEwQixPQUFPLFdBQVcsZ0RBQWdELDhFQUE4RSw0Q0FBNEMsMEJBQTBCLGdCQUFnQixFQUFFLDhCQUE4Qiw0QkFBNEIsMkJBQTJCLEVBQUUsVUFBVSxtQ0FBbUMsZ0dBQWdHLDRCQUE0QiwrQkFBK0IsK0NBQStDLDJDQUEyQyxxQkFBcUIsNEhBQTRILEdBQUcsMkNBQTJDLFFBQVEscURBQXFELDBEQUEwRCw2S0FBNksseUNBQXlDLGNBQWMsdUJBQXVCLHVCQUF1QixvQkFBb0IsbUNBQW1DLGlDQUFpQyw2QkFBNkIsNENBQTRDLEVBQUUsOEpBQThKLGtDQUFrQyxnQ0FBZ0MsT0FBTyxnQkFBZ0IsY0FBYyw4QkFBOEIsNEJBQTRCLHVEQUF1RCxRQUFRLCtDQUErQyxnUEFBZ1AsdUNBQXVDLEtBQUssMENBQTBDLHFDQUFxQyxtREFBbUQsb0NBQW9DLElBQUksS0FBSyxvQkFBb0IsK0JBQStCLG9CQUFvQixPQUFPLE9BQU8sYUFBYSxrRUFBa0UsU0FBUyxpQ0FBaUMsb0JBQW9CLHdSQUF3UixVQUFVLGtEQUFrRCx5QkFBeUIsc0NBQXNDLHVCQUF1QixtQkFBbUIsbUdBQW1HLFFBQVEsZ0NBQWdDLE9BQU8sc0lBQXNJLGtEQUFrRCwrRkFBK0YsVUFBVSxnQ0FBZ0MsNkJBQTZCLHVCQUF1QixFQUFFLEVBQUUsZ0VBQWdFLHNCQUFzQix3REFBd0Qsa0JBQWtCLHNCQUFzQixpQkFBaUIsdUJBQXVCLDRCQUE0Qiw4QkFBOEIsOEJBQThCLDRCQUE0QixxQkFBcUIsdUVBQXVFLHdDQUF3QyxnQkFBZ0IscUdBQXFHLDhDQUE4Qyw0QkFBNEIsYUFBYSxLQUFLLGtCQUFrQiw4QkFBOEIsd0JBQXdCLFdBQVcscUNBQXFDLGlDQUFpQyxxQkFBcUIsS0FBSyxzQkFBc0IsV0FBVyxnQ0FBZ0MseUJBQXlCLG9IQUFvSCx1R0FBdUcsT0FBTyxJQUFJLE9BQU8scUJBQXFCLDhCQUE4Qiw0QkFBNEIsMkJBQTJCLEVBQUUsVUFBVSw0QkFBNEIsMENBQTBDLFlBQVksT0FBTyx1RUFBdUUsNEdBQTRHLGFBQWEsZ0NBQWdDLDJDQUEyQyxLQUFLLHVCQUF1Qix1RUFBdUUsNEdBQTRHLGFBQWEsNkJBQTZCLHFDQUFxQyxJQUFJLCtEQUErRCxvRUFBb0UsR0FBRyw2QkFBNkIsK0JBQStCLFFBQVEsS0FBSyxRQUFRLFFBQVEsdUNBQXVDLHlCQUF5QixnQkFBZ0IsYUFBYSx1Q0FBdUMsNENBQTRDLG9KQUFvSixhQUFhLDJDQUEyQyx5Q0FBeUMsMkNBQTJDLG1DQUFtQyxNQUFNLHlFQUF5RSwwREFBMEQsSUFBSSx3REFBd0QsZ0NBQWdDLFdBQVcsc0JBQXNCLEtBQUssRUFBRSxVQUFVLDhDQUE4QywrREFBK0Qsd0JBQXdCLEtBQUsscUhBQXFILDBCQUEwQiw0QkFBNEIsWUFBWSxnQkFBZ0IsYUFBYSxrRUFBa0UsV0FBVyxpQkFBaUIsZUFBZSxrQ0FBa0MsMEJBQTBCLEVBQUUsRUFBRSxzQ0FBc0Msd0JBQXdCLEVBQUUsT0FBTyxlQUFlLGVBQWUsRUFBRSxFQUFFLHVEQUF1RCxzQkFBc0Isd0RBQXdELGtCQUFrQixjQUFjLHNCQUFzQixvREFBb0QsTUFBTSxjQUFjLHVCQUF1QiwwQkFBMEIsb0JBQW9CLDBCQUEwQixvQkFBb0IsU0FBUyxnQkFBZ0Isd0JBQXdCLGtCQUFrQix5QkFBeUIsc0JBQXNCLGlDQUFpQyxtREFBbUQseUZBQXlGLGVBQWUsZ0JBQWdCLHFCQUFxQixNQUFNLDhHQUE4RywwQkFBMEIsZUFBZSw0QkFBNEIsb0JBQW9CLHlCQUF5Qix5QkFBeUIsV0FBVyxxR0FBcUcsNkNBQTZDLE1BQU0saU5BQWlOLDhDQUE4QyxNQUFNLCtNQUErTSxFQUFFLEVBQUUsV0FBVyxzQkFBc0IsZUFBZSxhQUFhLCtHQUErRyxjQUFjLFdBQVcsc0JBQXNCLElBQUksUUFBUSx5QkFBeUIscUJBQXFCLGFBQWEsV0FBVyxxREFBcUQsa0NBQWtDLFNBQVMsT0FBTyxjQUFjLGdCQUFnQixlQUFlLGlFQUFpRSx3Q0FBd0MsY0FBYyxNQUFNLEdBQUcsTUFBTSwrSUFBK0ksSUFBSSxRQUFRLE9BQU8sc0pBQXNKLFlBQVksS0FBSyxjQUFjLGtCQUFrQixzR0FBc0csVUFBVSxZQUFZLE1BQU0sY0FBYyxrQkFBa0IsT0FBTyxrQkFBa0Isa0JBQWtCLDZCQUE2QiwyREFBMkQsOEJBQThCLE1BQU0saUJBQWlCLFFBQVEsa0JBQWtCLG1CQUFtQixtR0FBbUcsY0FBYywyREFBMkQsZUFBZSxvQ0FBb0MsaUtBQWlLLGFBQWEsYUFBYSx1T0FBdU8sT0FBTyx5REFBeUQsOEVBQThFLEtBQUssZ0RBQWdELCtJQUErSSx1QkFBdUIsU0FBUyxjQUFjLFNBQVMseUVBQXlFLHNDQUFzQyxvQkFBb0IsTUFBTSxFQUFFLGFBQWEsU0FBUyxjQUFjLG9EQUFvRCxNQUFNLGdEQUFnRCxnQ0FBZ0MsU0FBUyx5QkFBeUIsRUFBRSxPQUFPLHlCQUF5QixpQkFBaUIsNkJBQTZCLGVBQWUsNkJBQTZCLG1CQUFtQixzQ0FBc0MsaUJBQWlCLFNBQVMsb0NBQW9DLDZDQUE2QyxTQUFTLEVBQUUsU0FBUyxnQkFBZ0IsUUFBUSxLQUFLLEVBQUUsMkJBQTJCLDBCQUEwQixhQUFhLGNBQWMsK0RBQStELE1BQU0sT0FBTywyQkFBMkIsb0RBQW9ELDZHQUE2RyxZQUFZLGFBQWEsYUFBYSxtQkFBbUIsOEJBQThCLG9FQUFvRSxVQUFVLGVBQWUsMkNBQTJDLHVCQUF1QixVQUFVLFFBQVEsZ0NBQWdDLDZGQUE2RixLQUFLLDBDQUEwQyxtQkFBbUIsbUJBQW1CLHNCQUFzQixzQkFBc0Isc0JBQXNCLE9BQU8sS0FBSywwQkFBMEIsUUFBUSxxRUFBcUUsdUVBQXVFLDBKQUEwSixvQkFBb0IsSUFBSSxtQ0FBbUMsK0NBQStDLHNFQUFzRSx5RUFBeUUsRUFBRSw0RUFBNEUsRUFBRSxHQUFHLE1BQU0sU0FBUyxFQUFFLEc7Ozs7Ozs7O0FDQW5rM0MsT0FBTSxDQUFDLE9BQU8sR0FBRywwMDZGQUEwMDZGLEM7Ozs7Ozs7O0FDQTMxNkYsT0FBTSxDQUFDLE9BQU8sR0FBRyxvOGdCQUFvOGdCLEM7Ozs7Ozs7O0FDQXI5Z0IsT0FBTSxDQUFDLE9BQU8sR0FBRyw4MktBQTgySyxDIiwiZmlsZSI6ImJyb3dzZXItamFzbWluZS10ZXN0aW5nLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGV4cG9ydHM6IHt9LFxuIFx0XHRcdGlkOiBtb2R1bGVJZCxcbiBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiB3ZWJwYWNrL2Jvb3RzdHJhcCAzNzAwY2NlOWJmMTIyZTM1N2IxM1xuICoqLyIsImJpbmRQb2x5ZmlsbCgpO1xuXG5yZXF1aXJlKCcuL2xpYi9qYXNtaW5lLTIuNC4xL2phc21pbmUuY3NzJyk7XG5cbnJlcXVpcmUoJ2VzNS1zaGltJyk7XG52YXIgc2NyaXB0cyA9IFtcbiAgICByZXF1aXJlKCdzb3VyY2UtbWFwLXN1cHBvcnQvYnJvd3Nlci1zb3VyY2UtbWFwLXN1cHBvcnQuanMnKSxcbiAgICByZXF1aXJlKCcuL2xpYi9qYXNtaW5lLTIuNC4xL2phc21pbmUuanMnKSxcbiAgICByZXF1aXJlKCcuL2xpYi9qYXNtaW5lLTIuNC4xL2phc21pbmUtaHRtbC5qcycpLFxuICAgIHJlcXVpcmUoJy4vbGliL2phc21pbmUtMi40LjEvYm9vdC5qcycpLFxuXS5qb2luKCc7Jyk7XG5cblxuZXZhbC5jYWxsKGdsb2JhbCwgc2NyaXB0cyk7XG5yZXF1aXJlKCcuL21hdGNoZXJzJyk7XG5cblxuc291cmNlTWFwU3VwcG9ydC5pbnN0YWxsKCk7XG5cbi8vIE5lZWRlZCBmb3IgcGhhbnRvbUpTIHdoaWNoIGRvZXMgbm90IGluY2x1ZGUgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQoKVxuZnVuY3Rpb24gYmluZFBvbHlmaWxsKCkge1xuICAgIGlmICghRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQpIHtcbiAgICAgICAgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbihvVGhpcykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgLy8gY2xvc2VzdCB0aGluZyBwb3NzaWJsZSB0byB0aGUgRUNNQVNjcmlwdCA1XG4gICAgICAgICAgICAgICAgLy8gaW50ZXJuYWwgSXNDYWxsYWJsZSBmdW5jdGlvblxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kIC0gd2hhdCBpcyB0cnlpbmcgdG8gYmUgYm91bmQgaXMgbm90IGNhbGxhYmxlJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBhQXJncyAgID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSxcbiAgICAgICAgICAgICAgICBmVG9CaW5kID0gdGhpcyxcbiAgICAgICAgICAgICAgICBmTk9QICAgID0gZnVuY3Rpb24oKSB7fSxcbiAgICAgICAgICAgICAgICBmQm91bmQgID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmVG9CaW5kLmFwcGx5KHRoaXMgaW5zdGFuY2VvZiBmTk9QXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBvVGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFBcmdzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKHRoaXMucHJvdG90eXBlKSB7XG4gICAgICAgICAgICAgICAgLy8gbmF0aXZlIGZ1bmN0aW9ucyBkb24ndCBoYXZlIGEgcHJvdG90eXBlXG4gICAgICAgICAgICAgICAgZk5PUC5wcm90b3R5cGUgPSB0aGlzLnByb3RvdHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZCb3VuZC5wcm90b3R5cGUgPSBuZXcgZk5PUCgpO1xuXG4gICAgICAgICAgICByZXR1cm4gZkJvdW5kO1xuICAgICAgICB9O1xuICAgIH1cbn1cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9icm93c2VyLWphc21pbmUtdGVzdGluZy5qc1xuICoqLyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vamFzbWluZS5jc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLy4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vamFzbWluZS5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9qYXNtaW5lLmNzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9saWIvamFzbWluZS0yLjQuMS9qYXNtaW5lLmNzc1xuICoqIG1vZHVsZSBpZCA9IDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLy4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiYm9keSB7IG92ZXJmbG93LXk6IHNjcm9sbDsgfVxcblxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgeyBiYWNrZ3JvdW5kLWNvbG9yOiAjZWVlOyBwYWRkaW5nOiA1cHg7IG1hcmdpbjogLThweDsgZm9udC1zaXplOiAxMXB4OyBmb250LWZhbWlseTogTW9uYWNvLCBcXFwiTHVjaWRhIENvbnNvbGVcXFwiLCBtb25vc3BhY2U7IGxpbmUtaGVpZ2h0OiAxNHB4OyBjb2xvcjogIzMzMzsgfVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgYSB7IHRleHQtZGVjb3JhdGlvbjogbm9uZTsgfVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgYTpob3ZlciB7IHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lOyB9XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciBwLCAuamFzbWluZV9odG1sLXJlcG9ydGVyIGgxLCAuamFzbWluZV9odG1sLXJlcG9ydGVyIGgyLCAuamFzbWluZV9odG1sLXJlcG9ydGVyIGgzLCAuamFzbWluZV9odG1sLXJlcG9ydGVyIGg0LCAuamFzbWluZV9odG1sLXJlcG9ydGVyIGg1LCAuamFzbWluZV9odG1sLXJlcG9ydGVyIGg2IHsgbWFyZ2luOiAwOyBsaW5lLWhlaWdodDogMTRweDsgfVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtYmFubmVyLCAuamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN5bWJvbC1zdW1tYXJ5LCAuamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN1bW1hcnksIC5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtcmVzdWx0LW1lc3NhZ2UsIC5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3BlYyAuamFzbWluZS1kZXNjcmlwdGlvbiwgLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zcGVjLWRldGFpbCAuamFzbWluZS1kZXNjcmlwdGlvbiwgLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1hbGVydCAuamFzbWluZS1iYXIsIC5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3RhY2stdHJhY2UgeyBwYWRkaW5nLWxlZnQ6IDlweDsgcGFkZGluZy1yaWdodDogOXB4OyB9XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1iYW5uZXIgeyBwb3NpdGlvbjogcmVsYXRpdmU7IH1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWJhbm5lciAuamFzbWluZS10aXRsZSB7IGJhY2tncm91bmQ6IHVybCgnZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFGb0FBQUFaQ0FNQUFBQ0d1c255QUFBQ2RsQk1WRVgvLy8vL0FQK0FnSUNxVmFxQVFJQ1pNNW1BVllDU1NaS0FRSUNPT1k2QVRZQ0xSb3VBUUlDSk80bVNTWUNJUklpUFFJQ0hQSWVPUjRDR1E0YU1RSUNHUFlhTFJvQ0ZRNFdLUUlDUFBZV0pSWUNPUW9TSlFJQ05Qb1NJUklDTVFvU0hRSUNIUklDS1FvT0hRSUNLUG9PSk80T0pRWU9NUUlDTVE0Q0lRWUtMUUlDSVBvS0xRNENLUUlDTlBvS0pRSVNNUTRLSlFvU0xRWUtKUUlTTFE0S0lRb1NLUVlLSVFJQ0lRSVNNUW9TS1FZS0xRSU9MUW9PSlFZR0xRSU9LUUlPTVFvR0tRWU9MUVlHS1FJT0xRb0dKUVlPSlFJT0tRWUdKUUlPS1FvR0tRSUdMUUlLTFE0S0tRb0dMUVlLSlFJR0tRWUtKUUlHS1FJS0pRb0dLUVlLTFFJR0tRWUtMUUlPSlFvS0tRb09KUVlLS1FJT0pRb0tLUW9PS1FJT0xRb0tLUVlPTFFZS0pRSU9LUW9LS1FZS0tRb0tKUVlPS1FZS0xRSU9LUW9LTFFZT0tRWUtMUUlPSlFvR0tRWUtKUVlHSlFvR0tRWUtMUW9HTFFZR0tRb0dKUVlLS1FZR0pRSUtLUW9HSlFZS0xRSUtLUVlHTFFZS0tRWUdLUVlHS1FZS0pRWU9LUW9LSlFZT0tRWUtMUVlPTFFZT0tRWUtMUVlPS1FvS0tRWUtLUVlPS1FZT0pRWUtLUVlLTFFZS0tRSUtLUW9LS1FZS0tRWUtLUW9LSlFJS0tRWUtMUVlLS1FZS0tRSUtLUVlLS1FZS0tRWUtLUUlLS1FZS0pRWUdMUVlHS1FZS0tRWUtLUVlHS1FJS0tRWUdLUVlPSlFvS0tRWU9MUVlLS1FZT0tRb0tLUVlLS1FvS0tRWUtLUVlLSlFZS0xRWUtLUVlLS1FZS0tRWUtLUVlLS1FZS0tRWUtLUVlLS1FZS0pRWUtLUVlLS1FZS0tRWUtLUVlLS1FZS0tRWUtLUVlLS1FZS0tRWUtLUVlLS1FZS0xRWUtLUVlLS1FZS0tRWUtLUVlLS1FZS0tRWUtLUVlLS1FZS0tRWUtLUVlLS1FZS0tRWUttSURwRUFBQUEwWFJTVGxNQUFRSURCQVVHQndnSkNnc01EUTRQRUJFU0V4UVZGaGNZR1JvYkhCMGVIeUFpSXlRbEp5Y29LaXNzTFM0d01UUTFOamM0T1RvN1BEdytQMEJDUTBSSVNVcExURTFPVUZOVVZWZFlXRmxhVzE1ZllHRmlZMlpuYUdscWEyeHRiM0J4Y25OMGRuaDVlbnQ4Zlg1L2dJR0NoSVdJaW95TmpvK1FrWk9VbFphWW1acWJuSjJlb0tHaW82V21xS21zcmE2dnNMR3p0cmU0dWJxN3ZMMit3TUhEeE1qSnlzdk56cy9RMGRMVTF0ZlkyZHZjM3QvZzRlTGo1ZWJuNk9ucTYrenQ3dS93OHZQMDlmYjMrUG42Ky96OS92a1ZRWEFBQUFNYVNVUkJWSGhlNWRYeFYxTjFHTWZ4ejJBQmJEZ0lBbTVWREpPeVZESUpMVU1hVnBCV1VaVWFHYm1xb0dwWlJTaUdpUldwNktvWjVBQjBaWTUwUkltWlFJbGFoS2tNWVh2L1I5MGRCdkVUL3JKZk9yM091Yzh2OTl6UGVjNTl6dmY1NmordllLbFZpU2Y3MjUwWDRNcjNPMjlUZ3EwOEJkR0I0RGhjZWtFSjVZa1FLRnNnV1pkdGo5SnBWK0k4eFBqTEZxa3JzRUlxTzhQSFNwaXMzNmpXYXpjcWpFc2ZKamt2UnNzVlUzN1NkSU91NFhDZjV2RUpQc253SnBuUk5VOUpteGhNazhsMWdlaElycTdoVEZqek9EK1ZmODg2MjlxS01KVk5sdEluRmVSZXhSUXlKbE5lcWQxaUdEbFN6cklVSXlYYnlGZm0zUllwcmNRUmU3bHF0V3lHWWJmYzZkVDBSMnZtZE9Pa1gzdTU1QzFyUDM3ZnRpSCt0RGJ5NHIvUkJUMHc4VHlFa3IrZXBCOVhnUERtU1lZV2JyaEN1RllhSXl3M2ZEUUFYVG5Ta2grQU5vZmlIbVdmOWwrRlkxSTkwRmRRVGV0c3RPMDBvMjNub3Z6VnNKN3VCMy9DNVRrYmpSd1o1SmVyd1Y0aVJXcTlIRmJGTWFLL2QwVFlxYXlSaVFQdUl4eFMzQnU4SldVOTAvNjB0S2k3dmtoYXpuZXowYS9UYlZPS2o1Q2FPWmg2ZldHNi9MeXY5Qi9aTFIxZ3cvUy9mcGJlVkQzTUNXMWxpNlN2V0RPbjY1dHI5OS91dld0QlMwWERtNHMxdCtzT0hwRzBrcEJLeC9sNzd3T1NueExwY3g2VFhtWExUUFFPS1lPZjlRMWRmcjgvU0oybUZkQ3ZsMVlsOTNEaUhVWnZYZUxKYkdTell1NWdWSjJzbGJTYWtPUjhkeENxNWFkUTJvRkxxc0U5RXgzTDRxUU8wZU9QZVU1eDU2YnlwWHA0b25TRWI1T2tJQ1g2bERhdDU1VGVvenROS1FjSmFha3J6OUtDYjk1b0Q2OUlLcSt5S1c0WFBqa25hUzUyVjBUWnFFMmNUdFhqY0hTQ1JtVU84OGUrODVoajNFUDc0aTlwOHB5bHc3bHhnTUR5eWw2T1Y3WmVqbmpOTWZhdHU4N0x4UmJIMElTMzVndDJhNFpqbUdwVkJkS0szV3I2SU5rOGpXV1NHcWJBNTVDS2dqQlJDNkU5dzc4eWRUZzNBQlMzQUZWMVFOMFk0QWEycGdFalduUVVSajlMMGF5SzZSMnlzRXF4SFVLelluTHZ2eVUraTlLTTJKSEp6RTR2eVpPeURjT3dPc3lTYWplTFBjOHNOdlBKa0ZseUpkMjB3cHFBelplQWZaM29XeWJ4ZCtQLzNqK1NHM3VTQmRmMlZRQUFBQUJKUlU1RXJrSmdnZz09Jykgbm8tcmVwZWF0OyBiYWNrZ3JvdW5kOiB1cmwoJ2RhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEQ5NGJXd2dkbVZ5YzJsdmJqMGlNUzR3SWlCbGJtTnZaR2x1WnowaVZWUkdMVGdpSUhOMFlXNWtZV3h2Ym1VOUltNXZJajgrQ2p3aExTMGdRM0psWVhSbFpDQjNhWFJvSUVsdWEzTmpZWEJsSUNob2RIUndPaTh2ZDNkM0xtbHVhM05qWVhCbExtOXlaeThwSUMwdFBnb0tQSE4yWndvZ0lDQjRiV3h1Y3pwa1l6MGlhSFIwY0RvdkwzQjFjbXd1YjNKbkwyUmpMMlZzWlcxbGJuUnpMekV1TVM4aUNpQWdJSGh0Ykc1ek9tTmpQU0pvZEhSd09pOHZZM0psWVhScGRtVmpiMjF0YjI1ekxtOXlaeTl1Y3lNaUNpQWdJSGh0Ykc1ek9uSmtaajBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TVRrNU9TOHdNaTh5TWkxeVpHWXRjM2x1ZEdGNExXNXpJeUlLSUNBZ2VHMXNibk02YzNablBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHlNREF3TDNOMlp5SUtJQ0FnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JZ29nSUNCNGJXeHVjenBwYm10elkyRndaVDBpYUhSMGNEb3ZMM2QzZHk1cGJtdHpZMkZ3WlM1dmNtY3ZibUZ0WlhOd1lXTmxjeTlwYm10elkyRndaU0lLSUNBZ2RtVnljMmx2YmowaU1TNHhJZ29nSUNCM2FXUjBhRDBpTmpneExqazJNalV5SWdvZ0lDQm9aV2xuYUhROUlqRTROeTQxSWdvZ0lDQnBaRDBpYzNabk1pSUtJQ0FnZUcxc09uTndZV05sUFNKd2NtVnpaWEoyWlNJK1BHMWxkR0ZrWVhSaENpQWdJQ0FnYVdROUltMWxkR0ZrWVhSaE9DSStQSEprWmpwU1JFWStQR05qT2xkdmNtc0tJQ0FnSUNBZ0lDQWdjbVJtT21GaWIzVjBQU0lpUGp4a1l6cG1iM0p0WVhRK2FXMWhaMlV2YzNabkszaHRiRHd2WkdNNlptOXliV0YwUGp4a1l6cDBlWEJsQ2lBZ0lDQWdJQ0FnSUNBZ2NtUm1PbkpsYzI5MWNtTmxQU0pvZEhSd09pOHZjSFZ5YkM1dmNtY3ZaR012WkdOdGFYUjVjR1V2VTNScGJHeEpiV0ZuWlNJZ0x6NDhMMk5qT2xkdmNtcytQQzl5WkdZNlVrUkdQand2YldWMFlXUmhkR0UrUEdSbFpuTUtJQ0FnSUNCcFpEMGlaR1ZtY3pZaVBqeGpiR2x3VUdGMGFBb2dJQ0FnSUNBZ2FXUTlJbU5zYVhCUVlYUm9NVGdpUGp4d1lYUm9DaUFnSUNBZ0lDQWdJR1E5SWswZ01Dd3hOVEF3SURBc01DQnNJRFUwTlRVdU56UXNNQ0F3TERFMU1EQWdUQ0F3TERFMU1EQWdlaUlLSUNBZ0lDQWdJQ0FnYVc1cmMyTmhjR1U2WTI5dWJtVmpkRzl5TFdOMWNuWmhkSFZ5WlQwaU1DSUtJQ0FnSUNBZ0lDQWdhV1E5SW5CaGRHZ3lNQ0lnTHo0OEwyTnNhWEJRWVhSb1Bqd3ZaR1ZtY3o0OFp3b2dJQ0FnSUhSeVlXNXpabTl5YlQwaWJXRjBjbWw0S0RFdU1qVXNNQ3d3TEMweExqSTFMREFzTVRnM0xqVXBJZ29nSUNBZ0lHbGtQU0puTVRBaVBqeG5DaUFnSUNBZ0lDQjBjbUZ1YzJadmNtMDlJbk5qWVd4bEtEQXVNU3d3TGpFcElnb2dJQ0FnSUNBZ2FXUTlJbWN4TWlJK1BHY0tJQ0FnSUNBZ0lDQWdhV1E5SW1jeE5DSStQR2NLSUNBZ0lDQWdJQ0FnSUNCamJHbHdMWEJoZEdnOUluVnliQ2dqWTJ4cGNGQmhkR2d4T0NraUNpQWdJQ0FnSUNBZ0lDQWdhV1E5SW1jeE5pSStQSEJoZEdnS0lDQWdJQ0FnSUNBZ0lDQWdJR1E5SW0wZ01UVTBOQ3cxT1RrdU5ETTBJR01nTUM0NU1pd3ROREF1TXpVeUlESTFMalk0TEMwNE1TNDJNRElnTnpFdU5UTXNMVGd4TGpZd01pQXlOeTQxTVN3d0lEUTNMalk0TERFeUxqZ3pNaUEyTVM0ME5Dd3pOUzQzTlRRZ01USXVPRE1zTWpJdU9UTWdNVEl1T0RNc05UWXVPRFV5SURFeUxqZ3pMRGd5TGpVeU55QnNJREFzTXpJNUxqRTROQ0F0TnpFdU5USXNNQ0F3TERFd05DNDFORE1nTWpZMkxqZ3pMREFnTUN3dE1UQTBMalUwTXlBdE56QXVOaXd3SURBc0xUTTBOQzQzTnlCaklEQXNMVFU0TGpZNU1TQXRNeTQyT0N3dE1UQTBMalV6TVNBdE5EUXVPVE1zTFRFMU1pNHlNVGdnTFRNMkxqWTRMQzAwTWk0eE9DQXRPVFl1TWpnc0xUWTJMakF5SUMweE5UTXVNVFFzTFRZMkxqQXlJQzB4TVRjdU16Y3NNQ0F0TWpBM0xqSTBMRGMzTGprME1TQXRNakF5TGpZMExERTVOeTR4TkRVZ2JDQXhNekF1TWl3d0lnb2dJQ0FnSUNBZ0lDQWdJQ0FnYVc1cmMyTmhjR1U2WTI5dWJtVmpkRzl5TFdOMWNuWmhkSFZ5WlQwaU1DSUtJQ0FnSUNBZ0lDQWdJQ0FnSUdsa1BTSndZWFJvTWpJaUNpQWdJQ0FnSUNBZ0lDQWdJQ0J6ZEhsc1pUMGlabWxzYkRvak9HRTBNVGd5TzJacGJHd3RiM0JoWTJsMGVUb3hPMlpwYkd3dGNuVnNaVHB1YjI1NlpYSnZPM04wY205clpUcHViMjVsSWlBdlBqeHdZWFJvQ2lBZ0lDQWdJQ0FnSUNBZ0lDQmtQU0p0SURJek1ERXVOQ3cyTmpJdU5qazFJR01nTUN3NE1DNDNNRE1nTFRZMkxqazBMREUwTlM0NE1UTWdMVEUwTnk0Mk15d3hORFV1T0RFeklDMDRNeTQwTkN3d0lDMHhORGN1TmpNc0xUWTRMamM0TVNBdE1UUTNMall6TEMweE5URXVNekF4SURBc0xUYzVMamM0TlNBMk5pNDVOQ3d0TVRRMUxqZ3dNU0F4TkRVdU9Dd3RNVFExTGpnd01TQTROQzR6TlN3d0lERTBPUzQwTml3Mk55NDROVElnTVRRNUxqUTJMREUxTVM0eU9Ea2dlaUJ0SUMweExqZ3pMQzB4T0RFdU5UUTNJR01nTFRNMUxqYzNMQzAxTkM0d09UY2dMVGt6TGpVekxDMDNPQzQ0TlRrZ0xURTFOeTQzTWl3dE56Z3VPRFU1SUMweE5EQXVNeXd3SUMweU5URXVNalFzTVRFMkxqUTBPU0F0TWpVeExqSTBMREkxTkM0NU1UZ2dNQ3d4TkRJdU1USTVJREV4TXk0M0xESTJNQzQwTVNBeU5UWXVOelFzTWpZd0xqUXhJRFl6TGpJM0xEQWdNVEU0TGpJNUxDMHlPUzR6TXpZZ01UVXlMakl5TEMwNE1pNDFNak1nYkNBd0xEWTVMalk0TnlBeE56VXVNVFFzTUNBd0xDMHhNRFF1TlRJM0lDMDJNUzQwTkN3d0lEQXNMVEk0TUM0MU9UZ2dOakV1TkRRc01DQXdMQzB4TURRdU5USTNJQzB4TnpVdU1UUXNNQ0F3TERZMkxqQXhPU0lLSUNBZ0lDQWdJQ0FnSUNBZ0lHbHVhM05qWVhCbE9tTnZibTVsWTNSdmNpMWpkWEoyWVhSMWNtVTlJakFpQ2lBZ0lDQWdJQ0FnSUNBZ0lDQnBaRDBpY0dGMGFESTBJZ29nSUNBZ0lDQWdJQ0FnSUNBZ2MzUjViR1U5SW1acGJHdzZJemhoTkRFNE1qdG1hV3hzTFc5d1lXTnBkSGs2TVR0bWFXeHNMWEoxYkdVNmJtOXVlbVZ5Ynp0emRISnZhMlU2Ym05dVpTSWdMejQ4Y0dGMGFBb2dJQ0FnSUNBZ0lDQWdJQ0FnWkQwaWJTQXlOakl5TGpNekxEVTFOeTR5TlRnZ1l5QXpMalkzTEMwME5DNHdNVFlnTXpNdU1ERXNMVGN6TGpNME9DQTNPQzQ0Tml3dE56TXVNelE0SURNekxqa3pMREFnTmpZdU9UTXNNak11T0RJMElEWTJMamt6TERZd0xqVXdOQ0F3TERRNExqWXdOaUF0TkRVdU9EUXNOVFl1T0RVMklDMDRNeTQwTkN3Mk5pNDVOREVnTFRnMUxqSTRMREl5TGpBd05DQXRNVGM0TGpneExEUTRMall3TmlBdE1UYzRMamd4TERFMU5TNDROemtnTUN3NU15NDFNellnTnpndU9EWXNNVFEzTGpZek15QXhOalV1T1Rnc01UUTNMall6TXlBME5Dd3dJRGd6TGpRekxDMDVMakUzTmlBeE1UQXVPVFFzTFRRMExqQXdPQ0JzSURBc016TXVPVEl5SURneUxqVXpMREFnTUN3dE1UTXlMamsyTlNBdE1UQTRMakl4TERBZ1l5QXRNUzQ0TXl3ek5DNDROVFlnTFRJNExqUXlMRFUzTGpjM05DQXROak11TWpZc05UY3VOemMwSUMwek1DNHlOaXd3SUMwMk1pNHpOU3d0TVRjdU5ESXlJQzAyTWk0ek5Td3ROVEV1TXpRNElEQXNMVFExTGpnME55QTBOQzQ1TXl3dE5UVXVPVE1nT0RBdU5qa3NMVFkwTGpFNElEZzRMakF5TEMweU1DNHhOelVnTVRneUxqUTNMQzAwTnk0Mk9UVWdNVGd5TGpRM0xDMHhOVGN1TnpNMElEQXNMVGs1TGpBeU55QXRPRE11TkRRc0xURTFOQzR3TXprZ0xURTNOUzR4TXl3dE1UVTBMakF6T1NBdE5Ea3VOVE1zTUNBdE9UUXVORFlzTVRVdU5UZ3lJQzB4TWpZdU5UVXNOVE11TVRnZ2JDQXdMQzAwTUM0ek5DQXRPRFV1TWpjc01DQXdMREUwTWk0eE1qa2dNVEUwTGpZeUxEQWlDaUFnSUNBZ0lDQWdJQ0FnSUNCcGJtdHpZMkZ3WlRwamIyNXVaV04wYjNJdFkzVnlkbUYwZFhKbFBTSXdJZ29nSUNBZ0lDQWdJQ0FnSUNBZ2FXUTlJbkJoZEdneU5pSUtJQ0FnSUNBZ0lDQWdJQ0FnSUhOMGVXeGxQU0ptYVd4c09pTTRZVFF4T0RJN1ptbHNiQzF2Y0dGamFYUjVPakU3Wm1sc2JDMXlkV3hsT201dmJucGxjbTg3YzNSeWIydGxPbTV2Ym1VaUlDOCtQSEJoZEdnS0lDQWdJQ0FnSUNBZ0lDQWdJR1E5SW0wZ01qazRPQzR4T0N3NE1EQXVNalUwSUMwMk15NHlOaXd3SURBc01UQTBMalV5TnlBeE5qVXVNRFVzTUNBd0xDMDNNeTR6TlRVZ1l5QXpNUzR4T0N3MU1TNHpORGNnTnpndU9EWXNPRFV1TWpjM0lERTBNUzR5TVN3NE5TNHlOemNnTmpjdU9EVXNNQ0F4TWpRdU56RXNMVFF4TGpJMU9DQXhOVEl1TWpFc0xURXdNaTQyT1RrZ01qWXVOaXcyTWk0ek5URWdPVEl1TmpJc01UQXlMalk1T1NBeE5qQXVORGNzTVRBeUxqWTVPU0ExTXk0eE9Td3dJREV3TlM0ME5pd3RNaklnTVRReExqSXhMQzAyTWk0ek5URWdNemd1TlRJc0xUUTBMamt6T0NBek9DNDFNaXd0T1RNdU5UTXlJRE00TGpVeUxDMHhORGt1TkRVM0lHd2dNQ3d0TVRnMUxqSXpPU0EyTXk0eU55d3dJREFzTFRFd05DNDFNamNnTFRJek9DNDBNaXd3SURBc01UQTBMalV5TnlBMk15NHlPQ3d3SURBc01UVTNMamN4TlNCaklEQXNNekl1TVRBeUlEQXNOakF1TlRJM0lDMHhOQzQyTnl3NE9DNDVOVGNnTFRFNExqTTBMREkyTGpVNE1pQXRORGd1TmpFc05EQXVNelEwSUMwM09TNDNOeXcwTUM0ek5EUWdMVE13TGpJMkxEQWdMVFl6TGpJNExDMHhNaTQ0TkRRZ0xUZ3lMalV6TEMwek5pNDJOeklnTFRJeUxqa3pMQzB5T1M0ek5UVWdMVEl5TGprekxDMDFOaTQ0TmpNZ0xUSXlMamt6TEMwNU1pNDJNamtnYkNBd0xDMHhOVGN1TnpFMUlEWXpMakkzTERBZ01Dd3RNVEEwTGpVeU55QXRNak00TGpReExEQWdNQ3d4TURRdU5USTNJRFl6TGpJNExEQWdNQ3d4TlRBdU16Z3pJR01nTUN3eU9TNHpORGdnTUN3Mk5pNHdNak1nTFRFMExqWTNMRGt4TGpZNU9TQXRNVFV1TlRrc01qa3VNek0ySUMwME55NDJPU3cwTkM0NU16UWdMVGd3TGpjc05EUXVPVE0wSUMwek1TNHhPQ3d3SUMwMU55NDNOeXd0TVRFdU1EQTRJQzAzTnk0NU5Dd3RNelV1TnpjMElDMHlOQzQzTnl3dE16QXVNalV6SUMweU5pNDJMQzAyTWk0ek5ETWdMVEkyTGpZc0xUazVMamswTVNCc0lEQXNMVEUxTVM0ek1ERWdOak11TWpjc01DQXdMQzB4TURRdU5USTNJQzB5TXpndU5Dd3dJREFzTVRBMExqVXlOeUEyTXk0eU5pd3dJREFzTWpnd0xqVTVPQ0lLSUNBZ0lDQWdJQ0FnSUNBZ0lHbHVhM05qWVhCbE9tTnZibTVsWTNSdmNpMWpkWEoyWVhSMWNtVTlJakFpQ2lBZ0lDQWdJQ0FnSUNBZ0lDQnBaRDBpY0dGMGFESTRJZ29nSUNBZ0lDQWdJQ0FnSUNBZ2MzUjViR1U5SW1acGJHdzZJemhoTkRFNE1qdG1hV3hzTFc5d1lXTnBkSGs2TVR0bWFXeHNMWEoxYkdVNmJtOXVlbVZ5Ynp0emRISnZhMlU2Ym05dVpTSWdMejQ4Y0dGMGFBb2dJQ0FnSUNBZ0lDQWdJQ0FnWkQwaWJTQXpPVGs0TGpZMkxEazFNUzQxTkRjZ0xURXhNUzQ0Tnl3d0lEQXNNVEU0TGpJNU15QXhNVEV1T0Rjc01DQXdMQzB4TVRndU1qa3pJSG9nYlNBd0xDMDBNekV1T0RreElEWXpMakkzTERBZ01Dd3RNVEEwTGpVeU55QXRNak01TGpNekxEQWdNQ3d4TURRdU5USTNJRFkwTGpFNUxEQWdNQ3d5T0RBdU5UazRJQzAyTXk0eU55d3dJREFzTVRBMExqVXlOeUF4TnpVdU1UUXNNQ0F3TEMwek9EVXVNVEkxSWdvZ0lDQWdJQ0FnSUNBZ0lDQWdhVzVyYzJOaGNHVTZZMjl1Ym1WamRHOXlMV04xY25aaGRIVnlaVDBpTUNJS0lDQWdJQ0FnSUNBZ0lDQWdJR2xrUFNKd1lYUm9NekFpQ2lBZ0lDQWdJQ0FnSUNBZ0lDQnpkSGxzWlQwaVptbHNiRG9qT0dFME1UZ3lPMlpwYkd3dGIzQmhZMmwwZVRveE8yWnBiR3d0Y25Wc1pUcHViMjU2WlhKdk8zTjBjbTlyWlRwdWIyNWxJaUF2UGp4d1lYUm9DaUFnSUNBZ0lDQWdJQ0FnSUNCa1BTSnRJRFF4TlRrdU1USXNPREF3TGpJMU5DQXROak11TWpjc01DQXdMREV3TkM0MU1qY2dNVGMxTGpFMExEQWdNQ3d0TmprdU5qZzNJR01nTWprdU16VXNOVFF1TVRBeElEZzBMak0yTERnd0xqWTVPU0F4TkRRdU9EY3NPREF1TmprNUlEVXpMakU1TERBZ01UQTFMalExTEMweU1pNHdNVFlnTVRReExqSXlMQzAyTUM0MU1qY2dOREF1TXpRc0xUUTBMamt6TkNBME1TNHlOaXd0T0RndU1ETXlJRFF4TGpJMkxDMHhORE11T1RVM0lHd2dNQ3d0TVRreExqWTFNeUEyTXk0eU55d3dJREFzTFRFd05DNDFNamNnTFRJek9DNDBMREFnTUN3eE1EUXVOVEkzSURZekxqSTJMREFnTUN3eE5UZ3VOak0zSUdNZ01Dd3pNQzR5TmpJZ01DdzJNUzQwTXpRZ0xURTVMakkyTERnNExqQXpOU0F0TWpBdU1UY3NNall1TlRneUlDMDFNeTR4T0N3ek9TNDBNVFFnTFRnMkxqRTVMRE01TGpReE5DQXRNek11T1RNc01DQXROamd1Tnpjc0xURXpMamMxSUMwNE9DNDVOQ3d0TkRFdU1qVWdMVEl4TGpBNUxDMHlOeTQxSUMweU1TNHdPU3d0TmprdU5qZzNJQzB5TVM0d09Td3RNVEF5TGpjd055QnNJREFzTFRFME1pNHhNamtnTmpNdU1qWXNNQ0F3TEMweE1EUXVOVEkzSUMweU16Z3VOQ3d3SURBc01UQTBMalV5TnlBMk15NHlOeXd3SURBc01qZ3dMalU1T0NJS0lDQWdJQ0FnSUNBZ0lDQWdJR2x1YTNOallYQmxPbU52Ym01bFkzUnZjaTFqZFhKMllYUjFjbVU5SWpBaUNpQWdJQ0FnSUNBZ0lDQWdJQ0JwWkQwaWNHRjBhRE15SWdvZ0lDQWdJQ0FnSUNBZ0lDQWdjM1I1YkdVOUltWnBiR3c2SXpoaE5ERTRNanRtYVd4c0xXOXdZV05wZEhrNk1UdG1hV3hzTFhKMWJHVTZibTl1ZW1WeWJ6dHpkSEp2YTJVNmJtOXVaU0lnTHo0OGNHRjBhQW9nSUNBZ0lDQWdJQ0FnSUNBZ1pEMGliU0ExTURneUxqUTRMRGN3TXk0NU5qVWdZeUF0TVRrdU1qUXNOekF1TmpBMUlDMDRNUzQyTERFeE5TNDFORGNnTFRFMU5DNHdOQ3d4TVRVdU5UUTNJQzAyTmk0d05Dd3dJQzB4TWprdU15d3ROVEV1TXpRNElDMHhORE11TURVc0xURXhOUzQxTkRjZ2JDQXlPVGN1TURrc01DQjZJRzBnT0RVdU1qY3NMVEUwTkM0NE9ETWdZeUF0TXpndU5URXNMVGt6TGpVeU15QXRNVEk1TGpJM0xDMHhOVFl1TnpreklDMHlNekV1TURVc0xURTFOaTQzT1RNZ0xURTBNeTR3Tnl3d0lDMHlOVGN1Tmpnc01URXhMamczTVNBdE1qVTNMalk0TERJMU5TNDRNellnTUN3eE5EUXVPRGd6SURFd09TNHhNaXd5TmpFdU16STRJREkxTkM0NU1Td3lOakV1TXpJNElEWTNMamczTERBZ01UTTFMamN5TEMwek1DNHlOVGdnTVRnekxqTTVMQzAzT0M0NE5qTWdORGd1TmpJc0xUVXhMak0wTkNBMk9DNDNPU3d0TVRFekxqWTVOU0EyT0M0M09Td3RNVGd6TGpNNE15QnNJQzB6TGpZM0xDMHpPUzQwTXpRZ0xUTTVOaTR4TXl3d0lHTWdNVFF1Tmpjc0xUWTNMamcyTXlBM055NHdNeXd0TVRFM0xqTTJNeUF4TkRZdU56SXNMVEV4Tnk0ek5qTWdORGd1TlRrc01DQTVNQzQzTml3eE9DNHpNamdnTVRFNExqSTRMRFU0TGpZM01pQnNJREV4Tmk0ME5Dd3dJZ29nSUNBZ0lDQWdJQ0FnSUNBZ2FXNXJjMk5oY0dVNlkyOXVibVZqZEc5eUxXTjFjblpoZEhWeVpUMGlNQ0lLSUNBZ0lDQWdJQ0FnSUNBZ0lHbGtQU0p3WVhSb016UWlDaUFnSUNBZ0lDQWdJQ0FnSUNCemRIbHNaVDBpWm1sc2JEb2pPR0UwTVRneU8yWnBiR3d0YjNCaFkybDBlVG94TzJacGJHd3RjblZzWlRwdWIyNTZaWEp2TzNOMGNtOXJaVHB1YjI1bElpQXZQanh3WVhSb0NpQWdJQ0FnSUNBZ0lDQWdJQ0JrUFNKdElEWTVNQzQ0T1RVc09EVXdMamN3TXlBNU1DNDNOU3d3SURJeUxqVTBNeXd6TVM0d016VWdNQ3d5TkRNdU1USXlJQzB4TXpVdU9ESTVMREFnTUN3dE1qUXpMakUwTVNBeU1pNDFNellzTFRNeExqQXhOaUlLSUNBZ0lDQWdJQ0FnSUNBZ0lHbHVhM05qWVhCbE9tTnZibTVsWTNSdmNpMWpkWEoyWVhSMWNtVTlJakFpQ2lBZ0lDQWdJQ0FnSUNBZ0lDQnBaRDBpY0dGMGFETTJJZ29nSUNBZ0lDQWdJQ0FnSUNBZ2MzUjViR1U5SW1acGJHdzZJemhoTkRFNE1qdG1hV3hzTFc5d1lXTnBkSGs2TVR0bWFXeHNMWEoxYkdVNmJtOXVlbVZ5Ynp0emRISnZhMlU2Ym05dVpTSWdMejQ4Y0dGMGFBb2dJQ0FnSUNBZ0lDQWdJQ0FnWkQwaWJTQTJNekl1TXprMUxEYzBNaTR5TlRnZ01qZ3VNRE01TERnMkxqTXdOQ0F0TWpJdU5UVXhMRE14TGpBMElDMHlNekV1TWpJekxEYzFMakV5T0NBdE5ERXVPVGMyTEMweE1qa3VNVGd6SURJek1TNHlOVGNzTFRjMUxqRXpOeUF6Tmk0ME5UUXNNVEV1T0RRNElnb2dJQ0FnSUNBZ0lDQWdJQ0FnYVc1cmMyTmhjR1U2WTI5dWJtVmpkRzl5TFdOMWNuWmhkSFZ5WlQwaU1DSUtJQ0FnSUNBZ0lDQWdJQ0FnSUdsa1BTSndZWFJvTXpnaUNpQWdJQ0FnSUNBZ0lDQWdJQ0J6ZEhsc1pUMGlabWxzYkRvak9HRTBNVGd5TzJacGJHd3RiM0JoWTJsMGVUb3hPMlpwYkd3dGNuVnNaVHB1YjI1NlpYSnZPM04wY205clpUcHViMjVsSWlBdlBqeHdZWFJvQ2lBZ0lDQWdJQ0FnSUNBZ0lDQmtQU0p0SURjeE55NDBORGtzTmpVekxqRXdOU0F0TnpNdU5ERXNOVE11TXpZZ0xUTTJMalE0T0N3dE1URXVPRGMxSUMweE5ESXVPVEF6TEMweE9UWXVOamt5SURFd09TNDRPRE1zTFRjNUxqZ3lPQ0F4TkRJdU9URTRMREU1Tmk0M01ETWdNQ3d6T0M0ek16SWlDaUFnSUNBZ0lDQWdJQ0FnSUNCcGJtdHpZMkZ3WlRwamIyNXVaV04wYjNJdFkzVnlkbUYwZFhKbFBTSXdJZ29nSUNBZ0lDQWdJQ0FnSUNBZ2FXUTlJbkJoZEdnME1DSUtJQ0FnSUNBZ0lDQWdJQ0FnSUhOMGVXeGxQU0ptYVd4c09pTTRZVFF4T0RJN1ptbHNiQzF2Y0dGamFYUjVPakU3Wm1sc2JDMXlkV3hsT201dmJucGxjbTg3YzNSeWIydGxPbTV2Ym1VaUlDOCtQSEJoZEdnS0lDQWdJQ0FnSUNBZ0lDQWdJR1E5SW0wZ09ESTRMalV5TERjd05pNDBOalVnTFRjekxqUXlOaXd0TlRNdU16UWdNQzR3TVRFc0xUTTRMak0xT1NCTUlEZzVPQzR3TURRc05ERTRMakEzSURFd01EY3VPU3cwT1RjdU9EazRJRGcyTkM0NU56TXNOamswTGpZd09TQTRNamd1TlRJc056QTJMalEyTlNJS0lDQWdJQ0FnSUNBZ0lDQWdJR2x1YTNOallYQmxPbU52Ym01bFkzUnZjaTFqZFhKMllYUjFjbVU5SWpBaUNpQWdJQ0FnSUNBZ0lDQWdJQ0JwWkQwaWNHRjBhRFF5SWdvZ0lDQWdJQ0FnSUNBZ0lDQWdjM1I1YkdVOUltWnBiR3c2SXpoaE5ERTRNanRtYVd4c0xXOXdZV05wZEhrNk1UdG1hV3hzTFhKMWJHVTZibTl1ZW1WeWJ6dHpkSEp2YTJVNmJtOXVaU0lnTHo0OGNHRjBhQW9nSUNBZ0lDQWdJQ0FnSUNBZ1pEMGliU0E0TVRJdU1EZzJMRGd5T0M0MU9EWWdNamd1TURVMUxDMDROaTR6TWlBek5pNDBPRFFzTFRFeExqZ3pOaUF5TXpFdU1qSTFMRGMxTGpFeE55QXROREV1T1Rjc01USTVMakU0TXlBdE1qTXhMakl6T1N3dE56VXVNVFFnTFRJeUxqVTFOU3d0TXpFdU1EQTBJZ29nSUNBZ0lDQWdJQ0FnSUNBZ2FXNXJjMk5oY0dVNlkyOXVibVZqZEc5eUxXTjFjblpoZEhWeVpUMGlNQ0lLSUNBZ0lDQWdJQ0FnSUNBZ0lHbGtQU0p3WVhSb05EUWlDaUFnSUNBZ0lDQWdJQ0FnSUNCemRIbHNaVDBpWm1sc2JEb2pPR0UwTVRneU8yWnBiR3d0YjNCaFkybDBlVG94TzJacGJHd3RjblZzWlRwdWIyNTZaWEp2TzNOMGNtOXJaVHB1YjI1bElpQXZQanh3WVhSb0NpQWdJQ0FnSUNBZ0lDQWdJQ0JrUFNKdElEY3pOaTR6TURFc01UTXpOUzQ0T0NCaklDMHpNak11TURRM0xEQWdMVFU0TlM0NE56VXNMVEkyTWk0M09DQXROVGcxTGpnM05Td3ROVGcxTGpjNE1pQXdMQzB6TWpNdU1URTRJREkyTWk0NE1qZ3NMVFU0TlM0NU56Y2dOVGcxTGpnM05Td3ROVGcxTGprM055QXpNak11TURFNUxEQWdOVGcxTGpnd09Td3lOakl1T0RVNUlEVTROUzQ0TURrc05UZzFMamszTnlBd0xETXlNeTR3TURJZ0xUSTJNaTQzT1N3MU9EVXVOemd5SUMwMU9EVXVPREE1TERVNE5TNDNPRElnYkNBd0xEQWdlaUJ0SURBc0xURXhPQzQyTVNCaklESTFOeTQ1TnpJc01DQTBOamN1TVRnNUxDMHlNRGt1TVRNZ05EWTNMakU0T1N3dE5EWTNMakUzTWlBd0xDMHlOVGd1TVRJNUlDMHlNRGt1TWpFM0xDMDBOamN1TXpRNElDMDBOamN1TVRnNUxDMDBOamN1TXpRNElDMHlOVGd1TURjMExEQWdMVFEyTnk0eU5UUXNNakE1TGpJeE9TQXRORFkzTGpJMU5DdzBOamN1TXpRNElEQXNNalU0TGpBME1pQXlNRGt1TVRnc05EWTNMakUzTWlBME5qY3VNalUwTERRMk55NHhOeklpQ2lBZ0lDQWdJQ0FnSUNBZ0lDQnBibXR6WTJGd1pUcGpiMjV1WldOMGIzSXRZM1Z5ZG1GMGRYSmxQU0l3SWdvZ0lDQWdJQ0FnSUNBZ0lDQWdhV1E5SW5CaGRHZzBOaUlLSUNBZ0lDQWdJQ0FnSUNBZ0lITjBlV3hsUFNKbWFXeHNPaU00WVRReE9ESTdabWxzYkMxdmNHRmphWFI1T2pFN1ptbHNiQzF5ZFd4bE9tNXZibnBsY204N2MzUnliMnRsT201dmJtVWlJQzgrUEhCaGRHZ0tJQ0FnSUNBZ0lDQWdJQ0FnSUdROUltMGdNVEE1TVM0eE15dzJNVGt1T0RneklDMHhOelV1TnpjeExEVTNMakV5TVNBeE1TNDJNamtzTXpVdU9EQTRJREUzTlM0M05qSXNMVFUzTGpFeU1TQXRNVEV1TmpJc0xUTTFMamd3T0NJS0lDQWdJQ0FnSUNBZ0lDQWdJR2x1YTNOallYQmxPbU52Ym01bFkzUnZjaTFqZFhKMllYUjFjbVU5SWpBaUNpQWdJQ0FnSUNBZ0lDQWdJQ0JwWkQwaWNHRjBhRFE0SWdvZ0lDQWdJQ0FnSUNBZ0lDQWdjM1I1YkdVOUltWnBiR3c2SXpoaE5ERTRNanRtYVd4c0xXOXdZV05wZEhrNk1UdG1hV3hzTFhKMWJHVTZibTl1ZW1WeWJ6dHpkSEp2YTJVNmJtOXVaU0lnTHo0OGNHRjBhQW9nSUNBZ0lDQWdJQ0FnSUNBZ1pEMGlUU0E0TmpZdU9UVTNMRGt3TWk0d056UWdPRE0yTGpVc09USTBMakU1T1NBNU5EVXVNVEl4TERFd056TXVOek1nT1RjMUxqVTROaXd4TURVeExqWXhJRGcyTmk0NU5UY3NPVEF5TGpBM05DSUtJQ0FnSUNBZ0lDQWdJQ0FnSUdsdWEzTmpZWEJsT21OdmJtNWxZM1J2Y2kxamRYSjJZWFIxY21VOUlqQWlDaUFnSUNBZ0lDQWdJQ0FnSUNCcFpEMGljR0YwYURVd0lnb2dJQ0FnSUNBZ0lDQWdJQ0FnYzNSNWJHVTlJbVpwYkd3Nkl6aGhOREU0TWp0bWFXeHNMVzl3WVdOcGRIazZNVHRtYVd4c0xYSjFiR1U2Ym05dWVtVnlienR6ZEhKdmEyVTZibTl1WlNJZ0x6NDhjR0YwYUFvZ0lDQWdJQ0FnSUNBZ0lDQWdaRDBpVFNBMk1EY3VORFkxTERrd015NDBORFVnTkRrNExqZzFOU3d4TURVeUxqazNJRFV5T1M0ek1pd3hNRGMxTGpFZ05qTTNMamt6TERreU5TNDFOallnTmpBM0xqUTJOU3c1TURNdU5EUTFJZ29nSUNBZ0lDQWdJQ0FnSUNBZ2FXNXJjMk5oY0dVNlkyOXVibVZqZEc5eUxXTjFjblpoZEhWeVpUMGlNQ0lLSUNBZ0lDQWdJQ0FnSUNBZ0lHbGtQU0p3WVhSb05USWlDaUFnSUNBZ0lDQWdJQ0FnSUNCemRIbHNaVDBpWm1sc2JEb2pPR0UwTVRneU8yWnBiR3d0YjNCaFkybDBlVG94TzJacGJHd3RjblZzWlRwdWIyNTZaWEp2TzNOMGNtOXJaVHB1YjI1bElpQXZQanh3WVhSb0NpQWdJQ0FnSUNBZ0lDQWdJQ0JrUFNKdElETTRNQzQyT0Rnc05qSXlMakV5T1NBdE1URXVOakkyTERNMUxqZ3dNU0F4TnpVdU56VTRMRFUzTGpBNUlERXhMall5TVN3dE16VXVPREF4SUMweE56VXVOelV6TEMwMU55NHdPU0lLSUNBZ0lDQWdJQ0FnSUNBZ0lHbHVhM05qWVhCbE9tTnZibTVsWTNSdmNpMWpkWEoyWVhSMWNtVTlJakFpQ2lBZ0lDQWdJQ0FnSUNBZ0lDQnBaRDBpY0dGMGFEVTBJZ29nSUNBZ0lDQWdJQ0FnSUNBZ2MzUjViR1U5SW1acGJHdzZJemhoTkRFNE1qdG1hV3hzTFc5d1lXTnBkSGs2TVR0bWFXeHNMWEoxYkdVNmJtOXVlbVZ5Ynp0emRISnZhMlU2Ym05dVpTSWdMejQ4Y0dGMGFBb2dJQ0FnSUNBZ0lDQWdJQ0FnWkQwaWJTQTNNVFl1TWpnNUxETTNOaTQxT1NBek55NDJOREEyTERBZ01Dd3hPRFF1T0RFMklDMHpOeTQyTkRBMkxEQWdNQ3d0TVRnMExqZ3hOaUI2SWdvZ0lDQWdJQ0FnSUNBZ0lDQWdhVzVyYzJOaGNHVTZZMjl1Ym1WamRHOXlMV04xY25aaGRIVnlaVDBpTUNJS0lDQWdJQ0FnSUNBZ0lDQWdJR2xrUFNKd1lYUm9OVFlpQ2lBZ0lDQWdJQ0FnSUNBZ0lDQnpkSGxzWlQwaVptbHNiRG9qT0dFME1UZ3lPMlpwYkd3dGIzQmhZMmwwZVRveE8yWnBiR3d0Y25Wc1pUcHViMjU2WlhKdk8zTjBjbTlyWlRwdWIyNWxJaUF2UGp3dlp6NDhMMmMrUEM5blBqd3ZaejQ4TDNOMlp6ND0nKSBuby1yZXBlYXQsIG5vbmU7IC1tb3otYmFja2dyb3VuZC1zaXplOiAxMDAlOyAtby1iYWNrZ3JvdW5kLXNpemU6IDEwMCU7IC13ZWJraXQtYmFja2dyb3VuZC1zaXplOiAxMDAlOyBiYWNrZ3JvdW5kLXNpemU6IDEwMCU7IGRpc3BsYXk6IGJsb2NrOyBmbG9hdDogbGVmdDsgd2lkdGg6IDkwcHg7IGhlaWdodDogMjVweDsgfVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtYmFubmVyIC5qYXNtaW5lLXZlcnNpb24geyBtYXJnaW4tbGVmdDogMTRweDsgcG9zaXRpb246IHJlbGF0aXZlOyB0b3A6IDZweDsgfVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgI2phc21pbmVfY29udGVudCB7IHBvc2l0aW9uOiBmaXhlZDsgcmlnaHQ6IDEwMCU7IH1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXZlcnNpb24geyBjb2xvcjogI2FhYTsgfVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtYmFubmVyIHsgbWFyZ2luLXRvcDogMTRweDsgfVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtZHVyYXRpb24geyBjb2xvcjogI2ZmZjsgZmxvYXQ6IHJpZ2h0OyBsaW5lLWhlaWdodDogMjhweDsgcGFkZGluZy1yaWdodDogOXB4OyB9XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zeW1ib2wtc3VtbWFyeSB7IG92ZXJmbG93OiBoaWRkZW47ICp6b29tOiAxOyBtYXJnaW46IDE0cHggMDsgfVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3ltYm9sLXN1bW1hcnkgbGkgeyBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IGhlaWdodDogMTBweDsgd2lkdGg6IDE0cHg7IGZvbnQtc2l6ZTogMTZweDsgfVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3ltYm9sLXN1bW1hcnkgbGkuamFzbWluZS1wYXNzZWQgeyBmb250LXNpemU6IDE0cHg7IH1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN5bWJvbC1zdW1tYXJ5IGxpLmphc21pbmUtcGFzc2VkOmJlZm9yZSB7IGNvbG9yOiAjMDA3MDY5OyBjb250ZW50OiBcXFwiXFxcXDIwMjJcXFwiOyB9XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zeW1ib2wtc3VtbWFyeSBsaS5qYXNtaW5lLWZhaWxlZCB7IGxpbmUtaGVpZ2h0OiA5cHg7IH1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN5bWJvbC1zdW1tYXJ5IGxpLmphc21pbmUtZmFpbGVkOmJlZm9yZSB7IGNvbG9yOiAjY2EzYTExOyBjb250ZW50OiBcXFwiXFxcXEQ3XFxcIjsgZm9udC13ZWlnaHQ6IGJvbGQ7IG1hcmdpbi1sZWZ0OiAtMXB4OyB9XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zeW1ib2wtc3VtbWFyeSBsaS5qYXNtaW5lLWRpc2FibGVkIHsgZm9udC1zaXplOiAxNHB4OyB9XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zeW1ib2wtc3VtbWFyeSBsaS5qYXNtaW5lLWRpc2FibGVkOmJlZm9yZSB7IGNvbG9yOiAjYmFiYWJhOyBjb250ZW50OiBcXFwiXFxcXDIwMjJcXFwiOyB9XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zeW1ib2wtc3VtbWFyeSBsaS5qYXNtaW5lLXBlbmRpbmcgeyBsaW5lLWhlaWdodDogMTdweDsgfVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3ltYm9sLXN1bW1hcnkgbGkuamFzbWluZS1wZW5kaW5nOmJlZm9yZSB7IGNvbG9yOiAjYmE5ZDM3OyBjb250ZW50OiBcXFwiKlxcXCI7IH1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN5bWJvbC1zdW1tYXJ5IGxpLmphc21pbmUtZW1wdHkgeyBmb250LXNpemU6IDE0cHg7IH1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN5bWJvbC1zdW1tYXJ5IGxpLmphc21pbmUtZW1wdHk6YmVmb3JlIHsgY29sb3I6ICNiYTlkMzc7IGNvbnRlbnQ6IFxcXCJcXFxcMjAyMlxcXCI7IH1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXJ1bi1vcHRpb25zIHsgZmxvYXQ6IHJpZ2h0OyBtYXJnaW4tcmlnaHQ6IDVweDsgYm9yZGVyOiAxcHggc29saWQgIzhhNDE4MjsgY29sb3I6ICM4YTQxODI7IHBvc2l0aW9uOiByZWxhdGl2ZTsgbGluZS1oZWlnaHQ6IDIwcHg7IH1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXJ1bi1vcHRpb25zIC5qYXNtaW5lLXRyaWdnZXIgeyBjdXJzb3I6IHBvaW50ZXI7IHBhZGRpbmc6IDhweCAxNnB4OyB9XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1ydW4tb3B0aW9ucyAuamFzbWluZS1wYXlsb2FkIHsgcG9zaXRpb246IGFic29sdXRlOyBkaXNwbGF5OiBub25lOyByaWdodDogLTFweDsgYm9yZGVyOiAxcHggc29saWQgIzhhNDE4MjsgYmFja2dyb3VuZC1jb2xvcjogI2VlZTsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgcGFkZGluZzogNHB4IDhweDsgfVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtcnVuLW9wdGlvbnMgLmphc21pbmUtcGF5bG9hZC5qYXNtaW5lLW9wZW4geyBkaXNwbGF5OiBibG9jazsgfVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtYmFyIHsgbGluZS1oZWlnaHQ6IDI4cHg7IGZvbnQtc2l6ZTogMTRweDsgZGlzcGxheTogYmxvY2s7IGNvbG9yOiAjZWVlOyB9XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1iYXIuamFzbWluZS1mYWlsZWQgeyBiYWNrZ3JvdW5kLWNvbG9yOiAjY2EzYTExOyB9XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1iYXIuamFzbWluZS1wYXNzZWQgeyBiYWNrZ3JvdW5kLWNvbG9yOiAjMDA3MDY5OyB9XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1iYXIuamFzbWluZS1za2lwcGVkIHsgYmFja2dyb3VuZC1jb2xvcjogI2JhYmFiYTsgfVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtYmFyLmphc21pbmUtZXJyb3JlZCB7IGJhY2tncm91bmQtY29sb3I6ICNjYTNhMTE7IH1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWJhci5qYXNtaW5lLW1lbnUgeyBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmOyBjb2xvcjogI2FhYTsgfVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtYmFyLmphc21pbmUtbWVudSBhIHsgY29sb3I6ICMzMzM7IH1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWJhciBhIHsgY29sb3I6IHdoaXRlOyB9XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlci5qYXNtaW5lLXNwZWMtbGlzdCAuamFzbWluZS1iYXIuamFzbWluZS1tZW51Lmphc21pbmUtZmFpbHVyZS1saXN0LCAuamFzbWluZV9odG1sLXJlcG9ydGVyLmphc21pbmUtc3BlYy1saXN0IC5qYXNtaW5lLXJlc3VsdHMgLmphc21pbmUtZmFpbHVyZXMgeyBkaXNwbGF5OiBub25lOyB9XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlci5qYXNtaW5lLWZhaWx1cmUtbGlzdCAuamFzbWluZS1iYXIuamFzbWluZS1tZW51Lmphc21pbmUtc3BlYy1saXN0LCAuamFzbWluZV9odG1sLXJlcG9ydGVyLmphc21pbmUtZmFpbHVyZS1saXN0IC5qYXNtaW5lLXN1bW1hcnkgeyBkaXNwbGF5OiBub25lOyB9XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1yZXN1bHRzIHsgbWFyZ2luLXRvcDogMTRweDsgfVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3VtbWFyeSB7IG1hcmdpbi10b3A6IDE0cHg7IH1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN1bW1hcnkgdWwgeyBsaXN0LXN0eWxlLXR5cGU6IG5vbmU7IG1hcmdpbi1sZWZ0OiAxNHB4OyBwYWRkaW5nLXRvcDogMDsgcGFkZGluZy1sZWZ0OiAwOyB9XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zdW1tYXJ5IHVsLmphc21pbmUtc3VpdGUgeyBtYXJnaW4tdG9wOiA3cHg7IG1hcmdpbi1ib3R0b206IDdweDsgfVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtc3VtbWFyeSBsaS5qYXNtaW5lLXBhc3NlZCBhIHsgY29sb3I6ICMwMDcwNjk7IH1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN1bW1hcnkgbGkuamFzbWluZS1mYWlsZWQgYSB7IGNvbG9yOiAjY2EzYTExOyB9XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zdW1tYXJ5IGxpLmphc21pbmUtZW1wdHkgYSB7IGNvbG9yOiAjYmE5ZDM3OyB9XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zdW1tYXJ5IGxpLmphc21pbmUtcGVuZGluZyBhIHsgY29sb3I6ICNiYTlkMzc7IH1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN1bW1hcnkgbGkuamFzbWluZS1kaXNhYmxlZCBhIHsgY29sb3I6ICNiYWJhYmE7IH1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWRlc2NyaXB0aW9uICsgLmphc21pbmUtc3VpdGUgeyBtYXJnaW4tdG9wOiAwOyB9XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1zdWl0ZSB7IG1hcmdpbi10b3A6IDE0cHg7IH1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN1aXRlIGEgeyBjb2xvcjogIzMzMzsgfVxcbi5qYXNtaW5lX2h0bWwtcmVwb3J0ZXIgLmphc21pbmUtZmFpbHVyZXMgLmphc21pbmUtc3BlYy1kZXRhaWwgeyBtYXJnaW4tYm90dG9tOiAyOHB4OyB9XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1mYWlsdXJlcyAuamFzbWluZS1zcGVjLWRldGFpbCAuamFzbWluZS1kZXNjcmlwdGlvbiB7IGJhY2tncm91bmQtY29sb3I6ICNjYTNhMTE7IH1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLWZhaWx1cmVzIC5qYXNtaW5lLXNwZWMtZGV0YWlsIC5qYXNtaW5lLWRlc2NyaXB0aW9uIGEgeyBjb2xvcjogd2hpdGU7IH1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXJlc3VsdC1tZXNzYWdlIHsgcGFkZGluZy10b3A6IDE0cHg7IGNvbG9yOiAjMzMzOyB3aGl0ZS1zcGFjZTogcHJlOyB9XFxuLmphc21pbmVfaHRtbC1yZXBvcnRlciAuamFzbWluZS1yZXN1bHQtbWVzc2FnZSBzcGFuLmphc21pbmUtcmVzdWx0IHsgZGlzcGxheTogYmxvY2s7IH1cXG4uamFzbWluZV9odG1sLXJlcG9ydGVyIC5qYXNtaW5lLXN0YWNrLXRyYWNlIHsgbWFyZ2luOiA1cHggMCAwIDA7IG1heC1oZWlnaHQ6IDIyNHB4OyBvdmVyZmxvdzogYXV0bzsgbGluZS1oZWlnaHQ6IDE4cHg7IGNvbG9yOiAjNjY2OyBib3JkZXI6IDFweCBzb2xpZCAjZGRkOyBiYWNrZ3JvdW5kOiB3aGl0ZTsgd2hpdGUtc3BhY2U6IHByZTsgfVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL2hvbWUvc2NvdHQvd29yay9hc3VyaW9uL3JldGFpbGVycG9ydGFsL2NsaWVudC9+L2Nzcy1sb2FkZXIhLi9zcmMvbGliL2phc21pbmUtMi40LjEvamFzbWluZS5jc3NcbiAqKiBtb2R1bGUgaWQgPSAyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBsaXN0ID0gW107XHJcblxyXG5cdC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcclxuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XHJcblx0XHR2YXIgcmVzdWx0ID0gW107XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaXRlbSA9IHRoaXNbaV07XHJcblx0XHRcdGlmKGl0ZW1bMl0pIHtcclxuXHRcdFx0XHRyZXN1bHQucHVzaChcIkBtZWRpYSBcIiArIGl0ZW1bMl0gKyBcIntcIiArIGl0ZW1bMV0gKyBcIn1cIik7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cmVzdWx0LnB1c2goaXRlbVsxXSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiByZXN1bHQuam9pbihcIlwiKTtcclxuXHR9O1xyXG5cclxuXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxyXG5cdGxpc3QuaSA9IGZ1bmN0aW9uKG1vZHVsZXMsIG1lZGlhUXVlcnkpIHtcclxuXHRcdGlmKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKVxyXG5cdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XHJcblx0XHR2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcclxuXHRcdFx0aWYodHlwZW9mIGlkID09PSBcIm51bWJlclwiKVxyXG5cdFx0XHRcdGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcclxuXHRcdH1cclxuXHRcdGZvcihpID0gMDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGl0ZW0gPSBtb2R1bGVzW2ldO1xyXG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXHJcblx0XHRcdC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgbm90IDEwMCUgcGVyZmVjdCBmb3Igd2VpcmQgbWVkaWEgcXVlcnkgY29tYmluYXRpb25zXHJcblx0XHRcdC8vICB3aGVuIGEgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG1lZGlhIHF1ZXJpZXMuXHJcblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXHJcblx0XHRcdGlmKHR5cGVvZiBpdGVtWzBdICE9PSBcIm51bWJlclwiIHx8ICFhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XHJcblx0XHRcdFx0aWYobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xyXG5cdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XHJcblx0XHRcdFx0fSBlbHNlIGlmKG1lZGlhUXVlcnkpIHtcclxuXHRcdFx0XHRcdGl0ZW1bMl0gPSBcIihcIiArIGl0ZW1bMl0gKyBcIikgYW5kIChcIiArIG1lZGlhUXVlcnkgKyBcIilcIjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0bGlzdC5wdXNoKGl0ZW0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fTtcclxuXHRyZXR1cm4gbGlzdDtcclxufTtcclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvaG9tZS9zY290dC93b3JrL2FzdXJpb24vcmV0YWlsZXJwb3J0YWwvY2xpZW50L34vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcbiAqKiBtb2R1bGUgaWQgPSAzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgc3R5bGVzSW5Eb20gPSB7fSxcclxuXHRtZW1vaXplID0gZnVuY3Rpb24oZm4pIHtcclxuXHRcdHZhciBtZW1vO1xyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0aWYgKHR5cGVvZiBtZW1vID09PSBcInVuZGVmaW5lZFwiKSBtZW1vID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHRcdFx0cmV0dXJuIG1lbW87XHJcblx0XHR9O1xyXG5cdH0sXHJcblx0aXNPbGRJRSA9IG1lbW9pemUoZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gL21zaWUgWzYtOV1cXGIvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSk7XHJcblx0fSksXHJcblx0Z2V0SGVhZEVsZW1lbnQgPSBtZW1vaXplKGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXTtcclxuXHR9KSxcclxuXHRzaW5nbGV0b25FbGVtZW50ID0gbnVsbCxcclxuXHRzaW5nbGV0b25Db3VudGVyID0gMCxcclxuXHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcCA9IFtdO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsaXN0LCBvcHRpb25zKSB7XHJcblx0aWYodHlwZW9mIERFQlVHICE9PSBcInVuZGVmaW5lZFwiICYmIERFQlVHKSB7XHJcblx0XHRpZih0eXBlb2YgZG9jdW1lbnQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudFwiKTtcclxuXHR9XHJcblxyXG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cdC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxyXG5cdC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2VcclxuXHRpZiAodHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uID09PSBcInVuZGVmaW5lZFwiKSBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcclxuXHJcblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgYm90dG9tIG9mIDxoZWFkPi5cclxuXHRpZiAodHlwZW9mIG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidW5kZWZpbmVkXCIpIG9wdGlvbnMuaW5zZXJ0QXQgPSBcImJvdHRvbVwiO1xyXG5cclxuXHR2YXIgc3R5bGVzID0gbGlzdFRvU3R5bGVzKGxpc3QpO1xyXG5cdGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucyk7XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkge1xyXG5cdFx0dmFyIG1heVJlbW92ZSA9IFtdO1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcclxuXHRcdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XHJcblx0XHRcdGRvbVN0eWxlLnJlZnMtLTtcclxuXHRcdFx0bWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpO1xyXG5cdFx0fVxyXG5cdFx0aWYobmV3TGlzdCkge1xyXG5cdFx0XHR2YXIgbmV3U3R5bGVzID0gbGlzdFRvU3R5bGVzKG5ld0xpc3QpO1xyXG5cdFx0XHRhZGRTdHlsZXNUb0RvbShuZXdTdHlsZXMsIG9wdGlvbnMpO1xyXG5cdFx0fVxyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV07XHJcblx0XHRcdGlmKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcclxuXHRcdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspXHJcblx0XHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXSgpO1xyXG5cdFx0XHRcdGRlbGV0ZSBzdHlsZXNJbkRvbVtkb21TdHlsZS5pZF07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpIHtcclxuXHRmb3IodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcclxuXHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xyXG5cdFx0aWYoZG9tU3R5bGUpIHtcclxuXHRcdFx0ZG9tU3R5bGUucmVmcysrO1xyXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRmb3IoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR2YXIgcGFydHMgPSBbXTtcclxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0XHRwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRzdHlsZXNJbkRvbVtpdGVtLmlkXSA9IHtpZDogaXRlbS5pZCwgcmVmczogMSwgcGFydHM6IHBhcnRzfTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyhsaXN0KSB7XHJcblx0dmFyIHN0eWxlcyA9IFtdO1xyXG5cdHZhciBuZXdTdHlsZXMgPSB7fTtcclxuXHRmb3IodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xyXG5cdFx0dmFyIGl0ZW0gPSBsaXN0W2ldO1xyXG5cdFx0dmFyIGlkID0gaXRlbVswXTtcclxuXHRcdHZhciBjc3MgPSBpdGVtWzFdO1xyXG5cdFx0dmFyIG1lZGlhID0gaXRlbVsyXTtcclxuXHRcdHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdO1xyXG5cdFx0dmFyIHBhcnQgPSB7Y3NzOiBjc3MsIG1lZGlhOiBtZWRpYSwgc291cmNlTWFwOiBzb3VyY2VNYXB9O1xyXG5cdFx0aWYoIW5ld1N0eWxlc1tpZF0pXHJcblx0XHRcdHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7aWQ6IGlkLCBwYXJ0czogW3BhcnRdfSk7XHJcblx0XHRlbHNlXHJcblx0XHRcdG5ld1N0eWxlc1tpZF0ucGFydHMucHVzaChwYXJ0KTtcclxuXHR9XHJcblx0cmV0dXJuIHN0eWxlcztcclxufVxyXG5cclxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlRWxlbWVudCkge1xyXG5cdHZhciBoZWFkID0gZ2V0SGVhZEVsZW1lbnQoKTtcclxuXHR2YXIgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AgPSBzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcFtzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5sZW5ndGggLSAxXTtcclxuXHRpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJ0b3BcIikge1xyXG5cdFx0aWYoIWxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wKSB7XHJcblx0XHRcdGhlYWQuaW5zZXJ0QmVmb3JlKHN0eWxlRWxlbWVudCwgaGVhZC5maXJzdENoaWxkKTtcclxuXHRcdH0gZWxzZSBpZihsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZykge1xyXG5cdFx0XHRoZWFkLmluc2VydEJlZm9yZShzdHlsZUVsZW1lbnQsIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KTtcclxuXHRcdH1cclxuXHRcdHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLnB1c2goc3R5bGVFbGVtZW50KTtcclxuXHR9IGVsc2UgaWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwiYm90dG9tXCIpIHtcclxuXHRcdGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyICdpbnNlcnRBdCcuIE11c3QgYmUgJ3RvcCcgb3IgJ2JvdHRvbScuXCIpO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCkge1xyXG5cdHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudCk7XHJcblx0dmFyIGlkeCA9IHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLmluZGV4T2Yoc3R5bGVFbGVtZW50KTtcclxuXHRpZihpZHggPj0gMCkge1xyXG5cdFx0c3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3Auc3BsaWNlKGlkeCwgMSk7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykge1xyXG5cdHZhciBzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XHJcblx0c3R5bGVFbGVtZW50LnR5cGUgPSBcInRleHQvY3NzXCI7XHJcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlRWxlbWVudCk7XHJcblx0cmV0dXJuIHN0eWxlRWxlbWVudDtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlTGlua0VsZW1lbnQob3B0aW9ucykge1xyXG5cdHZhciBsaW5rRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xyXG5cdGxpbmtFbGVtZW50LnJlbCA9IFwic3R5bGVzaGVldFwiO1xyXG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBsaW5rRWxlbWVudCk7XHJcblx0cmV0dXJuIGxpbmtFbGVtZW50O1xyXG59XHJcblxyXG5mdW5jdGlvbiBhZGRTdHlsZShvYmosIG9wdGlvbnMpIHtcclxuXHR2YXIgc3R5bGVFbGVtZW50LCB1cGRhdGUsIHJlbW92ZTtcclxuXHJcblx0aWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XHJcblx0XHR2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcclxuXHRcdHN0eWxlRWxlbWVudCA9IHNpbmdsZXRvbkVsZW1lbnQgfHwgKHNpbmdsZXRvbkVsZW1lbnQgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xyXG5cdFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgZmFsc2UpO1xyXG5cdFx0cmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgdHJ1ZSk7XHJcblx0fSBlbHNlIGlmKG9iai5zb3VyY2VNYXAgJiZcclxuXHRcdHR5cGVvZiBVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxyXG5cdFx0dHlwZW9mIFVSTC5jcmVhdGVPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxyXG5cdFx0dHlwZW9mIFVSTC5yZXZva2VPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxyXG5cdFx0dHlwZW9mIEJsb2IgPT09IFwiZnVuY3Rpb25cIiAmJlxyXG5cdFx0dHlwZW9mIGJ0b2EgPT09IFwiZnVuY3Rpb25cIikge1xyXG5cdFx0c3R5bGVFbGVtZW50ID0gY3JlYXRlTGlua0VsZW1lbnQob3B0aW9ucyk7XHJcblx0XHR1cGRhdGUgPSB1cGRhdGVMaW5rLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50KTtcclxuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KTtcclxuXHRcdFx0aWYoc3R5bGVFbGVtZW50LmhyZWYpXHJcblx0XHRcdFx0VVJMLnJldm9rZU9iamVjdFVSTChzdHlsZUVsZW1lbnQuaHJlZik7XHJcblx0XHR9O1xyXG5cdH0gZWxzZSB7XHJcblx0XHRzdHlsZUVsZW1lbnQgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucyk7XHJcblx0XHR1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50KTtcclxuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KTtcclxuXHRcdH07XHJcblx0fVxyXG5cclxuXHR1cGRhdGUob2JqKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKG5ld09iaikge1xyXG5cdFx0aWYobmV3T2JqKSB7XHJcblx0XHRcdGlmKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiYgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiYgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcClcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdHVwZGF0ZShvYmogPSBuZXdPYmopO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmVtb3ZlKCk7XHJcblx0XHR9XHJcblx0fTtcclxufVxyXG5cclxudmFyIHJlcGxhY2VUZXh0ID0gKGZ1bmN0aW9uICgpIHtcclxuXHR2YXIgdGV4dFN0b3JlID0gW107XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2VtZW50KSB7XHJcblx0XHR0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XHJcblx0XHRyZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcclxuXHR9O1xyXG59KSgpO1xyXG5cclxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyhzdHlsZUVsZW1lbnQsIGluZGV4LCByZW1vdmUsIG9iaikge1xyXG5cdHZhciBjc3MgPSByZW1vdmUgPyBcIlwiIDogb2JqLmNzcztcclxuXHJcblx0aWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XHJcblx0XHRzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcclxuXHRcdHZhciBjaGlsZE5vZGVzID0gc3R5bGVFbGVtZW50LmNoaWxkTm9kZXM7XHJcblx0XHRpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7XHJcblx0XHRpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcclxuXHRcdFx0c3R5bGVFbGVtZW50Lmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBhcHBseVRvVGFnKHN0eWxlRWxlbWVudCwgb2JqKSB7XHJcblx0dmFyIGNzcyA9IG9iai5jc3M7XHJcblx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xyXG5cdHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xyXG5cclxuXHRpZihtZWRpYSkge1xyXG5cdFx0c3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsIG1lZGlhKVxyXG5cdH1cclxuXHJcblx0aWYoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcclxuXHRcdHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XHJcblx0fSBlbHNlIHtcclxuXHRcdHdoaWxlKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKSB7XHJcblx0XHRcdHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCk7XHJcblx0XHR9XHJcblx0XHRzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiB1cGRhdGVMaW5rKGxpbmtFbGVtZW50LCBvYmopIHtcclxuXHR2YXIgY3NzID0gb2JqLmNzcztcclxuXHR2YXIgbWVkaWEgPSBvYmoubWVkaWE7XHJcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XHJcblxyXG5cdGlmKHNvdXJjZU1hcCkge1xyXG5cdFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcclxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcclxuXHR9XHJcblxyXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xyXG5cclxuXHR2YXIgb2xkU3JjID0gbGlua0VsZW1lbnQuaHJlZjtcclxuXHJcblx0bGlua0VsZW1lbnQuaHJlZiA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XHJcblxyXG5cdGlmKG9sZFNyYylcclxuXHRcdFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcclxufVxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9ob21lL3Njb3R0L3dvcmsvYXN1cmlvbi9yZXRhaWxlcnBvcnRhbC9jbGllbnQvfi9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXG4gKiogbW9kdWxlIGlkID0gNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgamFzbWluZS5hZGRNYXRjaGVycyh7XG4gICAgICAgIHRvSGF2ZUxlbmd0aDogbWFrZU1hdGNoZXJGYWN0b3J5KGFjdHVhbCA9PiBhY3R1YWwubGVuZ3RoKVxuICAgIH0pO1xufSk7XG5cblxuZnVuY3Rpb24gbWFrZU1hdGNoZXJGYWN0b3J5KGZuKSB7XG4gICAgcmV0dXJuICh1dGlsLCBjdXN0b21FcXVhbGl0eVRlc3RlcnMpID0+ICh7XG4gICAgICAgIGNvbXBhcmU6IChhY3R1YWwsIGV4cGVjdGVkKSA9PiAoe3Bhc3M6IHV0aWwuZXF1YWxzKGZuKGFjdHVhbCksIGV4cGVjdGVkLCBjdXN0b21FcXVhbGl0eVRlc3RlcnMpfSlcbiAgICB9KTtcbn1cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9tYXRjaGVycy5qc1xuICoqLyIsIi8qIVxuICogaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltXG4gKiBAbGljZW5zZSBlczUtc2hpbSBDb3B5cmlnaHQgMjAwOS0yMDE1IGJ5IGNvbnRyaWJ1dG9ycywgTUlUIExpY2Vuc2VcbiAqIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0vYmxvYi9tYXN0ZXIvTElDRU5TRVxuICovXG5cbi8vIHZpbTogdHM9NCBzdHM9NCBzdz00IGV4cGFuZHRhYlxuXG4vLyBBZGQgc2VtaWNvbG9uIHRvIHByZXZlbnQgSUlGRSBmcm9tIGJlaW5nIHBhc3NlZCBhcyBhcmd1bWVudCB0byBjb25jYXRlbmF0ZWQgY29kZS5cbjtcblxuLy8gVU1EIChVbml2ZXJzYWwgTW9kdWxlIERlZmluaXRpb24pXG4vLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3VtZGpzL3VtZC9ibG9iL21hc3Rlci9yZXR1cm5FeHBvcnRzLmpzXG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvKiBnbG9iYWwgZGVmaW5lLCBleHBvcnRzLCBtb2R1bGUgKi9cbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cbiAgICAgICAgZGVmaW5lKGZhY3RvcnkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIE5vZGUuIERvZXMgbm90IHdvcmsgd2l0aCBzdHJpY3QgQ29tbW9uSlMsIGJ1dFxuICAgICAgICAvLyBvbmx5IENvbW1vbkpTLWxpa2UgZW52aXJvbWVudHMgdGhhdCBzdXBwb3J0IG1vZHVsZS5leHBvcnRzLFxuICAgICAgICAvLyBsaWtlIE5vZGUuXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEJyb3dzZXIgZ2xvYmFscyAocm9vdCBpcyB3aW5kb3cpXG4gICAgICAgIHJvb3QucmV0dXJuRXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcblxuLyoqXG4gKiBCcmluZ3MgYW4gZW52aXJvbm1lbnQgYXMgY2xvc2UgdG8gRUNNQVNjcmlwdCA1IGNvbXBsaWFuY2VcbiAqIGFzIGlzIHBvc3NpYmxlIHdpdGggdGhlIGZhY2lsaXRpZXMgb2YgZXJzdHdoaWxlIGVuZ2luZXMuXG4gKlxuICogQW5ub3RhdGVkIEVTNTogaHR0cDovL2VzNS5naXRodWIuY29tLyAoc3BlY2lmaWMgbGlua3MgYmVsb3cpXG4gKiBFUzUgU3BlYzogaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL3B1YmxpY2F0aW9ucy9maWxlcy9FQ01BLVNUL0VjbWEtMjYyLnBkZlxuICogUmVxdWlyZWQgcmVhZGluZzogaHR0cDovL2phdmFzY3JpcHR3ZWJsb2cud29yZHByZXNzLmNvbS8yMDExLzEyLzA1L2V4dGVuZGluZy1qYXZhc2NyaXB0LW5hdGl2ZXMvXG4gKi9cblxuLy8gU2hvcnRjdXQgdG8gYW4gb2Z0ZW4gYWNjZXNzZWQgcHJvcGVydGllcywgaW4gb3JkZXIgdG8gYXZvaWQgbXVsdGlwbGVcbi8vIGRlcmVmZXJlbmNlIHRoYXQgY29zdHMgdW5pdmVyc2FsbHkuIFRoaXMgYWxzbyBob2xkcyBhIHJlZmVyZW5jZSB0byBrbm93bi1nb29kXG4vLyBmdW5jdGlvbnMuXG52YXIgJEFycmF5ID0gQXJyYXk7XG52YXIgQXJyYXlQcm90b3R5cGUgPSAkQXJyYXkucHJvdG90eXBlO1xudmFyICRPYmplY3QgPSBPYmplY3Q7XG52YXIgT2JqZWN0UHJvdG90eXBlID0gJE9iamVjdC5wcm90b3R5cGU7XG52YXIgRnVuY3Rpb25Qcm90b3R5cGUgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG52YXIgJFN0cmluZyA9IFN0cmluZztcbnZhciBTdHJpbmdQcm90b3R5cGUgPSAkU3RyaW5nLnByb3RvdHlwZTtcbnZhciAkTnVtYmVyID0gTnVtYmVyO1xudmFyIE51bWJlclByb3RvdHlwZSA9ICROdW1iZXIucHJvdG90eXBlO1xudmFyIGFycmF5X3NsaWNlID0gQXJyYXlQcm90b3R5cGUuc2xpY2U7XG52YXIgYXJyYXlfc3BsaWNlID0gQXJyYXlQcm90b3R5cGUuc3BsaWNlO1xudmFyIGFycmF5X3B1c2ggPSBBcnJheVByb3RvdHlwZS5wdXNoO1xudmFyIGFycmF5X3Vuc2hpZnQgPSBBcnJheVByb3RvdHlwZS51bnNoaWZ0O1xudmFyIGFycmF5X2NvbmNhdCA9IEFycmF5UHJvdG90eXBlLmNvbmNhdDtcbnZhciBjYWxsID0gRnVuY3Rpb25Qcm90b3R5cGUuY2FsbDtcbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcblxuLy8gSGF2aW5nIGEgdG9TdHJpbmcgbG9jYWwgdmFyaWFibGUgbmFtZSBicmVha3MgaW4gT3BlcmEgc28gdXNlIHRvX3N0cmluZy5cbnZhciB0b19zdHJpbmcgPSBPYmplY3RQcm90b3R5cGUudG9TdHJpbmc7XG5cbnZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCc7XG52YXIgaXNDYWxsYWJsZTsgLyogaW5saW5lZCBmcm9tIGh0dHBzOi8vbnBtanMuY29tL2lzLWNhbGxhYmxlICovIHZhciBmblRvU3RyID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nLCB0cnlGdW5jdGlvbk9iamVjdCA9IGZ1bmN0aW9uIHRyeUZ1bmN0aW9uT2JqZWN0KHZhbHVlKSB7IHRyeSB7IGZuVG9TdHIuY2FsbCh2YWx1ZSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9LCBmbkNsYXNzID0gJ1tvYmplY3QgRnVuY3Rpb25dJywgZ2VuQ2xhc3MgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nOyBpc0NhbGxhYmxlID0gZnVuY3Rpb24gaXNDYWxsYWJsZSh2YWx1ZSkgeyBpZiAodHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfSBpZiAoaGFzVG9TdHJpbmdUYWcpIHsgcmV0dXJuIHRyeUZ1bmN0aW9uT2JqZWN0KHZhbHVlKTsgfSB2YXIgc3RyQ2xhc3MgPSB0b19zdHJpbmcuY2FsbCh2YWx1ZSk7IHJldHVybiBzdHJDbGFzcyA9PT0gZm5DbGFzcyB8fCBzdHJDbGFzcyA9PT0gZ2VuQ2xhc3M7IH07XG52YXIgaXNSZWdleDsgLyogaW5saW5lZCBmcm9tIGh0dHBzOi8vbnBtanMuY29tL2lzLXJlZ2V4ICovIHZhciByZWdleEV4ZWMgPSBSZWdFeHAucHJvdG90eXBlLmV4ZWMsIHRyeVJlZ2V4RXhlYyA9IGZ1bmN0aW9uIHRyeVJlZ2V4RXhlYyh2YWx1ZSkgeyB0cnkgeyByZWdleEV4ZWMuY2FsbCh2YWx1ZSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9LCByZWdleENsYXNzID0gJ1tvYmplY3QgUmVnRXhwXSc7IGlzUmVnZXggPSBmdW5jdGlvbiBpc1JlZ2V4KHZhbHVlKSB7IGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7IHJldHVybiBmYWxzZTsgfSByZXR1cm4gaGFzVG9TdHJpbmdUYWcgPyB0cnlSZWdleEV4ZWModmFsdWUpIDogdG9fc3RyaW5nLmNhbGwodmFsdWUpID09PSByZWdleENsYXNzOyB9O1xudmFyIGlzU3RyaW5nOyAvKiBpbmxpbmVkIGZyb20gaHR0cHM6Ly9ucG1qcy5jb20vaXMtc3RyaW5nICovIHZhciBzdHJWYWx1ZSA9IFN0cmluZy5wcm90b3R5cGUudmFsdWVPZiwgdHJ5U3RyaW5nT2JqZWN0ID0gZnVuY3Rpb24gdHJ5U3RyaW5nT2JqZWN0KHZhbHVlKSB7IHRyeSB7IHN0clZhbHVlLmNhbGwodmFsdWUpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfSwgc3RyaW5nQ2xhc3MgPSAnW29iamVjdCBTdHJpbmddJzsgaXNTdHJpbmcgPSBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkgeyBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykgeyByZXR1cm4gdHJ1ZTsgfSBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JykgeyByZXR1cm4gZmFsc2U7IH0gcmV0dXJuIGhhc1RvU3RyaW5nVGFnID8gdHJ5U3RyaW5nT2JqZWN0KHZhbHVlKSA6IHRvX3N0cmluZy5jYWxsKHZhbHVlKSA9PT0gc3RyaW5nQ2xhc3M7IH07XG5cbi8qIGlubGluZWQgZnJvbSBodHRwOi8vbnBtanMuY29tL2RlZmluZS1wcm9wZXJ0aWVzICovXG52YXIgZGVmaW5lUHJvcGVydGllcyA9IChmdW5jdGlvbiAoaGFzKSB7XG4gIHZhciBzdXBwb3J0c0Rlc2NyaXB0b3JzID0gJE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiAoZnVuY3Rpb24gKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgb2JqID0ge307XG4gICAgICAgICAgJE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosICd4JywgeyBlbnVtZXJhYmxlOiBmYWxzZSwgdmFsdWU6IG9iaiB9KTtcbiAgICAgICAgICBmb3IgKHZhciBfIGluIG9iaikgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgICAgICByZXR1cm4gb2JqLnggPT09IG9iajtcbiAgICAgIH0gY2F0Y2ggKGUpIHsgLyogdGhpcyBpcyBFUzMgKi9cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gIH0oKSk7XG5cbiAgLy8gRGVmaW5lIGNvbmZpZ3VyYWJsZSwgd3JpdGFibGUgYW5kIG5vbi1lbnVtZXJhYmxlIHByb3BzXG4gIC8vIGlmIHRoZXkgZG9uJ3QgZXhpc3QuXG4gIHZhciBkZWZpbmVQcm9wZXJ0eTtcbiAgaWYgKHN1cHBvcnRzRGVzY3JpcHRvcnMpIHtcbiAgICAgIGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZSwgbWV0aG9kLCBmb3JjZUFzc2lnbikge1xuICAgICAgICAgIGlmICghZm9yY2VBc3NpZ24gJiYgKG5hbWUgaW4gb2JqZWN0KSkgeyByZXR1cm47IH1cbiAgICAgICAgICAkT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgbmFtZSwge1xuICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgdmFsdWU6IG1ldGhvZFxuICAgICAgICAgIH0pO1xuICAgICAgfTtcbiAgfSBlbHNlIHtcbiAgICAgIGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZSwgbWV0aG9kLCBmb3JjZUFzc2lnbikge1xuICAgICAgICAgIGlmICghZm9yY2VBc3NpZ24gJiYgKG5hbWUgaW4gb2JqZWN0KSkgeyByZXR1cm47IH1cbiAgICAgICAgICBvYmplY3RbbmFtZV0gPSBtZXRob2Q7XG4gICAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKG9iamVjdCwgbWFwLCBmb3JjZUFzc2lnbikge1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBtYXApIHtcbiAgICAgICAgICBpZiAoaGFzLmNhbGwobWFwLCBuYW1lKSkge1xuICAgICAgICAgICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCBtYXBbbmFtZV0sIGZvcmNlQXNzaWduKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gIH07XG59KE9iamVjdFByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSkpO1xuXG4vL1xuLy8gVXRpbFxuLy8gPT09PT09XG4vL1xuXG4vKiByZXBsYWNlYWJsZSB3aXRoIGh0dHBzOi8vbnBtanMuY29tL3BhY2thZ2UvZXMtYWJzdHJhY3QgL2hlbHBlcnMvaXNQcmltaXRpdmUgKi9cbnZhciBpc1ByaW1pdGl2ZSA9IGZ1bmN0aW9uIGlzUHJpbWl0aXZlKGlucHV0KSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2YgaW5wdXQ7XG4gICAgcmV0dXJuIGlucHV0ID09PSBudWxsIHx8ICh0eXBlICE9PSAnb2JqZWN0JyAmJiB0eXBlICE9PSAnZnVuY3Rpb24nKTtcbn07XG5cbnZhciBpc0FjdHVhbE5hTiA9ICROdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggIT09IHg7IH07XG5cbnZhciBFUyA9IHtcbiAgICAvLyBFUzUgOS40XG4gICAgLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4OS40XG4gICAgLy8gaHR0cDovL2pzcGVyZi5jb20vdG8taW50ZWdlclxuICAgIC8qIHJlcGxhY2VhYmxlIHdpdGggaHR0cHM6Ly9ucG1qcy5jb20vcGFja2FnZS9lcy1hYnN0cmFjdCBFUzUuVG9JbnRlZ2VyICovXG4gICAgVG9JbnRlZ2VyOiBmdW5jdGlvbiBUb0ludGVnZXIobnVtKSB7XG4gICAgICAgIHZhciBuID0gK251bTtcbiAgICAgICAgaWYgKGlzQWN0dWFsTmFOKG4pKSB7XG4gICAgICAgICAgICBuID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChuICE9PSAwICYmIG4gIT09ICgxIC8gMCkgJiYgbiAhPT0gLSgxIC8gMCkpIHtcbiAgICAgICAgICAgIG4gPSAobiA+IDAgfHwgLTEpICogTWF0aC5mbG9vcihNYXRoLmFicyhuKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG47XG4gICAgfSxcblxuICAgIC8qIHJlcGxhY2VhYmxlIHdpdGggaHR0cHM6Ly9ucG1qcy5jb20vcGFja2FnZS9lcy1hYnN0cmFjdCBFUzUuVG9QcmltaXRpdmUgKi9cbiAgICBUb1ByaW1pdGl2ZTogZnVuY3Rpb24gVG9QcmltaXRpdmUoaW5wdXQpIHtcbiAgICAgICAgdmFyIHZhbCwgdmFsdWVPZiwgdG9TdHI7XG4gICAgICAgIGlmIChpc1ByaW1pdGl2ZShpbnB1dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZU9mID0gaW5wdXQudmFsdWVPZjtcbiAgICAgICAgaWYgKGlzQ2FsbGFibGUodmFsdWVPZikpIHtcbiAgICAgICAgICAgIHZhbCA9IHZhbHVlT2YuY2FsbChpbnB1dCk7XG4gICAgICAgICAgICBpZiAoaXNQcmltaXRpdmUodmFsKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdG9TdHIgPSBpbnB1dC50b1N0cmluZztcbiAgICAgICAgaWYgKGlzQ2FsbGFibGUodG9TdHIpKSB7XG4gICAgICAgICAgICB2YWwgPSB0b1N0ci5jYWxsKGlucHV0KTtcbiAgICAgICAgICAgIGlmIChpc1ByaW1pdGl2ZSh2YWwpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgfSxcblxuICAgIC8vIEVTNSA5LjlcbiAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3g5LjlcbiAgICAvKiByZXBsYWNlYWJsZSB3aXRoIGh0dHBzOi8vbnBtanMuY29tL3BhY2thZ2UvZXMtYWJzdHJhY3QgRVM1LlRvT2JqZWN0ICovXG4gICAgVG9PYmplY3Q6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIC8qIGpzaGludCBlcW51bGw6IHRydWUgKi9cbiAgICAgICAgaWYgKG8gPT0gbnVsbCkgeyAvLyB0aGlzIG1hdGNoZXMgYm90aCBudWxsIGFuZCB1bmRlZmluZWRcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjYW4ndCBjb252ZXJ0IFwiICsgbyArICcgdG8gb2JqZWN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICRPYmplY3Qobyk7XG4gICAgfSxcblxuICAgIC8qIHJlcGxhY2VhYmxlIHdpdGggaHR0cHM6Ly9ucG1qcy5jb20vcGFja2FnZS9lcy1hYnN0cmFjdCBFUzUuVG9VaW50MzIgKi9cbiAgICBUb1VpbnQzMjogZnVuY3Rpb24gVG9VaW50MzIoeCkge1xuICAgICAgICByZXR1cm4geCA+Pj4gMDtcbiAgICB9XG59O1xuXG4vL1xuLy8gRnVuY3Rpb25cbi8vID09PT09PT09XG4vL1xuXG4vLyBFUy01IDE1LjMuNC41XG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS4zLjQuNVxuXG52YXIgRW1wdHkgPSBmdW5jdGlvbiBFbXB0eSgpIHt9O1xuXG5kZWZpbmVQcm9wZXJ0aWVzKEZ1bmN0aW9uUHJvdG90eXBlLCB7XG4gICAgYmluZDogZnVuY3Rpb24gYmluZCh0aGF0KSB7IC8vIC5sZW5ndGggaXMgMVxuICAgICAgICAvLyAxLiBMZXQgVGFyZ2V0IGJlIHRoZSB0aGlzIHZhbHVlLlxuICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcztcbiAgICAgICAgLy8gMi4gSWYgSXNDYWxsYWJsZShUYXJnZXQpIGlzIGZhbHNlLCB0aHJvdyBhIFR5cGVFcnJvciBleGNlcHRpb24uXG4gICAgICAgIGlmICghaXNDYWxsYWJsZSh0YXJnZXQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGdW5jdGlvbi5wcm90b3R5cGUuYmluZCBjYWxsZWQgb24gaW5jb21wYXRpYmxlICcgKyB0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIDMuIExldCBBIGJlIGEgbmV3IChwb3NzaWJseSBlbXB0eSkgaW50ZXJuYWwgbGlzdCBvZiBhbGwgb2YgdGhlXG4gICAgICAgIC8vICAgYXJndW1lbnQgdmFsdWVzIHByb3ZpZGVkIGFmdGVyIHRoaXNBcmcgKGFyZzEsIGFyZzIgZXRjKSwgaW4gb3JkZXIuXG4gICAgICAgIC8vIFhYWCBzbGljZWRBcmdzIHdpbGwgc3RhbmQgaW4gZm9yIFwiQVwiIGlmIHVzZWRcbiAgICAgICAgdmFyIGFyZ3MgPSBhcnJheV9zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7IC8vIGZvciBub3JtYWwgY2FsbFxuICAgICAgICAvLyA0LiBMZXQgRiBiZSBhIG5ldyBuYXRpdmUgRUNNQVNjcmlwdCBvYmplY3QuXG4gICAgICAgIC8vIDExLiBTZXQgdGhlIFtbUHJvdG90eXBlXV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgRiB0byB0aGUgc3RhbmRhcmRcbiAgICAgICAgLy8gICBidWlsdC1pbiBGdW5jdGlvbiBwcm90b3R5cGUgb2JqZWN0IGFzIHNwZWNpZmllZCBpbiAxNS4zLjMuMS5cbiAgICAgICAgLy8gMTIuIFNldCB0aGUgW1tDYWxsXV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgRiBhcyBkZXNjcmliZWQgaW5cbiAgICAgICAgLy8gICAxNS4zLjQuNS4xLlxuICAgICAgICAvLyAxMy4gU2V0IHRoZSBbW0NvbnN0cnVjdF1dIGludGVybmFsIHByb3BlcnR5IG9mIEYgYXMgZGVzY3JpYmVkIGluXG4gICAgICAgIC8vICAgMTUuMy40LjUuMi5cbiAgICAgICAgLy8gMTQuIFNldCB0aGUgW1tIYXNJbnN0YW5jZV1dIGludGVybmFsIHByb3BlcnR5IG9mIEYgYXMgZGVzY3JpYmVkIGluXG4gICAgICAgIC8vICAgMTUuMy40LjUuMy5cbiAgICAgICAgdmFyIGJvdW5kO1xuICAgICAgICB2YXIgYmluZGVyID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSB7XG4gICAgICAgICAgICAgICAgLy8gMTUuMy40LjUuMiBbW0NvbnN0cnVjdF1dXG4gICAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgW1tDb25zdHJ1Y3RdXSBpbnRlcm5hbCBtZXRob2Qgb2YgYSBmdW5jdGlvbiBvYmplY3QsXG4gICAgICAgICAgICAgICAgLy8gRiB0aGF0IHdhcyBjcmVhdGVkIHVzaW5nIHRoZSBiaW5kIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIGFcbiAgICAgICAgICAgICAgICAvLyBsaXN0IG9mIGFyZ3VtZW50cyBFeHRyYUFyZ3MsIHRoZSBmb2xsb3dpbmcgc3RlcHMgYXJlIHRha2VuOlxuICAgICAgICAgICAgICAgIC8vIDEuIExldCB0YXJnZXQgYmUgdGhlIHZhbHVlIG9mIEYncyBbW1RhcmdldEZ1bmN0aW9uXV1cbiAgICAgICAgICAgICAgICAvLyAgIGludGVybmFsIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIC8vIDIuIElmIHRhcmdldCBoYXMgbm8gW1tDb25zdHJ1Y3RdXSBpbnRlcm5hbCBtZXRob2QsIGFcbiAgICAgICAgICAgICAgICAvLyAgIFR5cGVFcnJvciBleGNlcHRpb24gaXMgdGhyb3duLlxuICAgICAgICAgICAgICAgIC8vIDMuIExldCBib3VuZEFyZ3MgYmUgdGhlIHZhbHVlIG9mIEYncyBbW0JvdW5kQXJnc11dIGludGVybmFsXG4gICAgICAgICAgICAgICAgLy8gICBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAvLyA0LiBMZXQgYXJncyBiZSBhIG5ldyBsaXN0IGNvbnRhaW5pbmcgdGhlIHNhbWUgdmFsdWVzIGFzIHRoZVxuICAgICAgICAgICAgICAgIC8vICAgbGlzdCBib3VuZEFyZ3MgaW4gdGhlIHNhbWUgb3JkZXIgZm9sbG93ZWQgYnkgdGhlIHNhbWVcbiAgICAgICAgICAgICAgICAvLyAgIHZhbHVlcyBhcyB0aGUgbGlzdCBFeHRyYUFyZ3MgaW4gdGhlIHNhbWUgb3JkZXIuXG4gICAgICAgICAgICAgICAgLy8gNS4gUmV0dXJuIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgW1tDb25zdHJ1Y3RdXSBpbnRlcm5hbFxuICAgICAgICAgICAgICAgIC8vICAgbWV0aG9kIG9mIHRhcmdldCBwcm92aWRpbmcgYXJncyBhcyB0aGUgYXJndW1lbnRzLlxuXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRhcmdldC5hcHBseShcbiAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlfY29uY2F0LmNhbGwoYXJncywgYXJyYXlfc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKCRPYmplY3QocmVzdWx0KSA9PT0gcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIDE1LjMuNC41LjEgW1tDYWxsXV1cbiAgICAgICAgICAgICAgICAvLyBXaGVuIHRoZSBbW0NhbGxdXSBpbnRlcm5hbCBtZXRob2Qgb2YgYSBmdW5jdGlvbiBvYmplY3QsIEYsXG4gICAgICAgICAgICAgICAgLy8gd2hpY2ggd2FzIGNyZWF0ZWQgdXNpbmcgdGhlIGJpbmQgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggYVxuICAgICAgICAgICAgICAgIC8vIHRoaXMgdmFsdWUgYW5kIGEgbGlzdCBvZiBhcmd1bWVudHMgRXh0cmFBcmdzLCB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgICAgICAgLy8gc3RlcHMgYXJlIHRha2VuOlxuICAgICAgICAgICAgICAgIC8vIDEuIExldCBib3VuZEFyZ3MgYmUgdGhlIHZhbHVlIG9mIEYncyBbW0JvdW5kQXJnc11dIGludGVybmFsXG4gICAgICAgICAgICAgICAgLy8gICBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAvLyAyLiBMZXQgYm91bmRUaGlzIGJlIHRoZSB2YWx1ZSBvZiBGJ3MgW1tCb3VuZFRoaXNdXSBpbnRlcm5hbFxuICAgICAgICAgICAgICAgIC8vICAgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgLy8gMy4gTGV0IHRhcmdldCBiZSB0aGUgdmFsdWUgb2YgRidzIFtbVGFyZ2V0RnVuY3Rpb25dXSBpbnRlcm5hbFxuICAgICAgICAgICAgICAgIC8vICAgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgLy8gNC4gTGV0IGFyZ3MgYmUgYSBuZXcgbGlzdCBjb250YWluaW5nIHRoZSBzYW1lIHZhbHVlcyBhcyB0aGVcbiAgICAgICAgICAgICAgICAvLyAgIGxpc3QgYm91bmRBcmdzIGluIHRoZSBzYW1lIG9yZGVyIGZvbGxvd2VkIGJ5IHRoZSBzYW1lXG4gICAgICAgICAgICAgICAgLy8gICB2YWx1ZXMgYXMgdGhlIGxpc3QgRXh0cmFBcmdzIGluIHRoZSBzYW1lIG9yZGVyLlxuICAgICAgICAgICAgICAgIC8vIDUuIFJldHVybiB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhlIFtbQ2FsbF1dIGludGVybmFsIG1ldGhvZFxuICAgICAgICAgICAgICAgIC8vICAgb2YgdGFyZ2V0IHByb3ZpZGluZyBib3VuZFRoaXMgYXMgdGhlIHRoaXMgdmFsdWUgYW5kXG4gICAgICAgICAgICAgICAgLy8gICBwcm92aWRpbmcgYXJncyBhcyB0aGUgYXJndW1lbnRzLlxuXG4gICAgICAgICAgICAgICAgLy8gZXF1aXY6IHRhcmdldC5jYWxsKHRoaXMsIC4uLmJvdW5kQXJncywgLi4uYXJncylcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KFxuICAgICAgICAgICAgICAgICAgICB0aGF0LFxuICAgICAgICAgICAgICAgICAgICBhcnJheV9jb25jYXQuY2FsbChhcmdzLCBhcnJheV9zbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gMTUuIElmIHRoZSBbW0NsYXNzXV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgVGFyZ2V0IGlzIFwiRnVuY3Rpb25cIiwgdGhlblxuICAgICAgICAvLyAgICAgYS4gTGV0IEwgYmUgdGhlIGxlbmd0aCBwcm9wZXJ0eSBvZiBUYXJnZXQgbWludXMgdGhlIGxlbmd0aCBvZiBBLlxuICAgICAgICAvLyAgICAgYi4gU2V0IHRoZSBsZW5ndGggb3duIHByb3BlcnR5IG9mIEYgdG8gZWl0aGVyIDAgb3IgTCwgd2hpY2hldmVyIGlzXG4gICAgICAgIC8vICAgICAgIGxhcmdlci5cbiAgICAgICAgLy8gMTYuIEVsc2Ugc2V0IHRoZSBsZW5ndGggb3duIHByb3BlcnR5IG9mIEYgdG8gMC5cblxuICAgICAgICB2YXIgYm91bmRMZW5ndGggPSBtYXgoMCwgdGFyZ2V0Lmxlbmd0aCAtIGFyZ3MubGVuZ3RoKTtcblxuICAgICAgICAvLyAxNy4gU2V0IHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBsZW5ndGggb3duIHByb3BlcnR5IG9mIEYgdG8gdGhlIHZhbHVlc1xuICAgICAgICAvLyAgIHNwZWNpZmllZCBpbiAxNS4zLjUuMS5cbiAgICAgICAgdmFyIGJvdW5kQXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvdW5kTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFycmF5X3B1c2guY2FsbChib3VuZEFyZ3MsICckJyArIGkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gWFhYIEJ1aWxkIGEgZHluYW1pYyBmdW5jdGlvbiB3aXRoIGRlc2lyZWQgYW1vdW50IG9mIGFyZ3VtZW50cyBpcyB0aGUgb25seVxuICAgICAgICAvLyB3YXkgdG8gc2V0IHRoZSBsZW5ndGggcHJvcGVydHkgb2YgYSBmdW5jdGlvbi5cbiAgICAgICAgLy8gSW4gZW52aXJvbm1lbnRzIHdoZXJlIENvbnRlbnQgU2VjdXJpdHkgUG9saWNpZXMgZW5hYmxlZCAoQ2hyb21lIGV4dGVuc2lvbnMsXG4gICAgICAgIC8vIGZvciBleC4pIGFsbCB1c2Ugb2YgZXZhbCBvciBGdW5jdGlvbiBjb3N0cnVjdG9yIHRocm93cyBhbiBleGNlcHRpb24uXG4gICAgICAgIC8vIEhvd2V2ZXIgaW4gYWxsIG9mIHRoZXNlIGVudmlyb25tZW50cyBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCBleGlzdHNcbiAgICAgICAgLy8gYW5kIHNvIHRoaXMgY29kZSB3aWxsIG5ldmVyIGJlIGV4ZWN1dGVkLlxuICAgICAgICBib3VuZCA9IEZ1bmN0aW9uKCdiaW5kZXInLCAncmV0dXJuIGZ1bmN0aW9uICgnICsgYm91bmRBcmdzLmpvaW4oJywnKSArICcpeyByZXR1cm4gYmluZGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0nKShiaW5kZXIpO1xuXG4gICAgICAgIGlmICh0YXJnZXQucHJvdG90eXBlKSB7XG4gICAgICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSB0YXJnZXQucHJvdG90eXBlO1xuICAgICAgICAgICAgYm91bmQucHJvdG90eXBlID0gbmV3IEVtcHR5KCk7XG4gICAgICAgICAgICAvLyBDbGVhbiB1cCBkYW5nbGluZyByZWZlcmVuY2VzLlxuICAgICAgICAgICAgRW1wdHkucHJvdG90eXBlID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgLy8gMTguIFNldCB0aGUgW1tFeHRlbnNpYmxlXV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgRiB0byB0cnVlLlxuXG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgLy8gMTkuIExldCB0aHJvd2VyIGJlIHRoZSBbW1Rocm93VHlwZUVycm9yXV0gZnVuY3Rpb24gT2JqZWN0ICgxMy4yLjMpLlxuICAgICAgICAvLyAyMC4gQ2FsbCB0aGUgW1tEZWZpbmVPd25Qcm9wZXJ0eV1dIGludGVybmFsIG1ldGhvZCBvZiBGIHdpdGhcbiAgICAgICAgLy8gICBhcmd1bWVudHMgXCJjYWxsZXJcIiwgUHJvcGVydHlEZXNjcmlwdG9yIHtbW0dldF1dOiB0aHJvd2VyLCBbW1NldF1dOlxuICAgICAgICAvLyAgIHRocm93ZXIsIFtbRW51bWVyYWJsZV1dOiBmYWxzZSwgW1tDb25maWd1cmFibGVdXTogZmFsc2V9LCBhbmRcbiAgICAgICAgLy8gICBmYWxzZS5cbiAgICAgICAgLy8gMjEuIENhbGwgdGhlIFtbRGVmaW5lT3duUHJvcGVydHldXSBpbnRlcm5hbCBtZXRob2Qgb2YgRiB3aXRoXG4gICAgICAgIC8vICAgYXJndW1lbnRzIFwiYXJndW1lbnRzXCIsIFByb3BlcnR5RGVzY3JpcHRvciB7W1tHZXRdXTogdGhyb3dlcixcbiAgICAgICAgLy8gICBbW1NldF1dOiB0aHJvd2VyLCBbW0VudW1lcmFibGVdXTogZmFsc2UsIFtbQ29uZmlndXJhYmxlXV06IGZhbHNlfSxcbiAgICAgICAgLy8gICBhbmQgZmFsc2UuXG5cbiAgICAgICAgLy8gVE9ET1xuICAgICAgICAvLyBOT1RFIEZ1bmN0aW9uIG9iamVjdHMgY3JlYXRlZCB1c2luZyBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCBkbyBub3RcbiAgICAgICAgLy8gaGF2ZSBhIHByb3RvdHlwZSBwcm9wZXJ0eSBvciB0aGUgW1tDb2RlXV0sIFtbRm9ybWFsUGFyYW1ldGVyc11dLCBhbmRcbiAgICAgICAgLy8gW1tTY29wZV1dIGludGVybmFsIHByb3BlcnRpZXMuXG4gICAgICAgIC8vIFhYWCBjYW4ndCBkZWxldGUgcHJvdG90eXBlIGluIHB1cmUtanMuXG5cbiAgICAgICAgLy8gMjIuIFJldHVybiBGLlxuICAgICAgICByZXR1cm4gYm91bmQ7XG4gICAgfVxufSk7XG5cbi8vIF9QbGVhc2Ugbm90ZTogU2hvcnRjdXRzIGFyZSBkZWZpbmVkIGFmdGVyIGBGdW5jdGlvbi5wcm90b3R5cGUuYmluZGAgYXMgd2Vcbi8vIHVzIGl0IGluIGRlZmluaW5nIHNob3J0Y3V0cy5cbnZhciBvd25zID0gY2FsbC5iaW5kKE9iamVjdFByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG52YXIgdG9TdHIgPSBjYWxsLmJpbmQoT2JqZWN0UHJvdG90eXBlLnRvU3RyaW5nKTtcbnZhciBzdHJTbGljZSA9IGNhbGwuYmluZChTdHJpbmdQcm90b3R5cGUuc2xpY2UpO1xudmFyIHN0clNwbGl0ID0gY2FsbC5iaW5kKFN0cmluZ1Byb3RvdHlwZS5zcGxpdCk7XG52YXIgc3RySW5kZXhPZiA9IGNhbGwuYmluZChTdHJpbmdQcm90b3R5cGUuaW5kZXhPZik7XG52YXIgcHVzaCA9IGNhbGwuYmluZChhcnJheV9wdXNoKTtcblxuLy9cbi8vIEFycmF5XG4vLyA9PT09PVxuLy9cblxudmFyIGlzQXJyYXkgPSAkQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5KG9iaikge1xuICAgIHJldHVybiB0b1N0cihvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuLy8gRVM1IDE1LjQuNC4xMlxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNC40LjEzXG4vLyBSZXR1cm4gbGVuK2FyZ0NvdW50LlxuLy8gW2J1Z2ZpeCwgaWVsdDhdXG4vLyBJRSA8IDggYnVnOiBbXS51bnNoaWZ0KDApID09PSB1bmRlZmluZWQgYnV0IHNob3VsZCBiZSBcIjFcIlxudmFyIGhhc1Vuc2hpZnRSZXR1cm5WYWx1ZUJ1ZyA9IFtdLnVuc2hpZnQoMCkgIT09IDE7XG5kZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgdW5zaGlmdDogZnVuY3Rpb24gKCkge1xuICAgICAgICBhcnJheV91bnNoaWZ0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzLmxlbmd0aDtcbiAgICB9XG59LCBoYXNVbnNoaWZ0UmV0dXJuVmFsdWVCdWcpO1xuXG4vLyBFUzUgMTUuNC4zLjJcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjQuMy4yXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9pc0FycmF5XG5kZWZpbmVQcm9wZXJ0aWVzKCRBcnJheSwgeyBpc0FycmF5OiBpc0FycmF5IH0pO1xuXG4vLyBUaGUgSXNDYWxsYWJsZSgpIGNoZWNrIGluIHRoZSBBcnJheSBmdW5jdGlvbnNcbi8vIGhhcyBiZWVuIHJlcGxhY2VkIHdpdGggYSBzdHJpY3QgY2hlY2sgb24gdGhlXG4vLyBpbnRlcm5hbCBjbGFzcyBvZiB0aGUgb2JqZWN0IHRvIHRyYXAgY2FzZXMgd2hlcmVcbi8vIHRoZSBwcm92aWRlZCBmdW5jdGlvbiB3YXMgYWN0dWFsbHkgYSByZWd1bGFyXG4vLyBleHByZXNzaW9uIGxpdGVyYWwsIHdoaWNoIGluIFY4IGFuZFxuLy8gSmF2YVNjcmlwdENvcmUgaXMgYSB0eXBlb2YgXCJmdW5jdGlvblwiLiAgT25seSBpblxuLy8gVjggYXJlIHJlZ3VsYXIgZXhwcmVzc2lvbiBsaXRlcmFscyBwZXJtaXR0ZWQgYXNcbi8vIHJlZHVjZSBwYXJhbWV0ZXJzLCBzbyBpdCBpcyBkZXNpcmFibGUgaW4gdGhlXG4vLyBnZW5lcmFsIGNhc2UgZm9yIHRoZSBzaGltIHRvIG1hdGNoIHRoZSBtb3JlXG4vLyBzdHJpY3QgYW5kIGNvbW1vbiBiZWhhdmlvciBvZiByZWplY3RpbmcgcmVndWxhclxuLy8gZXhwcmVzc2lvbnMuXG5cbi8vIEVTNSAxNS40LjQuMThcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjQuNC4xOFxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvYXJyYXkvZm9yRWFjaFxuXG4vLyBDaGVjayBmYWlsdXJlIG9mIGJ5LWluZGV4IGFjY2VzcyBvZiBzdHJpbmcgY2hhcmFjdGVycyAoSUUgPCA5KVxuLy8gYW5kIGZhaWx1cmUgb2YgYDAgaW4gYm94ZWRTdHJpbmdgIChSaGlubylcbnZhciBib3hlZFN0cmluZyA9ICRPYmplY3QoJ2EnKTtcbnZhciBzcGxpdFN0cmluZyA9IGJveGVkU3RyaW5nWzBdICE9PSAnYScgfHwgISgwIGluIGJveGVkU3RyaW5nKTtcblxudmFyIHByb3Blcmx5Qm94ZXNDb250ZXh0ID0gZnVuY3Rpb24gcHJvcGVybHlCb3hlZChtZXRob2QpIHtcbiAgICAvLyBDaGVjayBub2RlIDAuNi4yMSBidWcgd2hlcmUgdGhpcmQgcGFyYW1ldGVyIGlzIG5vdCBib3hlZFxuICAgIHZhciBwcm9wZXJseUJveGVzTm9uU3RyaWN0ID0gdHJ1ZTtcbiAgICB2YXIgcHJvcGVybHlCb3hlc1N0cmljdCA9IHRydWU7XG4gICAgaWYgKG1ldGhvZCkge1xuICAgICAgICBtZXRob2QuY2FsbCgnZm9vJywgZnVuY3Rpb24gKF8sIF9fLCBjb250ZXh0KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRleHQgIT09ICdvYmplY3QnKSB7IHByb3Blcmx5Qm94ZXNOb25TdHJpY3QgPSBmYWxzZTsgfVxuICAgICAgICB9KTtcblxuICAgICAgICBtZXRob2QuY2FsbChbMV0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICAgICAgcHJvcGVybHlCb3hlc1N0cmljdCA9IHR5cGVvZiB0aGlzID09PSAnc3RyaW5nJztcbiAgICAgICAgfSwgJ3gnKTtcbiAgICB9XG4gICAgcmV0dXJuICEhbWV0aG9kICYmIHByb3Blcmx5Qm94ZXNOb25TdHJpY3QgJiYgcHJvcGVybHlCb3hlc1N0cmljdDtcbn07XG5cbmRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4vKiwgdGhpc0FyZyovKSB7XG4gICAgICAgIHZhciBvYmplY3QgPSBFUy5Ub09iamVjdCh0aGlzKTtcbiAgICAgICAgdmFyIHNlbGYgPSBzcGxpdFN0cmluZyAmJiBpc1N0cmluZyh0aGlzKSA/IHN0clNwbGl0KHRoaXMsICcnKSA6IG9iamVjdDtcbiAgICAgICAgdmFyIGkgPSAtMTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IEVTLlRvVWludDMyKHNlbGYubGVuZ3RoKTtcbiAgICAgICAgdmFyIFQ7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIFQgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBubyBjYWxsYmFjayBmdW5jdGlvbiBvciBpZiBjYWxsYmFjayBpcyBub3QgYSBjYWxsYWJsZSBmdW5jdGlvblxuICAgICAgICBpZiAoIWlzQ2FsbGFibGUoY2FsbGJhY2tmbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5LnByb3RvdHlwZS5mb3JFYWNoIGNhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKCsraSA8IGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGkgaW4gc2VsZikge1xuICAgICAgICAgICAgICAgIC8vIEludm9rZSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gd2l0aCBjYWxsLCBwYXNzaW5nIGFyZ3VtZW50czpcbiAgICAgICAgICAgICAgICAvLyBjb250ZXh0LCBwcm9wZXJ0eSB2YWx1ZSwgcHJvcGVydHkga2V5LCB0aGlzQXJnIG9iamVjdFxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgVCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tmbihzZWxmW2ldLCBpLCBvYmplY3QpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrZm4uY2FsbChULCBzZWxmW2ldLCBpLCBvYmplY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0sICFwcm9wZXJseUJveGVzQ29udGV4dChBcnJheVByb3RvdHlwZS5mb3JFYWNoKSk7XG5cbi8vIEVTNSAxNS40LjQuMTlcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjQuNC4xOVxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vQ29yZV9KYXZhU2NyaXB0XzEuNV9SZWZlcmVuY2UvT2JqZWN0cy9BcnJheS9tYXBcbmRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICBtYXA6IGZ1bmN0aW9uIG1hcChjYWxsYmFja2ZuLyosIHRoaXNBcmcqLykge1xuICAgICAgICB2YXIgb2JqZWN0ID0gRVMuVG9PYmplY3QodGhpcyk7XG4gICAgICAgIHZhciBzZWxmID0gc3BsaXRTdHJpbmcgJiYgaXNTdHJpbmcodGhpcykgPyBzdHJTcGxpdCh0aGlzLCAnJykgOiBvYmplY3Q7XG4gICAgICAgIHZhciBsZW5ndGggPSBFUy5Ub1VpbnQzMihzZWxmLmxlbmd0aCk7XG4gICAgICAgIHZhciByZXN1bHQgPSAkQXJyYXkobGVuZ3RoKTtcbiAgICAgICAgdmFyIFQ7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgVCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIG5vIGNhbGxiYWNrIGZ1bmN0aW9uIG9yIGlmIGNhbGxiYWNrIGlzIG5vdCBhIGNhbGxhYmxlIGZ1bmN0aW9uXG4gICAgICAgIGlmICghaXNDYWxsYWJsZShjYWxsYmFja2ZuKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkucHJvdG90eXBlLm1hcCBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpIGluIHNlbGYpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIFQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IGNhbGxiYWNrZm4oc2VsZltpXSwgaSwgb2JqZWN0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSBjYWxsYmFja2ZuLmNhbGwoVCwgc2VsZltpXSwgaSwgb2JqZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59LCAhcHJvcGVybHlCb3hlc0NvbnRleHQoQXJyYXlQcm90b3R5cGUubWFwKSk7XG5cbi8vIEVTNSAxNS40LjQuMjBcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjQuNC4yMFxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vQ29yZV9KYXZhU2NyaXB0XzEuNV9SZWZlcmVuY2UvT2JqZWN0cy9BcnJheS9maWx0ZXJcbmRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcihjYWxsYmFja2ZuLyosIHRoaXNBcmcqLykge1xuICAgICAgICB2YXIgb2JqZWN0ID0gRVMuVG9PYmplY3QodGhpcyk7XG4gICAgICAgIHZhciBzZWxmID0gc3BsaXRTdHJpbmcgJiYgaXNTdHJpbmcodGhpcykgPyBzdHJTcGxpdCh0aGlzLCAnJykgOiBvYmplY3Q7XG4gICAgICAgIHZhciBsZW5ndGggPSBFUy5Ub1VpbnQzMihzZWxmLmxlbmd0aCk7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICB2YXIgVDtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBUID0gYXJndW1lbnRzWzFdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgbm8gY2FsbGJhY2sgZnVuY3Rpb24gb3IgaWYgY2FsbGJhY2sgaXMgbm90IGEgY2FsbGFibGUgZnVuY3Rpb25cbiAgICAgICAgaWYgKCFpc0NhbGxhYmxlKGNhbGxiYWNrZm4pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheS5wcm90b3R5cGUuZmlsdGVyIGNhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgaW4gc2VsZikge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gc2VsZltpXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIFQgPT09ICd1bmRlZmluZWQnID8gY2FsbGJhY2tmbih2YWx1ZSwgaSwgb2JqZWN0KSA6IGNhbGxiYWNrZm4uY2FsbChULCB2YWx1ZSwgaSwgb2JqZWN0KSkge1xuICAgICAgICAgICAgICAgICAgICBwdXNoKHJlc3VsdCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn0sICFwcm9wZXJseUJveGVzQ29udGV4dChBcnJheVByb3RvdHlwZS5maWx0ZXIpKTtcblxuLy8gRVM1IDE1LjQuNC4xNlxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNC40LjE2XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9ldmVyeVxuZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgIGV2ZXJ5OiBmdW5jdGlvbiBldmVyeShjYWxsYmFja2ZuLyosIHRoaXNBcmcqLykge1xuICAgICAgICB2YXIgb2JqZWN0ID0gRVMuVG9PYmplY3QodGhpcyk7XG4gICAgICAgIHZhciBzZWxmID0gc3BsaXRTdHJpbmcgJiYgaXNTdHJpbmcodGhpcykgPyBzdHJTcGxpdCh0aGlzLCAnJykgOiBvYmplY3Q7XG4gICAgICAgIHZhciBsZW5ndGggPSBFUy5Ub1VpbnQzMihzZWxmLmxlbmd0aCk7XG4gICAgICAgIHZhciBUO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIFQgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBubyBjYWxsYmFjayBmdW5jdGlvbiBvciBpZiBjYWxsYmFjayBpcyBub3QgYSBjYWxsYWJsZSBmdW5jdGlvblxuICAgICAgICBpZiAoIWlzQ2FsbGFibGUoY2FsbGJhY2tmbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5LnByb3RvdHlwZS5ldmVyeSBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpIGluIHNlbGYgJiYgISh0eXBlb2YgVCA9PT0gJ3VuZGVmaW5lZCcgPyBjYWxsYmFja2ZuKHNlbGZbaV0sIGksIG9iamVjdCkgOiBjYWxsYmFja2ZuLmNhbGwoVCwgc2VsZltpXSwgaSwgb2JqZWN0KSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufSwgIXByb3Blcmx5Qm94ZXNDb250ZXh0KEFycmF5UHJvdG90eXBlLmV2ZXJ5KSk7XG5cbi8vIEVTNSAxNS40LjQuMTdcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjQuNC4xN1xuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvc29tZVxuZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgIHNvbWU6IGZ1bmN0aW9uIHNvbWUoY2FsbGJhY2tmbi8qLCB0aGlzQXJnICovKSB7XG4gICAgICAgIHZhciBvYmplY3QgPSBFUy5Ub09iamVjdCh0aGlzKTtcbiAgICAgICAgdmFyIHNlbGYgPSBzcGxpdFN0cmluZyAmJiBpc1N0cmluZyh0aGlzKSA/IHN0clNwbGl0KHRoaXMsICcnKSA6IG9iamVjdDtcbiAgICAgICAgdmFyIGxlbmd0aCA9IEVTLlRvVWludDMyKHNlbGYubGVuZ3RoKTtcbiAgICAgICAgdmFyIFQ7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgVCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIG5vIGNhbGxiYWNrIGZ1bmN0aW9uIG9yIGlmIGNhbGxiYWNrIGlzIG5vdCBhIGNhbGxhYmxlIGZ1bmN0aW9uXG4gICAgICAgIGlmICghaXNDYWxsYWJsZShjYWxsYmFja2ZuKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkucHJvdG90eXBlLnNvbWUgY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSBpbiBzZWxmICYmICh0eXBlb2YgVCA9PT0gJ3VuZGVmaW5lZCcgPyBjYWxsYmFja2ZuKHNlbGZbaV0sIGksIG9iamVjdCkgOiBjYWxsYmFja2ZuLmNhbGwoVCwgc2VsZltpXSwgaSwgb2JqZWN0KSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufSwgIXByb3Blcmx5Qm94ZXNDb250ZXh0KEFycmF5UHJvdG90eXBlLnNvbWUpKTtcblxuLy8gRVM1IDE1LjQuNC4yMVxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNC40LjIxXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9Db3JlX0phdmFTY3JpcHRfMS41X1JlZmVyZW5jZS9PYmplY3RzL0FycmF5L3JlZHVjZVxudmFyIHJlZHVjZUNvZXJjZXNUb09iamVjdCA9IGZhbHNlO1xuaWYgKEFycmF5UHJvdG90eXBlLnJlZHVjZSkge1xuICAgIHJlZHVjZUNvZXJjZXNUb09iamVjdCA9IHR5cGVvZiBBcnJheVByb3RvdHlwZS5yZWR1Y2UuY2FsbCgnZXM1JywgZnVuY3Rpb24gKF8sIF9fLCBfX18sIGxpc3QpIHsgcmV0dXJuIGxpc3Q7IH0pID09PSAnb2JqZWN0Jztcbn1cbmRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICByZWR1Y2U6IGZ1bmN0aW9uIHJlZHVjZShjYWxsYmFja2ZuLyosIGluaXRpYWxWYWx1ZSovKSB7XG4gICAgICAgIHZhciBvYmplY3QgPSBFUy5Ub09iamVjdCh0aGlzKTtcbiAgICAgICAgdmFyIHNlbGYgPSBzcGxpdFN0cmluZyAmJiBpc1N0cmluZyh0aGlzKSA/IHN0clNwbGl0KHRoaXMsICcnKSA6IG9iamVjdDtcbiAgICAgICAgdmFyIGxlbmd0aCA9IEVTLlRvVWludDMyKHNlbGYubGVuZ3RoKTtcblxuICAgICAgICAvLyBJZiBubyBjYWxsYmFjayBmdW5jdGlvbiBvciBpZiBjYWxsYmFjayBpcyBub3QgYSBjYWxsYWJsZSBmdW5jdGlvblxuICAgICAgICBpZiAoIWlzQ2FsbGFibGUoY2FsbGJhY2tmbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5LnByb3RvdHlwZS5yZWR1Y2UgY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBubyB2YWx1ZSB0byByZXR1cm4gaWYgbm8gaW5pdGlhbCB2YWx1ZSBhbmQgYW4gZW1wdHkgYXJyYXlcbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gMCAmJiBhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdyZWR1Y2Ugb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBpZiAoaSBpbiBzZWxmKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHNlbGZbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gaWYgYXJyYXkgY29udGFpbnMgbm8gdmFsdWVzLCBubyBpbml0aWFsIHZhbHVlIHRvIHJldHVyblxuICAgICAgICAgICAgICAgIGlmICgrK2kgPj0gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3JlZHVjZSBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlICh0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpIGluIHNlbGYpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBjYWxsYmFja2ZuKHJlc3VsdCwgc2VsZltpXSwgaSwgb2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufSwgIXJlZHVjZUNvZXJjZXNUb09iamVjdCk7XG5cbi8vIEVTNSAxNS40LjQuMjJcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjQuNC4yMlxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vQ29yZV9KYXZhU2NyaXB0XzEuNV9SZWZlcmVuY2UvT2JqZWN0cy9BcnJheS9yZWR1Y2VSaWdodFxudmFyIHJlZHVjZVJpZ2h0Q29lcmNlc1RvT2JqZWN0ID0gZmFsc2U7XG5pZiAoQXJyYXlQcm90b3R5cGUucmVkdWNlUmlnaHQpIHtcbiAgICByZWR1Y2VSaWdodENvZXJjZXNUb09iamVjdCA9IHR5cGVvZiBBcnJheVByb3RvdHlwZS5yZWR1Y2VSaWdodC5jYWxsKCdlczUnLCBmdW5jdGlvbiAoXywgX18sIF9fXywgbGlzdCkgeyByZXR1cm4gbGlzdDsgfSkgPT09ICdvYmplY3QnO1xufVxuZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgIHJlZHVjZVJpZ2h0OiBmdW5jdGlvbiByZWR1Y2VSaWdodChjYWxsYmFja2ZuLyosIGluaXRpYWwqLykge1xuICAgICAgICB2YXIgb2JqZWN0ID0gRVMuVG9PYmplY3QodGhpcyk7XG4gICAgICAgIHZhciBzZWxmID0gc3BsaXRTdHJpbmcgJiYgaXNTdHJpbmcodGhpcykgPyBzdHJTcGxpdCh0aGlzLCAnJykgOiBvYmplY3Q7XG4gICAgICAgIHZhciBsZW5ndGggPSBFUy5Ub1VpbnQzMihzZWxmLmxlbmd0aCk7XG5cbiAgICAgICAgLy8gSWYgbm8gY2FsbGJhY2sgZnVuY3Rpb24gb3IgaWYgY2FsbGJhY2sgaXMgbm90IGEgY2FsbGFibGUgZnVuY3Rpb25cbiAgICAgICAgaWYgKCFpc0NhbGxhYmxlKGNhbGxiYWNrZm4pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheS5wcm90b3R5cGUucmVkdWNlUmlnaHQgY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBubyB2YWx1ZSB0byByZXR1cm4gaWYgbm8gaW5pdGlhbCB2YWx1ZSwgZW1wdHkgYXJyYXlcbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gMCAmJiBhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdyZWR1Y2VSaWdodCBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHZhciBpID0gbGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgcmVzdWx0ID0gYXJndW1lbnRzWzFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGlmIChpIGluIHNlbGYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gc2VsZltpLS1dO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBpZiBhcnJheSBjb250YWlucyBubyB2YWx1ZXMsIG5vIGluaXRpYWwgdmFsdWUgdG8gcmV0dXJuXG4gICAgICAgICAgICAgICAgaWYgKC0taSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncmVkdWNlUmlnaHQgb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAodHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaSA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAoaSBpbiBzZWxmKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gY2FsbGJhY2tmbihyZXN1bHQsIHNlbGZbaV0sIGksIG9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKGktLSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59LCAhcmVkdWNlUmlnaHRDb2VyY2VzVG9PYmplY3QpO1xuXG4vLyBFUzUgMTUuNC40LjE0XG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjQuMTRcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2luZGV4T2ZcbnZhciBoYXNGaXJlZm94MkluZGV4T2ZCdWcgPSBBcnJheVByb3RvdHlwZS5pbmRleE9mICYmIFswLCAxXS5pbmRleE9mKDEsIDIpICE9PSAtMTtcbmRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICBpbmRleE9mOiBmdW5jdGlvbiBpbmRleE9mKHNlYXJjaEVsZW1lbnQvKiwgZnJvbUluZGV4ICovKSB7XG4gICAgICAgIHZhciBzZWxmID0gc3BsaXRTdHJpbmcgJiYgaXNTdHJpbmcodGhpcykgPyBzdHJTcGxpdCh0aGlzLCAnJykgOiBFUy5Ub09iamVjdCh0aGlzKTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IEVTLlRvVWludDMyKHNlbGYubGVuZ3RoKTtcblxuICAgICAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgaSA9IEVTLlRvSW50ZWdlcihhcmd1bWVudHNbMV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaGFuZGxlIG5lZ2F0aXZlIGluZGljZXNcbiAgICAgICAgaSA9IGkgPj0gMCA/IGkgOiBtYXgoMCwgbGVuZ3RoICsgaSk7XG4gICAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpIGluIHNlbGYgJiYgc2VsZltpXSA9PT0gc2VhcmNoRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG59LCBoYXNGaXJlZm94MkluZGV4T2ZCdWcpO1xuXG4vLyBFUzUgMTUuNC40LjE1XG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjQuMTVcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2xhc3RJbmRleE9mXG52YXIgaGFzRmlyZWZveDJMYXN0SW5kZXhPZkJ1ZyA9IEFycmF5UHJvdG90eXBlLmxhc3RJbmRleE9mICYmIFswLCAxXS5sYXN0SW5kZXhPZigwLCAtMykgIT09IC0xO1xuZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgIGxhc3RJbmRleE9mOiBmdW5jdGlvbiBsYXN0SW5kZXhPZihzZWFyY2hFbGVtZW50LyosIGZyb21JbmRleCAqLykge1xuICAgICAgICB2YXIgc2VsZiA9IHNwbGl0U3RyaW5nICYmIGlzU3RyaW5nKHRoaXMpID8gc3RyU3BsaXQodGhpcywgJycpIDogRVMuVG9PYmplY3QodGhpcyk7XG4gICAgICAgIHZhciBsZW5ndGggPSBFUy5Ub1VpbnQzMihzZWxmLmxlbmd0aCk7XG5cbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpID0gbGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBpID0gbWluKGksIEVTLlRvSW50ZWdlcihhcmd1bWVudHNbMV0pKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBoYW5kbGUgbmVnYXRpdmUgaW5kaWNlc1xuICAgICAgICBpID0gaSA+PSAwID8gaSA6IGxlbmd0aCAtIE1hdGguYWJzKGkpO1xuICAgICAgICBmb3IgKDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmIChpIGluIHNlbGYgJiYgc2VhcmNoRWxlbWVudCA9PT0gc2VsZltpXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG59LCBoYXNGaXJlZm94Mkxhc3RJbmRleE9mQnVnKTtcblxuLy8gRVM1IDE1LjQuNC4xMlxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNC40LjEyXG52YXIgc3BsaWNlTm9vcFJldHVybnNFbXB0eUFycmF5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYSA9IFsxLCAyXTtcbiAgICB2YXIgcmVzdWx0ID0gYS5zcGxpY2UoKTtcbiAgICByZXR1cm4gYS5sZW5ndGggPT09IDIgJiYgaXNBcnJheShyZXN1bHQpICYmIHJlc3VsdC5sZW5ndGggPT09IDA7XG59KCkpO1xuZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgIC8vIFNhZmFyaSA1LjAgYnVnIHdoZXJlIC5zcGxpY2UoKSByZXR1cm5zIHVuZGVmaW5lZFxuICAgIHNwbGljZTogZnVuY3Rpb24gc3BsaWNlKHN0YXJ0LCBkZWxldGVDb3VudCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGFycmF5X3NwbGljZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgfVxufSwgIXNwbGljZU5vb3BSZXR1cm5zRW1wdHlBcnJheSk7XG5cbnZhciBzcGxpY2VXb3Jrc1dpdGhFbXB0eU9iamVjdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iaiA9IHt9O1xuICAgIEFycmF5UHJvdG90eXBlLnNwbGljZS5jYWxsKG9iaiwgMCwgMCwgMSk7XG4gICAgcmV0dXJuIG9iai5sZW5ndGggPT09IDE7XG59KCkpO1xuZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgIHNwbGljZTogZnVuY3Rpb24gc3BsaWNlKHN0YXJ0LCBkZWxldGVDb3VudCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gW107IH1cbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbWF4KEVTLlRvSW50ZWdlcih0aGlzLmxlbmd0aCksIDApO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgdHlwZW9mIGRlbGV0ZUNvdW50ICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgYXJncyA9IGFycmF5X3NsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICBwdXNoKGFyZ3MsIHRoaXMubGVuZ3RoIC0gc3RhcnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcmdzWzFdID0gRVMuVG9JbnRlZ2VyKGRlbGV0ZUNvdW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXlfc3BsaWNlLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbn0sICFzcGxpY2VXb3Jrc1dpdGhFbXB0eU9iamVjdCk7XG52YXIgc3BsaWNlV29ya3NXaXRoTGFyZ2VTcGFyc2VBcnJheXMgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8vIFBlciBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0vaXNzdWVzLzI5NVxuICAgIC8vIFNhZmFyaSA3LzggYnJlYWtzIHdpdGggc3BhcnNlIGFycmF5cyBvZiBzaXplIDFlNSBvciBncmVhdGVyXG4gICAgdmFyIGFyciA9IG5ldyAkQXJyYXkoMWU1KTtcbiAgICAvLyBub3RlOiB0aGUgaW5kZXggTVVTVCBiZSA4IG9yIGxhcmdlciBvciB0aGUgdGVzdCB3aWxsIGZhbHNlIHBhc3NcbiAgICBhcnJbOF0gPSAneCc7XG4gICAgYXJyLnNwbGljZSgxLCAxKTtcbiAgICAvLyBub3RlOiB0aGlzIHRlc3QgbXVzdCBiZSBkZWZpbmVkICphZnRlciogdGhlIGluZGV4T2Ygc2hpbVxuICAgIC8vIHBlciBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0vaXNzdWVzLzMxM1xuICAgIHJldHVybiBhcnIuaW5kZXhPZigneCcpID09PSA3O1xufSgpKTtcbnZhciBzcGxpY2VXb3Jrc1dpdGhTbWFsbFNwYXJzZUFycmF5cyA9IChmdW5jdGlvbiAoKSB7XG4gICAgLy8gUGVyIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbS9pc3N1ZXMvMjk1XG4gICAgLy8gT3BlcmEgMTIuMTUgYnJlYWtzIG9uIHRoaXMsIG5vIGlkZWEgd2h5LlxuICAgIHZhciBuID0gMjU2O1xuICAgIHZhciBhcnIgPSBbXTtcbiAgICBhcnJbbl0gPSAnYSc7XG4gICAgYXJyLnNwbGljZShuICsgMSwgMCwgJ2InKTtcbiAgICByZXR1cm4gYXJyW25dID09PSAnYSc7XG59KCkpO1xuZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgIHNwbGljZTogZnVuY3Rpb24gc3BsaWNlKHN0YXJ0LCBkZWxldGVDb3VudCkge1xuICAgICAgICB2YXIgTyA9IEVTLlRvT2JqZWN0KHRoaXMpO1xuICAgICAgICB2YXIgQSA9IFtdO1xuICAgICAgICB2YXIgbGVuID0gRVMuVG9VaW50MzIoTy5sZW5ndGgpO1xuICAgICAgICB2YXIgcmVsYXRpdmVTdGFydCA9IEVTLlRvSW50ZWdlcihzdGFydCk7XG4gICAgICAgIHZhciBhY3R1YWxTdGFydCA9IHJlbGF0aXZlU3RhcnQgPCAwID8gbWF4KChsZW4gKyByZWxhdGl2ZVN0YXJ0KSwgMCkgOiBtaW4ocmVsYXRpdmVTdGFydCwgbGVuKTtcbiAgICAgICAgdmFyIGFjdHVhbERlbGV0ZUNvdW50ID0gbWluKG1heChFUy5Ub0ludGVnZXIoZGVsZXRlQ291bnQpLCAwKSwgbGVuIC0gYWN0dWFsU3RhcnQpO1xuXG4gICAgICAgIHZhciBrID0gMDtcbiAgICAgICAgdmFyIGZyb207XG4gICAgICAgIHdoaWxlIChrIDwgYWN0dWFsRGVsZXRlQ291bnQpIHtcbiAgICAgICAgICAgIGZyb20gPSAkU3RyaW5nKGFjdHVhbFN0YXJ0ICsgayk7XG4gICAgICAgICAgICBpZiAob3ducyhPLCBmcm9tKSkge1xuICAgICAgICAgICAgICAgIEFba10gPSBPW2Zyb21dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgayArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGl0ZW1zID0gYXJyYXlfc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgICAgICB2YXIgaXRlbUNvdW50ID0gaXRlbXMubGVuZ3RoO1xuICAgICAgICB2YXIgdG87XG4gICAgICAgIGlmIChpdGVtQ291bnQgPCBhY3R1YWxEZWxldGVDb3VudCkge1xuICAgICAgICAgICAgayA9IGFjdHVhbFN0YXJ0O1xuICAgICAgICAgICAgd2hpbGUgKGsgPCAobGVuIC0gYWN0dWFsRGVsZXRlQ291bnQpKSB7XG4gICAgICAgICAgICAgICAgZnJvbSA9ICRTdHJpbmcoayArIGFjdHVhbERlbGV0ZUNvdW50KTtcbiAgICAgICAgICAgICAgICB0byA9ICRTdHJpbmcoayArIGl0ZW1Db3VudCk7XG4gICAgICAgICAgICAgICAgaWYgKG93bnMoTywgZnJvbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgT1t0b10gPSBPW2Zyb21dO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBPW3RvXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgayArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgayA9IGxlbjtcbiAgICAgICAgICAgIHdoaWxlIChrID4gKGxlbiAtIGFjdHVhbERlbGV0ZUNvdW50ICsgaXRlbUNvdW50KSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBPW2sgLSAxXTtcbiAgICAgICAgICAgICAgICBrIC09IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaXRlbUNvdW50ID4gYWN0dWFsRGVsZXRlQ291bnQpIHtcbiAgICAgICAgICAgIGsgPSBsZW4gLSBhY3R1YWxEZWxldGVDb3VudDtcbiAgICAgICAgICAgIHdoaWxlIChrID4gYWN0dWFsU3RhcnQpIHtcbiAgICAgICAgICAgICAgICBmcm9tID0gJFN0cmluZyhrICsgYWN0dWFsRGVsZXRlQ291bnQgLSAxKTtcbiAgICAgICAgICAgICAgICB0byA9ICRTdHJpbmcoayArIGl0ZW1Db3VudCAtIDEpO1xuICAgICAgICAgICAgICAgIGlmIChvd25zKE8sIGZyb20pKSB7XG4gICAgICAgICAgICAgICAgICAgIE9bdG9dID0gT1tmcm9tXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgT1t0b107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGsgLT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBrID0gYWN0dWFsU3RhcnQ7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIE9ba10gPSBpdGVtc1tpXTtcbiAgICAgICAgICAgIGsgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBPLmxlbmd0aCA9IGxlbiAtIGFjdHVhbERlbGV0ZUNvdW50ICsgaXRlbUNvdW50O1xuXG4gICAgICAgIHJldHVybiBBO1xuICAgIH1cbn0sICFzcGxpY2VXb3Jrc1dpdGhMYXJnZVNwYXJzZUFycmF5cyB8fCAhc3BsaWNlV29ya3NXaXRoU21hbGxTcGFyc2VBcnJheXMpO1xuXG52YXIgaGFzSm9pblVuZGVmaW5lZEJ1ZyA9IFsxLCAyXS5qb2luKHVuZGVmaW5lZCkgIT09ICcxLDInO1xudmFyIG9yaWdpbmFsSm9pbiA9IEFycmF5UHJvdG90eXBlLmpvaW47XG5kZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgam9pbjogZnVuY3Rpb24gam9pbihzZXBhcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsSm9pbi5jYWxsKHRoaXMsIHR5cGVvZiBzZXBhcmF0b3IgPT09ICd1bmRlZmluZWQnID8gJywnIDogc2VwYXJhdG9yKTtcbiAgICB9XG59LCBoYXNKb2luVW5kZWZpbmVkQnVnKTtcblxudmFyIHB1c2hTaGltID0gZnVuY3Rpb24gcHVzaChpdGVtKSB7XG4gICAgdmFyIE8gPSBFUy5Ub09iamVjdCh0aGlzKTtcbiAgICB2YXIgbiA9IEVTLlRvVWludDMyKE8ubGVuZ3RoKTtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIE9bbiArIGldID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBpICs9IDE7XG4gICAgfVxuICAgIE8ubGVuZ3RoID0gbiArIGk7XG4gICAgcmV0dXJuIG4gKyBpO1xufTtcblxudmFyIHB1c2hJc05vdEdlbmVyaWMgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYmogPSB7fTtcbiAgICB2YXIgcmVzdWx0ID0gQXJyYXkucHJvdG90eXBlLnB1c2guY2FsbChvYmosIHVuZGVmaW5lZCk7XG4gICAgcmV0dXJuIHJlc3VsdCAhPT0gMSB8fCBvYmoubGVuZ3RoICE9PSAxIHx8IHR5cGVvZiBvYmpbMF0gIT09ICd1bmRlZmluZWQnIHx8ICFvd25zKG9iaiwgMCk7XG59KCkpO1xuZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgIHB1c2g6IGZ1bmN0aW9uIHB1c2goaXRlbSkge1xuICAgICAgICBpZiAoaXNBcnJheSh0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGFycmF5X3B1c2guYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHVzaFNoaW0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG59LCBwdXNoSXNOb3RHZW5lcmljKTtcblxuLy8gVGhpcyBmaXhlcyBhIHZlcnkgd2VpcmQgYnVnIGluIE9wZXJhIDEwLjYgd2hlbiBwdXNoaW5nIGB1bmRlZmluZWRcbnZhciBwdXNoVW5kZWZpbmVkSXNXZWlyZCA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyciA9IFtdO1xuICAgIHZhciByZXN1bHQgPSBhcnIucHVzaCh1bmRlZmluZWQpO1xuICAgIHJldHVybiByZXN1bHQgIT09IDEgfHwgYXJyLmxlbmd0aCAhPT0gMSB8fCB0eXBlb2YgYXJyWzBdICE9PSAndW5kZWZpbmVkJyB8fCAhb3ducyhhcnIsIDApO1xufSgpKTtcbmRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHsgcHVzaDogcHVzaFNoaW0gfSwgcHVzaFVuZGVmaW5lZElzV2VpcmQpO1xuXG4vL1xuLy8gT2JqZWN0XG4vLyA9PT09PT1cbi8vXG5cbi8vIEVTNSAxNS4yLjMuMTRcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjIuMy4xNFxuXG4vLyBodHRwOi8vd2hhdHRoZWhlYWRzYWlkLmNvbS8yMDEwLzEwL2Etc2FmZXItb2JqZWN0LWtleXMtY29tcGF0aWJpbGl0eS1pbXBsZW1lbnRhdGlvblxudmFyIGhhc0RvbnRFbnVtQnVnID0gISh7ICd0b1N0cmluZyc6IG51bGwgfSkucHJvcGVydHlJc0VudW1lcmFibGUoJ3RvU3RyaW5nJyk7XG52YXIgaGFzUHJvdG9FbnVtQnVnID0gZnVuY3Rpb24gKCkge30ucHJvcGVydHlJc0VudW1lcmFibGUoJ3Byb3RvdHlwZScpO1xudmFyIGhhc1N0cmluZ0VudW1CdWcgPSAhb3ducygneCcsICcwJyk7XG52YXIgZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUgPSBmdW5jdGlvbiAobykge1xuICAgIHZhciBjdG9yID0gby5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvciAmJiBjdG9yLnByb3RvdHlwZSA9PT0gbztcbn07XG52YXIgYmxhY2tsaXN0ZWRLZXlzID0ge1xuICAgICR3aW5kb3c6IHRydWUsXG4gICAgJGNvbnNvbGU6IHRydWUsXG4gICAgJHBhcmVudDogdHJ1ZSxcbiAgICAkc2VsZjogdHJ1ZSxcbiAgICAkZnJhbWU6IHRydWUsXG4gICAgJGZyYW1lczogdHJ1ZSxcbiAgICAkZnJhbWVFbGVtZW50OiB0cnVlLFxuICAgICR3ZWJraXRJbmRleGVkREI6IHRydWUsXG4gICAgJHdlYmtpdFN0b3JhZ2VJbmZvOiB0cnVlXG59O1xudmFyIGhhc0F1dG9tYXRpb25FcXVhbGl0eUJ1ZyA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyogZ2xvYmFscyB3aW5kb3cgKi9cbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZm9yICh2YXIgayBpbiB3aW5kb3cpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghYmxhY2tsaXN0ZWRLZXlzWyckJyArIGtdICYmIG93bnMod2luZG93LCBrKSAmJiB3aW5kb3dba10gIT09IG51bGwgJiYgdHlwZW9mIHdpbmRvd1trXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZSh3aW5kb3dba10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59KCkpO1xudmFyIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlSWZOb3RCdWdneSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgIWhhc0F1dG9tYXRpb25FcXVhbGl0eUJ1ZykgeyByZXR1cm4gZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUob2JqZWN0KTsgfVxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZShvYmplY3QpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn07XG52YXIgZG9udEVudW1zID0gW1xuICAgICd0b1N0cmluZycsXG4gICAgJ3RvTG9jYWxlU3RyaW5nJyxcbiAgICAndmFsdWVPZicsXG4gICAgJ2hhc093blByb3BlcnR5JyxcbiAgICAnaXNQcm90b3R5cGVPZicsXG4gICAgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJyxcbiAgICAnY29uc3RydWN0b3InXG5dO1xudmFyIGRvbnRFbnVtc0xlbmd0aCA9IGRvbnRFbnVtcy5sZW5ndGg7XG5cbi8vIHRha2VuIGRpcmVjdGx5IGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2xqaGFyYi9pcy1hcmd1bWVudHMvYmxvYi9tYXN0ZXIvaW5kZXguanNcbi8vIGNhbiBiZSByZXBsYWNlZCB3aXRoIHJlcXVpcmUoJ2lzLWFyZ3VtZW50cycpIGlmIHdlIGV2ZXIgdXNlIGEgYnVpbGQgcHJvY2VzcyBpbnN0ZWFkXG52YXIgaXNTdGFuZGFyZEFyZ3VtZW50cyA9IGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRvU3RyKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG59O1xudmFyIGlzTGVnYWN5QXJndW1lbnRzID0gZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICB0eXBlb2YgdmFsdWUubGVuZ3RoID09PSAnbnVtYmVyJyAmJlxuICAgICAgICB2YWx1ZS5sZW5ndGggPj0gMCAmJlxuICAgICAgICAhaXNBcnJheSh2YWx1ZSkgJiZcbiAgICAgICAgaXNDYWxsYWJsZSh2YWx1ZS5jYWxsZWUpO1xufTtcbnZhciBpc0FyZ3VtZW50cyA9IGlzU3RhbmRhcmRBcmd1bWVudHMoYXJndW1lbnRzKSA/IGlzU3RhbmRhcmRBcmd1bWVudHMgOiBpc0xlZ2FjeUFyZ3VtZW50cztcblxuZGVmaW5lUHJvcGVydGllcygkT2JqZWN0LCB7XG4gICAga2V5czogZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgICAgICAgdmFyIGlzRm4gPSBpc0NhbGxhYmxlKG9iamVjdCk7XG4gICAgICAgIHZhciBpc0FyZ3MgPSBpc0FyZ3VtZW50cyhvYmplY3QpO1xuICAgICAgICB2YXIgaXNPYmplY3QgPSBvYmplY3QgIT09IG51bGwgJiYgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCc7XG4gICAgICAgIHZhciBpc1N0ciA9IGlzT2JqZWN0ICYmIGlzU3RyaW5nKG9iamVjdCk7XG5cbiAgICAgICAgaWYgKCFpc09iamVjdCAmJiAhaXNGbiAmJiAhaXNBcmdzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3Qua2V5cyBjYWxsZWQgb24gYSBub24tb2JqZWN0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGhlS2V5cyA9IFtdO1xuICAgICAgICB2YXIgc2tpcFByb3RvID0gaGFzUHJvdG9FbnVtQnVnICYmIGlzRm47XG4gICAgICAgIGlmICgoaXNTdHIgJiYgaGFzU3RyaW5nRW51bUJ1ZykgfHwgaXNBcmdzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHB1c2godGhlS2V5cywgJFN0cmluZyhpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzQXJncykge1xuICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShza2lwUHJvdG8gJiYgbmFtZSA9PT0gJ3Byb3RvdHlwZScpICYmIG93bnMob2JqZWN0LCBuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBwdXNoKHRoZUtleXMsICRTdHJpbmcobmFtZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNEb250RW51bUJ1Zykge1xuICAgICAgICAgICAgdmFyIHNraXBDb25zdHJ1Y3RvciA9IGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlSWZOb3RCdWdneShvYmplY3QpO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkb250RW51bXNMZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHZhciBkb250RW51bSA9IGRvbnRFbnVtc1tqXTtcbiAgICAgICAgICAgICAgICBpZiAoIShza2lwQ29uc3RydWN0b3IgJiYgZG9udEVudW0gPT09ICdjb25zdHJ1Y3RvcicpICYmIG93bnMob2JqZWN0LCBkb250RW51bSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcHVzaCh0aGVLZXlzLCBkb250RW51bSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGVLZXlzO1xuICAgIH1cbn0pO1xuXG52YXIga2V5c1dvcmtzV2l0aEFyZ3VtZW50cyA9ICRPYmplY3Qua2V5cyAmJiAoZnVuY3Rpb24gKCkge1xuICAgIC8vIFNhZmFyaSA1LjAgYnVnXG4gICAgcmV0dXJuICRPYmplY3Qua2V5cyhhcmd1bWVudHMpLmxlbmd0aCA9PT0gMjtcbn0oMSwgMikpO1xudmFyIGtleXNIYXNBcmd1bWVudHNMZW5ndGhCdWcgPSAkT2JqZWN0LmtleXMgJiYgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJnS2V5cyA9ICRPYmplY3Qua2V5cyhhcmd1bWVudHMpO1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoICE9PSAxIHx8IGFyZ0tleXMubGVuZ3RoICE9PSAxIHx8IGFyZ0tleXNbMF0gIT09IDE7XG59KDEpKTtcbnZhciBvcmlnaW5hbEtleXMgPSAkT2JqZWN0LmtleXM7XG5kZWZpbmVQcm9wZXJ0aWVzKCRPYmplY3QsIHtcbiAgICBrZXlzOiBmdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICAgICAgICBpZiAoaXNBcmd1bWVudHMob2JqZWN0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsS2V5cyhhcnJheV9zbGljZS5jYWxsKG9iamVjdCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsS2V5cyhvYmplY3QpO1xuICAgICAgICB9XG4gICAgfVxufSwgIWtleXNXb3Jrc1dpdGhBcmd1bWVudHMgfHwga2V5c0hhc0FyZ3VtZW50c0xlbmd0aEJ1Zyk7XG5cbi8vXG4vLyBEYXRlXG4vLyA9PT09XG4vL1xuXG4vLyBFUzUgMTUuOS41LjQzXG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS45LjUuNDNcbi8vIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIFN0cmluZyB2YWx1ZSByZXByZXNlbnQgdGhlIGluc3RhbmNlIGluIHRpbWVcbi8vIHJlcHJlc2VudGVkIGJ5IHRoaXMgRGF0ZSBvYmplY3QuIFRoZSBmb3JtYXQgb2YgdGhlIFN0cmluZyBpcyB0aGUgRGF0ZSBUaW1lXG4vLyBzdHJpbmcgZm9ybWF0IGRlZmluZWQgaW4gMTUuOS4xLjE1LiBBbGwgZmllbGRzIGFyZSBwcmVzZW50IGluIHRoZSBTdHJpbmcuXG4vLyBUaGUgdGltZSB6b25lIGlzIGFsd2F5cyBVVEMsIGRlbm90ZWQgYnkgdGhlIHN1ZmZpeCBaLiBJZiB0aGUgdGltZSB2YWx1ZSBvZlxuLy8gdGhpcyBvYmplY3QgaXMgbm90IGEgZmluaXRlIE51bWJlciBhIFJhbmdlRXJyb3IgZXhjZXB0aW9uIGlzIHRocm93bi5cbnZhciBuZWdhdGl2ZURhdGUgPSAtNjIxOTg3NTUyMDAwMDA7XG52YXIgbmVnYXRpdmVZZWFyU3RyaW5nID0gJy0wMDAwMDEnO1xudmFyIGhhc05lZ2F0aXZlRGF0ZUJ1ZyA9IERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nICYmIG5ldyBEYXRlKG5lZ2F0aXZlRGF0ZSkudG9JU09TdHJpbmcoKS5pbmRleE9mKG5lZ2F0aXZlWWVhclN0cmluZykgPT09IC0xO1xudmFyIGhhc1NhZmFyaTUxRGF0ZUJ1ZyA9IERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nICYmIG5ldyBEYXRlKC0xKS50b0lTT1N0cmluZygpICE9PSAnMTk2OS0xMi0zMVQyMzo1OTo1OS45OTlaJztcblxuZGVmaW5lUHJvcGVydGllcyhEYXRlLnByb3RvdHlwZSwge1xuICAgIHRvSVNPU3RyaW5nOiBmdW5jdGlvbiB0b0lTT1N0cmluZygpIHtcbiAgICAgICAgdmFyIHJlc3VsdCwgbGVuZ3RoLCB2YWx1ZSwgeWVhciwgbW9udGg7XG4gICAgICAgIGlmICghaXNGaW5pdGUodGhpcykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZyBjYWxsZWQgb24gbm9uLWZpbml0ZSB2YWx1ZS4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHllYXIgPSB0aGlzLmdldFVUQ0Z1bGxZZWFyKCk7XG5cbiAgICAgICAgbW9udGggPSB0aGlzLmdldFVUQ01vbnRoKCk7XG4gICAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0vaXNzdWVzLzExMVxuICAgICAgICB5ZWFyICs9IE1hdGguZmxvb3IobW9udGggLyAxMik7XG4gICAgICAgIG1vbnRoID0gKG1vbnRoICUgMTIgKyAxMikgJSAxMjtcblxuICAgICAgICAvLyB0aGUgZGF0ZSB0aW1lIHN0cmluZyBmb3JtYXQgaXMgc3BlY2lmaWVkIGluIDE1LjkuMS4xNS5cbiAgICAgICAgcmVzdWx0ID0gW21vbnRoICsgMSwgdGhpcy5nZXRVVENEYXRlKCksIHRoaXMuZ2V0VVRDSG91cnMoKSwgdGhpcy5nZXRVVENNaW51dGVzKCksIHRoaXMuZ2V0VVRDU2Vjb25kcygpXTtcbiAgICAgICAgeWVhciA9IChcbiAgICAgICAgICAgICh5ZWFyIDwgMCA/ICctJyA6ICh5ZWFyID4gOTk5OSA/ICcrJyA6ICcnKSkgK1xuICAgICAgICAgICAgc3RyU2xpY2UoJzAwMDAwJyArIE1hdGguYWJzKHllYXIpLCAoMCA8PSB5ZWFyICYmIHllYXIgPD0gOTk5OSkgPyAtNCA6IC02KVxuICAgICAgICApO1xuXG4gICAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAgICAgdmFsdWUgPSByZXN1bHRbbGVuZ3RoXTtcbiAgICAgICAgICAgIC8vIHBhZCBtb250aHMsIGRheXMsIGhvdXJzLCBtaW51dGVzLCBhbmQgc2Vjb25kcyB0byBoYXZlIHR3b1xuICAgICAgICAgICAgLy8gZGlnaXRzLlxuICAgICAgICAgICAgaWYgKHZhbHVlIDwgMTApIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbbGVuZ3RoXSA9ICcwJyArIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHBhZCBtaWxsaXNlY29uZHMgdG8gaGF2ZSB0aHJlZSBkaWdpdHMuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB5ZWFyICsgJy0nICsgYXJyYXlfc2xpY2UuY2FsbChyZXN1bHQsIDAsIDIpLmpvaW4oJy0nKSArXG4gICAgICAgICAgICAnVCcgKyBhcnJheV9zbGljZS5jYWxsKHJlc3VsdCwgMikuam9pbignOicpICsgJy4nICtcbiAgICAgICAgICAgIHN0clNsaWNlKCcwMDAnICsgdGhpcy5nZXRVVENNaWxsaXNlY29uZHMoKSwgLTMpICsgJ1onXG4gICAgICAgICk7XG4gICAgfVxufSwgaGFzTmVnYXRpdmVEYXRlQnVnIHx8IGhhc1NhZmFyaTUxRGF0ZUJ1Zyk7XG5cbi8vIEVTNSAxNS45LjUuNDRcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjkuNS40NFxuLy8gVGhpcyBmdW5jdGlvbiBwcm92aWRlcyBhIFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIERhdGUgb2JqZWN0IGZvciB1c2UgYnlcbi8vIEpTT04uc3RyaW5naWZ5ICgxNS4xMi4zKS5cbnZhciBkYXRlVG9KU09OSXNTdXBwb3J0ZWQgPSAoZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBEYXRlLnByb3RvdHlwZS50b0pTT04gJiZcbiAgICAgICAgICAgIG5ldyBEYXRlKE5hTikudG9KU09OKCkgPT09IG51bGwgJiZcbiAgICAgICAgICAgIG5ldyBEYXRlKG5lZ2F0aXZlRGF0ZSkudG9KU09OKCkuaW5kZXhPZihuZWdhdGl2ZVllYXJTdHJpbmcpICE9PSAtMSAmJlxuICAgICAgICAgICAgRGF0ZS5wcm90b3R5cGUudG9KU09OLmNhbGwoeyAvLyBnZW5lcmljXG4gICAgICAgICAgICAgICAgdG9JU09TdHJpbmc6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH1cbiAgICAgICAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn0oKSk7XG5pZiAoIWRhdGVUb0pTT05Jc1N1cHBvcnRlZCkge1xuICAgIERhdGUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTihrZXkpIHtcbiAgICAgICAgLy8gV2hlbiB0aGUgdG9KU09OIG1ldGhvZCBpcyBjYWxsZWQgd2l0aCBhcmd1bWVudCBrZXksIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgLy8gc3RlcHMgYXJlIHRha2VuOlxuXG4gICAgICAgIC8vIDEuICBMZXQgTyBiZSB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgVG9PYmplY3QsIGdpdmluZyBpdCB0aGUgdGhpc1xuICAgICAgICAvLyB2YWx1ZSBhcyBpdHMgYXJndW1lbnQuXG4gICAgICAgIC8vIDIuIExldCB0diBiZSBFUy5Ub1ByaW1pdGl2ZShPLCBoaW50IE51bWJlcikuXG4gICAgICAgIHZhciBPID0gJE9iamVjdCh0aGlzKTtcbiAgICAgICAgdmFyIHR2ID0gRVMuVG9QcmltaXRpdmUoTyk7XG4gICAgICAgIC8vIDMuIElmIHR2IGlzIGEgTnVtYmVyIGFuZCBpcyBub3QgZmluaXRlLCByZXR1cm4gbnVsbC5cbiAgICAgICAgaWYgKHR5cGVvZiB0diA9PT0gJ251bWJlcicgJiYgIWlzRmluaXRlKHR2KSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gNC4gTGV0IHRvSVNPIGJlIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgW1tHZXRdXSBpbnRlcm5hbCBtZXRob2Qgb2ZcbiAgICAgICAgLy8gTyB3aXRoIGFyZ3VtZW50IFwidG9JU09TdHJpbmdcIi5cbiAgICAgICAgdmFyIHRvSVNPID0gTy50b0lTT1N0cmluZztcbiAgICAgICAgLy8gNS4gSWYgSXNDYWxsYWJsZSh0b0lTTykgaXMgZmFsc2UsIHRocm93IGEgVHlwZUVycm9yIGV4Y2VwdGlvbi5cbiAgICAgICAgaWYgKCFpc0NhbGxhYmxlKHRvSVNPKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndG9JU09TdHJpbmcgcHJvcGVydHkgaXMgbm90IGNhbGxhYmxlJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gNi4gUmV0dXJuIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgW1tDYWxsXV0gaW50ZXJuYWwgbWV0aG9kIG9mXG4gICAgICAgIC8vICB0b0lTTyB3aXRoIE8gYXMgdGhlIHRoaXMgdmFsdWUgYW5kIGFuIGVtcHR5IGFyZ3VtZW50IGxpc3QuXG4gICAgICAgIHJldHVybiB0b0lTTy5jYWxsKE8pO1xuXG4gICAgICAgIC8vIE5PVEUgMSBUaGUgYXJndW1lbnQgaXMgaWdub3JlZC5cblxuICAgICAgICAvLyBOT1RFIDIgVGhlIHRvSlNPTiBmdW5jdGlvbiBpcyBpbnRlbnRpb25hbGx5IGdlbmVyaWM7IGl0IGRvZXMgbm90XG4gICAgICAgIC8vIHJlcXVpcmUgdGhhdCBpdHMgdGhpcyB2YWx1ZSBiZSBhIERhdGUgb2JqZWN0LiBUaGVyZWZvcmUsIGl0IGNhbiBiZVxuICAgICAgICAvLyB0cmFuc2ZlcnJlZCB0byBvdGhlciBraW5kcyBvZiBvYmplY3RzIGZvciB1c2UgYXMgYSBtZXRob2QuIEhvd2V2ZXIsXG4gICAgICAgIC8vIGl0IGRvZXMgcmVxdWlyZSB0aGF0IGFueSBzdWNoIG9iamVjdCBoYXZlIGEgdG9JU09TdHJpbmcgbWV0aG9kLiBBblxuICAgICAgICAvLyBvYmplY3QgaXMgZnJlZSB0byB1c2UgdGhlIGFyZ3VtZW50IGtleSB0byBmaWx0ZXIgaXRzXG4gICAgICAgIC8vIHN0cmluZ2lmaWNhdGlvbi5cbiAgICB9O1xufVxuXG4vLyBFUzUgMTUuOS40LjJcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjkuNC4yXG4vLyBiYXNlZCBvbiB3b3JrIHNoYXJlZCBieSBEYW5pZWwgRnJpZXNlbiAoZGFudG1hbilcbi8vIGh0dHA6Ly9naXN0LmdpdGh1Yi5jb20vMzAzMjQ5XG52YXIgc3VwcG9ydHNFeHRlbmRlZFllYXJzID0gRGF0ZS5wYXJzZSgnKzAzMzY1OC0wOS0yN1QwMTo0Njo0MC4wMDBaJykgPT09IDFlMTU7XG52YXIgYWNjZXB0c0ludmFsaWREYXRlcyA9ICFpc05hTihEYXRlLnBhcnNlKCcyMDEyLTA0LTA0VDI0OjAwOjAwLjUwMFonKSkgfHwgIWlzTmFOKERhdGUucGFyc2UoJzIwMTItMTEtMzFUMjM6NTk6NTkuMDAwWicpKSB8fCAhaXNOYU4oRGF0ZS5wYXJzZSgnMjAxMi0xMi0zMVQyMzo1OTo2MC4wMDBaJykpO1xudmFyIGRvZXNOb3RQYXJzZVkyS05ld1llYXIgPSBpc05hTihEYXRlLnBhcnNlKCcyMDAwLTAxLTAxVDAwOjAwOjAwLjAwMFonKSk7XG5pZiAoZG9lc05vdFBhcnNlWTJLTmV3WWVhciB8fCBhY2NlcHRzSW52YWxpZERhdGVzIHx8ICFzdXBwb3J0c0V4dGVuZGVkWWVhcnMpIHtcbiAgICAvLyBYWFggZ2xvYmFsIGFzc2lnbm1lbnQgd29uJ3Qgd29yayBpbiBlbWJlZGRpbmdzIHRoYXQgdXNlXG4gICAgLy8gYW4gYWx0ZXJuYXRlIG9iamVjdCBmb3IgdGhlIGNvbnRleHQuXG4gICAgLyogZ2xvYmFsIERhdGU6IHRydWUgKi9cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlZiAqL1xuICAgIHZhciBtYXhTYWZlVW5zaWduZWQzMkJpdCA9IE1hdGgucG93KDIsIDMxKSAtIDE7XG4gICAgdmFyIHNlY29uZHNXaXRoaW5NYXhTYWZlVW5zaWduZWQzMkJpdCA9IE1hdGguZmxvb3IobWF4U2FmZVVuc2lnbmVkMzJCaXQgLyAxZTMpO1xuICAgIHZhciBoYXNTYWZhcmlTaWduZWRJbnRCdWcgPSBpc0FjdHVhbE5hTihuZXcgRGF0ZSgxOTcwLCAwLCAxLCAwLCAwLCAwLCBtYXhTYWZlVW5zaWduZWQzMkJpdCArIDEpLmdldFRpbWUoKSk7XG4gICAgRGF0ZSA9IChmdW5jdGlvbiAoTmF0aXZlRGF0ZSkge1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW5kZWYgKi9cbiAgICAgICAgLy8gRGF0ZS5sZW5ndGggPT09IDdcbiAgICAgICAgdmFyIERhdGVTaGltID0gZnVuY3Rpb24gRGF0ZShZLCBNLCBELCBoLCBtLCBzLCBtcykge1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgZGF0ZTtcbiAgICAgICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgTmF0aXZlRGF0ZSkge1xuICAgICAgICAgICAgICAgIHZhciBzZWNvbmRzID0gcztcbiAgICAgICAgICAgICAgICB2YXIgbWlsbGlzID0gbXM7XG4gICAgICAgICAgICAgICAgaWYgKGhhc1NhZmFyaVNpZ25lZEludEJ1ZyAmJiBsZW5ndGggPj0gNyAmJiBtcyA+IG1heFNhZmVVbnNpZ25lZDMyQml0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdvcmsgYXJvdW5kIGEgU2FmYXJpIDgvOSBidWcgd2hlcmUgaXQgdHJlYXRzIHRoZSBzZWNvbmRzIGFzIHNpZ25lZFxuICAgICAgICAgICAgICAgICAgICB2YXIgbXNUb1NoaWZ0ID0gTWF0aC5mbG9vcihtcyAvIG1heFNhZmVVbnNpZ25lZDMyQml0KSAqIG1heFNhZmVVbnNpZ25lZDMyQml0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgc1RvU2hpZnQgPSBNYXRoLmZsb29yKG1zVG9TaGlmdCAvIDFlMyk7XG4gICAgICAgICAgICAgICAgICAgIHNlY29uZHMgKz0gc1RvU2hpZnQ7XG4gICAgICAgICAgICAgICAgICAgIG1pbGxpcyAtPSBzVG9TaGlmdCAqIDFlMztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGF0ZSA9IGxlbmd0aCA9PT0gMSAmJiAkU3RyaW5nKFkpID09PSBZID8gLy8gaXNTdHJpbmcoWSlcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgZXhwbGljaXRseSBwYXNzIGl0IHRocm91Z2ggcGFyc2U6XG4gICAgICAgICAgICAgICAgICAgIG5ldyBOYXRpdmVEYXRlKERhdGVTaGltLnBhcnNlKFkpKSA6XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgdG8gbWFudWFsbHkgbWFrZSBjYWxscyBkZXBlbmRpbmcgb24gYXJndW1lbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gbGVuZ3RoIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID49IDcgPyBuZXcgTmF0aXZlRGF0ZShZLCBNLCBELCBoLCBtLCBzZWNvbmRzLCBtaWxsaXMpIDpcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID49IDYgPyBuZXcgTmF0aXZlRGF0ZShZLCBNLCBELCBoLCBtLCBzZWNvbmRzKSA6XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA+PSA1ID8gbmV3IE5hdGl2ZURhdGUoWSwgTSwgRCwgaCwgbSkgOlxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPj0gNCA/IG5ldyBOYXRpdmVEYXRlKFksIE0sIEQsIGgpIDpcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID49IDMgPyBuZXcgTmF0aXZlRGF0ZShZLCBNLCBEKSA6XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA+PSAyID8gbmV3IE5hdGl2ZURhdGUoWSwgTSkgOlxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPj0gMSA/IG5ldyBOYXRpdmVEYXRlKFkpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgTmF0aXZlRGF0ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRlID0gTmF0aXZlRGF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc1ByaW1pdGl2ZShkYXRlKSkge1xuICAgICAgICAgICAgICAvLyBQcmV2ZW50IG1peHVwcyB3aXRoIHVuZml4ZWQgRGF0ZSBvYmplY3RcbiAgICAgICAgICAgICAgZGVmaW5lUHJvcGVydGllcyhkYXRlLCB7IGNvbnN0cnVjdG9yOiBEYXRlU2hpbSB9LCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkYXRlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIDE1LjkuMS4xNSBEYXRlIFRpbWUgU3RyaW5nIEZvcm1hdC5cbiAgICAgICAgdmFyIGlzb0RhdGVFeHByZXNzaW9uID0gbmV3IFJlZ0V4cCgnXicgK1xuICAgICAgICAgICAgJyhcXFxcZHs0fXxbKy1dXFxcXGR7Nn0pJyArIC8vIGZvdXItZGlnaXQgeWVhciBjYXB0dXJlIG9yIHNpZ24gK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA2LWRpZ2l0IGV4dGVuZGVkIHllYXJcbiAgICAgICAgICAgICcoPzotKFxcXFxkezJ9KScgKyAvLyBvcHRpb25hbCBtb250aCBjYXB0dXJlXG4gICAgICAgICAgICAnKD86LShcXFxcZHsyfSknICsgLy8gb3B0aW9uYWwgZGF5IGNhcHR1cmVcbiAgICAgICAgICAgICcoPzonICsgLy8gY2FwdHVyZSBob3VyczptaW51dGVzOnNlY29uZHMubWlsbGlzZWNvbmRzXG4gICAgICAgICAgICAgICAgJ1QoXFxcXGR7Mn0pJyArIC8vIGhvdXJzIGNhcHR1cmVcbiAgICAgICAgICAgICAgICAnOihcXFxcZHsyfSknICsgLy8gbWludXRlcyBjYXB0dXJlXG4gICAgICAgICAgICAgICAgJyg/OicgKyAvLyBvcHRpb25hbCA6c2Vjb25kcy5taWxsaXNlY29uZHNcbiAgICAgICAgICAgICAgICAgICAgJzooXFxcXGR7Mn0pJyArIC8vIHNlY29uZHMgY2FwdHVyZVxuICAgICAgICAgICAgICAgICAgICAnKD86KFxcXFwuXFxcXGR7MSx9KSk/JyArIC8vIG1pbGxpc2Vjb25kcyBjYXB0dXJlXG4gICAgICAgICAgICAgICAgJyk/JyArXG4gICAgICAgICAgICAnKCcgKyAvLyBjYXB0dXJlIFVUQyBvZmZzZXQgY29tcG9uZW50XG4gICAgICAgICAgICAgICAgJ1p8JyArIC8vIFVUQyBjYXB0dXJlXG4gICAgICAgICAgICAgICAgJyg/OicgKyAvLyBvZmZzZXQgc3BlY2lmaWVyICsvLWhvdXJzOm1pbnV0ZXNcbiAgICAgICAgICAgICAgICAgICAgJyhbLStdKScgKyAvLyBzaWduIGNhcHR1cmVcbiAgICAgICAgICAgICAgICAgICAgJyhcXFxcZHsyfSknICsgLy8gaG91cnMgb2Zmc2V0IGNhcHR1cmVcbiAgICAgICAgICAgICAgICAgICAgJzooXFxcXGR7Mn0pJyArIC8vIG1pbnV0ZXMgb2Zmc2V0IGNhcHR1cmVcbiAgICAgICAgICAgICAgICAnKScgK1xuICAgICAgICAgICAgJyk/KT8pPyk/JyArXG4gICAgICAgICckJyk7XG5cbiAgICAgICAgdmFyIG1vbnRocyA9IFswLCAzMSwgNTksIDkwLCAxMjAsIDE1MSwgMTgxLCAyMTIsIDI0MywgMjczLCAzMDQsIDMzNCwgMzY1XTtcblxuICAgICAgICB2YXIgZGF5RnJvbU1vbnRoID0gZnVuY3Rpb24gZGF5RnJvbU1vbnRoKHllYXIsIG1vbnRoKSB7XG4gICAgICAgICAgICB2YXIgdCA9IG1vbnRoID4gMSA/IDEgOiAwO1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICBtb250aHNbbW9udGhdICtcbiAgICAgICAgICAgICAgICBNYXRoLmZsb29yKCh5ZWFyIC0gMTk2OSArIHQpIC8gNCkgLVxuICAgICAgICAgICAgICAgIE1hdGguZmxvb3IoKHllYXIgLSAxOTAxICsgdCkgLyAxMDApICtcbiAgICAgICAgICAgICAgICBNYXRoLmZsb29yKCh5ZWFyIC0gMTYwMSArIHQpIC8gNDAwKSArXG4gICAgICAgICAgICAgICAgMzY1ICogKHllYXIgLSAxOTcwKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgdG9VVEMgPSBmdW5jdGlvbiB0b1VUQyh0KSB7XG4gICAgICAgICAgICB2YXIgcyA9IDA7XG4gICAgICAgICAgICB2YXIgbXMgPSB0O1xuICAgICAgICAgICAgaWYgKGhhc1NhZmFyaVNpZ25lZEludEJ1ZyAmJiBtcyA+IG1heFNhZmVVbnNpZ25lZDMyQml0KSB7XG4gICAgICAgICAgICAgICAgLy8gd29yayBhcm91bmQgYSBTYWZhcmkgOC85IGJ1ZyB3aGVyZSBpdCB0cmVhdHMgdGhlIHNlY29uZHMgYXMgc2lnbmVkXG4gICAgICAgICAgICAgICAgdmFyIG1zVG9TaGlmdCA9IE1hdGguZmxvb3IobXMgLyBtYXhTYWZlVW5zaWduZWQzMkJpdCkgKiBtYXhTYWZlVW5zaWduZWQzMkJpdDtcbiAgICAgICAgICAgICAgICB2YXIgc1RvU2hpZnQgPSBNYXRoLmZsb29yKG1zVG9TaGlmdCAvIDFlMyk7XG4gICAgICAgICAgICAgICAgcyArPSBzVG9TaGlmdDtcbiAgICAgICAgICAgICAgICBtcyAtPSBzVG9TaGlmdCAqIDFlMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAkTnVtYmVyKG5ldyBOYXRpdmVEYXRlKDE5NzAsIDAsIDEsIDAsIDAsIHMsIG1zKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQ29weSBhbnkgY3VzdG9tIG1ldGhvZHMgYSAzcmQgcGFydHkgbGlicmFyeSBtYXkgaGF2ZSBhZGRlZFxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gTmF0aXZlRGF0ZSkge1xuICAgICAgICAgICAgaWYgKG93bnMoTmF0aXZlRGF0ZSwga2V5KSkge1xuICAgICAgICAgICAgICAgIERhdGVTaGltW2tleV0gPSBOYXRpdmVEYXRlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb3B5IFwibmF0aXZlXCIgbWV0aG9kcyBleHBsaWNpdGx5OyB0aGV5IG1heSBiZSBub24tZW51bWVyYWJsZVxuICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKERhdGVTaGltLCB7XG4gICAgICAgICAgICBub3c6IE5hdGl2ZURhdGUubm93LFxuICAgICAgICAgICAgVVRDOiBOYXRpdmVEYXRlLlVUQ1xuICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgRGF0ZVNoaW0ucHJvdG90eXBlID0gTmF0aXZlRGF0ZS5wcm90b3R5cGU7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXMoRGF0ZVNoaW0ucHJvdG90eXBlLCB7XG4gICAgICAgICAgICBjb25zdHJ1Y3RvcjogRGF0ZVNoaW1cbiAgICAgICAgfSwgdHJ1ZSk7XG5cbiAgICAgICAgLy8gVXBncmFkZSBEYXRlLnBhcnNlIHRvIGhhbmRsZSBzaW1wbGlmaWVkIElTTyA4NjAxIHN0cmluZ3NcbiAgICAgICAgdmFyIHBhcnNlU2hpbSA9IGZ1bmN0aW9uIHBhcnNlKHN0cmluZykge1xuICAgICAgICAgICAgdmFyIG1hdGNoID0gaXNvRGF0ZUV4cHJlc3Npb24uZXhlYyhzdHJpbmcpO1xuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgLy8gcGFyc2UgbW9udGhzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcywgYW5kIG1pbGxpc2Vjb25kc1xuICAgICAgICAgICAgICAgIC8vIHByb3ZpZGUgZGVmYXVsdCB2YWx1ZXMgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgICAgICAgLy8gcGFyc2UgdGhlIFVUQyBvZmZzZXQgY29tcG9uZW50XG4gICAgICAgICAgICAgICAgdmFyIHllYXIgPSAkTnVtYmVyKG1hdGNoWzFdKSxcbiAgICAgICAgICAgICAgICAgICAgbW9udGggPSAkTnVtYmVyKG1hdGNoWzJdIHx8IDEpIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgZGF5ID0gJE51bWJlcihtYXRjaFszXSB8fCAxKSAtIDEsXG4gICAgICAgICAgICAgICAgICAgIGhvdXIgPSAkTnVtYmVyKG1hdGNoWzRdIHx8IDApLFxuICAgICAgICAgICAgICAgICAgICBtaW51dGUgPSAkTnVtYmVyKG1hdGNoWzVdIHx8IDApLFxuICAgICAgICAgICAgICAgICAgICBzZWNvbmQgPSAkTnVtYmVyKG1hdGNoWzZdIHx8IDApLFxuICAgICAgICAgICAgICAgICAgICBtaWxsaXNlY29uZCA9IE1hdGguZmxvb3IoJE51bWJlcihtYXRjaFs3XSB8fCAwKSAqIDEwMDApLFxuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHRpbWUgem9uZSBpcyBtaXNzZWQsIGxvY2FsIG9mZnNldCBzaG91bGQgYmUgdXNlZFxuICAgICAgICAgICAgICAgICAgICAvLyAoRVMgNS4xIGJ1ZylcbiAgICAgICAgICAgICAgICAgICAgLy8gc2VlIGh0dHBzOi8vYnVncy5lY21hc2NyaXB0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTEyXG4gICAgICAgICAgICAgICAgICAgIGlzTG9jYWxUaW1lID0gQm9vbGVhbihtYXRjaFs0XSAmJiAhbWF0Y2hbOF0pLFxuICAgICAgICAgICAgICAgICAgICBzaWduT2Zmc2V0ID0gbWF0Y2hbOV0gPT09ICctJyA/IDEgOiAtMSxcbiAgICAgICAgICAgICAgICAgICAgaG91ck9mZnNldCA9ICROdW1iZXIobWF0Y2hbMTBdIHx8IDApLFxuICAgICAgICAgICAgICAgICAgICBtaW51dGVPZmZzZXQgPSAkTnVtYmVyKG1hdGNoWzExXSB8fCAwKSxcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0O1xuICAgICAgICAgICAgICAgIHZhciBoYXNNaW51dGVzT3JTZWNvbmRzT3JNaWxsaXNlY29uZHMgPSBtaW51dGUgPiAwIHx8IHNlY29uZCA+IDAgfHwgbWlsbGlzZWNvbmQgPiAwO1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgaG91ciA8IChoYXNNaW51dGVzT3JTZWNvbmRzT3JNaWxsaXNlY29uZHMgPyAyNCA6IDI1KSAmJlxuICAgICAgICAgICAgICAgICAgICBtaW51dGUgPCA2MCAmJiBzZWNvbmQgPCA2MCAmJiBtaWxsaXNlY29uZCA8IDEwMDAgJiZcbiAgICAgICAgICAgICAgICAgICAgbW9udGggPiAtMSAmJiBtb250aCA8IDEyICYmIGhvdXJPZmZzZXQgPCAyNCAmJlxuICAgICAgICAgICAgICAgICAgICBtaW51dGVPZmZzZXQgPCA2MCAmJiAvLyBkZXRlY3QgaW52YWxpZCBvZmZzZXRzXG4gICAgICAgICAgICAgICAgICAgIGRheSA+IC0xICYmXG4gICAgICAgICAgICAgICAgICAgIGRheSA8IChkYXlGcm9tTW9udGgoeWVhciwgbW9udGggKyAxKSAtIGRheUZyb21Nb250aCh5ZWFyLCBtb250aCkpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IChcbiAgICAgICAgICAgICAgICAgICAgICAgIChkYXlGcm9tTW9udGgoeWVhciwgbW9udGgpICsgZGF5KSAqIDI0ICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvdXIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgaG91ck9mZnNldCAqIHNpZ25PZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgKSAqIDYwO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSAoXG4gICAgICAgICAgICAgICAgICAgICAgICAocmVzdWx0ICsgbWludXRlICsgbWludXRlT2Zmc2V0ICogc2lnbk9mZnNldCkgKiA2MCArXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWNvbmRcbiAgICAgICAgICAgICAgICAgICAgKSAqIDEwMDAgKyBtaWxsaXNlY29uZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTG9jYWxUaW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0b1VUQyhyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICgtOC42NGUxNSA8PSByZXN1bHQgJiYgcmVzdWx0IDw9IDguNjRlMTUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBOYXRpdmVEYXRlLnBhcnNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXMoRGF0ZVNoaW0sIHsgcGFyc2U6IHBhcnNlU2hpbSB9KTtcblxuICAgICAgICByZXR1cm4gRGF0ZVNoaW07XG4gICAgfShEYXRlKSk7XG4gICAgLyogZ2xvYmFsIERhdGU6IGZhbHNlICovXG59XG5cbi8vIEVTNSAxNS45LjQuNFxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuOS40LjRcbmlmICghRGF0ZS5ub3cpIHtcbiAgICBEYXRlLm5vdyA9IGZ1bmN0aW9uIG5vdygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIH07XG59XG5cbi8vXG4vLyBOdW1iZXJcbi8vID09PT09PVxuLy9cblxuLy8gRVM1LjEgMTUuNy40LjVcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjcuNC41XG52YXIgaGFzVG9GaXhlZEJ1Z3MgPSBOdW1iZXJQcm90b3R5cGUudG9GaXhlZCAmJiAoXG4gICgwLjAwMDA4KS50b0ZpeGVkKDMpICE9PSAnMC4wMDAnIHx8XG4gICgwLjkpLnRvRml4ZWQoMCkgIT09ICcxJyB8fFxuICAoMS4yNTUpLnRvRml4ZWQoMikgIT09ICcxLjI1JyB8fFxuICAoMTAwMDAwMDAwMDAwMDAwMDEyOCkudG9GaXhlZCgwKSAhPT0gJzEwMDAwMDAwMDAwMDAwMDAxMjgnXG4pO1xuXG52YXIgdG9GaXhlZEhlbHBlcnMgPSB7XG4gIGJhc2U6IDFlNyxcbiAgc2l6ZTogNixcbiAgZGF0YTogWzAsIDAsIDAsIDAsIDAsIDBdLFxuICBtdWx0aXBseTogZnVuY3Rpb24gbXVsdGlwbHkobiwgYykge1xuICAgICAgdmFyIGkgPSAtMTtcbiAgICAgIHZhciBjMiA9IGM7XG4gICAgICB3aGlsZSAoKytpIDwgdG9GaXhlZEhlbHBlcnMuc2l6ZSkge1xuICAgICAgICAgIGMyICs9IG4gKiB0b0ZpeGVkSGVscGVycy5kYXRhW2ldO1xuICAgICAgICAgIHRvRml4ZWRIZWxwZXJzLmRhdGFbaV0gPSBjMiAlIHRvRml4ZWRIZWxwZXJzLmJhc2U7XG4gICAgICAgICAgYzIgPSBNYXRoLmZsb29yKGMyIC8gdG9GaXhlZEhlbHBlcnMuYmFzZSk7XG4gICAgICB9XG4gIH0sXG4gIGRpdmlkZTogZnVuY3Rpb24gZGl2aWRlKG4pIHtcbiAgICAgIHZhciBpID0gdG9GaXhlZEhlbHBlcnMuc2l6ZSwgYyA9IDA7XG4gICAgICB3aGlsZSAoLS1pID49IDApIHtcbiAgICAgICAgICBjICs9IHRvRml4ZWRIZWxwZXJzLmRhdGFbaV07XG4gICAgICAgICAgdG9GaXhlZEhlbHBlcnMuZGF0YVtpXSA9IE1hdGguZmxvb3IoYyAvIG4pO1xuICAgICAgICAgIGMgPSAoYyAlIG4pICogdG9GaXhlZEhlbHBlcnMuYmFzZTtcbiAgICAgIH1cbiAgfSxcbiAgbnVtVG9TdHJpbmc6IGZ1bmN0aW9uIG51bVRvU3RyaW5nKCkge1xuICAgICAgdmFyIGkgPSB0b0ZpeGVkSGVscGVycy5zaXplO1xuICAgICAgdmFyIHMgPSAnJztcbiAgICAgIHdoaWxlICgtLWkgPj0gMCkge1xuICAgICAgICAgIGlmIChzICE9PSAnJyB8fCBpID09PSAwIHx8IHRvRml4ZWRIZWxwZXJzLmRhdGFbaV0gIT09IDApIHtcbiAgICAgICAgICAgICAgdmFyIHQgPSAkU3RyaW5nKHRvRml4ZWRIZWxwZXJzLmRhdGFbaV0pO1xuICAgICAgICAgICAgICBpZiAocyA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgIHMgPSB0O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcyArPSBzdHJTbGljZSgnMDAwMDAwMCcsIDAsIDcgLSB0Lmxlbmd0aCkgKyB0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHM7XG4gIH0sXG4gIHBvdzogZnVuY3Rpb24gcG93KHgsIG4sIGFjYykge1xuICAgICAgcmV0dXJuIChuID09PSAwID8gYWNjIDogKG4gJSAyID09PSAxID8gcG93KHgsIG4gLSAxLCBhY2MgKiB4KSA6IHBvdyh4ICogeCwgbiAvIDIsIGFjYykpKTtcbiAgfSxcbiAgbG9nOiBmdW5jdGlvbiBsb2coeCkge1xuICAgICAgdmFyIG4gPSAwO1xuICAgICAgdmFyIHgyID0geDtcbiAgICAgIHdoaWxlICh4MiA+PSA0MDk2KSB7XG4gICAgICAgICAgbiArPSAxMjtcbiAgICAgICAgICB4MiAvPSA0MDk2O1xuICAgICAgfVxuICAgICAgd2hpbGUgKHgyID49IDIpIHtcbiAgICAgICAgICBuICs9IDE7XG4gICAgICAgICAgeDIgLz0gMjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuO1xuICB9XG59O1xuXG52YXIgdG9GaXhlZFNoaW0gPSBmdW5jdGlvbiB0b0ZpeGVkKGZyYWN0aW9uRGlnaXRzKSB7XG4gICAgdmFyIGYsIHgsIHMsIG0sIGUsIHosIGosIGs7XG5cbiAgICAvLyBUZXN0IGZvciBOYU4gYW5kIHJvdW5kIGZyYWN0aW9uRGlnaXRzIGRvd25cbiAgICBmID0gJE51bWJlcihmcmFjdGlvbkRpZ2l0cyk7XG4gICAgZiA9IGlzQWN0dWFsTmFOKGYpID8gMCA6IE1hdGguZmxvb3IoZik7XG5cbiAgICBpZiAoZiA8IDAgfHwgZiA+IDIwKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdOdW1iZXIudG9GaXhlZCBjYWxsZWQgd2l0aCBpbnZhbGlkIG51bWJlciBvZiBkZWNpbWFscycpO1xuICAgIH1cblxuICAgIHggPSAkTnVtYmVyKHRoaXMpO1xuXG4gICAgaWYgKGlzQWN0dWFsTmFOKHgpKSB7XG4gICAgICAgIHJldHVybiAnTmFOJztcbiAgICB9XG5cbiAgICAvLyBJZiBpdCBpcyB0b28gYmlnIG9yIHNtYWxsLCByZXR1cm4gdGhlIHN0cmluZyB2YWx1ZSBvZiB0aGUgbnVtYmVyXG4gICAgaWYgKHggPD0gLTFlMjEgfHwgeCA+PSAxZTIxKSB7XG4gICAgICAgIHJldHVybiAkU3RyaW5nKHgpO1xuICAgIH1cblxuICAgIHMgPSAnJztcblxuICAgIGlmICh4IDwgMCkge1xuICAgICAgICBzID0gJy0nO1xuICAgICAgICB4ID0gLXg7XG4gICAgfVxuXG4gICAgbSA9ICcwJztcblxuICAgIGlmICh4ID4gMWUtMjEpIHtcbiAgICAgICAgLy8gMWUtMjEgPCB4IDwgMWUyMVxuICAgICAgICAvLyAtNzAgPCBsb2cyKHgpIDwgNzBcbiAgICAgICAgZSA9IHRvRml4ZWRIZWxwZXJzLmxvZyh4ICogdG9GaXhlZEhlbHBlcnMucG93KDIsIDY5LCAxKSkgLSA2OTtcbiAgICAgICAgeiA9IChlIDwgMCA/IHggKiB0b0ZpeGVkSGVscGVycy5wb3coMiwgLWUsIDEpIDogeCAvIHRvRml4ZWRIZWxwZXJzLnBvdygyLCBlLCAxKSk7XG4gICAgICAgIHogKj0gMHgxMDAwMDAwMDAwMDAwMDsgLy8gTWF0aC5wb3coMiwgNTIpO1xuICAgICAgICBlID0gNTIgLSBlO1xuXG4gICAgICAgIC8vIC0xOCA8IGUgPCAxMjJcbiAgICAgICAgLy8geCA9IHogLyAyIF4gZVxuICAgICAgICBpZiAoZSA+IDApIHtcbiAgICAgICAgICAgIHRvRml4ZWRIZWxwZXJzLm11bHRpcGx5KDAsIHopO1xuICAgICAgICAgICAgaiA9IGY7XG5cbiAgICAgICAgICAgIHdoaWxlIChqID49IDcpIHtcbiAgICAgICAgICAgICAgICB0b0ZpeGVkSGVscGVycy5tdWx0aXBseSgxZTcsIDApO1xuICAgICAgICAgICAgICAgIGogLT0gNztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdG9GaXhlZEhlbHBlcnMubXVsdGlwbHkodG9GaXhlZEhlbHBlcnMucG93KDEwLCBqLCAxKSwgMCk7XG4gICAgICAgICAgICBqID0gZSAtIDE7XG5cbiAgICAgICAgICAgIHdoaWxlIChqID49IDIzKSB7XG4gICAgICAgICAgICAgICAgdG9GaXhlZEhlbHBlcnMuZGl2aWRlKDEgPDwgMjMpO1xuICAgICAgICAgICAgICAgIGogLT0gMjM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRvRml4ZWRIZWxwZXJzLmRpdmlkZSgxIDw8IGopO1xuICAgICAgICAgICAgdG9GaXhlZEhlbHBlcnMubXVsdGlwbHkoMSwgMSk7XG4gICAgICAgICAgICB0b0ZpeGVkSGVscGVycy5kaXZpZGUoMik7XG4gICAgICAgICAgICBtID0gdG9GaXhlZEhlbHBlcnMubnVtVG9TdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRvRml4ZWRIZWxwZXJzLm11bHRpcGx5KDAsIHopO1xuICAgICAgICAgICAgdG9GaXhlZEhlbHBlcnMubXVsdGlwbHkoMSA8PCAoLWUpLCAwKTtcbiAgICAgICAgICAgIG0gPSB0b0ZpeGVkSGVscGVycy5udW1Ub1N0cmluZygpICsgc3RyU2xpY2UoJzAuMDAwMDAwMDAwMDAwMDAwMDAwMDAnLCAyLCAyICsgZik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZiA+IDApIHtcbiAgICAgICAgayA9IG0ubGVuZ3RoO1xuXG4gICAgICAgIGlmIChrIDw9IGYpIHtcbiAgICAgICAgICAgIG0gPSBzICsgc3RyU2xpY2UoJzAuMDAwMDAwMDAwMDAwMDAwMDAwMCcsIDAsIGYgLSBrICsgMikgKyBtO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbSA9IHMgKyBzdHJTbGljZShtLCAwLCBrIC0gZikgKyAnLicgKyBzdHJTbGljZShtLCBrIC0gZik7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBtID0gcyArIG07XG4gICAgfVxuXG4gICAgcmV0dXJuIG07XG59O1xuZGVmaW5lUHJvcGVydGllcyhOdW1iZXJQcm90b3R5cGUsIHsgdG9GaXhlZDogdG9GaXhlZFNoaW0gfSwgaGFzVG9GaXhlZEJ1Z3MpO1xuXG52YXIgaGFzVG9QcmVjaXNpb25VbmRlZmluZWRCdWcgPSAoZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiAxLjAudG9QcmVjaXNpb24odW5kZWZpbmVkKSA9PT0gJzEnO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufSgpKTtcbnZhciBvcmlnaW5hbFRvUHJlY2lzaW9uID0gTnVtYmVyUHJvdG90eXBlLnRvUHJlY2lzaW9uO1xuZGVmaW5lUHJvcGVydGllcyhOdW1iZXJQcm90b3R5cGUsIHtcbiAgICB0b1ByZWNpc2lvbjogZnVuY3Rpb24gdG9QcmVjaXNpb24ocHJlY2lzaW9uKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgcHJlY2lzaW9uID09PSAndW5kZWZpbmVkJyA/IG9yaWdpbmFsVG9QcmVjaXNpb24uY2FsbCh0aGlzKSA6IG9yaWdpbmFsVG9QcmVjaXNpb24uY2FsbCh0aGlzLCBwcmVjaXNpb24pO1xuICAgIH1cbn0sIGhhc1RvUHJlY2lzaW9uVW5kZWZpbmVkQnVnKTtcblxuLy9cbi8vIFN0cmluZ1xuLy8gPT09PT09XG4vL1xuXG4vLyBFUzUgMTUuNS40LjE0XG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS41LjQuMTRcblxuLy8gW2J1Z2ZpeCwgSUUgbHQgOSwgZmlyZWZveCA0LCBLb25xdWVyb3IsIE9wZXJhLCBvYnNjdXJlIGJyb3dzZXJzXVxuLy8gTWFueSBicm93c2VycyBkbyBub3Qgc3BsaXQgcHJvcGVybHkgd2l0aCByZWd1bGFyIGV4cHJlc3Npb25zIG9yIHRoZXlcbi8vIGRvIG5vdCBwZXJmb3JtIHRoZSBzcGxpdCBjb3JyZWN0bHkgdW5kZXIgb2JzY3VyZSBjb25kaXRpb25zLlxuLy8gU2VlIGh0dHA6Ly9ibG9nLnN0ZXZlbmxldml0aGFuLmNvbS9hcmNoaXZlcy9jcm9zcy1icm93c2VyLXNwbGl0XG4vLyBJJ3ZlIHRlc3RlZCBpbiBtYW55IGJyb3dzZXJzIGFuZCB0aGlzIHNlZW1zIHRvIGNvdmVyIHRoZSBkZXZpYW50IG9uZXM6XG4vLyAgICAnYWInLnNwbGl0KC8oPzphYikqLykgc2hvdWxkIGJlIFtcIlwiLCBcIlwiXSwgbm90IFtcIlwiXVxuLy8gICAgJy4nLnNwbGl0KC8oLj8pKC4/KS8pIHNob3VsZCBiZSBbXCJcIiwgXCIuXCIsIFwiXCIsIFwiXCJdLCBub3QgW1wiXCIsIFwiXCJdXG4vLyAgICAndGVzc3QnLnNwbGl0KC8ocykqLykgc2hvdWxkIGJlIFtcInRcIiwgdW5kZWZpbmVkLCBcImVcIiwgXCJzXCIsIFwidFwiXSwgbm90XG4vLyAgICAgICBbdW5kZWZpbmVkLCBcInRcIiwgdW5kZWZpbmVkLCBcImVcIiwgLi4uXVxuLy8gICAgJycuc3BsaXQoLy4/Lykgc2hvdWxkIGJlIFtdLCBub3QgW1wiXCJdXG4vLyAgICAnLicuc3BsaXQoLygpKCkvKSBzaG91bGQgYmUgW1wiLlwiXSwgbm90IFtcIlwiLCBcIlwiLCBcIi5cIl1cblxuaWYgKFxuICAgICdhYicuc3BsaXQoLyg/OmFiKSovKS5sZW5ndGggIT09IDIgfHxcbiAgICAnLicuc3BsaXQoLyguPykoLj8pLykubGVuZ3RoICE9PSA0IHx8XG4gICAgJ3Rlc3N0Jy5zcGxpdCgvKHMpKi8pWzFdID09PSAndCcgfHxcbiAgICAndGVzdCcuc3BsaXQoLyg/OikvLCAtMSkubGVuZ3RoICE9PSA0IHx8XG4gICAgJycuc3BsaXQoLy4/LykubGVuZ3RoIHx8XG4gICAgJy4nLnNwbGl0KC8oKSgpLykubGVuZ3RoID4gMVxuKSB7XG4gICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbXBsaWFudEV4ZWNOcGNnID0gdHlwZW9mICgvKCk/Py8pLmV4ZWMoJycpWzFdID09PSAndW5kZWZpbmVkJzsgLy8gTlBDRzogbm9ucGFydGljaXBhdGluZyBjYXB0dXJpbmcgZ3JvdXBcbiAgICAgICAgdmFyIG1heFNhZmUzMkJpdEludCA9IE1hdGgucG93KDIsIDMyKSAtIDE7XG5cbiAgICAgICAgU3RyaW5nUHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gKHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgICAgICAgIHZhciBzdHJpbmcgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXBhcmF0b3IgPT09ICd1bmRlZmluZWQnICYmIGxpbWl0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBgc2VwYXJhdG9yYCBpcyBub3QgYSByZWdleCwgdXNlIG5hdGl2ZSBzcGxpdFxuICAgICAgICAgICAgaWYgKCFpc1JlZ2V4KHNlcGFyYXRvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyU3BsaXQodGhpcywgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICAgICAgICAgIHZhciBmbGFncyA9IChzZXBhcmF0b3IuaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLm11bHRpbGluZSA/ICdtJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLnVuaWNvZGUgPyAndScgOiAnJykgKyAvLyBpbiBFUzZcbiAgICAgICAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3Iuc3RpY2t5ID8gJ3knIDogJycpLCAvLyBGaXJlZm94IDMrIGFuZCBFUzZcbiAgICAgICAgICAgICAgICBsYXN0TGFzdEluZGV4ID0gMCxcbiAgICAgICAgICAgICAgICAvLyBNYWtlIGBnbG9iYWxgIGFuZCBhdm9pZCBgbGFzdEluZGV4YCBpc3N1ZXMgYnkgd29ya2luZyB3aXRoIGEgY29weVxuICAgICAgICAgICAgICAgIHNlcGFyYXRvcjIsIG1hdGNoLCBsYXN0SW5kZXgsIGxhc3RMZW5ndGg7XG4gICAgICAgICAgICB2YXIgc2VwYXJhdG9yQ29weSA9IG5ldyBSZWdFeHAoc2VwYXJhdG9yLnNvdXJjZSwgZmxhZ3MgKyAnZycpO1xuICAgICAgICAgICAgc3RyaW5nICs9ICcnOyAvLyBUeXBlLWNvbnZlcnRcbiAgICAgICAgICAgIGlmICghY29tcGxpYW50RXhlY05wY2cpIHtcbiAgICAgICAgICAgICAgICAvLyBEb2Vzbid0IG5lZWQgZmxhZ3MgZ3ksIGJ1dCB0aGV5IGRvbid0IGh1cnRcbiAgICAgICAgICAgICAgICBzZXBhcmF0b3IyID0gbmV3IFJlZ0V4cCgnXicgKyBzZXBhcmF0b3JDb3B5LnNvdXJjZSArICckKD8hXFxcXHMpJywgZmxhZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogVmFsdWVzIGZvciBgbGltaXRgLCBwZXIgdGhlIHNwZWM6XG4gICAgICAgICAgICAgKiBJZiB1bmRlZmluZWQ6IDQyOTQ5NjcyOTUgLy8gbWF4U2FmZTMyQml0SW50XG4gICAgICAgICAgICAgKiBJZiAwLCBJbmZpbml0eSwgb3IgTmFOOiAwXG4gICAgICAgICAgICAgKiBJZiBwb3NpdGl2ZSBudW1iZXI6IGxpbWl0ID0gTWF0aC5mbG9vcihsaW1pdCk7IGlmIChsaW1pdCA+IDQyOTQ5NjcyOTUpIGxpbWl0IC09IDQyOTQ5NjcyOTY7XG4gICAgICAgICAgICAgKiBJZiBuZWdhdGl2ZSBudW1iZXI6IDQyOTQ5NjcyOTYgLSBNYXRoLmZsb29yKE1hdGguYWJzKGxpbWl0KSlcbiAgICAgICAgICAgICAqIElmIG90aGVyOiBUeXBlLWNvbnZlcnQsIHRoZW4gdXNlIHRoZSBhYm92ZSBydWxlc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgc3BsaXRMaW1pdCA9IHR5cGVvZiBsaW1pdCA9PT0gJ3VuZGVmaW5lZCcgPyBtYXhTYWZlMzJCaXRJbnQgOiBFUy5Ub1VpbnQzMihsaW1pdCk7XG4gICAgICAgICAgICBtYXRjaCA9IHNlcGFyYXRvckNvcHkuZXhlYyhzdHJpbmcpO1xuICAgICAgICAgICAgd2hpbGUgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgLy8gYHNlcGFyYXRvckNvcHkubGFzdEluZGV4YCBpcyBub3QgcmVsaWFibGUgY3Jvc3MtYnJvd3NlclxuICAgICAgICAgICAgICAgIGxhc3RJbmRleCA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0SW5kZXggPiBsYXN0TGFzdEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHB1c2gob3V0cHV0LCBzdHJTbGljZShzdHJpbmcsIGxhc3RMYXN0SW5kZXgsIG1hdGNoLmluZGV4KSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpeCBicm93c2VycyB3aG9zZSBgZXhlY2AgbWV0aG9kcyBkb24ndCBjb25zaXN0ZW50bHkgcmV0dXJuIGB1bmRlZmluZWRgIGZvclxuICAgICAgICAgICAgICAgICAgICAvLyBub25wYXJ0aWNpcGF0aW5nIGNhcHR1cmluZyBncm91cHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb21wbGlhbnRFeGVjTnBjZyAmJiBtYXRjaC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1sb29wLWZ1bmMgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoWzBdLnJlcGxhY2Uoc2VwYXJhdG9yMiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aCAtIDI7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1tpXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoW2ldID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWxvb3AtZnVuYyAqL1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaC5sZW5ndGggPiAxICYmIG1hdGNoLmluZGV4IDwgc3RyaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlfcHVzaC5hcHBseShvdXRwdXQsIGFycmF5X3NsaWNlLmNhbGwobWF0Y2gsIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsYXN0TGVuZ3RoID0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBsYXN0TGFzdEluZGV4ID0gbGFzdEluZGV4O1xuICAgICAgICAgICAgICAgICAgICBpZiAob3V0cHV0Lmxlbmd0aCA+PSBzcGxpdExpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VwYXJhdG9yQ29weS5sYXN0SW5kZXggPT09IG1hdGNoLmluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlcGFyYXRvckNvcHkubGFzdEluZGV4Kys7IC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3BcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWF0Y2ggPSBzZXBhcmF0b3JDb3B5LmV4ZWMoc3RyaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYXN0TGFzdEluZGV4ID09PSBzdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RMZW5ndGggfHwgIXNlcGFyYXRvckNvcHkudGVzdCgnJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcHVzaChvdXRwdXQsICcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHB1c2gob3V0cHV0LCBzdHJTbGljZShzdHJpbmcsIGxhc3RMYXN0SW5kZXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQubGVuZ3RoID4gc3BsaXRMaW1pdCA/IHN0clNsaWNlKG91dHB1dCwgMCwgc3BsaXRMaW1pdCkgOiBvdXRwdXQ7XG4gICAgICAgIH07XG4gICAgfSgpKTtcblxuLy8gW2J1Z2ZpeCwgY2hyb21lXVxuLy8gSWYgc2VwYXJhdG9yIGlzIHVuZGVmaW5lZCwgdGhlbiB0aGUgcmVzdWx0IGFycmF5IGNvbnRhaW5zIGp1c3Qgb25lIFN0cmluZyxcbi8vIHdoaWNoIGlzIHRoZSB0aGlzIHZhbHVlIChjb252ZXJ0ZWQgdG8gYSBTdHJpbmcpLiBJZiBsaW1pdCBpcyBub3QgdW5kZWZpbmVkLFxuLy8gdGhlbiB0aGUgb3V0cHV0IGFycmF5IGlzIHRydW5jYXRlZCBzbyB0aGF0IGl0IGNvbnRhaW5zIG5vIG1vcmUgdGhhbiBsaW1pdFxuLy8gZWxlbWVudHMuXG4vLyBcIjBcIi5zcGxpdCh1bmRlZmluZWQsIDApIC0+IFtdXG59IGVsc2UgaWYgKCcwJy5zcGxpdCh2b2lkIDAsIDApLmxlbmd0aCkge1xuICAgIFN0cmluZ1Byb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIHNwbGl0KHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXBhcmF0b3IgPT09ICd1bmRlZmluZWQnICYmIGxpbWl0ID09PSAwKSB7IHJldHVybiBbXTsgfVxuICAgICAgICByZXR1cm4gc3RyU3BsaXQodGhpcywgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgfTtcbn1cblxudmFyIHN0cl9yZXBsYWNlID0gU3RyaW5nUHJvdG90eXBlLnJlcGxhY2U7XG52YXIgcmVwbGFjZVJlcG9ydHNHcm91cHNDb3JyZWN0bHkgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBncm91cHMgPSBbXTtcbiAgICAneCcucmVwbGFjZSgveCguKT8vZywgZnVuY3Rpb24gKG1hdGNoLCBncm91cCkge1xuICAgICAgICBwdXNoKGdyb3VwcywgZ3JvdXApO1xuICAgIH0pO1xuICAgIHJldHVybiBncm91cHMubGVuZ3RoID09PSAxICYmIHR5cGVvZiBncm91cHNbMF0gPT09ICd1bmRlZmluZWQnO1xufSgpKTtcblxuaWYgKCFyZXBsYWNlUmVwb3J0c0dyb3Vwc0NvcnJlY3RseSkge1xuICAgIFN0cmluZ1Byb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZShzZWFyY2hWYWx1ZSwgcmVwbGFjZVZhbHVlKSB7XG4gICAgICAgIHZhciBpc0ZuID0gaXNDYWxsYWJsZShyZXBsYWNlVmFsdWUpO1xuICAgICAgICB2YXIgaGFzQ2FwdHVyaW5nR3JvdXBzID0gaXNSZWdleChzZWFyY2hWYWx1ZSkgJiYgKC9cXClbKj9dLykudGVzdChzZWFyY2hWYWx1ZS5zb3VyY2UpO1xuICAgICAgICBpZiAoIWlzRm4gfHwgIWhhc0NhcHR1cmluZ0dyb3Vwcykge1xuICAgICAgICAgICAgcmV0dXJuIHN0cl9yZXBsYWNlLmNhbGwodGhpcywgc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgd3JhcHBlZFJlcGxhY2VWYWx1ZSA9IGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHZhciBvcmlnaW5hbExhc3RJbmRleCA9IHNlYXJjaFZhbHVlLmxhc3RJbmRleDtcbiAgICAgICAgICAgICAgICBzZWFyY2hWYWx1ZS5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gc2VhcmNoVmFsdWUuZXhlYyhtYXRjaCkgfHwgW107XG4gICAgICAgICAgICAgICAgc2VhcmNoVmFsdWUubGFzdEluZGV4ID0gb3JpZ2luYWxMYXN0SW5kZXg7XG4gICAgICAgICAgICAgICAgcHVzaChhcmdzLCBhcmd1bWVudHNbbGVuZ3RoIC0gMl0sIGFyZ3VtZW50c1tsZW5ndGggLSAxXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2VWYWx1ZS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gc3RyX3JlcGxhY2UuY2FsbCh0aGlzLCBzZWFyY2hWYWx1ZSwgd3JhcHBlZFJlcGxhY2VWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG4vLyBFQ01BLTI2MiwgM3JkIEIuMi4zXG4vLyBOb3QgYW4gRUNNQVNjcmlwdCBzdGFuZGFyZCwgYWx0aG91Z2ggRUNNQVNjcmlwdCAzcmQgRWRpdGlvbiBoYXMgYVxuLy8gbm9uLW5vcm1hdGl2ZSBzZWN0aW9uIHN1Z2dlc3RpbmcgdW5pZm9ybSBzZW1hbnRpY3MgYW5kIGl0IHNob3VsZCBiZVxuLy8gbm9ybWFsaXplZCBhY3Jvc3MgYWxsIGJyb3dzZXJzXG4vLyBbYnVnZml4LCBJRSBsdCA5XSBJRSA8IDkgc3Vic3RyKCkgd2l0aCBuZWdhdGl2ZSB2YWx1ZSBub3Qgd29ya2luZyBpbiBJRVxudmFyIHN0cmluZ19zdWJzdHIgPSBTdHJpbmdQcm90b3R5cGUuc3Vic3RyO1xudmFyIGhhc05lZ2F0aXZlU3Vic3RyQnVnID0gJycuc3Vic3RyICYmICcwYicuc3Vic3RyKC0xKSAhPT0gJ2InO1xuZGVmaW5lUHJvcGVydGllcyhTdHJpbmdQcm90b3R5cGUsIHtcbiAgICBzdWJzdHI6IGZ1bmN0aW9uIHN1YnN0cihzdGFydCwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBub3JtYWxpemVkU3RhcnQgPSBzdGFydDtcbiAgICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICAgICAgbm9ybWFsaXplZFN0YXJ0ID0gbWF4KHRoaXMubGVuZ3RoICsgc3RhcnQsIDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJpbmdfc3Vic3RyLmNhbGwodGhpcywgbm9ybWFsaXplZFN0YXJ0LCBsZW5ndGgpO1xuICAgIH1cbn0sIGhhc05lZ2F0aXZlU3Vic3RyQnVnKTtcblxuLy8gRVM1IDE1LjUuNC4yMFxuLy8gd2hpdGVzcGFjZSBmcm9tOiBodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjUuNC4yMFxudmFyIHdzID0gJ1xceDA5XFx4MEFcXHgwQlxceDBDXFx4MERcXHgyMFxceEEwXFx1MTY4MFxcdTE4MEVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzJyArXG4gICAgJ1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMEFcXHUyMDJGXFx1MjA1RlxcdTMwMDBcXHUyMDI4JyArXG4gICAgJ1xcdTIwMjlcXHVGRUZGJztcbnZhciB6ZXJvV2lkdGggPSAnXFx1MjAwYic7XG52YXIgd3NSZWdleENoYXJzID0gJ1snICsgd3MgKyAnXSc7XG52YXIgdHJpbUJlZ2luUmVnZXhwID0gbmV3IFJlZ0V4cCgnXicgKyB3c1JlZ2V4Q2hhcnMgKyB3c1JlZ2V4Q2hhcnMgKyAnKicpO1xudmFyIHRyaW1FbmRSZWdleHAgPSBuZXcgUmVnRXhwKHdzUmVnZXhDaGFycyArIHdzUmVnZXhDaGFycyArICcqJCcpO1xudmFyIGhhc1RyaW1XaGl0ZXNwYWNlQnVnID0gU3RyaW5nUHJvdG90eXBlLnRyaW0gJiYgKHdzLnRyaW0oKSB8fCAhemVyb1dpZHRoLnRyaW0oKSk7XG5kZWZpbmVQcm9wZXJ0aWVzKFN0cmluZ1Byb3RvdHlwZSwge1xuICAgIC8vIGh0dHA6Ly9ibG9nLnN0ZXZlbmxldml0aGFuLmNvbS9hcmNoaXZlcy9mYXN0ZXItdHJpbS1qYXZhc2NyaXB0XG4gICAgLy8gaHR0cDovL3BlcmZlY3Rpb25raWxscy5jb20vd2hpdGVzcGFjZS1kZXZpYXRpb25zL1xuICAgIHRyaW06IGZ1bmN0aW9uIHRyaW0oKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcyA9PT0gJ3VuZGVmaW5lZCcgfHwgdGhpcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbid0IGNvbnZlcnQgXCIgKyB0aGlzICsgJyB0byBvYmplY3QnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJFN0cmluZyh0aGlzKS5yZXBsYWNlKHRyaW1CZWdpblJlZ2V4cCwgJycpLnJlcGxhY2UodHJpbUVuZFJlZ2V4cCwgJycpO1xuICAgIH1cbn0sIGhhc1RyaW1XaGl0ZXNwYWNlQnVnKTtcblxudmFyIGhhc0xhc3RJbmRleEJ1ZyA9IFN0cmluZ1Byb3RvdHlwZS5sYXN0SW5kZXhPZiAmJiAnYWJj44GC44GEJy5sYXN0SW5kZXhPZign44GC44GEJywgMikgIT09IC0xO1xuZGVmaW5lUHJvcGVydGllcyhTdHJpbmdQcm90b3R5cGUsIHtcbiAgICBsYXN0SW5kZXhPZjogZnVuY3Rpb24gbGFzdEluZGV4T2Yoc2VhcmNoU3RyaW5nKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcyA9PT0gJ3VuZGVmaW5lZCcgfHwgdGhpcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbid0IGNvbnZlcnQgXCIgKyB0aGlzICsgJyB0byBvYmplY3QnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgUyA9ICRTdHJpbmcodGhpcyk7XG4gICAgICAgIHZhciBzZWFyY2hTdHIgPSAkU3RyaW5nKHNlYXJjaFN0cmluZyk7XG4gICAgICAgIHZhciBudW1Qb3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/ICROdW1iZXIoYXJndW1lbnRzWzFdKSA6IE5hTjtcbiAgICAgICAgdmFyIHBvcyA9IGlzQWN0dWFsTmFOKG51bVBvcykgPyBJbmZpbml0eSA6IEVTLlRvSW50ZWdlcihudW1Qb3MpO1xuICAgICAgICB2YXIgc3RhcnQgPSBtaW4obWF4KHBvcywgMCksIFMubGVuZ3RoKTtcbiAgICAgICAgdmFyIHNlYXJjaExlbiA9IHNlYXJjaFN0ci5sZW5ndGg7XG4gICAgICAgIHZhciBrID0gc3RhcnQgKyBzZWFyY2hMZW47XG4gICAgICAgIHdoaWxlIChrID4gMCkge1xuICAgICAgICAgICAgayA9IG1heCgwLCBrIC0gc2VhcmNoTGVuKTtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHN0ckluZGV4T2Yoc3RyU2xpY2UoUywgaywgc3RhcnQgKyBzZWFyY2hMZW4pLCBzZWFyY2hTdHIpO1xuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBrICsgaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbn0sIGhhc0xhc3RJbmRleEJ1Zyk7XG5cbnZhciBvcmlnaW5hbExhc3RJbmRleE9mID0gU3RyaW5nUHJvdG90eXBlLmxhc3RJbmRleE9mO1xuZGVmaW5lUHJvcGVydGllcyhTdHJpbmdQcm90b3R5cGUsIHtcbiAgICBsYXN0SW5kZXhPZjogZnVuY3Rpb24gbGFzdEluZGV4T2Yoc2VhcmNoU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBvcmlnaW5hbExhc3RJbmRleE9mLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxufSwgU3RyaW5nUHJvdG90eXBlLmxhc3RJbmRleE9mLmxlbmd0aCAhPT0gMSk7XG5cbi8vIEVTLTUgMTUuMS4yLjJcbi8qIGVzbGludC1kaXNhYmxlIHJhZGl4ICovXG5pZiAocGFyc2VJbnQod3MgKyAnMDgnKSAhPT0gOCB8fCBwYXJzZUludCh3cyArICcweDE2JykgIT09IDIyKSB7XG4vKiBlc2xpbnQtZW5hYmxlIHJhZGl4ICovXG4gICAgLyogZ2xvYmFsIHBhcnNlSW50OiB0cnVlICovXG4gICAgcGFyc2VJbnQgPSAoZnVuY3Rpb24gKG9yaWdQYXJzZUludCkge1xuICAgICAgICB2YXIgaGV4UmVnZXggPSAvXltcXC0rXT8wW3hYXS87XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBwYXJzZUludChzdHIsIHJhZGl4KSB7XG4gICAgICAgICAgICB2YXIgc3RyaW5nID0gJFN0cmluZyhzdHIpLnRyaW0oKTtcbiAgICAgICAgICAgIHZhciBkZWZhdWx0ZWRSYWRpeCA9ICROdW1iZXIocmFkaXgpIHx8IChoZXhSZWdleC50ZXN0KHN0cmluZykgPyAxNiA6IDEwKTtcbiAgICAgICAgICAgIHJldHVybiBvcmlnUGFyc2VJbnQoc3RyaW5nLCBkZWZhdWx0ZWRSYWRpeCk7XG4gICAgICAgIH07XG4gICAgfShwYXJzZUludCkpO1xufVxuXG5pZiAoU3RyaW5nKG5ldyBSYW5nZUVycm9yKCd0ZXN0JykpICE9PSAnUmFuZ2VFcnJvcjogdGVzdCcpIHtcbiAgICB2YXIgb3JpZ2luYWxFcnJvclRvU3RyaW5nID0gRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nO1xuICAgIHZhciBlcnJvclRvU3RyaW5nU2hpbSA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMgPT09ICd1bmRlZmluZWQnIHx8IHRoaXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjYW4ndCBjb252ZXJ0IFwiICsgdGhpcyArICcgdG8gb2JqZWN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5hbWUgPSB0aGlzLm5hbWU7XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIG5hbWUgPSAnRXJyb3InO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgbmFtZSA9ICRTdHJpbmcobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1zZyA9IHRoaXMubWVzc2FnZTtcbiAgICAgICAgaWYgKHR5cGVvZiBtc2cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBtc2cgPSAnJztcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbXNnICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgbXNnID0gJFN0cmluZyhtc2cpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIG1zZztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1zZykge1xuICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5hbWUgKyAnOiAnICsgbXNnO1xuICAgIH07XG4gICAgLy8gY2FuJ3QgdXNlIGRlZmluZVByb3BlcnRpZXMgaGVyZSBiZWNhdXNlIG9mIHRvU3RyaW5nIGVudW1lcmF0aW9uIGlzc3VlIGluIElFIDw9IDhcbiAgICBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcgPSBlcnJvclRvU3RyaW5nU2hpbTtcbn1cblxufSkpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9lczUtc2hpbS9lczUtc2hpbS5qc1xuICoqIG1vZHVsZSBpZCA9IDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCIvKlxcbiAqIFN1cHBvcnQgZm9yIHNvdXJjZSBtYXBzIGluIFY4IHN0YWNrIHRyYWNlc1xcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ldmFudy9ub2RlLXNvdXJjZS1tYXAtc3VwcG9ydFxcbiAqL1xcbih0aGlzLmRlZmluZXx8ZnVuY3Rpb24oSyxOKXt0aGlzLnNvdXJjZU1hcFN1cHBvcnQ9TigpfSkoXFxcImJyb3dzZXItc291cmNlLW1hcC1zdXBwb3J0XFxcIixmdW5jdGlvbihLKXsoZnVuY3Rpb24gbih3LHQsZSl7ZnVuY3Rpb24gcihnLGIpe2lmKCF0W2ddKXtpZighd1tnXSl7dmFyIGY9XFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWImJmYpcmV0dXJuIGYoZywhMCk7aWYobClyZXR1cm4gbChnLCEwKTt0aHJvdyBFcnJvcihcXFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcXFwiK2crXFxcIidcXFwiKTt9Zj10W2ddPXtleHBvcnRzOnt9fTt3W2ddWzBdLmNhbGwoZi5leHBvcnRzLGZ1bmN0aW9uKGIpe3ZhciBhPXdbZ11bMV1bYl07cmV0dXJuIHIoYT9hOmIpfSxmLGYuZXhwb3J0cyxuLHcsdCxlKX1yZXR1cm4gdFtnXS5leHBvcnRzfWZvcih2YXIgbD1cXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxtPTA7bTxlLmxlbmd0aDttKyspcihlW21dKTtyZXR1cm4gcn0pKHsxOltmdW5jdGlvbihuLFxcbncsdCl7Sz1uKFxcXCIuL3NvdXJjZS1tYXAtc3VwcG9ydFxcXCIpfSx7XFxcIi4vc291cmNlLW1hcC1zdXBwb3J0XFxcIjoxOH1dLDI6W2Z1bmN0aW9uKG4sdyx0KXsoZnVuY3Rpb24oZSxyKXt3LmV4cG9ydHM9ZnVuY3Rpb24obCxtKXtmdW5jdGlvbiBnKGMsZCl7dmFyIGE7aWYoYyYmXFxcIi5cXFwiPT09Yy5jaGFyQXQoMCkmJmQpe2E9ZC5zcGxpdChcXFwiL1xcXCIpO2E9YS5zbGljZSgwLGEubGVuZ3RoLTEpO3ZhciBiPWE9YS5jb25jYXQoYy5zcGxpdChcXFwiL1xcXCIpKSxmLGs7Zm9yKGY9MDtiW2ZdO2YrPTEpaWYoaz1iW2ZdLFxcXCIuXFxcIj09PWspYi5zcGxpY2UoZiwxKSwtLWY7ZWxzZSBpZihcXFwiLi5cXFwiPT09aylpZigxIT09Znx8XFxcIi4uXFxcIiE9PWJbMl0mJlxcXCIuLlxcXCIhPT1iWzBdKTA8ZiYmKGIuc3BsaWNlKGYtMSwyKSxmLT0yKTtlbHNlIGJyZWFrO2M9YS5qb2luKFxcXCIvXFxcIil9cmV0dXJuIGN9ZnVuY3Rpb24gYihjKXtyZXR1cm4gZnVuY3Rpb24oYSl7cmV0dXJuIGcoYSxjKX19ZnVuY3Rpb24gZihjKXtmdW5jdGlvbiBhKGIpe2RbY109Yn1hLmZyb21UZXh0PVxcbmZ1bmN0aW9uKGMsYSl7dGhyb3cgRXJyb3IoXFxcImFtZGVmaW5lIGRvZXMgbm90IGltcGxlbWVudCBsb2FkLmZyb21UZXh0XFxcIik7fTtyZXR1cm4gYX1mdW5jdGlvbiBrKGMsYSxiKXt2YXIgZixrLGc7aWYoYylrPWRbY109e30sZz17aWQ6Yyx1cmk6cixleHBvcnRzOmt9LGY9QShtLGssZyxjKTtlbHNle2lmKHkpdGhyb3cgRXJyb3IoXFxcImFtZGVmaW5lIHdpdGggbm8gbW9kdWxlIElEIGNhbm5vdCBiZSBjYWxsZWQgbW9yZSB0aGFuIG9uY2UgcGVyIGZpbGUuXFxcIik7eT0hMDtrPWwuZXhwb3J0cztnPWw7Zj1BKG0sayxnLGwuaWQpfWEmJihhPWEubWFwKGZ1bmN0aW9uKGMpe3JldHVybiBmKGMpfSkpO2E9XFxcImZ1bmN0aW9uXFxcIj09PXR5cGVvZiBiP2IuYXBwbHkoZy5leHBvcnRzLGEpOmI7dm9pZCAwIT09YSYmKGcuZXhwb3J0cz1hLGMmJihkW2NdPWcuZXhwb3J0cykpfWZ1bmN0aW9uIGEoYSxkLGIpe0FycmF5LmlzQXJyYXkoYSk/KGI9ZCxkPWEsYT12b2lkIDApOlxcXCJzdHJpbmdcXFwiIT09dHlwZW9mIGEmJlxcbihiPWEsYT1kPXZvaWQgMCk7ZCYmIUFycmF5LmlzQXJyYXkoZCkmJihiPWQsZD12b2lkIDApO2R8fChkPVtcXFwicmVxdWlyZVxcXCIsXFxcImV4cG9ydHNcXFwiLFxcXCJtb2R1bGVcXFwiXSk7YT9jW2FdPVthLGQsYl06ayhhLGQsYil9dmFyIGM9e30sZD17fSx5PSExLHg9bihcXFwicGF0aFxcXCIpLEEsQjtBPWZ1bmN0aW9uKGMsYSxkLGIpe2Z1bmN0aW9uIGYoayxnKXtpZihcXFwic3RyaW5nXFxcIj09PXR5cGVvZiBrKXJldHVybiBCKGMsYSxkLGssYik7az1rLm1hcChmdW5jdGlvbihmKXtyZXR1cm4gQihjLGEsZCxmLGIpfSk7ZyYmZS5uZXh0VGljayhmdW5jdGlvbigpe2cuYXBwbHkobnVsbCxrKX0pfWYudG9Vcmw9ZnVuY3Rpb24oYyl7cmV0dXJuIDA9PT1jLmluZGV4T2YoXFxcIi5cXFwiKT9nKGMseC5kaXJuYW1lKGQuZmlsZW5hbWUpKTpjfTtyZXR1cm4gZn07bT1tfHxmdW5jdGlvbigpe3JldHVybiBsLnJlcXVpcmUuYXBwbHkobCxhcmd1bWVudHMpfTtCPWZ1bmN0aW9uKGEsZSx5LG0seCl7dmFyIGw9bS5pbmRleE9mKFxcXCIhXFxcIikscj1tO1xcbmlmKC0xPT09bCl7bT1nKG0seCk7aWYoXFxcInJlcXVpcmVcXFwiPT09bSlyZXR1cm4gQShhLGUseSx4KTtpZihcXFwiZXhwb3J0c1xcXCI9PT1tKXJldHVybiBlO2lmKFxcXCJtb2R1bGVcXFwiPT09bSlyZXR1cm4geTtpZihkLmhhc093blByb3BlcnR5KG0pKXJldHVybiBkW21dO2lmKGNbbV0pcmV0dXJuIGsuYXBwbHkobnVsbCxjW21dKSxkW21dO2lmKGEpcmV0dXJuIGEocik7dGhyb3cgRXJyb3IoXFxcIk5vIG1vZHVsZSB3aXRoIElEOiBcXFwiK20pO31yPW0uc3Vic3RyaW5nKDAsbCk7bT1tLnN1YnN0cmluZyhsKzEsbS5sZW5ndGgpO2w9QihhLGUseSxyLHgpO209bC5ub3JtYWxpemU/bC5ub3JtYWxpemUobSxiKHgpKTpnKG0seCk7ZFttXXx8bC5sb2FkKG0sQShhLGUseSx4KSxmKG0pLHt9KTtyZXR1cm4gZFttXX07YS5yZXF1aXJlPWZ1bmN0aW9uKGEpe2lmKGRbYV0pcmV0dXJuIGRbYV07aWYoY1thXSlyZXR1cm4gay5hcHBseShudWxsLGNbYV0pLGRbYV19O2EuYW1kPXt9O3JldHVybiBhfX0pLmNhbGwodGhpcyxuKFxcXCJub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzXFxcIiksXFxuXFxcIi9ub2RlX21vZHVsZXMvYW1kZWZpbmUvYW1kZWZpbmUuanNcXFwiKX0se1xcXCJub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzXFxcIjo4LHBhdGg6N31dLDM6W2Z1bmN0aW9uKG4sdyx0KXsoZnVuY3Rpb24oZSl7ZnVuY3Rpb24gcihlKXtlPWUuY2hhckNvZGVBdCgwKTtpZig0Mz09PWV8fDQ1PT09ZSlyZXR1cm4gNjI7aWYoNDc9PT1lfHw5NT09PWUpcmV0dXJuIDYzO2lmKDQ4PmUpcmV0dXJuLTE7aWYoNTg+ZSlyZXR1cm4gZS00OCs1MjtpZig5MT5lKXJldHVybiBlLTY1O2lmKDEyMz5lKXJldHVybiBlLTk3KzI2fXZhciBsPVxcXCJ1bmRlZmluZWRcXFwiIT09dHlwZW9mIFVpbnQ4QXJyYXk/VWludDhBcnJheTpBcnJheTtlLnRvQnl0ZUFycmF5PWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIGcoYSl7Y1tkKytdPWF9dmFyIGIsZixrLGEsYztpZigwPGUubGVuZ3RoJTQpdGhyb3cgRXJyb3IoXFxcIkludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDRcXFwiKTtiPWUubGVuZ3RoO2E9XFxcIj1cXFwiPT09XFxuZS5jaGFyQXQoYi0yKT8yOlxcXCI9XFxcIj09PWUuY2hhckF0KGItMSk/MTowO2M9bmV3IGwoMyplLmxlbmd0aC80LWEpO2Y9MDxhP2UubGVuZ3RoLTQ6ZS5sZW5ndGg7dmFyIGQ9MDtmb3IoYj0wO2I8ZjtiKz00KWs9cihlLmNoYXJBdChiKSk8PDE4fHIoZS5jaGFyQXQoYisxKSk8PDEyfHIoZS5jaGFyQXQoYisyKSk8PDZ8cihlLmNoYXJBdChiKzMpKSxnKChrJjE2NzExNjgwKT4+MTYpLGcoKGsmNjUyODApPj44KSxnKGsmMjU1KTsyPT09YT8oaz1yKGUuY2hhckF0KGIpKTw8MnxyKGUuY2hhckF0KGIrMSkpPj40LGcoayYyNTUpKToxPT09YSYmKGs9cihlLmNoYXJBdChiKSk8PDEwfHIoZS5jaGFyQXQoYisxKSk8PDR8cihlLmNoYXJBdChiKzIpKT4+MixnKGs+PjgmMjU1KSxnKGsmMjU1KSk7cmV0dXJuIGN9O2UuZnJvbUJ5dGVBcnJheT1mdW5jdGlvbihlKXt2YXIgZyxiPWUubGVuZ3RoJTMsZj1cXFwiXFxcIixrLGE7Zz0wO2ZvcihhPWUubGVuZ3RoLWI7ZzxhO2crPTMpaz0oZVtnXTw8MTYpKyhlW2crXFxuMV08PDgpK2VbZysyXSxrPVxcXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXFxcIi5jaGFyQXQoaz4+MTgmNjMpK1xcXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXFxcIi5jaGFyQXQoaz4+MTImNjMpK1xcXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXFxcIi5jaGFyQXQoaz4+NiY2MykrXFxcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cXFwiLmNoYXJBdChrJjYzKSxmKz1rO3N3aXRjaChiKXtjYXNlIDE6az1lW2UubGVuZ3RoLTFdO2YrPVxcXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXFxcIi5jaGFyQXQoaz4+Mik7Zis9XFxcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cXFwiLmNoYXJBdChrPDxcXG40JjYzKTtmKz1cXFwiPT1cXFwiO2JyZWFrO2Nhc2UgMjprPShlW2UubGVuZ3RoLTJdPDw4KStlW2UubGVuZ3RoLTFdLGYrPVxcXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXFxcIi5jaGFyQXQoaz4+MTApLGYrPVxcXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXFxcIi5jaGFyQXQoaz4+NCY2MyksZis9XFxcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cXFwiLmNoYXJBdChrPDwyJjYzKSxmKz1cXFwiPVxcXCJ9cmV0dXJuIGZ9fSkoXFxcInVuZGVmaW5lZFxcXCI9PT10eXBlb2YgdD90aGlzLmJhc2U2NGpzPXt9OnQpfSx7fV0sNDpbZnVuY3Rpb24obix3LHQpe30se31dLDU6W2Z1bmN0aW9uKG4sdyx0KXtmdW5jdGlvbiBlKGgscSxjKXtpZighKHRoaXMgaW5zdGFuY2VvZiBlKSlyZXR1cm4gbmV3IGUoaCxxLGMpO3ZhciBhPXR5cGVvZiBoO1xcbmlmKFxcXCJiYXNlNjRcXFwiPT09cSYmXFxcInN0cmluZ1xcXCI9PT1hKWZvcihoPWgudHJpbT9oLnRyaW0oKTpoLnJlcGxhY2UoL15cXFxccyt8XFxcXHMrJC9nLFxcXCJcXFwiKTswIT09aC5sZW5ndGglNDspaCs9XFxcIj1cXFwiO3ZhciBkO2lmKFxcXCJudW1iZXJcXFwiPT09YSlkPUYoaCk7ZWxzZSBpZihcXFwic3RyaW5nXFxcIj09PWEpZD1lLmJ5dGVMZW5ndGgoaCxxKTtlbHNlIGlmKFxcXCJvYmplY3RcXFwiPT09YSlkPUYoaC5sZW5ndGgpO2Vsc2UgdGhyb3cgRXJyb3IoXFxcIkZpcnN0IGFyZ3VtZW50IG5lZWRzIHRvIGJlIGEgbnVtYmVyLCBhcnJheSBvciBzdHJpbmcuXFxcIik7dmFyIGI7ZS5fdXNlVHlwZWRBcnJheXM/Yj1lLl9hdWdtZW50KG5ldyBVaW50OEFycmF5KGQpKTooYj10aGlzLGIubGVuZ3RoPWQsYi5faXNCdWZmZXI9ITApO2lmKGUuX3VzZVR5cGVkQXJyYXlzJiZcXFwibnVtYmVyXFxcIj09PXR5cGVvZiBoLmJ5dGVMZW5ndGgpYi5fc2V0KGgpO2Vsc2V7dmFyIGY9aDtpZihFKGYpfHxlLmlzQnVmZmVyKGYpfHxmJiZcXFwib2JqZWN0XFxcIj09PXR5cGVvZiBmJiZcXFwibnVtYmVyXFxcIj09PVxcbnR5cGVvZiBmLmxlbmd0aClmb3IocT0wO3E8ZDtxKyspZS5pc0J1ZmZlcihoKT9iW3FdPWgucmVhZFVJbnQ4KHEpOmJbcV09aFtxXTtlbHNlIGlmKFxcXCJzdHJpbmdcXFwiPT09YSliLndyaXRlKGgsMCxxKTtlbHNlIGlmKFxcXCJudW1iZXJcXFwiPT09YSYmIWUuX3VzZVR5cGVkQXJyYXlzJiYhYylmb3IocT0wO3E8ZDtxKyspYltxXT0wfXJldHVybiBifWZ1bmN0aW9uIHIoaCxxLGMpe3ZhciBhPVxcXCJcXFwiO2ZvcihjPU1hdGgubWluKGgubGVuZ3RoLGMpO3E8YztxKyspYSs9U3RyaW5nLmZyb21DaGFyQ29kZShoW3FdKTtyZXR1cm4gYX1mdW5jdGlvbiBsKGgscSxjLGEpe2F8fChwKFxcXCJib29sZWFuXFxcIj09PXR5cGVvZiBjLFxcXCJtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuXFxcIikscCh2b2lkIDAhPT1xJiZudWxsIT09cSxcXFwibWlzc2luZyBvZmZzZXRcXFwiKSxwKHErMTxoLmxlbmd0aCxcXFwiVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGhcXFwiKSk7YT1oLmxlbmd0aDtpZighKHE+PWEpKXJldHVybiBjPyhjPWhbcV0scStcXG4xPGEmJihjfD1oW3ErMV08PDgpKTooYz1oW3FdPDw4LHErMTxhJiYoY3w9aFtxKzFdKSksY31mdW5jdGlvbiBtKGgscSxjLGEpe2F8fChwKFxcXCJib29sZWFuXFxcIj09PXR5cGVvZiBjLFxcXCJtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuXFxcIikscCh2b2lkIDAhPT1xJiZudWxsIT09cSxcXFwibWlzc2luZyBvZmZzZXRcXFwiKSxwKHErMzxoLmxlbmd0aCxcXFwiVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGhcXFwiKSk7YT1oLmxlbmd0aDtpZighKHE+PWEpKXt2YXIgZDtjPyhxKzI8YSYmKGQ9aFtxKzJdPDwxNikscSsxPGEmJihkfD1oW3ErMV08PDgpLGR8PWhbcV0scSszPGEmJihkKz1oW3ErM108PDI0Pj4+MCkpOihxKzE8YSYmKGQ9aFtxKzFdPDwxNikscSsyPGEmJihkfD1oW3ErMl08PDgpLHErMzxhJiYoZHw9aFtxKzNdKSxkKz1oW3FdPDwyND4+PjApO3JldHVybiBkfX1mdW5jdGlvbiBnKGgscSxhLGMpe2N8fChwKFxcXCJib29sZWFuXFxcIj09PXR5cGVvZiBhLFxcXCJtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuXFxcIiksXFxucCh2b2lkIDAhPT1xJiZudWxsIT09cSxcXFwibWlzc2luZyBvZmZzZXRcXFwiKSxwKHErMTxoLmxlbmd0aCxcXFwiVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGhcXFwiKSk7aWYoIShxPj1oLmxlbmd0aCkpcmV0dXJuIGg9bChoLHEsYSwhMCksaCYzMjc2OD8tMSooNjU1MzUtaCsxKTpofWZ1bmN0aW9uIGIoaCxxLGEsYyl7Y3x8KHAoXFxcImJvb2xlYW5cXFwiPT09dHlwZW9mIGEsXFxcIm1pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW5cXFwiKSxwKHZvaWQgMCE9PXEmJm51bGwhPT1xLFxcXCJtaXNzaW5nIG9mZnNldFxcXCIpLHAocSszPGgubGVuZ3RoLFxcXCJUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aFxcXCIpKTtpZighKHE+PWgubGVuZ3RoKSlyZXR1cm4gaD1tKGgscSxhLCEwKSxoJjIxNDc0ODM2NDg/LTEqKDQyOTQ5NjcyOTUtaCsxKTpofWZ1bmN0aW9uIGYoaCxxLGEsYyl7Y3x8KHAoXFxcImJvb2xlYW5cXFwiPT09dHlwZW9mIGEsXFxcIm1pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW5cXFwiKSxwKHErMzxoLmxlbmd0aCxcXFwiVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGhcXFwiKSk7XFxucmV0dXJuIEkucmVhZChoLHEsYSwyMyw0KX1mdW5jdGlvbiBrKGgscSxhLGMpe2N8fChwKFxcXCJib29sZWFuXFxcIj09PXR5cGVvZiBhLFxcXCJtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuXFxcIikscChxKzc8aC5sZW5ndGgsXFxcIlRyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoXFxcIikpO3JldHVybiBJLnJlYWQoaCxxLGEsNTIsOCl9ZnVuY3Rpb24gYShoLGEsYyxkLGIpe2J8fChwKHZvaWQgMCE9PWEmJm51bGwhPT1hLFxcXCJtaXNzaW5nIHZhbHVlXFxcIikscChcXFwiYm9vbGVhblxcXCI9PT10eXBlb2YgZCxcXFwibWlzc2luZyBvciBpbnZhbGlkIGVuZGlhblxcXCIpLHAodm9pZCAwIT09YyYmbnVsbCE9PWMsXFxcIm1pc3Npbmcgb2Zmc2V0XFxcIikscChjKzE8aC5sZW5ndGgsXFxcInRyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aFxcXCIpLEgoYSw2NTUzNSkpO3ZhciBmPWgubGVuZ3RoO2lmKCEoYz49ZikpZm9yKGI9MCxmPU1hdGgubWluKGYtYywyKTtiPGY7YisrKWhbYytiXT0oYSYyNTU8PDgqKGQ/YjoxLWIpKT4+PjgqXFxuKGQ/YjoxLWIpfWZ1bmN0aW9uIGMoaCxhLGMsZCxiKXtifHwocCh2b2lkIDAhPT1hJiZudWxsIT09YSxcXFwibWlzc2luZyB2YWx1ZVxcXCIpLHAoXFxcImJvb2xlYW5cXFwiPT09dHlwZW9mIGQsXFxcIm1pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW5cXFwiKSxwKHZvaWQgMCE9PWMmJm51bGwhPT1jLFxcXCJtaXNzaW5nIG9mZnNldFxcXCIpLHAoYyszPGgubGVuZ3RoLFxcXCJ0cnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGhcXFwiKSxIKGEsNDI5NDk2NzI5NSkpO3ZhciBmPWgubGVuZ3RoO2lmKCEoYz49ZikpZm9yKGI9MCxmPU1hdGgubWluKGYtYyw0KTtiPGY7YisrKWhbYytiXT1hPj4+OCooZD9iOjMtYikmMjU1fWZ1bmN0aW9uIGQoaCxjLGQsYixmKXtmfHwocCh2b2lkIDAhPT1jJiZudWxsIT09YyxcXFwibWlzc2luZyB2YWx1ZVxcXCIpLHAoXFxcImJvb2xlYW5cXFwiPT09dHlwZW9mIGIsXFxcIm1pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW5cXFwiKSxwKHZvaWQgMCE9PWQmJm51bGwhPT1kLFxcXCJtaXNzaW5nIG9mZnNldFxcXCIpLHAoZCsxPGgubGVuZ3RoLFxcblxcXCJUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGhcXFwiKSxMKGMsMzI3NjcsLTMyNzY4KSk7ZD49aC5sZW5ndGh8fCgwPD1jP2EoaCxjLGQsYixmKTphKGgsNjU1MzUrYysxLGQsYixmKSl9ZnVuY3Rpb24geShoLGEsZCxiLGYpe2Z8fChwKHZvaWQgMCE9PWEmJm51bGwhPT1hLFxcXCJtaXNzaW5nIHZhbHVlXFxcIikscChcXFwiYm9vbGVhblxcXCI9PT10eXBlb2YgYixcXFwibWlzc2luZyBvciBpbnZhbGlkIGVuZGlhblxcXCIpLHAodm9pZCAwIT09ZCYmbnVsbCE9PWQsXFxcIm1pc3Npbmcgb2Zmc2V0XFxcIikscChkKzM8aC5sZW5ndGgsXFxcIlRyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aFxcXCIpLEwoYSwyMTQ3NDgzNjQ3LC0yMTQ3NDgzNjQ4KSk7ZD49aC5sZW5ndGh8fCgwPD1hP2MoaCxhLGQsYixmKTpjKGgsNDI5NDk2NzI5NSthKzEsZCxiLGYpKX1mdW5jdGlvbiB4KGgsYSxjLGQsYil7Ynx8KHAodm9pZCAwIT09YSYmbnVsbCE9PWEsXFxcIm1pc3NpbmcgdmFsdWVcXFwiKSxwKFxcXCJib29sZWFuXFxcIj09PXR5cGVvZiBkLFxcblxcXCJtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuXFxcIikscCh2b2lkIDAhPT1jJiZudWxsIT09YyxcXFwibWlzc2luZyBvZmZzZXRcXFwiKSxwKGMrMzxoLmxlbmd0aCxcXFwiVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoXFxcIiksTShhLDMuNDAyODIzNDY2Mzg1Mjg4NkUzOCwtMy40MDI4MjM0NjYzODUyODg2RTM4KSk7Yz49aC5sZW5ndGh8fEkud3JpdGUoaCxhLGMsZCwyMyw0KX1mdW5jdGlvbiBBKGgsYyxhLGQsYil7Ynx8KHAodm9pZCAwIT09YyYmbnVsbCE9PWMsXFxcIm1pc3NpbmcgdmFsdWVcXFwiKSxwKFxcXCJib29sZWFuXFxcIj09PXR5cGVvZiBkLFxcXCJtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuXFxcIikscCh2b2lkIDAhPT1hJiZudWxsIT09YSxcXFwibWlzc2luZyBvZmZzZXRcXFwiKSxwKGErNzxoLmxlbmd0aCxcXFwiVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoXFxcIiksTShjLDEuNzk3NjkzMTM0ODYyMzE1N0UzMDgsLTEuNzk3NjkzMTM0ODYyMzE1N0UzMDgpKTthPj1oLmxlbmd0aHx8SS53cml0ZShoLFxcbmMsYSxkLDUyLDgpfWZ1bmN0aW9uIEIoaCxhLGMpe2lmKFxcXCJudW1iZXJcXFwiIT09dHlwZW9mIGgpcmV0dXJuIGM7aD1+fmg7aWYoaD49YSlyZXR1cm4gYTtpZigwPD1oKXJldHVybiBoO2grPWE7cmV0dXJuIDA8PWg/aDowfWZ1bmN0aW9uIEYoaCl7aD1+fk1hdGguY2VpbCgraCk7cmV0dXJuIDA+aD8wOmh9ZnVuY3Rpb24gRShoKXtyZXR1cm4oQXJyYXkuaXNBcnJheXx8ZnVuY3Rpb24oaCl7cmV0dXJuXFxcIltvYmplY3QgQXJyYXldXFxcIj09PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChoKX0pKGgpfWZ1bmN0aW9uIEcoaCl7cmV0dXJuIDE2Pmg/XFxcIjBcXFwiK2gudG9TdHJpbmcoMTYpOmgudG9TdHJpbmcoMTYpfWZ1bmN0aW9uIHUoaCl7Zm9yKHZhciBhPVtdLGM9MDtjPGgubGVuZ3RoO2MrKyl7dmFyIGQ9aC5jaGFyQ29kZUF0KGMpO2lmKDEyNz49ZClhLnB1c2goaC5jaGFyQ29kZUF0KGMpKTtlbHNle3ZhciBiPWM7NTUyOTY8PWQmJjU3MzQzPj1kJiZjKys7ZD1lbmNvZGVVUklDb21wb25lbnQoaC5zbGljZShiLFxcbmMrMSkpLnN1YnN0cigxKS5zcGxpdChcXFwiJVxcXCIpO2ZvcihiPTA7YjxkLmxlbmd0aDtiKyspYS5wdXNoKHBhcnNlSW50KGRbYl0sMTYpKX19cmV0dXJuIGF9ZnVuY3Rpb24gQyhoKXtmb3IodmFyIGM9W10sYT0wO2E8aC5sZW5ndGg7YSsrKWMucHVzaChoLmNoYXJDb2RlQXQoYSkmMjU1KTtyZXR1cm4gY31mdW5jdGlvbiB6KGgsYyxhLGQpe2Zvcih2YXIgYj0wO2I8ZCYmIShiK2E+PWMubGVuZ3RofHxiPj1oLmxlbmd0aCk7YisrKWNbYithXT1oW2JdO3JldHVybiBifWZ1bmN0aW9uIEQoaCl7dHJ5e3JldHVybiBkZWNvZGVVUklDb21wb25lbnQoaCl9Y2F0Y2goYyl7cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoNjU1MzMpfX1mdW5jdGlvbiBIKGgsYyl7cChcXFwibnVtYmVyXFxcIj09PXR5cGVvZiBoLFxcXCJjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyXFxcIik7cCgwPD1oLFxcXCJzcGVjaWZpZWQgYSBuZWdhdGl2ZSB2YWx1ZSBmb3Igd3JpdGluZyBhbiB1bnNpZ25lZCB2YWx1ZVxcXCIpO3AoaDw9XFxuYyxcXFwidmFsdWUgaXMgbGFyZ2VyIHRoYW4gbWF4aW11bSB2YWx1ZSBmb3IgdHlwZVxcXCIpO3AoTWF0aC5mbG9vcihoKT09PWgsXFxcInZhbHVlIGhhcyBhIGZyYWN0aW9uYWwgY29tcG9uZW50XFxcIil9ZnVuY3Rpb24gTChoLGMsYSl7cChcXFwibnVtYmVyXFxcIj09PXR5cGVvZiBoLFxcXCJjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyXFxcIik7cChoPD1jLFxcXCJ2YWx1ZSBsYXJnZXIgdGhhbiBtYXhpbXVtIGFsbG93ZWQgdmFsdWVcXFwiKTtwKGg+PWEsXFxcInZhbHVlIHNtYWxsZXIgdGhhbiBtaW5pbXVtIGFsbG93ZWQgdmFsdWVcXFwiKTtwKE1hdGguZmxvb3IoaCk9PT1oLFxcXCJ2YWx1ZSBoYXMgYSBmcmFjdGlvbmFsIGNvbXBvbmVudFxcXCIpfWZ1bmN0aW9uIE0oaCxjLGEpe3AoXFxcIm51bWJlclxcXCI9PT10eXBlb2YgaCxcXFwiY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlclxcXCIpO3AoaDw9YyxcXFwidmFsdWUgbGFyZ2VyIHRoYW4gbWF4aW11bSBhbGxvd2VkIHZhbHVlXFxcIik7cChoPj1hLFxcXCJ2YWx1ZSBzbWFsbGVyIHRoYW4gbWluaW11bSBhbGxvd2VkIHZhbHVlXFxcIil9XFxuZnVuY3Rpb24gcChoLGMpe2lmKCFoKXRocm93IEVycm9yKGN8fFxcXCJGYWlsZWQgYXNzZXJ0aW9uXFxcIik7fXZhciBKPW4oXFxcImJhc2U2NC1qc1xcXCIpLEk9bihcXFwiaWVlZTc1NFxcXCIpO3QuQnVmZmVyPWU7dC5TbG93QnVmZmVyPWU7dC5JTlNQRUNUX01BWF9CWVRFUz01MDtlLnBvb2xTaXplPTgxOTI7ZS5fdXNlVHlwZWRBcnJheXM9ZnVuY3Rpb24oKXt0cnl7dmFyIGg9bmV3IEFycmF5QnVmZmVyKDApLGM9bmV3IFVpbnQ4QXJyYXkoaCk7Yy5mb289ZnVuY3Rpb24oKXtyZXR1cm4gNDJ9O3JldHVybiA0Mj09PWMuZm9vKCkmJlxcXCJmdW5jdGlvblxcXCI9PT10eXBlb2YgYy5zdWJhcnJheX1jYXRjaChhKXtyZXR1cm4hMX19KCk7ZS5pc0VuY29kaW5nPWZ1bmN0aW9uKGgpe3N3aXRjaChTdHJpbmcoaCkudG9Mb3dlckNhc2UoKSl7Y2FzZSBcXFwiaGV4XFxcIjpjYXNlIFxcXCJ1dGY4XFxcIjpjYXNlIFxcXCJ1dGYtOFxcXCI6Y2FzZSBcXFwiYXNjaWlcXFwiOmNhc2UgXFxcImJpbmFyeVxcXCI6Y2FzZSBcXFwiYmFzZTY0XFxcIjpjYXNlIFxcXCJyYXdcXFwiOmNhc2UgXFxcInVjczJcXFwiOmNhc2UgXFxcInVjcy0yXFxcIjpjYXNlIFxcXCJ1dGYxNmxlXFxcIjpjYXNlIFxcXCJ1dGYtMTZsZVxcXCI6cmV0dXJuITA7XFxuZGVmYXVsdDpyZXR1cm4hMX19O2UuaXNCdWZmZXI9ZnVuY3Rpb24oaCl7cmV0dXJuIShudWxsPT09aHx8dm9pZCAwPT09aHx8IWguX2lzQnVmZmVyKX07ZS5ieXRlTGVuZ3RoPWZ1bmN0aW9uKGgsYyl7dmFyIGE7aCs9XFxcIlxcXCI7c3dpdGNoKGN8fFxcXCJ1dGY4XFxcIil7Y2FzZSBcXFwiaGV4XFxcIjphPWgubGVuZ3RoLzI7YnJlYWs7Y2FzZSBcXFwidXRmOFxcXCI6Y2FzZSBcXFwidXRmLThcXFwiOmE9dShoKS5sZW5ndGg7YnJlYWs7Y2FzZSBcXFwiYXNjaWlcXFwiOmNhc2UgXFxcImJpbmFyeVxcXCI6Y2FzZSBcXFwicmF3XFxcIjphPWgubGVuZ3RoO2JyZWFrO2Nhc2UgXFxcImJhc2U2NFxcXCI6YT1KLnRvQnl0ZUFycmF5KGgpLmxlbmd0aDticmVhaztjYXNlIFxcXCJ1Y3MyXFxcIjpjYXNlIFxcXCJ1Y3MtMlxcXCI6Y2FzZSBcXFwidXRmMTZsZVxcXCI6Y2FzZSBcXFwidXRmLTE2bGVcXFwiOmE9MipoLmxlbmd0aDticmVhaztkZWZhdWx0OnRocm93IEVycm9yKFxcXCJVbmtub3duIGVuY29kaW5nXFxcIik7fXJldHVybiBhfTtlLmNvbmNhdD1mdW5jdGlvbihoLGMpe3AoRShoKSxcXFwiVXNhZ2U6IEJ1ZmZlci5jb25jYXQobGlzdCwgW3RvdGFsTGVuZ3RoXSlcXFxcbmxpc3Qgc2hvdWxkIGJlIGFuIEFycmF5LlxcXCIpO1xcbmlmKDA9PT1oLmxlbmd0aClyZXR1cm4gbmV3IGUoMCk7aWYoMT09PWgubGVuZ3RoKXJldHVybiBoWzBdO3ZhciBhO2lmKFxcXCJudW1iZXJcXFwiIT09dHlwZW9mIGMpZm9yKGE9Yz0wO2E8aC5sZW5ndGg7YSsrKWMrPWhbYV0ubGVuZ3RoO3ZhciBkPW5ldyBlKGMpLGI9MDtmb3IoYT0wO2E8aC5sZW5ndGg7YSsrKXt2YXIgZj1oW2FdO2YuY29weShkLGIpO2IrPWYubGVuZ3RofXJldHVybiBkfTtlLnByb3RvdHlwZS53cml0ZT1mdW5jdGlvbihoLGMsYSxkKXtpZihpc0Zpbml0ZShjKSlpc0Zpbml0ZShhKXx8KGQ9YSxhPXZvaWQgMCk7ZWxzZXt2YXIgYj1kO2Q9YztjPWE7YT1ifWM9TnVtYmVyKGMpfHwwO2I9dGhpcy5sZW5ndGgtYzthPyhhPU51bWJlcihhKSxhPmImJihhPWIpKTphPWI7ZD1TdHJpbmcoZHx8XFxcInV0ZjhcXFwiKS50b0xvd2VyQ2FzZSgpO3N3aXRjaChkKXtjYXNlIFxcXCJoZXhcXFwiOmM9TnVtYmVyKGMpfHwwO2Q9dGhpcy5sZW5ndGgtYzthPyhhPU51bWJlcihhKSxhPmQmJihhPWQpKTphPWQ7ZD1cXG5oLmxlbmd0aDtwKDA9PT1kJTIsXFxcIkludmFsaWQgaGV4IHN0cmluZ1xcXCIpO2E+ZC8yJiYoYT1kLzIpO2ZvcihkPTA7ZDxhO2QrKyliPXBhcnNlSW50KGguc3Vic3RyKDIqZCwyKSwxNikscCghaXNOYU4oYiksXFxcIkludmFsaWQgaGV4IHN0cmluZ1xcXCIpLHRoaXNbYytkXT1iO2UuX2NoYXJzV3JpdHRlbj0yKmQ7aD1kO2JyZWFrO2Nhc2UgXFxcInV0ZjhcXFwiOmNhc2UgXFxcInV0Zi04XFxcIjpoPWUuX2NoYXJzV3JpdHRlbj16KHUoaCksdGhpcyxjLGEpO2JyZWFrO2Nhc2UgXFxcImFzY2lpXFxcIjpoPWUuX2NoYXJzV3JpdHRlbj16KEMoaCksdGhpcyxjLGEpO2JyZWFrO2Nhc2UgXFxcImJpbmFyeVxcXCI6aD1lLl9jaGFyc1dyaXR0ZW49eihDKGgpLHRoaXMsYyxhKTticmVhaztjYXNlIFxcXCJiYXNlNjRcXFwiOmg9ZS5fY2hhcnNXcml0dGVuPXooSi50b0J5dGVBcnJheShoKSx0aGlzLGMsYSk7YnJlYWs7Y2FzZSBcXFwidWNzMlxcXCI6Y2FzZSBcXFwidWNzLTJcXFwiOmNhc2UgXFxcInV0ZjE2bGVcXFwiOmNhc2UgXFxcInV0Zi0xNmxlXFxcIjpmb3IodmFyIGYsYj1bXSxrPTA7azxoLmxlbmd0aDtrKyspZj1cXG5oLmNoYXJDb2RlQXQoayksZD1mPj44LGYlPTI1NixiLnB1c2goZiksYi5wdXNoKGQpO2g9ZS5fY2hhcnNXcml0dGVuPXooYix0aGlzLGMsYSk7YnJlYWs7ZGVmYXVsdDp0aHJvdyBFcnJvcihcXFwiVW5rbm93biBlbmNvZGluZ1xcXCIpO31yZXR1cm4gaH07ZS5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oYSxjLGQpe2E9U3RyaW5nKGF8fFxcXCJ1dGY4XFxcIikudG9Mb3dlckNhc2UoKTtjPU51bWJlcihjKXx8MDtkPXZvaWQgMCE9PWQ/TnVtYmVyKGQpOmQ9dGhpcy5sZW5ndGg7aWYoZD09PWMpcmV0dXJuXFxcIlxcXCI7c3dpdGNoKGEpe2Nhc2UgXFxcImhleFxcXCI6YT10aGlzLmxlbmd0aDtpZighY3x8MD5jKWM9MDtpZighZHx8MD5kfHxkPmEpZD1hO2ZvcihhPVxcXCJcXFwiO2M8ZDtjKyspYSs9Ryh0aGlzW2NdKTtkPWE7YnJlYWs7Y2FzZSBcXFwidXRmOFxcXCI6Y2FzZSBcXFwidXRmLThcXFwiOnZhciBiPWE9XFxcIlxcXCI7Zm9yKGQ9TWF0aC5taW4odGhpcy5sZW5ndGgsZCk7YzxkO2MrKykxMjc+PXRoaXNbY10/KGErPUQoYikrU3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzW2NdKSxcXG5iPVxcXCJcXFwiKTpiKz1cXFwiJVxcXCIrdGhpc1tjXS50b1N0cmluZygxNik7ZD1hK0QoYik7YnJlYWs7Y2FzZSBcXFwiYXNjaWlcXFwiOmQ9cih0aGlzLGMsZCk7YnJlYWs7Y2FzZSBcXFwiYmluYXJ5XFxcIjpkPXIodGhpcyxjLGQpO2JyZWFrO2Nhc2UgXFxcImJhc2U2NFxcXCI6ZD0wPT09YyYmZD09PXRoaXMubGVuZ3RoP0ouZnJvbUJ5dGVBcnJheSh0aGlzKTpKLmZyb21CeXRlQXJyYXkodGhpcy5zbGljZShjLGQpKTticmVhaztjYXNlIFxcXCJ1Y3MyXFxcIjpjYXNlIFxcXCJ1Y3MtMlxcXCI6Y2FzZSBcXFwidXRmMTZsZVxcXCI6Y2FzZSBcXFwidXRmLTE2bGVcXFwiOmQ9dGhpcy5zbGljZShjLGQpO2M9XFxcIlxcXCI7Zm9yKGE9MDthPGQubGVuZ3RoO2ErPTIpYys9U3RyaW5nLmZyb21DaGFyQ29kZShkW2FdKzI1NipkW2ErMV0pO2Q9YzticmVhaztkZWZhdWx0OnRocm93IEVycm9yKFxcXCJVbmtub3duIGVuY29kaW5nXFxcIik7fXJldHVybiBkfTtlLnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpcXFwiQnVmZmVyXFxcIixkYXRhOkFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2Fycnx8XFxudGhpcywwKX19O2UucHJvdG90eXBlLmNvcHk9ZnVuY3Rpb24oYSxjLGQsYil7ZHx8KGQ9MCk7Ynx8MD09PWJ8fChiPXRoaXMubGVuZ3RoKTtjfHwoYz0wKTtpZihiIT09ZCYmMCE9PWEubGVuZ3RoJiYwIT09dGhpcy5sZW5ndGgpaWYocChiPj1kLFxcXCJzb3VyY2VFbmQgPCBzb3VyY2VTdGFydFxcXCIpLHAoMDw9YyYmYzxhLmxlbmd0aCxcXFwidGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kc1xcXCIpLHAoMDw9ZCYmZDx0aGlzLmxlbmd0aCxcXFwic291cmNlU3RhcnQgb3V0IG9mIGJvdW5kc1xcXCIpLHAoMDw9YiYmYjw9dGhpcy5sZW5ndGgsXFxcInNvdXJjZUVuZCBvdXQgb2YgYm91bmRzXFxcIiksYj50aGlzLmxlbmd0aCYmKGI9dGhpcy5sZW5ndGgpLGEubGVuZ3RoLWM8Yi1kJiYoYj1hLmxlbmd0aC1jK2QpLGItPWQsMTAwPmJ8fCFlLl91c2VUeXBlZEFycmF5cylmb3IodmFyIGY9MDtmPGI7ZisrKWFbZitjXT10aGlzW2YrZF07ZWxzZSBhLl9zZXQodGhpcy5zdWJhcnJheShkLGQrYiksYyl9O2UucHJvdG90eXBlLnNsaWNlPVxcbmZ1bmN0aW9uKGEsYyl7dmFyIGQ9dGhpcy5sZW5ndGg7YT1CKGEsZCwwKTtjPUIoYyxkLGQpO2lmKGUuX3VzZVR5cGVkQXJyYXlzKXJldHVybiBlLl9hdWdtZW50KHRoaXMuc3ViYXJyYXkoYSxjKSk7Zm9yKHZhciBkPWMtYSxiPW5ldyBlKGQsdm9pZCAwLCEwKSxmPTA7ZjxkO2YrKyliW2ZdPXRoaXNbZithXTtyZXR1cm4gYn07ZS5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKGEpe2NvbnNvbGUubG9nKFxcXCIuZ2V0KCkgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHVzaW5nIGFycmF5IGluZGV4ZXMgaW5zdGVhZC5cXFwiKTtyZXR1cm4gdGhpcy5yZWFkVUludDgoYSl9O2UucHJvdG90eXBlLnNldD1mdW5jdGlvbihhLGMpe2NvbnNvbGUubG9nKFxcXCIuc2V0KCkgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHVzaW5nIGFycmF5IGluZGV4ZXMgaW5zdGVhZC5cXFwiKTtyZXR1cm4gdGhpcy53cml0ZVVJbnQ4KGEsYyl9O2UucHJvdG90eXBlLnJlYWRVSW50OD1mdW5jdGlvbihhLGMpe2N8fChwKHZvaWQgMCE9PWEmJm51bGwhPT1cXG5hLFxcXCJtaXNzaW5nIG9mZnNldFxcXCIpLHAoYTx0aGlzLmxlbmd0aCxcXFwiVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGhcXFwiKSk7aWYoIShhPj10aGlzLmxlbmd0aCkpcmV0dXJuIHRoaXNbYV19O2UucHJvdG90eXBlLnJlYWRVSW50MTZMRT1mdW5jdGlvbihhLGMpe3JldHVybiBsKHRoaXMsYSwhMCxjKX07ZS5wcm90b3R5cGUucmVhZFVJbnQxNkJFPWZ1bmN0aW9uKGEsYyl7cmV0dXJuIGwodGhpcyxhLCExLGMpfTtlLnByb3RvdHlwZS5yZWFkVUludDMyTEU9ZnVuY3Rpb24oYSxjKXtyZXR1cm4gbSh0aGlzLGEsITAsYyl9O2UucHJvdG90eXBlLnJlYWRVSW50MzJCRT1mdW5jdGlvbihhLGMpe3JldHVybiBtKHRoaXMsYSwhMSxjKX07ZS5wcm90b3R5cGUucmVhZEludDg9ZnVuY3Rpb24oYSxjKXtjfHwocCh2b2lkIDAhPT1hJiZudWxsIT09YSxcXFwibWlzc2luZyBvZmZzZXRcXFwiKSxwKGE8dGhpcy5sZW5ndGgsXFxcIlRyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoXFxcIikpO2lmKCEoYT49XFxudGhpcy5sZW5ndGgpKXJldHVybiB0aGlzW2FdJjEyOD8tMSooMjU1LXRoaXNbYV0rMSk6dGhpc1thXX07ZS5wcm90b3R5cGUucmVhZEludDE2TEU9ZnVuY3Rpb24oYSxjKXtyZXR1cm4gZyh0aGlzLGEsITAsYyl9O2UucHJvdG90eXBlLnJlYWRJbnQxNkJFPWZ1bmN0aW9uKGEsYyl7cmV0dXJuIGcodGhpcyxhLCExLGMpfTtlLnByb3RvdHlwZS5yZWFkSW50MzJMRT1mdW5jdGlvbihhLGMpe3JldHVybiBiKHRoaXMsYSwhMCxjKX07ZS5wcm90b3R5cGUucmVhZEludDMyQkU9ZnVuY3Rpb24oYSxjKXtyZXR1cm4gYih0aGlzLGEsITEsYyl9O2UucHJvdG90eXBlLnJlYWRGbG9hdExFPWZ1bmN0aW9uKGEsYyl7cmV0dXJuIGYodGhpcyxhLCEwLGMpfTtlLnByb3RvdHlwZS5yZWFkRmxvYXRCRT1mdW5jdGlvbihhLGMpe3JldHVybiBmKHRoaXMsYSwhMSxjKX07ZS5wcm90b3R5cGUucmVhZERvdWJsZUxFPWZ1bmN0aW9uKGEsYyl7cmV0dXJuIGsodGhpcyxhLCEwLGMpfTtlLnByb3RvdHlwZS5yZWFkRG91YmxlQkU9XFxuZnVuY3Rpb24oYSxjKXtyZXR1cm4gayh0aGlzLGEsITEsYyl9O2UucHJvdG90eXBlLndyaXRlVUludDg9ZnVuY3Rpb24oYSxjLGQpe2R8fChwKHZvaWQgMCE9PWEmJm51bGwhPT1hLFxcXCJtaXNzaW5nIHZhbHVlXFxcIikscCh2b2lkIDAhPT1jJiZudWxsIT09YyxcXFwibWlzc2luZyBvZmZzZXRcXFwiKSxwKGM8dGhpcy5sZW5ndGgsXFxcInRyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aFxcXCIpLEgoYSwyNTUpKTtjPj10aGlzLmxlbmd0aHx8KHRoaXNbY109YSl9O2UucHJvdG90eXBlLndyaXRlVUludDE2TEU9ZnVuY3Rpb24oYyxkLGIpe2EodGhpcyxjLGQsITAsYil9O2UucHJvdG90eXBlLndyaXRlVUludDE2QkU9ZnVuY3Rpb24oYyxkLGIpe2EodGhpcyxjLGQsITEsYil9O2UucHJvdG90eXBlLndyaXRlVUludDMyTEU9ZnVuY3Rpb24oYSxkLGIpe2ModGhpcyxhLGQsITAsYil9O2UucHJvdG90eXBlLndyaXRlVUludDMyQkU9ZnVuY3Rpb24oYSxkLGIpe2ModGhpcyxhLGQsITEsYil9O2UucHJvdG90eXBlLndyaXRlSW50OD1cXG5mdW5jdGlvbihhLGMsZCl7ZHx8KHAodm9pZCAwIT09YSYmbnVsbCE9PWEsXFxcIm1pc3NpbmcgdmFsdWVcXFwiKSxwKHZvaWQgMCE9PWMmJm51bGwhPT1jLFxcXCJtaXNzaW5nIG9mZnNldFxcXCIpLHAoYzx0aGlzLmxlbmd0aCxcXFwiVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoXFxcIiksTChhLDEyNywtMTI4KSk7Yz49dGhpcy5sZW5ndGh8fCgwPD1hP3RoaXMud3JpdGVVSW50OChhLGMsZCk6dGhpcy53cml0ZVVJbnQ4KDI1NSthKzEsYyxkKSl9O2UucHJvdG90eXBlLndyaXRlSW50MTZMRT1mdW5jdGlvbihhLGMsYil7ZCh0aGlzLGEsYywhMCxiKX07ZS5wcm90b3R5cGUud3JpdGVJbnQxNkJFPWZ1bmN0aW9uKGEsYyxiKXtkKHRoaXMsYSxjLCExLGIpfTtlLnByb3RvdHlwZS53cml0ZUludDMyTEU9ZnVuY3Rpb24oYSxjLGQpe3kodGhpcyxhLGMsITAsZCl9O2UucHJvdG90eXBlLndyaXRlSW50MzJCRT1mdW5jdGlvbihhLGMsZCl7eSh0aGlzLGEsYywhMSxkKX07ZS5wcm90b3R5cGUud3JpdGVGbG9hdExFPVxcbmZ1bmN0aW9uKGEsYyxkKXt4KHRoaXMsYSxjLCEwLGQpfTtlLnByb3RvdHlwZS53cml0ZUZsb2F0QkU9ZnVuY3Rpb24oYSxjLGQpe3godGhpcyxhLGMsITEsZCl9O2UucHJvdG90eXBlLndyaXRlRG91YmxlTEU9ZnVuY3Rpb24oYSxjLGQpe0EodGhpcyxhLGMsITAsZCl9O2UucHJvdG90eXBlLndyaXRlRG91YmxlQkU9ZnVuY3Rpb24oYSxjLGQpe0EodGhpcyxhLGMsITEsZCl9O2UucHJvdG90eXBlLmZpbGw9ZnVuY3Rpb24oYSxjLGQpe2F8fChhPTApO2N8fChjPTApO2R8fChkPXRoaXMubGVuZ3RoKTtcXFwic3RyaW5nXFxcIj09PXR5cGVvZiBhJiYoYT1hLmNoYXJDb2RlQXQoMCkpO3AoXFxcIm51bWJlclxcXCI9PT10eXBlb2YgYSYmIWlzTmFOKGEpLFxcXCJ2YWx1ZSBpcyBub3QgYSBudW1iZXJcXFwiKTtwKGQ+PWMsXFxcImVuZCA8IHN0YXJ0XFxcIik7aWYoZCE9PWMmJjAhPT10aGlzLmxlbmd0aClmb3IocCgwPD1jJiZjPHRoaXMubGVuZ3RoLFxcXCJzdGFydCBvdXQgb2YgYm91bmRzXFxcIikscCgwPD1kJiZkPD10aGlzLmxlbmd0aCxcXG5cXFwiZW5kIG91dCBvZiBib3VuZHNcXFwiKTtjPGQ7YysrKXRoaXNbY109YX07ZS5wcm90b3R5cGUuaW5zcGVjdD1mdW5jdGlvbigpe2Zvcih2YXIgYT1bXSxjPXRoaXMubGVuZ3RoLGQ9MDtkPGM7ZCsrKWlmKGFbZF09Ryh0aGlzW2RdKSxkPT09dC5JTlNQRUNUX01BWF9CWVRFUyl7YVtkKzFdPVxcXCIuLi5cXFwiO2JyZWFrfXJldHVyblxcXCI8QnVmZmVyIFxcXCIrYS5qb2luKFxcXCIgXFxcIikrXFxcIj5cXFwifTtlLnByb3RvdHlwZS50b0FycmF5QnVmZmVyPWZ1bmN0aW9uKCl7aWYoXFxcInVuZGVmaW5lZFxcXCIhPT10eXBlb2YgVWludDhBcnJheSl7aWYoZS5fdXNlVHlwZWRBcnJheXMpcmV0dXJuKG5ldyBlKHRoaXMpKS5idWZmZXI7Zm9yKHZhciBhPW5ldyBVaW50OEFycmF5KHRoaXMubGVuZ3RoKSxjPTAsZD1hLmxlbmd0aDtjPGQ7Yys9MSlhW2NdPXRoaXNbY107cmV0dXJuIGEuYnVmZmVyfXRocm93IEVycm9yKFxcXCJCdWZmZXIudG9BcnJheUJ1ZmZlciBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlclxcXCIpO307dmFyIHY9ZS5wcm90b3R5cGU7XFxuZS5fYXVnbWVudD1mdW5jdGlvbihhKXthLl9pc0J1ZmZlcj0hMDthLl9nZXQ9YS5nZXQ7YS5fc2V0PWEuc2V0O2EuZ2V0PXYuZ2V0O2Euc2V0PXYuc2V0O2Eud3JpdGU9di53cml0ZTthLnRvU3RyaW5nPXYudG9TdHJpbmc7YS50b0xvY2FsZVN0cmluZz12LnRvU3RyaW5nO2EudG9KU09OPXYudG9KU09OO2EuY29weT12LmNvcHk7YS5zbGljZT12LnNsaWNlO2EucmVhZFVJbnQ4PXYucmVhZFVJbnQ4O2EucmVhZFVJbnQxNkxFPXYucmVhZFVJbnQxNkxFO2EucmVhZFVJbnQxNkJFPXYucmVhZFVJbnQxNkJFO2EucmVhZFVJbnQzMkxFPXYucmVhZFVJbnQzMkxFO2EucmVhZFVJbnQzMkJFPXYucmVhZFVJbnQzMkJFO2EucmVhZEludDg9di5yZWFkSW50ODthLnJlYWRJbnQxNkxFPXYucmVhZEludDE2TEU7YS5yZWFkSW50MTZCRT12LnJlYWRJbnQxNkJFO2EucmVhZEludDMyTEU9di5yZWFkSW50MzJMRTthLnJlYWRJbnQzMkJFPXYucmVhZEludDMyQkU7YS5yZWFkRmxvYXRMRT12LnJlYWRGbG9hdExFO1xcbmEucmVhZEZsb2F0QkU9di5yZWFkRmxvYXRCRTthLnJlYWREb3VibGVMRT12LnJlYWREb3VibGVMRTthLnJlYWREb3VibGVCRT12LnJlYWREb3VibGVCRTthLndyaXRlVUludDg9di53cml0ZVVJbnQ4O2Eud3JpdGVVSW50MTZMRT12LndyaXRlVUludDE2TEU7YS53cml0ZVVJbnQxNkJFPXYud3JpdGVVSW50MTZCRTthLndyaXRlVUludDMyTEU9di53cml0ZVVJbnQzMkxFO2Eud3JpdGVVSW50MzJCRT12LndyaXRlVUludDMyQkU7YS53cml0ZUludDg9di53cml0ZUludDg7YS53cml0ZUludDE2TEU9di53cml0ZUludDE2TEU7YS53cml0ZUludDE2QkU9di53cml0ZUludDE2QkU7YS53cml0ZUludDMyTEU9di53cml0ZUludDMyTEU7YS53cml0ZUludDMyQkU9di53cml0ZUludDMyQkU7YS53cml0ZUZsb2F0TEU9di53cml0ZUZsb2F0TEU7YS53cml0ZUZsb2F0QkU9di53cml0ZUZsb2F0QkU7YS53cml0ZURvdWJsZUxFPXYud3JpdGVEb3VibGVMRTthLndyaXRlRG91YmxlQkU9di53cml0ZURvdWJsZUJFO1xcbmEuZmlsbD12LmZpbGw7YS5pbnNwZWN0PXYuaW5zcGVjdDthLnRvQXJyYXlCdWZmZXI9di50b0FycmF5QnVmZmVyO3JldHVybiBhfX0se1xcXCJiYXNlNjQtanNcXFwiOjMsaWVlZTc1NDo2fV0sNjpbZnVuY3Rpb24obix3LHQpe3QucmVhZD1mdW5jdGlvbihlLHIsbCxtLGcpe3ZhciBiO2I9OCpnLW0tMTt2YXIgZj0oMTw8YiktMSxrPWY+PjEsYT0tNztnPWw/Zy0xOjA7dmFyIGM9bD8tMToxLGQ9ZVtyK2ddO2crPWM7bD1kJigxPDwtYSktMTtkPj49LWE7Zm9yKGErPWI7MDxhO2w9MjU2KmwrZVtyK2ddLGcrPWMsYS09OCk7Yj1sJigxPDwtYSktMTtsPj49LWE7Zm9yKGErPW07MDxhO2I9MjU2KmIrZVtyK2ddLGcrPWMsYS09OCk7aWYoMD09PWwpbD0xLWs7ZWxzZXtpZihsPT09ZilyZXR1cm4gYj9OYU46SW5maW5pdHkqKGQ/LTE6MSk7Yis9TWF0aC5wb3coMixtKTtsLT1rfXJldHVybihkPy0xOjEpKmIqTWF0aC5wb3coMixsLW0pfTt0LndyaXRlPWZ1bmN0aW9uKGUscixsLG0sZyxiKXt2YXIgZixcXG5rPTgqYi1nLTEsYT0oMTw8ayktMSxjPWE+PjEsZD0yMz09PWc/TWF0aC5wb3coMiwtMjQpLU1hdGgucG93KDIsLTc3KTowO2I9bT8wOmItMTt2YXIgeT1tPzE6LTEseD0wPnJ8fDA9PT1yJiYwPjEvcj8xOjA7cj1NYXRoLmFicyhyKTtpc05hTihyKXx8SW5maW5pdHk9PT1yPyhyPWlzTmFOKHIpPzE6MCxtPWEpOihtPU1hdGguZmxvb3IoTWF0aC5sb2cocikvTWF0aC5MTjIpLDE+ciooZj1NYXRoLnBvdygyLC1tKSkmJihtLS0sZio9Mikscj0xPD1tK2M/citkL2Y6citkKk1hdGgucG93KDIsMS1jKSwyPD1yKmYmJihtKyssZi89MiksbStjPj1hPyhyPTAsbT1hKToxPD1tK2M/KHI9KHIqZi0xKSpNYXRoLnBvdygyLGcpLG0rPWMpOihyPXIqTWF0aC5wb3coMixjLTEpKk1hdGgucG93KDIsZyksbT0wKSk7Zm9yKDs4PD1nO2VbbCtiXT1yJjI1NSxiKz15LHIvPTI1NixnLT04KTttPW08PGd8cjtmb3Ioays9ZzswPGs7ZVtsK2JdPW0mMjU1LGIrPXksbS89MjU2LGstPTgpO2VbbCtiLXldfD1cXG4xMjgqeH19LHt9XSw3OltmdW5jdGlvbihuLHcsdCl7KGZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHIoYixmKXtmb3IodmFyIGU9MCxhPWIubGVuZ3RoLTE7MDw9YTthLS0pe3ZhciBjPWJbYV07XFxcIi5cXFwiPT09Yz9iLnNwbGljZShhLDEpOlxcXCIuLlxcXCI9PT1jPyhiLnNwbGljZShhLDEpLGUrKyk6ZSYmKGIuc3BsaWNlKGEsMSksZS0tKX1pZihmKWZvcig7ZS0tO2UpYi51bnNoaWZ0KFxcXCIuLlxcXCIpO3JldHVybiBifWZ1bmN0aW9uIGwoYixmKXtpZihiLmZpbHRlcilyZXR1cm4gYi5maWx0ZXIoZik7Zm9yKHZhciBlPVtdLGE9MDthPGIubGVuZ3RoO2ErKylmKGJbYV0sYSxiKSYmZS5wdXNoKGJbYV0pO3JldHVybiBlfXZhciBtPS9eKFxcXFwvP3wpKFtcXFxcc1xcXFxTXSo/KSgoPzpcXFxcLnsxLDJ9fFteXFxcXC9dKz98KShcXFxcLlteLlxcXFwvXSp8KSkoPzpbXFxcXC9dKikkLzt0LnJlc29sdmU9ZnVuY3Rpb24oKXtmb3IodmFyIGI9XFxcIlxcXCIsZj0hMSxrPWFyZ3VtZW50cy5sZW5ndGgtMTstMTw9ayYmIWY7ay0tKXt2YXIgYT0wPD1rP2FyZ3VtZW50c1trXTpcXG5lLmN3ZCgpO2lmKFxcXCJzdHJpbmdcXFwiIT09dHlwZW9mIGEpdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3NcXFwiKTthJiYoYj1hK1xcXCIvXFxcIitiLGY9XFxcIi9cXFwiPT09YS5jaGFyQXQoMCkpfWI9cihsKGIuc3BsaXQoXFxcIi9cXFwiKSxmdW5jdGlvbihhKXtyZXR1cm4hIWF9KSwhZikuam9pbihcXFwiL1xcXCIpO3JldHVybihmP1xcXCIvXFxcIjpcXFwiXFxcIikrYnx8XFxcIi5cXFwifTt0Lm5vcm1hbGl6ZT1mdW5jdGlvbihiKXt2YXIgZj10LmlzQWJzb2x1dGUoYiksZT1cXFwiL1xcXCI9PT1nKGIsLTEpOyhiPXIobChiLnNwbGl0KFxcXCIvXFxcIiksZnVuY3Rpb24oYSl7cmV0dXJuISFhfSksIWYpLmpvaW4oXFxcIi9cXFwiKSl8fGZ8fChiPVxcXCIuXFxcIik7YiYmZSYmKGIrPVxcXCIvXFxcIik7cmV0dXJuKGY/XFxcIi9cXFwiOlxcXCJcXFwiKStifTt0LmlzQWJzb2x1dGU9ZnVuY3Rpb24oYil7cmV0dXJuXFxcIi9cXFwiPT09Yi5jaGFyQXQoMCl9O3Quam9pbj1mdW5jdGlvbigpe3ZhciBiPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywwKTtyZXR1cm4gdC5ub3JtYWxpemUobChiLFxcbmZ1bmN0aW9uKGIsZSl7aWYoXFxcInN0cmluZ1xcXCIhPT10eXBlb2YgYil0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJBcmd1bWVudHMgdG8gcGF0aC5qb2luIG11c3QgYmUgc3RyaW5nc1xcXCIpO3JldHVybiBifSkuam9pbihcXFwiL1xcXCIpKX07dC5yZWxhdGl2ZT1mdW5jdGlvbihiLGYpe2Z1bmN0aW9uIGUoYSl7Zm9yKHZhciBjPTA7YzxhLmxlbmd0aCYmXFxcIlxcXCI9PT1hW2NdO2MrKyk7Zm9yKHZhciBkPWEubGVuZ3RoLTE7MDw9ZCYmXFxcIlxcXCI9PT1hW2RdO2QtLSk7cmV0dXJuIGM+ZD9bXTphLnNsaWNlKGMsZC1jKzEpfWI9dC5yZXNvbHZlKGIpLnN1YnN0cigxKTtmPXQucmVzb2x2ZShmKS5zdWJzdHIoMSk7Zm9yKHZhciBhPWUoYi5zcGxpdChcXFwiL1xcXCIpKSxjPWUoZi5zcGxpdChcXFwiL1xcXCIpKSxkPU1hdGgubWluKGEubGVuZ3RoLGMubGVuZ3RoKSxnPWQseD0wO3g8ZDt4KyspaWYoYVt4XSE9PWNbeF0pe2c9eDticmVha31kPVtdO2Zvcih4PWc7eDxhLmxlbmd0aDt4KyspZC5wdXNoKFxcXCIuLlxcXCIpO2Q9ZC5jb25jYXQoYy5zbGljZShnKSk7XFxucmV0dXJuIGQuam9pbihcXFwiL1xcXCIpfTt0LnNlcD1cXFwiL1xcXCI7dC5kZWxpbWl0ZXI9XFxcIjpcXFwiO3QuZGlybmFtZT1mdW5jdGlvbihiKXt2YXIgZj1tLmV4ZWMoYikuc2xpY2UoMSk7Yj1mWzBdO2Y9ZlsxXTtpZighYiYmIWYpcmV0dXJuXFxcIi5cXFwiO2YmJihmPWYuc3Vic3RyKDAsZi5sZW5ndGgtMSkpO3JldHVybiBiK2Z9O3QuYmFzZW5hbWU9ZnVuY3Rpb24oYixmKXt2YXIgZT1tLmV4ZWMoYikuc2xpY2UoMSlbMl07ZiYmZS5zdWJzdHIoLTEqZi5sZW5ndGgpPT09ZiYmKGU9ZS5zdWJzdHIoMCxlLmxlbmd0aC1mLmxlbmd0aCkpO3JldHVybiBlfTt0LmV4dG5hbWU9ZnVuY3Rpb24oYil7cmV0dXJuIG0uZXhlYyhiKS5zbGljZSgxKVszXX07dmFyIGc9XFxcImJcXFwiPT09XFxcImFiXFxcIi5zdWJzdHIoLTEpP2Z1bmN0aW9uKGIsZixlKXtyZXR1cm4gYi5zdWJzdHIoZixlKX06ZnVuY3Rpb24oYixmLGUpezA+ZiYmKGY9Yi5sZW5ndGgrZik7cmV0dXJuIGIuc3Vic3RyKGYsZSl9fSkuY2FsbCh0aGlzLG4oXFxcIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanNcXFwiKSl9LFxcbntcXFwibm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1xcXCI6OH1dLDg6W2Z1bmN0aW9uKG4sdyx0KXtmdW5jdGlvbiBlKCl7fW49dy5leHBvcnRzPXt9O24ubmV4dFRpY2s9ZnVuY3Rpb24oKXtpZihcXFwidW5kZWZpbmVkXFxcIiE9PXR5cGVvZiB3aW5kb3cmJndpbmRvdy5zZXRJbW1lZGlhdGUpcmV0dXJuIGZ1bmN0aW9uKGUpe3JldHVybiB3aW5kb3cuc2V0SW1tZWRpYXRlKGUpfTtpZihcXFwidW5kZWZpbmVkXFxcIiE9PXR5cGVvZiB3aW5kb3cmJndpbmRvdy5wb3N0TWVzc2FnZSYmd2luZG93LmFkZEV2ZW50TGlzdGVuZXIpe3ZhciBlPVtdO3dpbmRvdy5hZGRFdmVudExpc3RlbmVyKFxcXCJtZXNzYWdlXFxcIixmdW5jdGlvbihsKXt2YXIgbT1sLnNvdXJjZTttIT09d2luZG93JiZudWxsIT09bXx8XFxcInByb2Nlc3MtdGlja1xcXCIhPT1sLmRhdGF8fChsLnN0b3BQcm9wYWdhdGlvbigpLDA8ZS5sZW5ndGgmJmUuc2hpZnQoKSgpKX0sITApO3JldHVybiBmdW5jdGlvbihsKXtlLnB1c2gobCk7d2luZG93LnBvc3RNZXNzYWdlKFxcXCJwcm9jZXNzLXRpY2tcXFwiLFxcblxcXCIqXFxcIil9fXJldHVybiBmdW5jdGlvbihlKXtzZXRUaW1lb3V0KGUsMCl9fSgpO24udGl0bGU9XFxcImJyb3dzZXJcXFwiO24uYnJvd3Nlcj0hMDtuLmVudj17fTtuLmFyZ3Y9W107bi5vbj1lO24ub25jZT1lO24ub2ZmPWU7bi5lbWl0PWU7bi5iaW5kaW5nPWZ1bmN0aW9uKGUpe3Rocm93IEVycm9yKFxcXCJwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZFxcXCIpO307bi5jd2Q9ZnVuY3Rpb24oKXtyZXR1cm5cXFwiL1xcXCJ9O24uY2hkaXI9ZnVuY3Rpb24oZSl7dGhyb3cgRXJyb3IoXFxcInByb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZFxcXCIpO319LHt9XSw5OltmdW5jdGlvbihuLHcsdCl7dC5Tb3VyY2VNYXBHZW5lcmF0b3I9bihcXFwiLi9zb3VyY2UtbWFwL3NvdXJjZS1tYXAtZ2VuZXJhdG9yXFxcIikuU291cmNlTWFwR2VuZXJhdG9yO3QuU291cmNlTWFwQ29uc3VtZXI9bihcXFwiLi9zb3VyY2UtbWFwL3NvdXJjZS1tYXAtY29uc3VtZXJcXFwiKS5Tb3VyY2VNYXBDb25zdW1lcjt0LlNvdXJjZU5vZGU9bihcXFwiLi9zb3VyY2UtbWFwL3NvdXJjZS1ub2RlXFxcIikuU291cmNlTm9kZX0sXFxue1xcXCIuL3NvdXJjZS1tYXAvc291cmNlLW1hcC1jb25zdW1lclxcXCI6MTQsXFxcIi4vc291cmNlLW1hcC9zb3VyY2UtbWFwLWdlbmVyYXRvclxcXCI6MTUsXFxcIi4vc291cmNlLW1hcC9zb3VyY2Utbm9kZVxcXCI6MTZ9XSwxMDpbZnVuY3Rpb24obix3LHQpe2lmKFxcXCJmdW5jdGlvblxcXCIhPT10eXBlb2YgZSl2YXIgZT1uKFxcXCJhbWRlZmluZVxcXCIpKHcsbik7ZShmdW5jdGlvbihlLGwsbSl7ZnVuY3Rpb24gZygpe3RoaXMuX2FycmF5PVtdO3RoaXMuX3NldD17fX12YXIgYj1lKFxcXCIuL3V0aWxcXFwiKTtnLmZyb21BcnJheT1mdW5jdGlvbihiLGUpe2Zvcih2YXIgYT1uZXcgZyxjPTAsZD1iLmxlbmd0aDtjPGQ7YysrKWEuYWRkKGJbY10sZSk7cmV0dXJuIGF9O2cucHJvdG90eXBlLmFkZD1mdW5jdGlvbihmLGUpe3ZhciBhPXRoaXMuaGFzKGYpLGM9dGhpcy5fYXJyYXkubGVuZ3RoO2EmJiFlfHx0aGlzLl9hcnJheS5wdXNoKGYpO2F8fCh0aGlzLl9zZXRbYi50b1NldFN0cmluZyhmKV09Yyl9O2cucHJvdG90eXBlLmhhcz1mdW5jdGlvbihmKXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuX3NldCxcXG5iLnRvU2V0U3RyaW5nKGYpKX07Zy5wcm90b3R5cGUuaW5kZXhPZj1mdW5jdGlvbihmKXtpZih0aGlzLmhhcyhmKSlyZXR1cm4gdGhpcy5fc2V0W2IudG9TZXRTdHJpbmcoZildO3Rocm93IEVycm9yKCdcXFwiJytmKydcXFwiIGlzIG5vdCBpbiB0aGUgc2V0LicpO307Zy5wcm90b3R5cGUuYXQ9ZnVuY3Rpb24oYil7aWYoMDw9YiYmYjx0aGlzLl9hcnJheS5sZW5ndGgpcmV0dXJuIHRoaXMuX2FycmF5W2JdO3Rocm93IEVycm9yKFxcXCJObyBlbGVtZW50IGluZGV4ZWQgYnkgXFxcIitiKTt9O2cucHJvdG90eXBlLnRvQXJyYXk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fYXJyYXkuc2xpY2UoKX07bC5BcnJheVNldD1nfSl9LHtcXFwiLi91dGlsXFxcIjoxNyxhbWRlZmluZToyfV0sMTE6W2Z1bmN0aW9uKG4sdyx0KXtpZihcXFwiZnVuY3Rpb25cXFwiIT09dHlwZW9mIGUpdmFyIGU9bihcXFwiYW1kZWZpbmVcXFwiKSh3LG4pO2UoZnVuY3Rpb24oZSxsLG0pe3ZhciBnPWUoXFxcIi4vYmFzZTY0XFxcIik7bC5lbmNvZGU9ZnVuY3Rpb24oYil7dmFyIGU9XFxuXFxcIlxcXCIsaz0wPmI/KC1iPDwxKSsxOihiPDwxKSswO2RvIGI9ayYzMSxrPj4+PTUsMDxrJiYoYnw9MzIpLGUrPWcuZW5jb2RlKGIpO3doaWxlKDA8ayk7cmV0dXJuIGV9O2wuZGVjb2RlPWZ1bmN0aW9uKGIpe3ZhciBlPTAsaz1iLmxlbmd0aCxhPTAsYz0wLGQseTtkb3tpZihlPj1rKXRocm93IEVycm9yKFxcXCJFeHBlY3RlZCBtb3JlIGRpZ2l0cyBpbiBiYXNlIDY0IFZMUSB2YWx1ZS5cXFwiKTt5PWcuZGVjb2RlKGIuY2hhckF0KGUrKykpO2Q9ISEoeSYzMik7eSY9MzE7YSs9eTw8YztjKz01fXdoaWxlKGQpO2s9YT4+MTtyZXR1cm57dmFsdWU6MT09PShhJjEpPy1rOmsscmVzdDpiLnNsaWNlKGUpfX19KX0se1xcXCIuL2Jhc2U2NFxcXCI6MTIsYW1kZWZpbmU6Mn1dLDEyOltmdW5jdGlvbihuLHcsdCl7aWYoXFxcImZ1bmN0aW9uXFxcIiE9PXR5cGVvZiBlKXZhciBlPW4oXFxcImFtZGVmaW5lXFxcIikodyxuKTtlKGZ1bmN0aW9uKGUsbCxtKXt2YXIgZz17fSxiPXt9O1xcXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXFxcIi5zcGxpdChcXFwiXFxcIikuZm9yRWFjaChmdW5jdGlvbihlLFxcbmspe2dbZV09aztiW2tdPWV9KTtsLmVuY29kZT1mdW5jdGlvbihlKXtpZihlIGluIGIpcmV0dXJuIGJbZV07dGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiTXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDYzOiBcXFwiK2UpO307bC5kZWNvZGU9ZnVuY3Rpb24oYil7aWYoYiBpbiBnKXJldHVybiBnW2JdO3Rocm93IG5ldyBUeXBlRXJyb3IoXFxcIk5vdCBhIHZhbGlkIGJhc2UgNjQgZGlnaXQ6IFxcXCIrYik7fX0pfSx7YW1kZWZpbmU6Mn1dLDEzOltmdW5jdGlvbihuLHcsdCl7aWYoXFxcImZ1bmN0aW9uXFxcIiE9PXR5cGVvZiBlKXZhciBlPW4oXFxcImFtZGVmaW5lXFxcIikodyxuKTtlKGZ1bmN0aW9uKGUsbCxtKXtmdW5jdGlvbiBnKGIsZSxrLGEsYyl7dmFyIGQ9TWF0aC5mbG9vcigoZS1iKS8yKStiLHk9YyhrLGFbZF0sITApO3JldHVybiAwPT09eT9hW2RdOjA8eT8xPGUtZD9nKGQsZSxrLGEsYyk6YVtkXToxPGQtYj9nKGIsZCxrLGEsYyk6MD5iP251bGw6YVtiXX1sLnNlYXJjaD1mdW5jdGlvbihiLGUsayl7cmV0dXJuIDA8ZS5sZW5ndGg/XFxuZygtMSxlLmxlbmd0aCxiLGUsayk6bnVsbH19KX0se2FtZGVmaW5lOjJ9XSwxNDpbZnVuY3Rpb24obix3LHQpe2lmKFxcXCJmdW5jdGlvblxcXCIhPT10eXBlb2YgZSl2YXIgZT1uKFxcXCJhbWRlZmluZVxcXCIpKHcsbik7ZShmdW5jdGlvbihlLGwsbSl7ZnVuY3Rpb24gZyhhKXt2YXIgZD1hO1xcXCJzdHJpbmdcXFwiPT09dHlwZW9mIGEmJihkPUpTT04ucGFyc2UoYS5yZXBsYWNlKC9eXFxcXClcXFxcXVxcXFx9Jy8sXFxcIlxcXCIpKSk7YT1iLmdldEFyZyhkLFxcXCJ2ZXJzaW9uXFxcIik7dmFyIGU9Yi5nZXRBcmcoZCxcXFwic291cmNlc1xcXCIpLGY9Yi5nZXRBcmcoZCxcXFwibmFtZXNcXFwiLFtdKSxnPWIuZ2V0QXJnKGQsXFxcInNvdXJjZVJvb3RcXFwiLG51bGwpLGw9Yi5nZXRBcmcoZCxcXFwic291cmNlc0NvbnRlbnRcXFwiLG51bGwpLG09Yi5nZXRBcmcoZCxcXFwibWFwcGluZ3NcXFwiKSxkPWIuZ2V0QXJnKGQsXFxcImZpbGVcXFwiLG51bGwpO2lmKGEhPXRoaXMuX3ZlcnNpb24pdGhyb3cgRXJyb3IoXFxcIlVuc3VwcG9ydGVkIHZlcnNpb246IFxcXCIrYSk7dGhpcy5fbmFtZXM9ay5mcm9tQXJyYXkoZiwhMCk7XFxudGhpcy5fc291cmNlcz1rLmZyb21BcnJheShlLCEwKTt0aGlzLnNvdXJjZVJvb3Q9Zzt0aGlzLnNvdXJjZXNDb250ZW50PWw7dGhpcy5fbWFwcGluZ3M9bTt0aGlzLmZpbGU9ZH12YXIgYj1lKFxcXCIuL3V0aWxcXFwiKSxmPWUoXFxcIi4vYmluYXJ5LXNlYXJjaFxcXCIpLGs9ZShcXFwiLi9hcnJheS1zZXRcXFwiKS5BcnJheVNldCxhPWUoXFxcIi4vYmFzZTY0LXZscVxcXCIpO2cuZnJvbVNvdXJjZU1hcD1mdW5jdGlvbihhKXt2YXIgZD1PYmplY3QuY3JlYXRlKGcucHJvdG90eXBlKTtkLl9uYW1lcz1rLmZyb21BcnJheShhLl9uYW1lcy50b0FycmF5KCksITApO2QuX3NvdXJjZXM9ay5mcm9tQXJyYXkoYS5fc291cmNlcy50b0FycmF5KCksITApO2Quc291cmNlUm9vdD1hLl9zb3VyY2VSb290O2Quc291cmNlc0NvbnRlbnQ9YS5fZ2VuZXJhdGVTb3VyY2VzQ29udGVudChkLl9zb3VyY2VzLnRvQXJyYXkoKSxkLnNvdXJjZVJvb3QpO2QuZmlsZT1hLl9maWxlO2QuX19nZW5lcmF0ZWRNYXBwaW5ncz1hLl9tYXBwaW5ncy5zbGljZSgpLnNvcnQoYi5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnMpO1xcbmQuX19vcmlnaW5hbE1hcHBpbmdzPWEuX21hcHBpbmdzLnNsaWNlKCkuc29ydChiLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKTtyZXR1cm4gZH07Zy5wcm90b3R5cGUuX3ZlcnNpb249MztPYmplY3QuZGVmaW5lUHJvcGVydHkoZy5wcm90b3R5cGUsXFxcInNvdXJjZXNcXFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc291cmNlcy50b0FycmF5KCkubWFwKGZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLnNvdXJjZVJvb3Q/Yi5qb2luKHRoaXMuc291cmNlUm9vdCxhKTphfSx0aGlzKX19KTtnLnByb3RvdHlwZS5fX2dlbmVyYXRlZE1hcHBpbmdzPW51bGw7T2JqZWN0LmRlZmluZVByb3BlcnR5KGcucHJvdG90eXBlLFxcXCJfZ2VuZXJhdGVkTWFwcGluZ3NcXFwiLHtnZXQ6ZnVuY3Rpb24oKXt0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3N8fCh0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3M9W10sdGhpcy5fX29yaWdpbmFsTWFwcGluZ3M9W10sdGhpcy5fcGFyc2VNYXBwaW5ncyh0aGlzLl9tYXBwaW5ncyxcXG50aGlzLnNvdXJjZVJvb3QpKTtyZXR1cm4gdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzfX0pO2cucHJvdG90eXBlLl9fb3JpZ2luYWxNYXBwaW5ncz1udWxsO09iamVjdC5kZWZpbmVQcm9wZXJ0eShnLnByb3RvdHlwZSxcXFwiX29yaWdpbmFsTWFwcGluZ3NcXFwiLHtnZXQ6ZnVuY3Rpb24oKXt0aGlzLl9fb3JpZ2luYWxNYXBwaW5nc3x8KHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncz1bXSx0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncz1bXSx0aGlzLl9wYXJzZU1hcHBpbmdzKHRoaXMuX21hcHBpbmdzLHRoaXMuc291cmNlUm9vdCkpO3JldHVybiB0aGlzLl9fb3JpZ2luYWxNYXBwaW5nc319KTtnLnByb3RvdHlwZS5fcGFyc2VNYXBwaW5ncz1mdW5jdGlvbihjLGQpe2Zvcih2YXIgZT0xLGY9MCxnPTAsaz0wLGw9MCxtPTAscj0vXlssO10vLHU9YyxuOzA8dS5sZW5ndGg7KWlmKFxcXCI7XFxcIj09PXUuY2hhckF0KDApKWUrKyx1PXUuc2xpY2UoMSksZj0wO2Vsc2UgaWYoXFxcIixcXFwiPT09dS5jaGFyQXQoMCkpdT11LnNsaWNlKDEpO1xcbmVsc2V7bj17fTtuLmdlbmVyYXRlZExpbmU9ZTt1PWEuZGVjb2RlKHUpO24uZ2VuZXJhdGVkQ29sdW1uPWYrdS52YWx1ZTtmPW4uZ2VuZXJhdGVkQ29sdW1uO3U9dS5yZXN0O2lmKDA8dS5sZW5ndGgmJiFyLnRlc3QodS5jaGFyQXQoMCkpKXt1PWEuZGVjb2RlKHUpO24uc291cmNlPXRoaXMuX3NvdXJjZXMuYXQobCt1LnZhbHVlKTtsKz11LnZhbHVlO3U9dS5yZXN0O2lmKDA9PT11Lmxlbmd0aHx8ci50ZXN0KHUuY2hhckF0KDApKSl0aHJvdyBFcnJvcihcXFwiRm91bmQgYSBzb3VyY2UsIGJ1dCBubyBsaW5lIGFuZCBjb2x1bW5cXFwiKTt1PWEuZGVjb2RlKHUpO24ub3JpZ2luYWxMaW5lPWcrdS52YWx1ZTtnPW4ub3JpZ2luYWxMaW5lO24ub3JpZ2luYWxMaW5lKz0xO3U9dS5yZXN0O2lmKDA9PT11Lmxlbmd0aHx8ci50ZXN0KHUuY2hhckF0KDApKSl0aHJvdyBFcnJvcihcXFwiRm91bmQgYSBzb3VyY2UgYW5kIGxpbmUsIGJ1dCBubyBjb2x1bW5cXFwiKTt1PWEuZGVjb2RlKHUpO24ub3JpZ2luYWxDb2x1bW49XFxuayt1LnZhbHVlO2s9bi5vcmlnaW5hbENvbHVtbjt1PXUucmVzdDswPHUubGVuZ3RoJiYhci50ZXN0KHUuY2hhckF0KDApKSYmKHU9YS5kZWNvZGUodSksbi5uYW1lPXRoaXMuX25hbWVzLmF0KG0rdS52YWx1ZSksbSs9dS52YWx1ZSx1PXUucmVzdCl9dGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzLnB1c2gobik7XFxcIm51bWJlclxcXCI9PT10eXBlb2Ygbi5vcmlnaW5hbExpbmUmJnRoaXMuX19vcmlnaW5hbE1hcHBpbmdzLnB1c2gobil9dGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzLnNvcnQoYi5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnMpO3RoaXMuX19vcmlnaW5hbE1hcHBpbmdzLnNvcnQoYi5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyl9O2cucHJvdG90eXBlLl9maW5kTWFwcGluZz1mdW5jdGlvbihhLGQsYixlLGcpe2lmKDA+PWFbYl0pdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiTGluZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxLCBnb3QgXFxcIithW2JdKTtpZigwPmFbZV0pdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ29sdW1uIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDAsIGdvdCBcXFwiK1xcbmFbZV0pO3JldHVybiBmLnNlYXJjaChhLGQsZyl9O2cucHJvdG90eXBlLm9yaWdpbmFsUG9zaXRpb25Gb3I9ZnVuY3Rpb24oYSl7YT17Z2VuZXJhdGVkTGluZTpiLmdldEFyZyhhLFxcXCJsaW5lXFxcIiksZ2VuZXJhdGVkQ29sdW1uOmIuZ2V0QXJnKGEsXFxcImNvbHVtblxcXCIpfTtpZihhPXRoaXMuX2ZpbmRNYXBwaW5nKGEsdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3MsXFxcImdlbmVyYXRlZExpbmVcXFwiLFxcXCJnZW5lcmF0ZWRDb2x1bW5cXFwiLGIuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zKSl7dmFyIGQ9Yi5nZXRBcmcoYSxcXFwic291cmNlXFxcIixudWxsKTtkJiZ0aGlzLnNvdXJjZVJvb3QmJihkPWIuam9pbih0aGlzLnNvdXJjZVJvb3QsZCkpO3JldHVybntzb3VyY2U6ZCxsaW5lOmIuZ2V0QXJnKGEsXFxcIm9yaWdpbmFsTGluZVxcXCIsbnVsbCksY29sdW1uOmIuZ2V0QXJnKGEsXFxcIm9yaWdpbmFsQ29sdW1uXFxcIixudWxsKSxuYW1lOmIuZ2V0QXJnKGEsXFxcIm5hbWVcXFwiLG51bGwpfX1yZXR1cm57c291cmNlOm51bGwsbGluZTpudWxsLGNvbHVtbjpudWxsLFxcbm5hbWU6bnVsbH19O2cucHJvdG90eXBlLnNvdXJjZUNvbnRlbnRGb3I9ZnVuY3Rpb24oYSl7aWYoIXRoaXMuc291cmNlc0NvbnRlbnQpcmV0dXJuIG51bGw7dGhpcy5zb3VyY2VSb290JiYoYT1iLnJlbGF0aXZlKHRoaXMuc291cmNlUm9vdCxhKSk7aWYodGhpcy5fc291cmNlcy5oYXMoYSkpcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbdGhpcy5fc291cmNlcy5pbmRleE9mKGEpXTt2YXIgZDtpZih0aGlzLnNvdXJjZVJvb3QmJihkPWIudXJsUGFyc2UodGhpcy5zb3VyY2VSb290KSkpe3ZhciBlPWEucmVwbGFjZSgvXmZpbGU6XFxcXC9cXFxcLy8sXFxcIlxcXCIpO2lmKFxcXCJmaWxlXFxcIj09ZC5zY2hlbWUmJnRoaXMuX3NvdXJjZXMuaGFzKGUpKXJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50W3RoaXMuX3NvdXJjZXMuaW5kZXhPZihlKV07aWYoKCFkLnBhdGh8fFxcXCIvXFxcIj09ZC5wYXRoKSYmdGhpcy5fc291cmNlcy5oYXMoXFxcIi9cXFwiK2EpKXJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50W3RoaXMuX3NvdXJjZXMuaW5kZXhPZihcXFwiL1xcXCIrXFxuYSldfXRocm93IEVycm9yKCdcXFwiJythKydcXFwiIGlzIG5vdCBpbiB0aGUgU291cmNlTWFwLicpO307Zy5wcm90b3R5cGUuZ2VuZXJhdGVkUG9zaXRpb25Gb3I9ZnVuY3Rpb24oYSl7YT17c291cmNlOmIuZ2V0QXJnKGEsXFxcInNvdXJjZVxcXCIpLG9yaWdpbmFsTGluZTpiLmdldEFyZyhhLFxcXCJsaW5lXFxcIiksb3JpZ2luYWxDb2x1bW46Yi5nZXRBcmcoYSxcXFwiY29sdW1uXFxcIil9O3RoaXMuc291cmNlUm9vdCYmKGEuc291cmNlPWIucmVsYXRpdmUodGhpcy5zb3VyY2VSb290LGEuc291cmNlKSk7cmV0dXJuKGE9dGhpcy5fZmluZE1hcHBpbmcoYSx0aGlzLl9vcmlnaW5hbE1hcHBpbmdzLFxcXCJvcmlnaW5hbExpbmVcXFwiLFxcXCJvcmlnaW5hbENvbHVtblxcXCIsYi5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucykpP3tsaW5lOmIuZ2V0QXJnKGEsXFxcImdlbmVyYXRlZExpbmVcXFwiLG51bGwpLGNvbHVtbjpiLmdldEFyZyhhLFxcXCJnZW5lcmF0ZWRDb2x1bW5cXFwiLG51bGwpfTp7bGluZTpudWxsLGNvbHVtbjpudWxsfX07Zy5HRU5FUkFURURfT1JERVI9XFxuMTtnLk9SSUdJTkFMX09SREVSPTI7Zy5wcm90b3R5cGUuZWFjaE1hcHBpbmc9ZnVuY3Rpb24oYSxkLGUpe2Q9ZHx8bnVsbDtzd2l0Y2goZXx8Zy5HRU5FUkFURURfT1JERVIpe2Nhc2UgZy5HRU5FUkFURURfT1JERVI6ZT10aGlzLl9nZW5lcmF0ZWRNYXBwaW5nczticmVhaztjYXNlIGcuT1JJR0lOQUxfT1JERVI6ZT10aGlzLl9vcmlnaW5hbE1hcHBpbmdzO2JyZWFrO2RlZmF1bHQ6dGhyb3cgRXJyb3IoXFxcIlVua25vd24gb3JkZXIgb2YgaXRlcmF0aW9uLlxcXCIpO312YXIgZj10aGlzLnNvdXJjZVJvb3Q7ZS5tYXAoZnVuY3Rpb24oYSl7dmFyIGM9YS5zb3VyY2U7YyYmZiYmKGM9Yi5qb2luKGYsYykpO3JldHVybntzb3VyY2U6YyxnZW5lcmF0ZWRMaW5lOmEuZ2VuZXJhdGVkTGluZSxnZW5lcmF0ZWRDb2x1bW46YS5nZW5lcmF0ZWRDb2x1bW4sb3JpZ2luYWxMaW5lOmEub3JpZ2luYWxMaW5lLG9yaWdpbmFsQ29sdW1uOmEub3JpZ2luYWxDb2x1bW4sbmFtZTphLm5hbWV9fSkuZm9yRWFjaChhLFxcbmQpfTtsLlNvdXJjZU1hcENvbnN1bWVyPWd9KX0se1xcXCIuL2FycmF5LXNldFxcXCI6MTAsXFxcIi4vYmFzZTY0LXZscVxcXCI6MTEsXFxcIi4vYmluYXJ5LXNlYXJjaFxcXCI6MTMsXFxcIi4vdXRpbFxcXCI6MTcsYW1kZWZpbmU6Mn1dLDE1OltmdW5jdGlvbihuLHcsdCl7aWYoXFxcImZ1bmN0aW9uXFxcIiE9PXR5cGVvZiBlKXZhciBlPW4oXFxcImFtZGVmaW5lXFxcIikodyxuKTtlKGZ1bmN0aW9uKGUsbCxtKXtmdW5jdGlvbiBnKGEpe3RoaXMuX2ZpbGU9Zi5nZXRBcmcoYSxcXFwiZmlsZVxcXCIpO3RoaXMuX3NvdXJjZVJvb3Q9Zi5nZXRBcmcoYSxcXFwic291cmNlUm9vdFxcXCIsbnVsbCk7dGhpcy5fc291cmNlcz1uZXcgazt0aGlzLl9uYW1lcz1uZXcgazt0aGlzLl9tYXBwaW5ncz1bXTt0aGlzLl9zb3VyY2VzQ29udGVudHM9bnVsbH12YXIgYj1lKFxcXCIuL2Jhc2U2NC12bHFcXFwiKSxmPWUoXFxcIi4vdXRpbFxcXCIpLGs9ZShcXFwiLi9hcnJheS1zZXRcXFwiKS5BcnJheVNldDtnLnByb3RvdHlwZS5fdmVyc2lvbj0zO2cuZnJvbVNvdXJjZU1hcD1mdW5jdGlvbihhKXt2YXIgYz1hLnNvdXJjZVJvb3QsXFxuZD1uZXcgZyh7ZmlsZTphLmZpbGUsc291cmNlUm9vdDpjfSk7YS5lYWNoTWFwcGluZyhmdW5jdGlvbihhKXt2YXIgYj17Z2VuZXJhdGVkOntsaW5lOmEuZ2VuZXJhdGVkTGluZSxjb2x1bW46YS5nZW5lcmF0ZWRDb2x1bW59fTthLnNvdXJjZSYmKGIuc291cmNlPWEuc291cmNlLGMmJihiLnNvdXJjZT1mLnJlbGF0aXZlKGMsYi5zb3VyY2UpKSxiLm9yaWdpbmFsPXtsaW5lOmEub3JpZ2luYWxMaW5lLGNvbHVtbjphLm9yaWdpbmFsQ29sdW1ufSxhLm5hbWUmJihiLm5hbWU9YS5uYW1lKSk7ZC5hZGRNYXBwaW5nKGIpfSk7YS5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24oYyl7dmFyIGI9YS5zb3VyY2VDb250ZW50Rm9yKGMpO2ImJmQuc2V0U291cmNlQ29udGVudChjLGIpfSk7cmV0dXJuIGR9O2cucHJvdG90eXBlLmFkZE1hcHBpbmc9ZnVuY3Rpb24oYSl7dmFyIGM9Zi5nZXRBcmcoYSxcXFwiZ2VuZXJhdGVkXFxcIiksZD1mLmdldEFyZyhhLFxcXCJvcmlnaW5hbFxcXCIsbnVsbCksYj1mLmdldEFyZyhhLFxcXCJzb3VyY2VcXFwiLFxcbm51bGwpO2E9Zi5nZXRBcmcoYSxcXFwibmFtZVxcXCIsbnVsbCk7dGhpcy5fdmFsaWRhdGVNYXBwaW5nKGMsZCxiLGEpO2ImJiF0aGlzLl9zb3VyY2VzLmhhcyhiKSYmdGhpcy5fc291cmNlcy5hZGQoYik7YSYmIXRoaXMuX25hbWVzLmhhcyhhKSYmdGhpcy5fbmFtZXMuYWRkKGEpO3RoaXMuX21hcHBpbmdzLnB1c2goe2dlbmVyYXRlZExpbmU6Yy5saW5lLGdlbmVyYXRlZENvbHVtbjpjLmNvbHVtbixvcmlnaW5hbExpbmU6bnVsbCE9ZCYmZC5saW5lLG9yaWdpbmFsQ29sdW1uOm51bGwhPWQmJmQuY29sdW1uLHNvdXJjZTpiLG5hbWU6YX0pfTtnLnByb3RvdHlwZS5zZXRTb3VyY2VDb250ZW50PWZ1bmN0aW9uKGEsYyl7dmFyIGQ9YTt0aGlzLl9zb3VyY2VSb290JiYoZD1mLnJlbGF0aXZlKHRoaXMuX3NvdXJjZVJvb3QsZCkpO251bGwhPT1jPyh0aGlzLl9zb3VyY2VzQ29udGVudHN8fCh0aGlzLl9zb3VyY2VzQ29udGVudHM9e30pLHRoaXMuX3NvdXJjZXNDb250ZW50c1tmLnRvU2V0U3RyaW5nKGQpXT1cXG5jKTooZGVsZXRlIHRoaXMuX3NvdXJjZXNDb250ZW50c1tmLnRvU2V0U3RyaW5nKGQpXSwwPT09T2JqZWN0LmtleXModGhpcy5fc291cmNlc0NvbnRlbnRzKS5sZW5ndGgmJih0aGlzLl9zb3VyY2VzQ29udGVudHM9bnVsbCkpfTtnLnByb3RvdHlwZS5hcHBseVNvdXJjZU1hcD1mdW5jdGlvbihhLGMpe2N8fChjPWEuZmlsZSk7dmFyIGQ9dGhpcy5fc291cmNlUm9vdDtkJiYoYz1mLnJlbGF0aXZlKGQsYykpO3ZhciBiPW5ldyBrLGU9bmV3IGs7dGhpcy5fbWFwcGluZ3MuZm9yRWFjaChmdW5jdGlvbihnKXtpZihnLnNvdXJjZT09PWMmJmcub3JpZ2luYWxMaW5lKXt2YXIgaz1hLm9yaWdpbmFsUG9zaXRpb25Gb3Ioe2xpbmU6Zy5vcmlnaW5hbExpbmUsY29sdW1uOmcub3JpZ2luYWxDb2x1bW59KTtudWxsIT09ay5zb3VyY2UmJihnLnNvdXJjZT1kP2YucmVsYXRpdmUoZCxrLnNvdXJjZSk6ay5zb3VyY2UsZy5vcmlnaW5hbExpbmU9ay5saW5lLGcub3JpZ2luYWxDb2x1bW49ay5jb2x1bW4sXFxubnVsbCE9PWsubmFtZSYmbnVsbCE9PWcubmFtZSYmKGcubmFtZT1rLm5hbWUpKX0oaz1nLnNvdXJjZSkmJiFiLmhhcyhrKSYmYi5hZGQoayk7KGc9Zy5uYW1lKSYmIWUuaGFzKGcpJiZlLmFkZChnKX0sdGhpcyk7dGhpcy5fc291cmNlcz1iO3RoaXMuX25hbWVzPWU7YS5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24oYyl7dmFyIGI9YS5zb3VyY2VDb250ZW50Rm9yKGMpO2ImJihkJiYoYz1mLnJlbGF0aXZlKGQsYykpLHRoaXMuc2V0U291cmNlQ29udGVudChjLGIpKX0sdGhpcyl9O2cucHJvdG90eXBlLl92YWxpZGF0ZU1hcHBpbmc9ZnVuY3Rpb24oYSxjLGQsYil7aWYoIShhJiZcXFwibGluZVxcXCJpbiBhJiZcXFwiY29sdW1uXFxcImluIGEmJjA8YS5saW5lJiYwPD1hLmNvbHVtbiYmIWMmJiFkJiYhYnx8YSYmXFxcImxpbmVcXFwiaW4gYSYmXFxcImNvbHVtblxcXCJpbiBhJiZjJiZcXFwibGluZVxcXCJpbiBjJiZcXFwiY29sdW1uXFxcImluIGMmJjA8YS5saW5lJiYwPD1hLmNvbHVtbiYmMDxjLmxpbmUmJjA8PWMuY29sdW1uJiZkKSl0aHJvdyBFcnJvcihcXFwiSW52YWxpZCBtYXBwaW5nOiBcXFwiK1xcbkpTT04uc3RyaW5naWZ5KHtnZW5lcmF0ZWQ6YSxzb3VyY2U6ZCxvcmlnaW5hbDpjLG5hbWU6Yn0pKTt9O2cucHJvdG90eXBlLl9zZXJpYWxpemVNYXBwaW5ncz1mdW5jdGlvbigpe3ZhciBhPTAsYz0xLGQ9MCxlPTAsZz0wLGs9MCxsPVxcXCJcXFwiLG07dGhpcy5fbWFwcGluZ3Muc29ydChmLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9ucyk7Zm9yKHZhciBuPTAscj10aGlzLl9tYXBwaW5ncy5sZW5ndGg7bjxyO24rKyl7bT10aGlzLl9tYXBwaW5nc1tuXTtpZihtLmdlbmVyYXRlZExpbmUhPT1jKWZvcihhPTA7bS5nZW5lcmF0ZWRMaW5lIT09YzspbCs9XFxcIjtcXFwiLGMrKztlbHNlIGlmKDA8bil7aWYoIWYuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zKG0sdGhpcy5fbWFwcGluZ3Nbbi0xXSkpY29udGludWU7bCs9XFxcIixcXFwifWwrPWIuZW5jb2RlKG0uZ2VuZXJhdGVkQ29sdW1uLWEpO2E9bS5nZW5lcmF0ZWRDb2x1bW47bS5zb3VyY2UmJihsKz1iLmVuY29kZSh0aGlzLl9zb3VyY2VzLmluZGV4T2YobS5zb3VyY2UpLVxcbmspLGs9dGhpcy5fc291cmNlcy5pbmRleE9mKG0uc291cmNlKSxsKz1iLmVuY29kZShtLm9yaWdpbmFsTGluZS0xLWUpLGU9bS5vcmlnaW5hbExpbmUtMSxsKz1iLmVuY29kZShtLm9yaWdpbmFsQ29sdW1uLWQpLGQ9bS5vcmlnaW5hbENvbHVtbixtLm5hbWUmJihsKz1iLmVuY29kZSh0aGlzLl9uYW1lcy5pbmRleE9mKG0ubmFtZSktZyksZz10aGlzLl9uYW1lcy5pbmRleE9mKG0ubmFtZSkpKX1yZXR1cm4gbH07Zy5wcm90b3R5cGUuX2dlbmVyYXRlU291cmNlc0NvbnRlbnQ9ZnVuY3Rpb24oYSxjKXtyZXR1cm4gYS5tYXAoZnVuY3Rpb24oYSl7aWYoIXRoaXMuX3NvdXJjZXNDb250ZW50cylyZXR1cm4gbnVsbDtjJiYoYT1mLnJlbGF0aXZlKGMsYSkpO2E9Zi50b1NldFN0cmluZyhhKTtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuX3NvdXJjZXNDb250ZW50cyxhKT90aGlzLl9zb3VyY2VzQ29udGVudHNbYV06bnVsbH0sdGhpcyl9O2cucHJvdG90eXBlLnRvSlNPTj1cXG5mdW5jdGlvbigpe3ZhciBhPXt2ZXJzaW9uOnRoaXMuX3ZlcnNpb24sZmlsZTp0aGlzLl9maWxlLHNvdXJjZXM6dGhpcy5fc291cmNlcy50b0FycmF5KCksbmFtZXM6dGhpcy5fbmFtZXMudG9BcnJheSgpLG1hcHBpbmdzOnRoaXMuX3NlcmlhbGl6ZU1hcHBpbmdzKCl9O3RoaXMuX3NvdXJjZVJvb3QmJihhLnNvdXJjZVJvb3Q9dGhpcy5fc291cmNlUm9vdCk7dGhpcy5fc291cmNlc0NvbnRlbnRzJiYoYS5zb3VyY2VzQ29udGVudD10aGlzLl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50KGEuc291cmNlcyxhLnNvdXJjZVJvb3QpKTtyZXR1cm4gYX07Zy5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcyl9O2wuU291cmNlTWFwR2VuZXJhdG9yPWd9KX0se1xcXCIuL2FycmF5LXNldFxcXCI6MTAsXFxcIi4vYmFzZTY0LXZscVxcXCI6MTEsXFxcIi4vdXRpbFxcXCI6MTcsYW1kZWZpbmU6Mn1dLDE2OltmdW5jdGlvbihuLHcsdCl7aWYoXFxcImZ1bmN0aW9uXFxcIiE9PXR5cGVvZiBlKXZhciBlPVxcbm4oXFxcImFtZGVmaW5lXFxcIikodyxuKTtlKGZ1bmN0aW9uKGUsbCxtKXtmdW5jdGlvbiBnKGIsYSxjLGQsZSl7dGhpcy5jaGlsZHJlbj1bXTt0aGlzLnNvdXJjZUNvbnRlbnRzPXt9O3RoaXMubGluZT12b2lkIDA9PT1iP251bGw6Yjt0aGlzLmNvbHVtbj12b2lkIDA9PT1hP251bGw6YTt0aGlzLnNvdXJjZT12b2lkIDA9PT1jP251bGw6Yzt0aGlzLm5hbWU9dm9pZCAwPT09ZT9udWxsOmU7bnVsbCE9ZCYmdGhpcy5hZGQoZCl9dmFyIGI9ZShcXFwiLi9zb3VyY2UtbWFwLWdlbmVyYXRvclxcXCIpLlNvdXJjZU1hcEdlbmVyYXRvcixmPWUoXFxcIi4vdXRpbFxcXCIpO2cuZnJvbVN0cmluZ1dpdGhTb3VyY2VNYXA9ZnVuY3Rpb24oYixhKXtmdW5jdGlvbiBjKGEsYyl7bnVsbD09PWF8fHZvaWQgMD09PWEuc291cmNlP2QuYWRkKGMpOmQuYWRkKG5ldyBnKGEub3JpZ2luYWxMaW5lLGEub3JpZ2luYWxDb2x1bW4sYS5zb3VyY2UsYyxhLm5hbWUpKX12YXIgZD1uZXcgZyxlPWIuc3BsaXQoXFxcIlxcXFxuXFxcIiksZj0xLGw9MCxtPW51bGw7XFxuYS5lYWNoTWFwcGluZyhmdW5jdGlvbihhKXtpZihudWxsPT09bSl7Zm9yKDtmPGEuZ2VuZXJhdGVkTGluZTspZC5hZGQoZS5zaGlmdCgpK1xcXCJcXFxcblxcXCIpLGYrKztpZihsPGEuZ2VuZXJhdGVkQ29sdW1uKXt2YXIgYj1lWzBdO2QuYWRkKGIuc3Vic3RyKDAsYS5nZW5lcmF0ZWRDb2x1bW4pKTtlWzBdPWIuc3Vic3RyKGEuZ2VuZXJhdGVkQ29sdW1uKTtsPWEuZ2VuZXJhdGVkQ29sdW1ufX1lbHNle2lmKGY8YS5nZW5lcmF0ZWRMaW5lKXt2YXIgZz1cXFwiXFxcIjtkbyBnKz1lLnNoaWZ0KCkrXFxcIlxcXFxuXFxcIixmKyssbD0wO3doaWxlKGY8YS5nZW5lcmF0ZWRMaW5lKTtsPGEuZ2VuZXJhdGVkQ29sdW1uJiYoYj1lWzBdLGcrPWIuc3Vic3RyKDAsYS5nZW5lcmF0ZWRDb2x1bW4pLGVbMF09Yi5zdWJzdHIoYS5nZW5lcmF0ZWRDb2x1bW4pLGw9YS5nZW5lcmF0ZWRDb2x1bW4pfWVsc2UgYj1lWzBdLGc9Yi5zdWJzdHIoMCxhLmdlbmVyYXRlZENvbHVtbi1sKSxlWzBdPWIuc3Vic3RyKGEuZ2VuZXJhdGVkQ29sdW1uLWwpLFxcbmw9YS5nZW5lcmF0ZWRDb2x1bW47YyhtLGcpfW09YX0sdGhpcyk7YyhtLGUuam9pbihcXFwiXFxcXG5cXFwiKSk7YS5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24oYyl7dmFyIGI9YS5zb3VyY2VDb250ZW50Rm9yKGMpO2ImJmQuc2V0U291cmNlQ29udGVudChjLGIpfSk7cmV0dXJuIGR9O2cucHJvdG90eXBlLmFkZD1mdW5jdGlvbihiKXtpZihBcnJheS5pc0FycmF5KGIpKWIuZm9yRWFjaChmdW5jdGlvbihhKXt0aGlzLmFkZChhKX0sdGhpcyk7ZWxzZSBpZihiIGluc3RhbmNlb2YgZ3x8XFxcInN0cmluZ1xcXCI9PT10eXBlb2YgYiliJiZ0aGlzLmNoaWxkcmVuLnB1c2goYik7ZWxzZSB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJFeHBlY3RlZCBhIFNvdXJjZU5vZGUsIHN0cmluZywgb3IgYW4gYXJyYXkgb2YgU291cmNlTm9kZXMgYW5kIHN0cmluZ3MuIEdvdCBcXFwiK2IpO3JldHVybiB0aGlzfTtnLnByb3RvdHlwZS5wcmVwZW5kPWZ1bmN0aW9uKGIpe2lmKEFycmF5LmlzQXJyYXkoYikpZm9yKHZhciBhPWIubGVuZ3RoLVxcbjE7MDw9YTthLS0pdGhpcy5wcmVwZW5kKGJbYV0pO2Vsc2UgaWYoYiBpbnN0YW5jZW9mIGd8fFxcXCJzdHJpbmdcXFwiPT09dHlwZW9mIGIpdGhpcy5jaGlsZHJlbi51bnNoaWZ0KGIpO2Vsc2UgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiRXhwZWN0ZWQgYSBTb3VyY2VOb2RlLCBzdHJpbmcsIG9yIGFuIGFycmF5IG9mIFNvdXJjZU5vZGVzIGFuZCBzdHJpbmdzLiBHb3QgXFxcIitiKTtyZXR1cm4gdGhpc307Zy5wcm90b3R5cGUud2Fsaz1mdW5jdGlvbihiKXtmb3IodmFyIGEsYz0wLGQ9dGhpcy5jaGlsZHJlbi5sZW5ndGg7YzxkO2MrKylhPXRoaXMuY2hpbGRyZW5bY10sYSBpbnN0YW5jZW9mIGc/YS53YWxrKGIpOlxcXCJcXFwiIT09YSYmYihhLHtzb3VyY2U6dGhpcy5zb3VyY2UsbGluZTp0aGlzLmxpbmUsY29sdW1uOnRoaXMuY29sdW1uLG5hbWU6dGhpcy5uYW1lfSl9O2cucHJvdG90eXBlLmpvaW49ZnVuY3Rpb24oYil7dmFyIGEsYyxkPXRoaXMuY2hpbGRyZW4ubGVuZ3RoO2lmKDA8ZCl7YT1bXTtmb3IoYz0wO2M8XFxuZC0xO2MrKylhLnB1c2godGhpcy5jaGlsZHJlbltjXSksYS5wdXNoKGIpO2EucHVzaCh0aGlzLmNoaWxkcmVuW2NdKTt0aGlzLmNoaWxkcmVuPWF9cmV0dXJuIHRoaXN9O2cucHJvdG90eXBlLnJlcGxhY2VSaWdodD1mdW5jdGlvbihiLGEpe3ZhciBjPXRoaXMuY2hpbGRyZW5bdGhpcy5jaGlsZHJlbi5sZW5ndGgtMV07YyBpbnN0YW5jZW9mIGc/Yy5yZXBsYWNlUmlnaHQoYixhKTpcXFwic3RyaW5nXFxcIj09PXR5cGVvZiBjP3RoaXMuY2hpbGRyZW5bdGhpcy5jaGlsZHJlbi5sZW5ndGgtMV09Yy5yZXBsYWNlKGIsYSk6dGhpcy5jaGlsZHJlbi5wdXNoKFxcXCJcXFwiLnJlcGxhY2UoYixhKSk7cmV0dXJuIHRoaXN9O2cucHJvdG90eXBlLnNldFNvdXJjZUNvbnRlbnQ9ZnVuY3Rpb24oYixhKXt0aGlzLnNvdXJjZUNvbnRlbnRzW2YudG9TZXRTdHJpbmcoYildPWF9O2cucHJvdG90eXBlLndhbGtTb3VyY2VDb250ZW50cz1mdW5jdGlvbihiKXtmb3IodmFyIGE9MCxjPXRoaXMuY2hpbGRyZW4ubGVuZ3RoO2E8XFxuYzthKyspdGhpcy5jaGlsZHJlblthXWluc3RhbmNlb2YgZyYmdGhpcy5jaGlsZHJlblthXS53YWxrU291cmNlQ29udGVudHMoYik7Zm9yKHZhciBkPU9iamVjdC5rZXlzKHRoaXMuc291cmNlQ29udGVudHMpLGE9MCxjPWQubGVuZ3RoO2E8YzthKyspYihmLmZyb21TZXRTdHJpbmcoZFthXSksdGhpcy5zb3VyY2VDb250ZW50c1tkW2FdXSl9O2cucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7dmFyIGI9XFxcIlxcXCI7dGhpcy53YWxrKGZ1bmN0aW9uKGEpe2IrPWF9KTtyZXR1cm4gYn07Zy5wcm90b3R5cGUudG9TdHJpbmdXaXRoU291cmNlTWFwPWZ1bmN0aW9uKGUpe3ZhciBhPVxcXCJcXFwiLGM9MSxkPTAsZj1uZXcgYihlKSxnPSExLGw9bnVsbCxtPW51bGwsbj1udWxsLHI9bnVsbDt0aGlzLndhbGsoZnVuY3Rpb24oYixlKXthKz1iO251bGwhPT1lLnNvdXJjZSYmbnVsbCE9PWUubGluZSYmbnVsbCE9PWUuY29sdW1uPyhsPT09ZS5zb3VyY2UmJm09PT1lLmxpbmUmJm49PT1lLmNvbHVtbiYmcj09PVxcbmUubmFtZXx8Zi5hZGRNYXBwaW5nKHtzb3VyY2U6ZS5zb3VyY2Usb3JpZ2luYWw6e2xpbmU6ZS5saW5lLGNvbHVtbjplLmNvbHVtbn0sZ2VuZXJhdGVkOntsaW5lOmMsY29sdW1uOmR9LG5hbWU6ZS5uYW1lfSksbD1lLnNvdXJjZSxtPWUubGluZSxuPWUuY29sdW1uLHI9ZS5uYW1lLGc9ITApOmcmJihmLmFkZE1hcHBpbmcoe2dlbmVyYXRlZDp7bGluZTpjLGNvbHVtbjpkfX0pLGw9bnVsbCxnPSExKTtiLnNwbGl0KFxcXCJcXFwiKS5mb3JFYWNoKGZ1bmN0aW9uKGEpe1xcXCJcXFxcblxcXCI9PT1hPyhjKyssZD0wKTpkKyt9KX0pO3RoaXMud2Fsa1NvdXJjZUNvbnRlbnRzKGZ1bmN0aW9uKGEsYyl7Zi5zZXRTb3VyY2VDb250ZW50KGEsYyl9KTtyZXR1cm57Y29kZTphLG1hcDpmfX07bC5Tb3VyY2VOb2RlPWd9KX0se1xcXCIuL3NvdXJjZS1tYXAtZ2VuZXJhdG9yXFxcIjoxNSxcXFwiLi91dGlsXFxcIjoxNyxhbWRlZmluZToyfV0sMTc6W2Z1bmN0aW9uKG4sdyx0KXtpZihcXFwiZnVuY3Rpb25cXFwiIT09dHlwZW9mIGUpdmFyIGU9bihcXFwiYW1kZWZpbmVcXFwiKSh3LFxcbm4pO2UoZnVuY3Rpb24oZSxsLG0pe2Z1bmN0aW9uIGcoYSl7cmV0dXJuKGE9YS5tYXRjaChrKSk/e3NjaGVtZTphWzFdLGF1dGg6YVszXSxob3N0OmFbNF0scG9ydDphWzZdLHBhdGg6YVs3XX06bnVsbH1mdW5jdGlvbiBiKGEpe3ZhciBiPWEuc2NoZW1lK1xcXCI6Ly9cXFwiO2EuYXV0aCYmKGIrPWEuYXV0aCtcXFwiQFxcXCIpO2EuaG9zdCYmKGIrPWEuaG9zdCk7YS5wb3J0JiYoYis9XFxcIjpcXFwiK2EucG9ydCk7YS5wYXRoJiYoYis9YS5wYXRoKTtyZXR1cm4gYn1mdW5jdGlvbiBmKGEsYil7dmFyIGU9YXx8XFxcIlxcXCIsZj1ifHxcXFwiXFxcIjtyZXR1cm4oZT5mKS0oZTxmKX1sLmdldEFyZz1mdW5jdGlvbihhLGIsZSl7aWYoYiBpbiBhKXJldHVybiBhW2JdO2lmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiBlO3Rocm93IEVycm9yKCdcXFwiJytiKydcXFwiIGlzIGEgcmVxdWlyZWQgYXJndW1lbnQuJyk7fTt2YXIgaz0vKFtcXFxcdytcXFxcLS5dKyk6XFxcXC9cXFxcLygoXFxcXHcrOlxcXFx3KylAKT8oW1xcXFx3Ll0rKT8oOihcXFxcZCspKT8oXFxcXFMrKT8vLGE9L15kYXRhOi4rXFxcXCwuKy87XFxubC51cmxQYXJzZT1nO2wudXJsR2VuZXJhdGU9YjtsLmpvaW49ZnVuY3Rpb24oYyxkKXt2YXIgZTtyZXR1cm4gZC5tYXRjaChrKXx8ZC5tYXRjaChhKT9kOlxcXCIvXFxcIj09PWQuY2hhckF0KDApJiYoZT1nKGMpKT8oZS5wYXRoPWQsYihlKSk6Yy5yZXBsYWNlKC9cXFxcLyQvLFxcXCJcXFwiKStcXFwiL1xcXCIrZH07bC50b1NldFN0cmluZz1mdW5jdGlvbihhKXtyZXR1cm5cXFwiJFxcXCIrYX07bC5mcm9tU2V0U3RyaW5nPWZ1bmN0aW9uKGEpe3JldHVybiBhLnN1YnN0cigxKX07bC5yZWxhdGl2ZT1mdW5jdGlvbihhLGIpe2E9YS5yZXBsYWNlKC9cXFxcLyQvLFxcXCJcXFwiKTt2YXIgZT1nKGEpO3JldHVyblxcXCIvXFxcIj09Yi5jaGFyQXQoMCkmJmUmJlxcXCIvXFxcIj09ZS5wYXRoP2Iuc2xpY2UoMSk6MD09PWIuaW5kZXhPZihhK1xcXCIvXFxcIik/Yi5zdWJzdHIoYS5sZW5ndGgrMSk6Yn07bC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucz1mdW5jdGlvbihhLGIsZSl7dmFyIGc7cmV0dXJuKGc9ZihhLnNvdXJjZSxiLnNvdXJjZSkpfHwoZz1hLm9yaWdpbmFsTGluZS1iLm9yaWdpbmFsTGluZSl8fFxcbihnPWEub3JpZ2luYWxDb2x1bW4tYi5vcmlnaW5hbENvbHVtbil8fGV8fChnPWYoYS5uYW1lLGIubmFtZSkpP2c6KGc9YS5nZW5lcmF0ZWRMaW5lLWIuZ2VuZXJhdGVkTGluZSk/ZzphLmdlbmVyYXRlZENvbHVtbi1iLmdlbmVyYXRlZENvbHVtbn07bC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnM9ZnVuY3Rpb24oYSxiLGUpe3ZhciBnO3JldHVybihnPWEuZ2VuZXJhdGVkTGluZS1iLmdlbmVyYXRlZExpbmUpfHwoZz1hLmdlbmVyYXRlZENvbHVtbi1iLmdlbmVyYXRlZENvbHVtbil8fGV8fChnPWYoYS5zb3VyY2UsYi5zb3VyY2UpKXx8KGc9YS5vcmlnaW5hbExpbmUtYi5vcmlnaW5hbExpbmUpP2c6KGc9YS5vcmlnaW5hbENvbHVtbi1iLm9yaWdpbmFsQ29sdW1uKT9nOmYoYS5uYW1lLGIubmFtZSl9fSl9LHthbWRlZmluZToyfV0sMTg6W2Z1bmN0aW9uKG4sdyx0KXsoZnVuY3Rpb24oZSxyKXtmdW5jdGlvbiBsKCl7cmV0dXJuXFxcImJyb3dzZXJcXFwiPT09Qz8hMDpcXFwibm9kZVxcXCI9PT1DPyExOlxcblxcXCJ1bmRlZmluZWRcXFwiIT09dHlwZW9mIHdpbmRvdyYmXFxcImZ1bmN0aW9uXFxcIj09PXR5cGVvZiBYTUxIdHRwUmVxdWVzdH1mdW5jdGlvbiBtKGEpe2E9YS50cmltKCk7aWYoYSBpbiB6KXJldHVybiB6W2FdO3RyeXtpZihsKCkpe3ZhciBiPW5ldyBYTUxIdHRwUmVxdWVzdDtiLm9wZW4oXFxcIkdFVFxcXCIsYSwhMSk7Yi5zZW5kKG51bGwpO3ZhciBjPW51bGw7ND09PWIucmVhZHlTdGF0ZSYmMjAwPT09Yi5zdGF0dXMmJihjPWIucmVzcG9uc2VUZXh0KX1lbHNlIGM9RS5yZWFkRmlsZVN5bmMoYSxcXFwidXRmOFxcXCIpfWNhdGNoKGQpe2M9bnVsbH1yZXR1cm4gelthXT1jfWZ1bmN0aW9uIGcoYSxiKXtpZighYSlyZXR1cm4gYjt2YXIgYz1GLmRpcm5hbWUoYSksZD0vXlxcXFx3KzpcXFxcL1xcXFwvW15cXFxcL10qLy5leGVjKGMpLGQ9ZD9kWzBdOlxcXCJcXFwiO3JldHVybiBkK0YucmVzb2x2ZShjLnNsaWNlKGQubGVuZ3RoKSxiKX1mdW5jdGlvbiBiKGEpe3ZhciBiO2E6e3ZhciBjO2lmKGwoKSYmKGM9bmV3IFhNTEh0dHBSZXF1ZXN0LGMub3BlbihcXFwiR0VUXFxcIixcXG5hLCExKSxjLnNlbmQobnVsbCksYz1jLmdldFJlc3BvbnNlSGVhZGVyKFxcXCJTb3VyY2VNYXBcXFwiKXx8Yy5nZXRSZXNwb25zZUhlYWRlcihcXFwiWC1Tb3VyY2VNYXBcXFwiKSkpe2I9YzticmVhayBhfWM9bShhKTtmb3IodmFyIGQ9Lyg/OlxcXFwvXFxcXC9bQCNdWyBcXFxcdF0rc291cmNlTWFwcGluZ1VSTD0oW15cXFxccydcXFwiXSs/KVsgXFxcXHRdKiQpfCg/OlxcXFwvXFxcXCpbQCNdWyBcXFxcdF0rc291cmNlTWFwcGluZ1VSTD0oW15cXFxcKl0rPylbIFxcXFx0XSooPzpcXFxcKlxcXFwvKVsgXFxcXHRdKiQpL21nLGU7ZT1kLmV4ZWMoYyk7KWI9ZTtiPWI/YlsxXTpudWxsfWlmKCFiKXJldHVybiBudWxsO0gudGVzdChiKT8oYT1iLnNsaWNlKGIuaW5kZXhPZihcXFwiLFxcXCIpKzEpLGE9KG5ldyByKGEsXFxcImJhc2U2NFxcXCIpKS50b1N0cmluZygpLGI9bnVsbCk6KGI9ZyhhLGIpLGE9bShiKSk7cmV0dXJuIGE/e3VybDpiLG1hcDphfTpudWxsfWZ1bmN0aW9uIGYoYSl7dmFyIGM9RFthLnNvdXJjZV07aWYoIWMpe3ZhciBkPWIoYS5zb3VyY2UpO2Q/KGM9RFthLnNvdXJjZV09e3VybDpkLnVybCxcXG5tYXA6bmV3IEIoZC5tYXApfSxjLm1hcC5zb3VyY2VzQ29udGVudCYmYy5tYXAuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uKGEsYil7dmFyIGQ9Yy5tYXAuc291cmNlc0NvbnRlbnRbYl07aWYoZCl7dmFyIGU9ZyhjLnVybCxhKTt6W2VdPWR9fSkpOmM9RFthLnNvdXJjZV09e3VybDpudWxsLG1hcDpudWxsfX1yZXR1cm4gYyYmYy5tYXAmJihkPWMubWFwLm9yaWdpbmFsUG9zaXRpb25Gb3IoYSksbnVsbCE9PWQuc291cmNlKT8oZC5zb3VyY2U9ZyhjLnVybCxkLnNvdXJjZSksZCk6YX1mdW5jdGlvbiBrKGEpe3ZhciBiPS9eZXZhbCBhdCAoW14oXSspIFxcXFwoKC4rKTooXFxcXGQrKTooXFxcXGQrKVxcXFwpJC8uZXhlYyhhKTtyZXR1cm4gYj8oYT1mKHtzb3VyY2U6YlsyXSxsaW5lOmJbM10sY29sdW1uOmJbNF0tMX0pLFxcXCJldmFsIGF0IFxcXCIrYlsxXStcXFwiIChcXFwiK2Euc291cmNlK1xcXCI6XFxcIithLmxpbmUrXFxcIjpcXFwiKyhhLmNvbHVtbisxKStcXFwiKVxcXCIpOihiPS9eZXZhbCBhdCAoW14oXSspIFxcXFwoKC4rKVxcXFwpJC8uZXhlYyhhKSk/XFxcImV2YWwgYXQgXFxcIitcXG5iWzFdK1xcXCIgKFxcXCIrayhiWzJdKStcXFwiKVxcXCI6YX1mdW5jdGlvbiBhKCl7dmFyIGEsYj1cXFwiXFxcIjt0aGlzLmlzTmF0aXZlKCk/Yj1cXFwibmF0aXZlXFxcIjooYT10aGlzLmdldFNjcmlwdE5hbWVPclNvdXJjZVVSTCgpLCFhJiZ0aGlzLmlzRXZhbCgpJiYoYj10aGlzLmdldEV2YWxPcmlnaW4oKSxiKz1cXFwiLCBcXFwiKSxiPWE/YithOmIrXFxcIjxhbm9ueW1vdXM+XFxcIixhPXRoaXMuZ2V0TGluZU51bWJlcigpLG51bGwhPWEmJihiKz1cXFwiOlxcXCIrYSwoYT10aGlzLmdldENvbHVtbk51bWJlcigpKSYmKGIrPVxcXCI6XFxcIithKSkpO2E9XFxcIlxcXCI7dmFyIGM9dGhpcy5nZXRGdW5jdGlvbk5hbWUoKSxkPSEwLGU9dGhpcy5pc0NvbnN0cnVjdG9yKCk7aWYodGhpcy5pc1RvcGxldmVsKCl8fGUpZT9hKz1cXFwibmV3IFxcXCIrKGN8fFxcXCI8YW5vbnltb3VzPlxcXCIpOmM/YSs9YzooYSs9YixkPSExKTtlbHNle3ZhciBlPXRoaXMuZ2V0VHlwZU5hbWUoKSxmPXRoaXMuZ2V0TWV0aG9kTmFtZSgpO2M/KGUmJjAhPWMuaW5kZXhPZihlKSYmKGErPWUrXFxcIi5cXFwiKSxhKz1jLGYmJmMuaW5kZXhPZihcXFwiLlxcXCIrXFxuZikhPWMubGVuZ3RoLWYubGVuZ3RoLTEmJihhKz1cXFwiIFthcyBcXFwiK2YrXFxcIl1cXFwiKSk6YSs9ZStcXFwiLlxcXCIrKGZ8fFxcXCI8YW5vbnltb3VzPlxcXCIpfWQmJihhKz1cXFwiIChcXFwiK2IrXFxcIilcXFwiKTtyZXR1cm4gYX1mdW5jdGlvbiBjKGIpe3ZhciBjPXt9O09iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE9iamVjdC5nZXRQcm90b3R5cGVPZihiKSkuZm9yRWFjaChmdW5jdGlvbihhKXtjW2FdPS9eKD86aXN8Z2V0KS8udGVzdChhKT9mdW5jdGlvbigpe3JldHVybiBiW2FdLmNhbGwoYil9OmJbYV19KTtjLnRvU3RyaW5nPWE7cmV0dXJuIGN9ZnVuY3Rpb24gZChhKXt2YXIgYj1hLmdldEZpbGVOYW1lKCl8fGEuZ2V0U2NyaXB0TmFtZU9yU291cmNlVVJMKCk7aWYoYil7dmFyIGQ9YS5nZXRMaW5lTnVtYmVyKCksZT1hLmdldENvbHVtbk51bWJlcigpLTE7MSE9PWR8fGwoKXx8YS5pc0V2YWwoKXx8KGUtPTYyKTt2YXIgZz1mKHtzb3VyY2U6YixsaW5lOmQsY29sdW1uOmV9KTthPWMoYSk7YS5nZXRGaWxlTmFtZT1mdW5jdGlvbigpe3JldHVybiBnLnNvdXJjZX07XFxuYS5nZXRMaW5lTnVtYmVyPWZ1bmN0aW9uKCl7cmV0dXJuIGcubGluZX07YS5nZXRDb2x1bW5OdW1iZXI9ZnVuY3Rpb24oKXtyZXR1cm4gZy5jb2x1bW4rMX07YS5nZXRTY3JpcHROYW1lT3JTb3VyY2VVUkw9ZnVuY3Rpb24oKXtyZXR1cm4gZy5zb3VyY2V9O3JldHVybiBhfXZhciBtPWEuaXNFdmFsKCkmJmEuZ2V0RXZhbE9yaWdpbigpO20mJihtPWsobSksYT1jKGEpLGEuZ2V0RXZhbE9yaWdpbj1mdW5jdGlvbigpe3JldHVybiBtfSk7cmV0dXJuIGF9ZnVuY3Rpb24gdyhhLGIpe3UmJih6PXt9LEQ9e30pO3JldHVybiBhK2IubWFwKGZ1bmN0aW9uKGEpe3JldHVyblxcXCJcXFxcbiAgICBhdCBcXFwiK2QoYSl9KS5qb2luKFxcXCJcXFwiKX1mdW5jdGlvbiB4KGEpe3ZhciBiPS9cXFxcbiAgICBhdCBbXihdKyBcXFxcKCguKik6KFxcXFxkKyk6KFxcXFxkKylcXFxcKS8uZXhlYyhhLnN0YWNrKTtpZihiKXthPWJbMV07dmFyIGM9K2JbMl0sYj0rYlszXSxkPXpbYV07IWQmJkUuZXhpc3RzU3luYyhhKSYmKGQ9RS5yZWFkRmlsZVN5bmMoYSxcXFwidXRmOFxcXCIpKTtcXG5pZihkJiYoZD1kLnNwbGl0KC8oPzpcXFxcclxcXFxufFxcXFxyfFxcXFxuKS8pW2MtMV0pKXJldHVybiBhK1xcXCI6XFxcIitjK1xcXCJcXFxcblxcXCIrZCtcXFwiXFxcXG5cXFwiK0FycmF5KGIpLmpvaW4oXFxcIiBcXFwiKStcXFwiXlxcXCJ9cmV0dXJuIG51bGx9ZnVuY3Rpb24gQSgpe3ZhciBhPWUuZW1pdDtlLmVtaXQ9ZnVuY3Rpb24oYil7aWYoXFxcInVuY2F1Z2h0RXhjZXB0aW9uXFxcIj09PWIpe3ZhciBjPWFyZ3VtZW50c1sxXSYmYXJndW1lbnRzWzFdLnN0YWNrLGQ9MDx0aGlzLmxpc3RlbmVycyhiKS5sZW5ndGg7aWYoYyYmIWQpe2M9YXJndW1lbnRzWzFdO2lmKGQ9eChjKSljb25zb2xlLmVycm9yKCksY29uc29sZS5lcnJvcihkKTtjb25zb2xlLmVycm9yKGMuc3RhY2spO2UuZXhpdCgxKTtyZXR1cm59fXJldHVybiBhLmFwcGx5KHRoaXMsYXJndW1lbnRzKX19dmFyIEI9bihcXFwic291cmNlLW1hcFxcXCIpLlNvdXJjZU1hcENvbnN1bWVyLEY9bihcXFwicGF0aFxcXCIpLEU9bihcXFwiZnNcXFwiKSxHPSExLHU9ITEsQz1cXFwiYXV0b1xcXCIsej17fSxEPXt9LEg9L15kYXRhOmFwcGxpY2F0aW9uXFxcXC9qc29uW14sXStiYXNlNjQsLztcXG50LndyYXBDYWxsU2l0ZT1kO3QuZ2V0RXJyb3JTb3VyY2U9eDt0Lm1hcFNvdXJjZVBvc2l0aW9uPWY7dC5yZXRyaWV2ZVNvdXJjZU1hcD1iO3QuaW5zdGFsbD1mdW5jdGlvbihhKXtpZighRyl7Rz0hMDtFcnJvci5wcmVwYXJlU3RhY2tUcmFjZT13O2E9YXx8e307dmFyIGM9XFxcImhhbmRsZVVuY2F1Z2h0RXhjZXB0aW9uc1xcXCJpbiBhP2EuaGFuZGxlVW5jYXVnaHRFeGNlcHRpb25zOiEwO3U9XFxcImVtcHR5Q2FjaGVCZXR3ZWVuT3BlcmF0aW9uc1xcXCJpbiBhP2EuZW1wdHlDYWNoZUJldHdlZW5PcGVyYXRpb25zOiExO2lmKGEuZW52aXJvbm1lbnQmJihDPWEuZW52aXJvbm1lbnQsLTE9PT1bXFxcIm5vZGVcXFwiLFxcXCJicm93c2VyXFxcIixcXFwiYXV0b1xcXCJdLmluZGV4T2YoQykpKXRocm93IEVycm9yKFxcXCJlbnZpcm9ubWVudCBcXFwiK0MrXFxcIiB3YXMgdW5rbm93bi4gQXZhaWxhYmxlIG9wdGlvbnMgYXJlIHthdXRvLCBicm93c2VyLCBub2RlfVxcXCIpO2EucmV0cmlldmVGaWxlJiYobT1hLnJldHJpZXZlRmlsZSk7YS5yZXRyaWV2ZVNvdXJjZU1hcCYmXFxuKGI9YS5yZXRyaWV2ZVNvdXJjZU1hcCk7YyYmXFxcIm9iamVjdFxcXCI9PT10eXBlb2YgZSYmbnVsbCE9PWUmJlxcXCJmdW5jdGlvblxcXCI9PT10eXBlb2YgZS5vbiYmQSgpfX19KS5jYWxsKHRoaXMsbihcXFwibm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1xcXCIpLG4oXFxcImJ1ZmZlclxcXCIpLkJ1ZmZlcil9LHtcXFwibm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1xcXCI6OCxidWZmZXI6NSxmczo0LHBhdGg6NyxcXFwic291cmNlLW1hcFxcXCI6OX1dfSx7fSxbMV0pO3JldHVybiBLfSk7XFxuXCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL3NvdXJjZS1tYXAtc3VwcG9ydC9icm93c2VyLXNvdXJjZS1tYXAtc3VwcG9ydC5qc1xuICoqIG1vZHVsZSBpZCA9IDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCIvKlxcbkNvcHlyaWdodCAoYykgMjAwOC0yMDE1IFBpdm90YWwgTGFic1xcblxcblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZ1xcbmEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxcblxcXCJTb2Z0d2FyZVxcXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcXG53aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXFxuZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXFxucGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvXFxudGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxcblxcblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXFxuaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXFxuXFxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFxcXCJBUyBJU1xcXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXFxuRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXFxuTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcXG5OT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFXFxuTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTlxcbk9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTlxcbldJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxcbiovXFxudmFyIGdldEphc21pbmVSZXF1aXJlT2JqID0gKGZ1bmN0aW9uIChqYXNtaW5lR2xvYmFsKSB7XFxuICB2YXIgamFzbWluZVJlcXVpcmU7XFxuXFxuICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcXG4gICAgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgamFzbWluZUdsb2JhbCA9IGdsb2JhbDtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBqYXNtaW5lR2xvYmFsID0ge307XFxuICAgIH1cXG4gICAgamFzbWluZVJlcXVpcmUgPSBleHBvcnRzO1xcbiAgfSBlbHNlIHtcXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cudG9TdHJpbmcgPT09ICdmdW5jdGlvbicgJiYgd2luZG93LnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IEdqc0dsb2JhbF0nKSB7XFxuICAgICAgamFzbWluZUdsb2JhbCA9IHdpbmRvdztcXG4gICAgfVxcbiAgICBqYXNtaW5lUmVxdWlyZSA9IGphc21pbmVHbG9iYWwuamFzbWluZVJlcXVpcmUgPSBqYXNtaW5lR2xvYmFsLmphc21pbmVSZXF1aXJlIHx8IHt9O1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gZ2V0SmFzbWluZVJlcXVpcmUoKSB7XFxuICAgIHJldHVybiBqYXNtaW5lUmVxdWlyZTtcXG4gIH1cXG5cXG4gIGdldEphc21pbmVSZXF1aXJlKCkuY29yZSA9IGZ1bmN0aW9uKGpSZXF1aXJlKSB7XFxuICAgIHZhciBqJCA9IHt9O1xcblxcbiAgICBqUmVxdWlyZS5iYXNlKGokLCBqYXNtaW5lR2xvYmFsKTtcXG4gICAgaiQudXRpbCA9IGpSZXF1aXJlLnV0aWwoKTtcXG4gICAgaiQuZXJyb3JzID0galJlcXVpcmUuZXJyb3JzKCk7XFxuICAgIGokLkFueSA9IGpSZXF1aXJlLkFueShqJCk7XFxuICAgIGokLkFueXRoaW5nID0galJlcXVpcmUuQW55dGhpbmcoaiQpO1xcbiAgICBqJC5DYWxsVHJhY2tlciA9IGpSZXF1aXJlLkNhbGxUcmFja2VyKCk7XFxuICAgIGokLk1vY2tEYXRlID0galJlcXVpcmUuTW9ja0RhdGUoKTtcXG4gICAgaiQuQ2xvY2sgPSBqUmVxdWlyZS5DbG9jaygpO1xcbiAgICBqJC5EZWxheWVkRnVuY3Rpb25TY2hlZHVsZXIgPSBqUmVxdWlyZS5EZWxheWVkRnVuY3Rpb25TY2hlZHVsZXIoKTtcXG4gICAgaiQuRW52ID0galJlcXVpcmUuRW52KGokKTtcXG4gICAgaiQuRXhjZXB0aW9uRm9ybWF0dGVyID0galJlcXVpcmUuRXhjZXB0aW9uRm9ybWF0dGVyKCk7XFxuICAgIGokLkV4cGVjdGF0aW9uID0galJlcXVpcmUuRXhwZWN0YXRpb24oKTtcXG4gICAgaiQuYnVpbGRFeHBlY3RhdGlvblJlc3VsdCA9IGpSZXF1aXJlLmJ1aWxkRXhwZWN0YXRpb25SZXN1bHQoKTtcXG4gICAgaiQuSnNBcGlSZXBvcnRlciA9IGpSZXF1aXJlLkpzQXBpUmVwb3J0ZXIoKTtcXG4gICAgaiQubWF0Y2hlcnNVdGlsID0galJlcXVpcmUubWF0Y2hlcnNVdGlsKGokKTtcXG4gICAgaiQuT2JqZWN0Q29udGFpbmluZyA9IGpSZXF1aXJlLk9iamVjdENvbnRhaW5pbmcoaiQpO1xcbiAgICBqJC5BcnJheUNvbnRhaW5pbmcgPSBqUmVxdWlyZS5BcnJheUNvbnRhaW5pbmcoaiQpO1xcbiAgICBqJC5wcCA9IGpSZXF1aXJlLnBwKGokKTtcXG4gICAgaiQuUXVldWVSdW5uZXIgPSBqUmVxdWlyZS5RdWV1ZVJ1bm5lcihqJCk7XFxuICAgIGokLlJlcG9ydERpc3BhdGNoZXIgPSBqUmVxdWlyZS5SZXBvcnREaXNwYXRjaGVyKCk7XFxuICAgIGokLlNwZWMgPSBqUmVxdWlyZS5TcGVjKGokKTtcXG4gICAgaiQuU3B5UmVnaXN0cnkgPSBqUmVxdWlyZS5TcHlSZWdpc3RyeShqJCk7XFxuICAgIGokLlNweVN0cmF0ZWd5ID0galJlcXVpcmUuU3B5U3RyYXRlZ3koKTtcXG4gICAgaiQuU3RyaW5nTWF0Y2hpbmcgPSBqUmVxdWlyZS5TdHJpbmdNYXRjaGluZyhqJCk7XFxuICAgIGokLlN1aXRlID0galJlcXVpcmUuU3VpdGUoaiQpO1xcbiAgICBqJC5UaW1lciA9IGpSZXF1aXJlLlRpbWVyKCk7XFxuICAgIGokLlRyZWVQcm9jZXNzb3IgPSBqUmVxdWlyZS5UcmVlUHJvY2Vzc29yKCk7XFxuICAgIGokLnZlcnNpb24gPSBqUmVxdWlyZS52ZXJzaW9uKCk7XFxuICAgIGokLk9yZGVyID0galJlcXVpcmUuT3JkZXIoKTtcXG5cXG4gICAgaiQubWF0Y2hlcnMgPSBqUmVxdWlyZS5yZXF1aXJlTWF0Y2hlcnMoalJlcXVpcmUsIGokKTtcXG5cXG4gICAgcmV0dXJuIGokO1xcbiAgfTtcXG5cXG4gIHJldHVybiBnZXRKYXNtaW5lUmVxdWlyZTtcXG59KSh0aGlzKTtcXG5cXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnJlcXVpcmVNYXRjaGVycyA9IGZ1bmN0aW9uKGpSZXF1aXJlLCBqJCkge1xcbiAgdmFyIGF2YWlsYWJsZU1hdGNoZXJzID0gW1xcbiAgICAgICd0b0JlJyxcXG4gICAgICAndG9CZUNsb3NlVG8nLFxcbiAgICAgICd0b0JlRGVmaW5lZCcsXFxuICAgICAgJ3RvQmVGYWxzeScsXFxuICAgICAgJ3RvQmVHcmVhdGVyVGhhbicsXFxuICAgICAgJ3RvQmVMZXNzVGhhbicsXFxuICAgICAgJ3RvQmVOYU4nLFxcbiAgICAgICd0b0JlTnVsbCcsXFxuICAgICAgJ3RvQmVUcnV0aHknLFxcbiAgICAgICd0b0JlVW5kZWZpbmVkJyxcXG4gICAgICAndG9Db250YWluJyxcXG4gICAgICAndG9FcXVhbCcsXFxuICAgICAgJ3RvSGF2ZUJlZW5DYWxsZWQnLFxcbiAgICAgICd0b0hhdmVCZWVuQ2FsbGVkV2l0aCcsXFxuICAgICAgJ3RvSGF2ZUJlZW5DYWxsZWRUaW1lcycsXFxuICAgICAgJ3RvTWF0Y2gnLFxcbiAgICAgICd0b1Rocm93JyxcXG4gICAgICAndG9UaHJvd0Vycm9yJ1xcbiAgICBdLFxcbiAgICBtYXRjaGVycyA9IHt9O1xcblxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdmFpbGFibGVNYXRjaGVycy5sZW5ndGg7IGkrKykge1xcbiAgICB2YXIgbmFtZSA9IGF2YWlsYWJsZU1hdGNoZXJzW2ldO1xcbiAgICBtYXRjaGVyc1tuYW1lXSA9IGpSZXF1aXJlW25hbWVdKGokKTtcXG4gIH1cXG5cXG4gIHJldHVybiBtYXRjaGVycztcXG59O1xcblxcbmdldEphc21pbmVSZXF1aXJlT2JqKCkuYmFzZSA9IGZ1bmN0aW9uKGokLCBqYXNtaW5lR2xvYmFsKSB7XFxuICBqJC51bmltcGxlbWVudGVkTWV0aG9kXyA9IGZ1bmN0aW9uKCkge1xcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuaW1wbGVtZW50ZWQgbWV0aG9kJyk7XFxuICB9O1xcblxcbiAgaiQuTUFYX1BSRVRUWV9QUklOVF9ERVBUSCA9IDQwO1xcbiAgaiQuTUFYX1BSRVRUWV9QUklOVF9BUlJBWV9MRU5HVEggPSAxMDA7XFxuICBqJC5ERUZBVUxUX1RJTUVPVVRfSU5URVJWQUwgPSA1MDAwO1xcblxcbiAgaiQuZ2V0R2xvYmFsID0gZnVuY3Rpb24oKSB7XFxuICAgIHJldHVybiBqYXNtaW5lR2xvYmFsO1xcbiAgfTtcXG5cXG4gIGokLmdldEVudiA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcXG4gICAgdmFyIGVudiA9IGokLmN1cnJlbnRFbnZfID0gaiQuY3VycmVudEVudl8gfHwgbmV3IGokLkVudihvcHRpb25zKTtcXG4gICAgLy9qYXNtaW5lLiBzaW5nbGV0b25zIGluIGhlcmUgKHNldFRpbWVvdXQgYmxhaCBibGFoKS5cXG4gICAgcmV0dXJuIGVudjtcXG4gIH07XFxuXFxuICBqJC5pc0FycmF5XyA9IGZ1bmN0aW9uKHZhbHVlKSB7XFxuICAgIHJldHVybiBqJC5pc0FfKCdBcnJheScsIHZhbHVlKTtcXG4gIH07XFxuXFxuICBqJC5pc1N0cmluZ18gPSBmdW5jdGlvbih2YWx1ZSkge1xcbiAgICByZXR1cm4gaiQuaXNBXygnU3RyaW5nJywgdmFsdWUpO1xcbiAgfTtcXG5cXG4gIGokLmlzTnVtYmVyXyA9IGZ1bmN0aW9uKHZhbHVlKSB7XFxuICAgIHJldHVybiBqJC5pc0FfKCdOdW1iZXInLCB2YWx1ZSk7XFxuICB9O1xcblxcbiAgaiQuaXNBXyA9IGZ1bmN0aW9uKHR5cGVOYW1lLCB2YWx1ZSkge1xcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5hcHBseSh2YWx1ZSkgPT09ICdbb2JqZWN0ICcgKyB0eXBlTmFtZSArICddJztcXG4gIH07XFxuXFxuICBqJC5pc0RvbU5vZGUgPSBmdW5jdGlvbihvYmopIHtcXG4gICAgcmV0dXJuIG9iai5ub2RlVHlwZSA+IDA7XFxuICB9O1xcblxcbiAgaiQuZm5OYW1lRm9yID0gZnVuY3Rpb24oZnVuYykge1xcbiAgICByZXR1cm4gZnVuYy5uYW1lIHx8IGZ1bmMudG9TdHJpbmcoKS5tYXRjaCgvXlxcXFxzKmZ1bmN0aW9uXFxcXHMqKFxcXFx3KilcXFxccypcXFxcKC8pWzFdO1xcbiAgfTtcXG5cXG4gIGokLmFueSA9IGZ1bmN0aW9uKGNsYXp6KSB7XFxuICAgIHJldHVybiBuZXcgaiQuQW55KGNsYXp6KTtcXG4gIH07XFxuXFxuICBqJC5hbnl0aGluZyA9IGZ1bmN0aW9uKCkge1xcbiAgICByZXR1cm4gbmV3IGokLkFueXRoaW5nKCk7XFxuICB9O1xcblxcbiAgaiQub2JqZWN0Q29udGFpbmluZyA9IGZ1bmN0aW9uKHNhbXBsZSkge1xcbiAgICByZXR1cm4gbmV3IGokLk9iamVjdENvbnRhaW5pbmcoc2FtcGxlKTtcXG4gIH07XFxuXFxuICBqJC5zdHJpbmdNYXRjaGluZyA9IGZ1bmN0aW9uKGV4cGVjdGVkKSB7XFxuICAgIHJldHVybiBuZXcgaiQuU3RyaW5nTWF0Y2hpbmcoZXhwZWN0ZWQpO1xcbiAgfTtcXG5cXG4gIGokLmFycmF5Q29udGFpbmluZyA9IGZ1bmN0aW9uKHNhbXBsZSkge1xcbiAgICByZXR1cm4gbmV3IGokLkFycmF5Q29udGFpbmluZyhzYW1wbGUpO1xcbiAgfTtcXG5cXG4gIGokLmNyZWF0ZVNweSA9IGZ1bmN0aW9uKG5hbWUsIG9yaWdpbmFsRm4pIHtcXG5cXG4gICAgdmFyIHNweVN0cmF0ZWd5ID0gbmV3IGokLlNweVN0cmF0ZWd5KHtcXG4gICAgICAgIG5hbWU6IG5hbWUsXFxuICAgICAgICBmbjogb3JpZ2luYWxGbixcXG4gICAgICAgIGdldFNweTogZnVuY3Rpb24oKSB7IHJldHVybiBzcHk7IH1cXG4gICAgICB9KSxcXG4gICAgICBjYWxsVHJhY2tlciA9IG5ldyBqJC5DYWxsVHJhY2tlcigpLFxcbiAgICAgIHNweSA9IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgdmFyIGNhbGxEYXRhID0ge1xcbiAgICAgICAgICBvYmplY3Q6IHRoaXMsXFxuICAgICAgICAgIGFyZ3M6IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShhcmd1bWVudHMpXFxuICAgICAgICB9O1xcblxcbiAgICAgICAgY2FsbFRyYWNrZXIudHJhY2soY2FsbERhdGEpO1xcbiAgICAgICAgdmFyIHJldHVyblZhbHVlID0gc3B5U3RyYXRlZ3kuZXhlYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgICAgICAgY2FsbERhdGEucmV0dXJuVmFsdWUgPSByZXR1cm5WYWx1ZTtcXG5cXG4gICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcXG4gICAgICB9O1xcblxcbiAgICBmb3IgKHZhciBwcm9wIGluIG9yaWdpbmFsRm4pIHtcXG4gICAgICBpZiAocHJvcCA9PT0gJ2FuZCcgfHwgcHJvcCA9PT0gJ2NhbGxzJykge1xcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdKYXNtaW5lIHNwaWVzIHdvdWxkIG92ZXJ3cml0ZSB0aGUgXFxcXCdhbmRcXFxcJyBhbmQgXFxcXCdjYWxsc1xcXFwnIHByb3BlcnRpZXMgb24gdGhlIG9iamVjdCBiZWluZyBzcGllZCB1cG9uJyk7XFxuICAgICAgfVxcblxcbiAgICAgIHNweVtwcm9wXSA9IG9yaWdpbmFsRm5bcHJvcF07XFxuICAgIH1cXG5cXG4gICAgc3B5LmFuZCA9IHNweVN0cmF0ZWd5O1xcbiAgICBzcHkuY2FsbHMgPSBjYWxsVHJhY2tlcjtcXG5cXG4gICAgcmV0dXJuIHNweTtcXG4gIH07XFxuXFxuICBqJC5pc1NweSA9IGZ1bmN0aW9uKHB1dGF0aXZlU3B5KSB7XFxuICAgIGlmICghcHV0YXRpdmVTcHkpIHtcXG4gICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG4gICAgcmV0dXJuIHB1dGF0aXZlU3B5LmFuZCBpbnN0YW5jZW9mIGokLlNweVN0cmF0ZWd5ICYmXFxuICAgICAgcHV0YXRpdmVTcHkuY2FsbHMgaW5zdGFuY2VvZiBqJC5DYWxsVHJhY2tlcjtcXG4gIH07XFxuXFxuICBqJC5jcmVhdGVTcHlPYmogPSBmdW5jdGlvbihiYXNlTmFtZSwgbWV0aG9kTmFtZXMpIHtcXG4gICAgaWYgKGokLmlzQXJyYXlfKGJhc2VOYW1lKSAmJiBqJC51dGlsLmlzVW5kZWZpbmVkKG1ldGhvZE5hbWVzKSkge1xcbiAgICAgIG1ldGhvZE5hbWVzID0gYmFzZU5hbWU7XFxuICAgICAgYmFzZU5hbWUgPSAndW5rbm93bic7XFxuICAgIH1cXG5cXG4gICAgaWYgKCFqJC5pc0FycmF5XyhtZXRob2ROYW1lcykgfHwgbWV0aG9kTmFtZXMubGVuZ3RoID09PSAwKSB7XFxuICAgICAgdGhyb3cgJ2NyZWF0ZVNweU9iaiByZXF1aXJlcyBhIG5vbi1lbXB0eSBhcnJheSBvZiBtZXRob2QgbmFtZXMgdG8gY3JlYXRlIHNwaWVzIGZvcic7XFxuICAgIH1cXG4gICAgdmFyIG9iaiA9IHt9O1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1ldGhvZE5hbWVzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgb2JqW21ldGhvZE5hbWVzW2ldXSA9IGokLmNyZWF0ZVNweShiYXNlTmFtZSArICcuJyArIG1ldGhvZE5hbWVzW2ldKTtcXG4gICAgfVxcbiAgICByZXR1cm4gb2JqO1xcbiAgfTtcXG59O1xcblxcbmdldEphc21pbmVSZXF1aXJlT2JqKCkudXRpbCA9IGZ1bmN0aW9uKCkge1xcblxcbiAgdmFyIHV0aWwgPSB7fTtcXG5cXG4gIHV0aWwuaW5oZXJpdCA9IGZ1bmN0aW9uKGNoaWxkQ2xhc3MsIHBhcmVudENsYXNzKSB7XFxuICAgIHZhciBTdWJjbGFzcyA9IGZ1bmN0aW9uKCkge1xcbiAgICB9O1xcbiAgICBTdWJjbGFzcy5wcm90b3R5cGUgPSBwYXJlbnRDbGFzcy5wcm90b3R5cGU7XFxuICAgIGNoaWxkQ2xhc3MucHJvdG90eXBlID0gbmV3IFN1YmNsYXNzKCk7XFxuICB9O1xcblxcbiAgdXRpbC5odG1sRXNjYXBlID0gZnVuY3Rpb24oc3RyKSB7XFxuICAgIGlmICghc3RyKSB7XFxuICAgICAgcmV0dXJuIHN0cjtcXG4gICAgfVxcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyYvZywgJyZhbXA7JylcXG4gICAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXFxuICAgICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKTtcXG4gIH07XFxuXFxuICB1dGlsLmFyZ3NUb0FycmF5ID0gZnVuY3Rpb24oYXJncykge1xcbiAgICB2YXIgYXJyYXlPZkFyZ3MgPSBbXTtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgYXJyYXlPZkFyZ3MucHVzaChhcmdzW2ldKTtcXG4gICAgfVxcbiAgICByZXR1cm4gYXJyYXlPZkFyZ3M7XFxuICB9O1xcblxcbiAgdXRpbC5pc1VuZGVmaW5lZCA9IGZ1bmN0aW9uKG9iaikge1xcbiAgICByZXR1cm4gb2JqID09PSB2b2lkIDA7XFxuICB9O1xcblxcbiAgdXRpbC5hcnJheUNvbnRhaW5zID0gZnVuY3Rpb24oYXJyYXksIHNlYXJjaCkge1xcbiAgICB2YXIgaSA9IGFycmF5Lmxlbmd0aDtcXG4gICAgd2hpbGUgKGktLSkge1xcbiAgICAgIGlmIChhcnJheVtpXSA9PT0gc2VhcmNoKSB7XFxuICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgcmV0dXJuIGZhbHNlO1xcbiAgfTtcXG5cXG4gIHV0aWwuY2xvbmUgPSBmdW5jdGlvbihvYmopIHtcXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xcbiAgICAgIHJldHVybiBvYmouc2xpY2UoKTtcXG4gICAgfVxcblxcbiAgICB2YXIgY2xvbmVkID0ge307XFxuICAgIGZvciAodmFyIHByb3AgaW4gb2JqKSB7XFxuICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xcbiAgICAgICAgY2xvbmVkW3Byb3BdID0gb2JqW3Byb3BdO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICByZXR1cm4gY2xvbmVkO1xcbiAgfTtcXG5cXG4gIHJldHVybiB1dGlsO1xcbn07XFxuXFxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5TcGVjID0gZnVuY3Rpb24oaiQpIHtcXG4gIGZ1bmN0aW9uIFNwZWMoYXR0cnMpIHtcXG4gICAgdGhpcy5leHBlY3RhdGlvbkZhY3RvcnkgPSBhdHRycy5leHBlY3RhdGlvbkZhY3Rvcnk7XFxuICAgIHRoaXMucmVzdWx0Q2FsbGJhY2sgPSBhdHRycy5yZXN1bHRDYWxsYmFjayB8fCBmdW5jdGlvbigpIHt9O1xcbiAgICB0aGlzLmlkID0gYXR0cnMuaWQ7XFxuICAgIHRoaXMuZGVzY3JpcHRpb24gPSBhdHRycy5kZXNjcmlwdGlvbiB8fCAnJztcXG4gICAgdGhpcy5xdWV1ZWFibGVGbiA9IGF0dHJzLnF1ZXVlYWJsZUZuO1xcbiAgICB0aGlzLmJlZm9yZUFuZEFmdGVyRm5zID0gYXR0cnMuYmVmb3JlQW5kQWZ0ZXJGbnMgfHwgZnVuY3Rpb24oKSB7IHJldHVybiB7YmVmb3JlczogW10sIGFmdGVyczogW119OyB9O1xcbiAgICB0aGlzLnVzZXJDb250ZXh0ID0gYXR0cnMudXNlckNvbnRleHQgfHwgZnVuY3Rpb24oKSB7IHJldHVybiB7fTsgfTtcXG4gICAgdGhpcy5vblN0YXJ0ID0gYXR0cnMub25TdGFydCB8fCBmdW5jdGlvbigpIHt9O1xcbiAgICB0aGlzLmdldFNwZWNOYW1lID0gYXR0cnMuZ2V0U3BlY05hbWUgfHwgZnVuY3Rpb24oKSB7IHJldHVybiAnJzsgfTtcXG4gICAgdGhpcy5leHBlY3RhdGlvblJlc3VsdEZhY3RvcnkgPSBhdHRycy5leHBlY3RhdGlvblJlc3VsdEZhY3RvcnkgfHwgZnVuY3Rpb24oKSB7IH07XFxuICAgIHRoaXMucXVldWVSdW5uZXJGYWN0b3J5ID0gYXR0cnMucXVldWVSdW5uZXJGYWN0b3J5IHx8IGZ1bmN0aW9uKCkge307XFxuICAgIHRoaXMuY2F0Y2hpbmdFeGNlcHRpb25zID0gYXR0cnMuY2F0Y2hpbmdFeGNlcHRpb25zIHx8IGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfTtcXG4gICAgdGhpcy50aHJvd09uRXhwZWN0YXRpb25GYWlsdXJlID0gISFhdHRycy50aHJvd09uRXhwZWN0YXRpb25GYWlsdXJlO1xcblxcbiAgICBpZiAoIXRoaXMucXVldWVhYmxlRm4uZm4pIHtcXG4gICAgICB0aGlzLnBlbmQoKTtcXG4gICAgfVxcblxcbiAgICB0aGlzLnJlc3VsdCA9IHtcXG4gICAgICBpZDogdGhpcy5pZCxcXG4gICAgICBkZXNjcmlwdGlvbjogdGhpcy5kZXNjcmlwdGlvbixcXG4gICAgICBmdWxsTmFtZTogdGhpcy5nZXRGdWxsTmFtZSgpLFxcbiAgICAgIGZhaWxlZEV4cGVjdGF0aW9uczogW10sXFxuICAgICAgcGFzc2VkRXhwZWN0YXRpb25zOiBbXSxcXG4gICAgICBwZW5kaW5nUmVhc29uOiAnJ1xcbiAgICB9O1xcbiAgfVxcblxcbiAgU3BlYy5wcm90b3R5cGUuYWRkRXhwZWN0YXRpb25SZXN1bHQgPSBmdW5jdGlvbihwYXNzZWQsIGRhdGEsIGlzRXJyb3IpIHtcXG4gICAgdmFyIGV4cGVjdGF0aW9uUmVzdWx0ID0gdGhpcy5leHBlY3RhdGlvblJlc3VsdEZhY3RvcnkoZGF0YSk7XFxuICAgIGlmIChwYXNzZWQpIHtcXG4gICAgICB0aGlzLnJlc3VsdC5wYXNzZWRFeHBlY3RhdGlvbnMucHVzaChleHBlY3RhdGlvblJlc3VsdCk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdGhpcy5yZXN1bHQuZmFpbGVkRXhwZWN0YXRpb25zLnB1c2goZXhwZWN0YXRpb25SZXN1bHQpO1xcblxcbiAgICAgIGlmICh0aGlzLnRocm93T25FeHBlY3RhdGlvbkZhaWx1cmUgJiYgIWlzRXJyb3IpIHtcXG4gICAgICAgIHRocm93IG5ldyBqJC5lcnJvcnMuRXhwZWN0YXRpb25GYWlsZWQoKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH07XFxuXFxuICBTcGVjLnByb3RvdHlwZS5leHBlY3QgPSBmdW5jdGlvbihhY3R1YWwpIHtcXG4gICAgcmV0dXJuIHRoaXMuZXhwZWN0YXRpb25GYWN0b3J5KGFjdHVhbCwgdGhpcyk7XFxuICB9O1xcblxcbiAgU3BlYy5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uKG9uQ29tcGxldGUsIGVuYWJsZWQpIHtcXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xcblxcbiAgICB0aGlzLm9uU3RhcnQodGhpcyk7XFxuXFxuICAgIGlmICghdGhpcy5pc0V4ZWN1dGFibGUoKSB8fCB0aGlzLm1hcmtlZFBlbmRpbmcgfHwgZW5hYmxlZCA9PT0gZmFsc2UpIHtcXG4gICAgICBjb21wbGV0ZShlbmFibGVkKTtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgdmFyIGZucyA9IHRoaXMuYmVmb3JlQW5kQWZ0ZXJGbnMoKTtcXG4gICAgdmFyIGFsbEZucyA9IGZucy5iZWZvcmVzLmNvbmNhdCh0aGlzLnF1ZXVlYWJsZUZuKS5jb25jYXQoZm5zLmFmdGVycyk7XFxuXFxuICAgIHRoaXMucXVldWVSdW5uZXJGYWN0b3J5KHtcXG4gICAgICBxdWV1ZWFibGVGbnM6IGFsbEZucyxcXG4gICAgICBvbkV4Y2VwdGlvbjogZnVuY3Rpb24oKSB7IHNlbGYub25FeGNlcHRpb24uYXBwbHkoc2VsZiwgYXJndW1lbnRzKTsgfSxcXG4gICAgICBvbkNvbXBsZXRlOiBjb21wbGV0ZSxcXG4gICAgICB1c2VyQ29udGV4dDogdGhpcy51c2VyQ29udGV4dCgpXFxuICAgIH0pO1xcblxcbiAgICBmdW5jdGlvbiBjb21wbGV0ZShlbmFibGVkQWdhaW4pIHtcXG4gICAgICBzZWxmLnJlc3VsdC5zdGF0dXMgPSBzZWxmLnN0YXR1cyhlbmFibGVkQWdhaW4pO1xcbiAgICAgIHNlbGYucmVzdWx0Q2FsbGJhY2soc2VsZi5yZXN1bHQpO1xcblxcbiAgICAgIGlmIChvbkNvbXBsZXRlKSB7XFxuICAgICAgICBvbkNvbXBsZXRlKCk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9O1xcblxcbiAgU3BlYy5wcm90b3R5cGUub25FeGNlcHRpb24gPSBmdW5jdGlvbiBvbkV4Y2VwdGlvbihlKSB7XFxuICAgIGlmIChTcGVjLmlzUGVuZGluZ1NwZWNFeGNlcHRpb24oZSkpIHtcXG4gICAgICB0aGlzLnBlbmQoZXh0cmFjdEN1c3RvbVBlbmRpbmdNZXNzYWdlKGUpKTtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgaWYgKGUgaW5zdGFuY2VvZiBqJC5lcnJvcnMuRXhwZWN0YXRpb25GYWlsZWQpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgdGhpcy5hZGRFeHBlY3RhdGlvblJlc3VsdChmYWxzZSwge1xcbiAgICAgIG1hdGNoZXJOYW1lOiAnJyxcXG4gICAgICBwYXNzZWQ6IGZhbHNlLFxcbiAgICAgIGV4cGVjdGVkOiAnJyxcXG4gICAgICBhY3R1YWw6ICcnLFxcbiAgICAgIGVycm9yOiBlXFxuICAgIH0sIHRydWUpO1xcbiAgfTtcXG5cXG4gIFNwZWMucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbigpIHtcXG4gICAgdGhpcy5kaXNhYmxlZCA9IHRydWU7XFxuICB9O1xcblxcbiAgU3BlYy5wcm90b3R5cGUucGVuZCA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcXG4gICAgdGhpcy5tYXJrZWRQZW5kaW5nID0gdHJ1ZTtcXG4gICAgaWYgKG1lc3NhZ2UpIHtcXG4gICAgICB0aGlzLnJlc3VsdC5wZW5kaW5nUmVhc29uID0gbWVzc2FnZTtcXG4gICAgfVxcbiAgfTtcXG5cXG4gIFNwZWMucHJvdG90eXBlLmdldFJlc3VsdCA9IGZ1bmN0aW9uKCkge1xcbiAgICB0aGlzLnJlc3VsdC5zdGF0dXMgPSB0aGlzLnN0YXR1cygpO1xcbiAgICByZXR1cm4gdGhpcy5yZXN1bHQ7XFxuICB9O1xcblxcbiAgU3BlYy5wcm90b3R5cGUuc3RhdHVzID0gZnVuY3Rpb24oZW5hYmxlZCkge1xcbiAgICBpZiAodGhpcy5kaXNhYmxlZCB8fCBlbmFibGVkID09PSBmYWxzZSkge1xcbiAgICAgIHJldHVybiAnZGlzYWJsZWQnO1xcbiAgICB9XFxuXFxuICAgIGlmICh0aGlzLm1hcmtlZFBlbmRpbmcpIHtcXG4gICAgICByZXR1cm4gJ3BlbmRpbmcnO1xcbiAgICB9XFxuXFxuICAgIGlmICh0aGlzLnJlc3VsdC5mYWlsZWRFeHBlY3RhdGlvbnMubGVuZ3RoID4gMCkge1xcbiAgICAgIHJldHVybiAnZmFpbGVkJztcXG4gICAgfSBlbHNlIHtcXG4gICAgICByZXR1cm4gJ3Bhc3NlZCc7XFxuICAgIH1cXG4gIH07XFxuXFxuICBTcGVjLnByb3RvdHlwZS5pc0V4ZWN1dGFibGUgPSBmdW5jdGlvbigpIHtcXG4gICAgcmV0dXJuICF0aGlzLmRpc2FibGVkO1xcbiAgfTtcXG5cXG4gIFNwZWMucHJvdG90eXBlLmdldEZ1bGxOYW1lID0gZnVuY3Rpb24oKSB7XFxuICAgIHJldHVybiB0aGlzLmdldFNwZWNOYW1lKHRoaXMpO1xcbiAgfTtcXG5cXG4gIHZhciBleHRyYWN0Q3VzdG9tUGVuZGluZ01lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XFxuICAgIHZhciBmdWxsTWVzc2FnZSA9IGUudG9TdHJpbmcoKSxcXG4gICAgICAgIGJvaWxlcnBsYXRlU3RhcnQgPSBmdWxsTWVzc2FnZS5pbmRleE9mKFNwZWMucGVuZGluZ1NwZWNFeGNlcHRpb25NZXNzYWdlKSxcXG4gICAgICAgIGJvaWxlcnBsYXRlRW5kID0gYm9pbGVycGxhdGVTdGFydCArIFNwZWMucGVuZGluZ1NwZWNFeGNlcHRpb25NZXNzYWdlLmxlbmd0aDtcXG5cXG4gICAgcmV0dXJuIGZ1bGxNZXNzYWdlLnN1YnN0cihib2lsZXJwbGF0ZUVuZCk7XFxuICB9O1xcblxcbiAgU3BlYy5wZW5kaW5nU3BlY0V4Y2VwdGlvbk1lc3NhZ2UgPSAnPT4gbWFya2VkIFBlbmRpbmcnO1xcblxcbiAgU3BlYy5pc1BlbmRpbmdTcGVjRXhjZXB0aW9uID0gZnVuY3Rpb24oZSkge1xcbiAgICByZXR1cm4gISEoZSAmJiBlLnRvU3RyaW5nICYmIGUudG9TdHJpbmcoKS5pbmRleE9mKFNwZWMucGVuZGluZ1NwZWNFeGNlcHRpb25NZXNzYWdlKSAhPT0gLTEpO1xcbiAgfTtcXG5cXG4gIHJldHVybiBTcGVjO1xcbn07XFxuXFxuaWYgKHR5cGVvZiB3aW5kb3cgPT0gdm9pZCAwICYmIHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnKSB7XFxuICBleHBvcnRzLlNwZWMgPSBqYXNtaW5lUmVxdWlyZS5TcGVjO1xcbn1cXG5cXG4vKmpzaGludCBiaXR3aXNlOiBmYWxzZSovXFxuXFxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5PcmRlciA9IGZ1bmN0aW9uKCkge1xcbiAgZnVuY3Rpb24gT3JkZXIob3B0aW9ucykge1xcbiAgICB0aGlzLnJhbmRvbSA9ICdyYW5kb20nIGluIG9wdGlvbnMgPyBvcHRpb25zLnJhbmRvbSA6IHRydWU7XFxuICAgIHZhciBzZWVkID0gdGhpcy5zZWVkID0gb3B0aW9ucy5zZWVkIHx8IGdlbmVyYXRlU2VlZCgpO1xcbiAgICB0aGlzLnNvcnQgPSB0aGlzLnJhbmRvbSA/IHJhbmRvbU9yZGVyIDogbmF0dXJhbE9yZGVyO1xcblxcbiAgICBmdW5jdGlvbiBuYXR1cmFsT3JkZXIoaXRlbXMpIHtcXG4gICAgICByZXR1cm4gaXRlbXM7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gcmFuZG9tT3JkZXIoaXRlbXMpIHtcXG4gICAgICB2YXIgY29weSA9IGl0ZW1zLnNsaWNlKCk7XFxuICAgICAgY29weS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcXG4gICAgICAgIHJldHVybiBqZW5raW5zSGFzaChzZWVkICsgYS5pZCkgLSBqZW5raW5zSGFzaChzZWVkICsgYi5pZCk7XFxuICAgICAgfSk7XFxuICAgICAgcmV0dXJuIGNvcHk7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVTZWVkKCkge1xcbiAgICAgIHJldHVybiBTdHJpbmcoTWF0aC5yYW5kb20oKSkuc2xpY2UoLTUpO1xcbiAgICB9XFxuXFxuICAgIC8vIEJvYiBKZW5raW5zIE9uZS1hdC1hLVRpbWUgSGFzaCBhbGdvcml0aG0gaXMgYSBub24tY3J5cHRvZ3JhcGhpYyBoYXNoIGZ1bmN0aW9uXFxuICAgIC8vIHVzZWQgdG8gZ2V0IGEgZGlmZmVyZW50IG91dHB1dCB3aGVuIHRoZSBrZXkgY2hhbmdlcyBzbGlnaGx5LlxcbiAgICAvLyBXZSB1c2UgeW91ciByZXR1cm4gdG8gc29ydCB0aGUgY2hpbGRyZW4gcmFuZG9tbHkgaW4gYSBjb25zaXN0ZW50IHdheSB3aGVuXFxuICAgIC8vIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBhIHNlZWRcXG5cXG4gICAgZnVuY3Rpb24gamVua2luc0hhc2goa2V5KSB7XFxuICAgICAgdmFyIGhhc2gsIGk7XFxuICAgICAgZm9yKGhhc2ggPSBpID0gMDsgaSA8IGtleS5sZW5ndGg7ICsraSkge1xcbiAgICAgICAgaGFzaCArPSBrZXkuY2hhckNvZGVBdChpKTtcXG4gICAgICAgIGhhc2ggKz0gKGhhc2ggPDwgMTApO1xcbiAgICAgICAgaGFzaCBePSAoaGFzaCA+PiA2KTtcXG4gICAgICB9XFxuICAgICAgaGFzaCArPSAoaGFzaCA8PCAzKTtcXG4gICAgICBoYXNoIF49IChoYXNoID4+IDExKTtcXG4gICAgICBoYXNoICs9IChoYXNoIDw8IDE1KTtcXG4gICAgICByZXR1cm4gaGFzaDtcXG4gICAgfVxcblxcbiAgfVxcblxcbiAgcmV0dXJuIE9yZGVyO1xcbn07XFxuXFxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5FbnYgPSBmdW5jdGlvbihqJCkge1xcbiAgZnVuY3Rpb24gRW52KG9wdGlvbnMpIHtcXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XFxuXFxuICAgIHZhciBzZWxmID0gdGhpcztcXG4gICAgdmFyIGdsb2JhbCA9IG9wdGlvbnMuZ2xvYmFsIHx8IGokLmdldEdsb2JhbCgpO1xcblxcbiAgICB2YXIgdG90YWxTcGVjc0RlZmluZWQgPSAwO1xcblxcbiAgICB2YXIgY2F0Y2hFeGNlcHRpb25zID0gdHJ1ZTtcXG5cXG4gICAgdmFyIHJlYWxTZXRUaW1lb3V0ID0gaiQuZ2V0R2xvYmFsKCkuc2V0VGltZW91dDtcXG4gICAgdmFyIHJlYWxDbGVhclRpbWVvdXQgPSBqJC5nZXRHbG9iYWwoKS5jbGVhclRpbWVvdXQ7XFxuICAgIHRoaXMuY2xvY2sgPSBuZXcgaiQuQ2xvY2soZ2xvYmFsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgaiQuRGVsYXllZEZ1bmN0aW9uU2NoZWR1bGVyKCk7IH0sIG5ldyBqJC5Nb2NrRGF0ZShnbG9iYWwpKTtcXG5cXG4gICAgdmFyIHJ1bm5hYmxlTG9va3VwVGFibGUgPSB7fTtcXG4gICAgdmFyIHJ1bm5hYmxlUmVzb3VyY2VzID0ge307XFxuXFxuICAgIHZhciBjdXJyZW50U3BlYyA9IG51bGw7XFxuICAgIHZhciBjdXJyZW50bHlFeGVjdXRpbmdTdWl0ZXMgPSBbXTtcXG4gICAgdmFyIGN1cnJlbnREZWNsYXJhdGlvblN1aXRlID0gbnVsbDtcXG4gICAgdmFyIHRocm93T25FeHBlY3RhdGlvbkZhaWx1cmUgPSBmYWxzZTtcXG4gICAgdmFyIHJhbmRvbSA9IGZhbHNlO1xcbiAgICB2YXIgc2VlZCA9IG51bGw7XFxuXFxuICAgIHZhciBjdXJyZW50U3VpdGUgPSBmdW5jdGlvbigpIHtcXG4gICAgICByZXR1cm4gY3VycmVudGx5RXhlY3V0aW5nU3VpdGVzW2N1cnJlbnRseUV4ZWN1dGluZ1N1aXRlcy5sZW5ndGggLSAxXTtcXG4gICAgfTtcXG5cXG4gICAgdmFyIGN1cnJlbnRSdW5uYWJsZSA9IGZ1bmN0aW9uKCkge1xcbiAgICAgIHJldHVybiBjdXJyZW50U3BlYyB8fCBjdXJyZW50U3VpdGUoKTtcXG4gICAgfTtcXG5cXG4gICAgdmFyIHJlcG9ydGVyID0gbmV3IGokLlJlcG9ydERpc3BhdGNoZXIoW1xcbiAgICAgICdqYXNtaW5lU3RhcnRlZCcsXFxuICAgICAgJ2phc21pbmVEb25lJyxcXG4gICAgICAnc3VpdGVTdGFydGVkJyxcXG4gICAgICAnc3VpdGVEb25lJyxcXG4gICAgICAnc3BlY1N0YXJ0ZWQnLFxcbiAgICAgICdzcGVjRG9uZSdcXG4gICAgXSk7XFxuXFxuICAgIHRoaXMuc3BlY0ZpbHRlciA9IGZ1bmN0aW9uKCkge1xcbiAgICAgIHJldHVybiB0cnVlO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLmFkZEN1c3RvbUVxdWFsaXR5VGVzdGVyID0gZnVuY3Rpb24odGVzdGVyKSB7XFxuICAgICAgaWYoIWN1cnJlbnRSdW5uYWJsZSgpKSB7XFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0N1c3RvbSBFcXVhbGl0aWVzIG11c3QgYmUgYWRkZWQgaW4gYSBiZWZvcmUgZnVuY3Rpb24gb3IgYSBzcGVjJyk7XFxuICAgICAgfVxcbiAgICAgIHJ1bm5hYmxlUmVzb3VyY2VzW2N1cnJlbnRSdW5uYWJsZSgpLmlkXS5jdXN0b21FcXVhbGl0eVRlc3RlcnMucHVzaCh0ZXN0ZXIpO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLmFkZE1hdGNoZXJzID0gZnVuY3Rpb24obWF0Y2hlcnNUb0FkZCkge1xcbiAgICAgIGlmKCFjdXJyZW50UnVubmFibGUoKSkge1xcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYXRjaGVycyBtdXN0IGJlIGFkZGVkIGluIGEgYmVmb3JlIGZ1bmN0aW9uIG9yIGEgc3BlYycpO1xcbiAgICAgIH1cXG4gICAgICB2YXIgY3VzdG9tTWF0Y2hlcnMgPSBydW5uYWJsZVJlc291cmNlc1tjdXJyZW50UnVubmFibGUoKS5pZF0uY3VzdG9tTWF0Y2hlcnM7XFxuICAgICAgZm9yICh2YXIgbWF0Y2hlck5hbWUgaW4gbWF0Y2hlcnNUb0FkZCkge1xcbiAgICAgICAgY3VzdG9tTWF0Y2hlcnNbbWF0Y2hlck5hbWVdID0gbWF0Y2hlcnNUb0FkZFttYXRjaGVyTmFtZV07XFxuICAgICAgfVxcbiAgICB9O1xcblxcbiAgICBqJC5FeHBlY3RhdGlvbi5hZGRDb3JlTWF0Y2hlcnMoaiQubWF0Y2hlcnMpO1xcblxcbiAgICB2YXIgbmV4dFNwZWNJZCA9IDA7XFxuICAgIHZhciBnZXROZXh0U3BlY0lkID0gZnVuY3Rpb24oKSB7XFxuICAgICAgcmV0dXJuICdzcGVjJyArIG5leHRTcGVjSWQrKztcXG4gICAgfTtcXG5cXG4gICAgdmFyIG5leHRTdWl0ZUlkID0gMDtcXG4gICAgdmFyIGdldE5leHRTdWl0ZUlkID0gZnVuY3Rpb24oKSB7XFxuICAgICAgcmV0dXJuICdzdWl0ZScgKyBuZXh0U3VpdGVJZCsrO1xcbiAgICB9O1xcblxcbiAgICB2YXIgZXhwZWN0YXRpb25GYWN0b3J5ID0gZnVuY3Rpb24oYWN0dWFsLCBzcGVjKSB7XFxuICAgICAgcmV0dXJuIGokLkV4cGVjdGF0aW9uLkZhY3Rvcnkoe1xcbiAgICAgICAgdXRpbDogaiQubWF0Y2hlcnNVdGlsLFxcbiAgICAgICAgY3VzdG9tRXF1YWxpdHlUZXN0ZXJzOiBydW5uYWJsZVJlc291cmNlc1tzcGVjLmlkXS5jdXN0b21FcXVhbGl0eVRlc3RlcnMsXFxuICAgICAgICBjdXN0b21NYXRjaGVyczogcnVubmFibGVSZXNvdXJjZXNbc3BlYy5pZF0uY3VzdG9tTWF0Y2hlcnMsXFxuICAgICAgICBhY3R1YWw6IGFjdHVhbCxcXG4gICAgICAgIGFkZEV4cGVjdGF0aW9uUmVzdWx0OiBhZGRFeHBlY3RhdGlvblJlc3VsdFxcbiAgICAgIH0pO1xcblxcbiAgICAgIGZ1bmN0aW9uIGFkZEV4cGVjdGF0aW9uUmVzdWx0KHBhc3NlZCwgcmVzdWx0KSB7XFxuICAgICAgICByZXR1cm4gc3BlYy5hZGRFeHBlY3RhdGlvblJlc3VsdChwYXNzZWQsIHJlc3VsdCk7XFxuICAgICAgfVxcbiAgICB9O1xcblxcbiAgICB2YXIgZGVmYXVsdFJlc291cmNlc0ZvclJ1bm5hYmxlID0gZnVuY3Rpb24oaWQsIHBhcmVudFJ1bm5hYmxlSWQpIHtcXG4gICAgICB2YXIgcmVzb3VyY2VzID0ge3NwaWVzOiBbXSwgY3VzdG9tRXF1YWxpdHlUZXN0ZXJzOiBbXSwgY3VzdG9tTWF0Y2hlcnM6IHt9fTtcXG5cXG4gICAgICBpZihydW5uYWJsZVJlc291cmNlc1twYXJlbnRSdW5uYWJsZUlkXSl7XFxuICAgICAgICByZXNvdXJjZXMuY3VzdG9tRXF1YWxpdHlUZXN0ZXJzID0gaiQudXRpbC5jbG9uZShydW5uYWJsZVJlc291cmNlc1twYXJlbnRSdW5uYWJsZUlkXS5jdXN0b21FcXVhbGl0eVRlc3RlcnMpO1xcbiAgICAgICAgcmVzb3VyY2VzLmN1c3RvbU1hdGNoZXJzID0gaiQudXRpbC5jbG9uZShydW5uYWJsZVJlc291cmNlc1twYXJlbnRSdW5uYWJsZUlkXS5jdXN0b21NYXRjaGVycyk7XFxuICAgICAgfVxcblxcbiAgICAgIHJ1bm5hYmxlUmVzb3VyY2VzW2lkXSA9IHJlc291cmNlcztcXG4gICAgfTtcXG5cXG4gICAgdmFyIGNsZWFyUmVzb3VyY2VzRm9yUnVubmFibGUgPSBmdW5jdGlvbihpZCkge1xcbiAgICAgICAgc3B5UmVnaXN0cnkuY2xlYXJTcGllcygpO1xcbiAgICAgICAgZGVsZXRlIHJ1bm5hYmxlUmVzb3VyY2VzW2lkXTtcXG4gICAgfTtcXG5cXG4gICAgdmFyIGJlZm9yZUFuZEFmdGVyRm5zID0gZnVuY3Rpb24oc3VpdGUpIHtcXG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XFxuICAgICAgICB2YXIgYmVmb3JlcyA9IFtdLFxcbiAgICAgICAgICBhZnRlcnMgPSBbXTtcXG5cXG4gICAgICAgIHdoaWxlKHN1aXRlKSB7XFxuICAgICAgICAgIGJlZm9yZXMgPSBiZWZvcmVzLmNvbmNhdChzdWl0ZS5iZWZvcmVGbnMpO1xcbiAgICAgICAgICBhZnRlcnMgPSBhZnRlcnMuY29uY2F0KHN1aXRlLmFmdGVyRm5zKTtcXG5cXG4gICAgICAgICAgc3VpdGUgPSBzdWl0ZS5wYXJlbnRTdWl0ZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgIGJlZm9yZXM6IGJlZm9yZXMucmV2ZXJzZSgpLFxcbiAgICAgICAgICBhZnRlcnM6IGFmdGVyc1xcbiAgICAgICAgfTtcXG4gICAgICB9O1xcbiAgICB9O1xcblxcbiAgICB2YXIgZ2V0U3BlY05hbWUgPSBmdW5jdGlvbihzcGVjLCBzdWl0ZSkge1xcbiAgICAgIHJldHVybiBzdWl0ZS5nZXRGdWxsTmFtZSgpICsgJyAnICsgc3BlYy5kZXNjcmlwdGlvbjtcXG4gICAgfTtcXG5cXG4gICAgLy8gVE9ETzogd2UgbWF5IGp1c3QgYmUgYWJsZSB0byBwYXNzIGluIHRoZSBmbiBpbnN0ZWFkIG9mIHdyYXBwaW5nIGhlcmVcXG4gICAgdmFyIGJ1aWxkRXhwZWN0YXRpb25SZXN1bHQgPSBqJC5idWlsZEV4cGVjdGF0aW9uUmVzdWx0LFxcbiAgICAgICAgZXhjZXB0aW9uRm9ybWF0dGVyID0gbmV3IGokLkV4Y2VwdGlvbkZvcm1hdHRlcigpLFxcbiAgICAgICAgZXhwZWN0YXRpb25SZXN1bHRGYWN0b3J5ID0gZnVuY3Rpb24oYXR0cnMpIHtcXG4gICAgICAgICAgYXR0cnMubWVzc2FnZUZvcm1hdHRlciA9IGV4Y2VwdGlvbkZvcm1hdHRlci5tZXNzYWdlO1xcbiAgICAgICAgICBhdHRycy5zdGFja0Zvcm1hdHRlciA9IGV4Y2VwdGlvbkZvcm1hdHRlci5zdGFjaztcXG5cXG4gICAgICAgICAgcmV0dXJuIGJ1aWxkRXhwZWN0YXRpb25SZXN1bHQoYXR0cnMpO1xcbiAgICAgICAgfTtcXG5cXG4gICAgLy8gVE9ETzogZml4IHRoaXMgbmFtaW5nLCBhbmQgaGVyZSdzIHdoZXJlIHRoZSB2YWx1ZSBjb21lcyBpblxcbiAgICB0aGlzLmNhdGNoRXhjZXB0aW9ucyA9IGZ1bmN0aW9uKHZhbHVlKSB7XFxuICAgICAgY2F0Y2hFeGNlcHRpb25zID0gISF2YWx1ZTtcXG4gICAgICByZXR1cm4gY2F0Y2hFeGNlcHRpb25zO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLmNhdGNoaW5nRXhjZXB0aW9ucyA9IGZ1bmN0aW9uKCkge1xcbiAgICAgIHJldHVybiBjYXRjaEV4Y2VwdGlvbnM7XFxuICAgIH07XFxuXFxuICAgIHZhciBtYXhpbXVtU3BlY0NhbGxiYWNrRGVwdGggPSAyMDtcXG4gICAgdmFyIGN1cnJlbnRTcGVjQ2FsbGJhY2tEZXB0aCA9IDA7XFxuXFxuICAgIGZ1bmN0aW9uIGNsZWFyU3RhY2soZm4pIHtcXG4gICAgICBjdXJyZW50U3BlY0NhbGxiYWNrRGVwdGgrKztcXG4gICAgICBpZiAoY3VycmVudFNwZWNDYWxsYmFja0RlcHRoID49IG1heGltdW1TcGVjQ2FsbGJhY2tEZXB0aCkge1xcbiAgICAgICAgY3VycmVudFNwZWNDYWxsYmFja0RlcHRoID0gMDtcXG4gICAgICAgIHJlYWxTZXRUaW1lb3V0KGZuLCAwKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgZm4oKTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgdmFyIGNhdGNoRXhjZXB0aW9uID0gZnVuY3Rpb24oZSkge1xcbiAgICAgIHJldHVybiBqJC5TcGVjLmlzUGVuZGluZ1NwZWNFeGNlcHRpb24oZSkgfHwgY2F0Y2hFeGNlcHRpb25zO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLnRocm93T25FeHBlY3RhdGlvbkZhaWx1cmUgPSBmdW5jdGlvbih2YWx1ZSkge1xcbiAgICAgIHRocm93T25FeHBlY3RhdGlvbkZhaWx1cmUgPSAhIXZhbHVlO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLnRocm93aW5nRXhwZWN0YXRpb25GYWlsdXJlcyA9IGZ1bmN0aW9uKCkge1xcbiAgICAgIHJldHVybiB0aHJvd09uRXhwZWN0YXRpb25GYWlsdXJlO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLnJhbmRvbWl6ZVRlc3RzID0gZnVuY3Rpb24odmFsdWUpIHtcXG4gICAgICByYW5kb20gPSAhIXZhbHVlO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLnJhbmRvbVRlc3RzID0gZnVuY3Rpb24oKSB7XFxuICAgICAgcmV0dXJuIHJhbmRvbTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5zZWVkID0gZnVuY3Rpb24odmFsdWUpIHtcXG4gICAgICBpZiAodmFsdWUpIHtcXG4gICAgICAgIHNlZWQgPSB2YWx1ZTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHNlZWQ7XFxuICAgIH07XFxuXFxuICAgIHZhciBxdWV1ZVJ1bm5lckZhY3RvcnkgPSBmdW5jdGlvbihvcHRpb25zKSB7XFxuICAgICAgb3B0aW9ucy5jYXRjaEV4Y2VwdGlvbiA9IGNhdGNoRXhjZXB0aW9uO1xcbiAgICAgIG9wdGlvbnMuY2xlYXJTdGFjayA9IG9wdGlvbnMuY2xlYXJTdGFjayB8fCBjbGVhclN0YWNrO1xcbiAgICAgIG9wdGlvbnMudGltZW91dCA9IHtzZXRUaW1lb3V0OiByZWFsU2V0VGltZW91dCwgY2xlYXJUaW1lb3V0OiByZWFsQ2xlYXJUaW1lb3V0fTtcXG4gICAgICBvcHRpb25zLmZhaWwgPSBzZWxmLmZhaWw7XFxuXFxuICAgICAgbmV3IGokLlF1ZXVlUnVubmVyKG9wdGlvbnMpLmV4ZWN1dGUoKTtcXG4gICAgfTtcXG5cXG4gICAgdmFyIHRvcFN1aXRlID0gbmV3IGokLlN1aXRlKHtcXG4gICAgICBlbnY6IHRoaXMsXFxuICAgICAgaWQ6IGdldE5leHRTdWl0ZUlkKCksXFxuICAgICAgZGVzY3JpcHRpb246ICdKYXNtaW5lX19Ub3BMZXZlbF9fU3VpdGUnLFxcbiAgICAgIHF1ZXVlUnVubmVyOiBxdWV1ZVJ1bm5lckZhY3RvcnlcXG4gICAgfSk7XFxuICAgIHJ1bm5hYmxlTG9va3VwVGFibGVbdG9wU3VpdGUuaWRdID0gdG9wU3VpdGU7XFxuICAgIGRlZmF1bHRSZXNvdXJjZXNGb3JSdW5uYWJsZSh0b3BTdWl0ZS5pZCk7XFxuICAgIGN1cnJlbnREZWNsYXJhdGlvblN1aXRlID0gdG9wU3VpdGU7XFxuXFxuICAgIHRoaXMudG9wU3VpdGUgPSBmdW5jdGlvbigpIHtcXG4gICAgICByZXR1cm4gdG9wU3VpdGU7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuZXhlY3V0ZSA9IGZ1bmN0aW9uKHJ1bm5hYmxlc1RvUnVuKSB7XFxuICAgICAgaWYoIXJ1bm5hYmxlc1RvUnVuKSB7XFxuICAgICAgICBpZiAoZm9jdXNlZFJ1bm5hYmxlcy5sZW5ndGgpIHtcXG4gICAgICAgICAgcnVubmFibGVzVG9SdW4gPSBmb2N1c2VkUnVubmFibGVzO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgcnVubmFibGVzVG9SdW4gPSBbdG9wU3VpdGUuaWRdO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgb3JkZXIgPSBuZXcgaiQuT3JkZXIoe1xcbiAgICAgICAgcmFuZG9tOiByYW5kb20sXFxuICAgICAgICBzZWVkOiBzZWVkXFxuICAgICAgfSk7XFxuXFxuICAgICAgdmFyIHByb2Nlc3NvciA9IG5ldyBqJC5UcmVlUHJvY2Vzc29yKHtcXG4gICAgICAgIHRyZWU6IHRvcFN1aXRlLFxcbiAgICAgICAgcnVubmFibGVJZHM6IHJ1bm5hYmxlc1RvUnVuLFxcbiAgICAgICAgcXVldWVSdW5uZXJGYWN0b3J5OiBxdWV1ZVJ1bm5lckZhY3RvcnksXFxuICAgICAgICBub2RlU3RhcnQ6IGZ1bmN0aW9uKHN1aXRlKSB7XFxuICAgICAgICAgIGN1cnJlbnRseUV4ZWN1dGluZ1N1aXRlcy5wdXNoKHN1aXRlKTtcXG4gICAgICAgICAgZGVmYXVsdFJlc291cmNlc0ZvclJ1bm5hYmxlKHN1aXRlLmlkLCBzdWl0ZS5wYXJlbnRTdWl0ZS5pZCk7XFxuICAgICAgICAgIHJlcG9ydGVyLnN1aXRlU3RhcnRlZChzdWl0ZS5yZXN1bHQpO1xcbiAgICAgICAgfSxcXG4gICAgICAgIG5vZGVDb21wbGV0ZTogZnVuY3Rpb24oc3VpdGUsIHJlc3VsdCkge1xcbiAgICAgICAgICBpZiAoIXN1aXRlLmRpc2FibGVkKSB7XFxuICAgICAgICAgICAgY2xlYXJSZXNvdXJjZXNGb3JSdW5uYWJsZShzdWl0ZS5pZCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgY3VycmVudGx5RXhlY3V0aW5nU3VpdGVzLnBvcCgpO1xcbiAgICAgICAgICByZXBvcnRlci5zdWl0ZURvbmUocmVzdWx0KTtcXG4gICAgICAgIH0sXFxuICAgICAgICBvcmRlckNoaWxkcmVuOiBmdW5jdGlvbihub2RlKSB7XFxuICAgICAgICAgIHJldHVybiBvcmRlci5zb3J0KG5vZGUuY2hpbGRyZW4pO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcblxcbiAgICAgIGlmKCFwcm9jZXNzb3IucHJvY2Vzc1RyZWUoKS52YWxpZCkge1xcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG9yZGVyOiB3b3VsZCBjYXVzZSBhIGJlZm9yZUFsbCBvciBhZnRlckFsbCB0byBiZSBydW4gbXVsdGlwbGUgdGltZXMnKTtcXG4gICAgICB9XFxuXFxuICAgICAgcmVwb3J0ZXIuamFzbWluZVN0YXJ0ZWQoe1xcbiAgICAgICAgdG90YWxTcGVjc0RlZmluZWQ6IHRvdGFsU3BlY3NEZWZpbmVkXFxuICAgICAgfSk7XFxuXFxuICAgICAgcHJvY2Vzc29yLmV4ZWN1dGUoZnVuY3Rpb24oKSB7XFxuICAgICAgICByZXBvcnRlci5qYXNtaW5lRG9uZSh7XFxuICAgICAgICAgIG9yZGVyOiBvcmRlclxcbiAgICAgICAgfSk7XFxuICAgICAgfSk7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuYWRkUmVwb3J0ZXIgPSBmdW5jdGlvbihyZXBvcnRlclRvQWRkKSB7XFxuICAgICAgcmVwb3J0ZXIuYWRkUmVwb3J0ZXIocmVwb3J0ZXJUb0FkZCk7XFxuICAgIH07XFxuXFxuICAgIHZhciBzcHlSZWdpc3RyeSA9IG5ldyBqJC5TcHlSZWdpc3RyeSh7Y3VycmVudFNwaWVzOiBmdW5jdGlvbigpIHtcXG4gICAgICBpZighY3VycmVudFJ1bm5hYmxlKCkpIHtcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU3BpZXMgbXVzdCBiZSBjcmVhdGVkIGluIGEgYmVmb3JlIGZ1bmN0aW9uIG9yIGEgc3BlYycpO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gcnVubmFibGVSZXNvdXJjZXNbY3VycmVudFJ1bm5hYmxlKCkuaWRdLnNwaWVzO1xcbiAgICB9fSk7XFxuXFxuICAgIHRoaXMuc3B5T24gPSBmdW5jdGlvbigpIHtcXG4gICAgICByZXR1cm4gc3B5UmVnaXN0cnkuc3B5T24uYXBwbHkoc3B5UmVnaXN0cnksIGFyZ3VtZW50cyk7XFxuICAgIH07XFxuXFxuICAgIHZhciBzdWl0ZUZhY3RvcnkgPSBmdW5jdGlvbihkZXNjcmlwdGlvbikge1xcbiAgICAgIHZhciBzdWl0ZSA9IG5ldyBqJC5TdWl0ZSh7XFxuICAgICAgICBlbnY6IHNlbGYsXFxuICAgICAgICBpZDogZ2V0TmV4dFN1aXRlSWQoKSxcXG4gICAgICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbixcXG4gICAgICAgIHBhcmVudFN1aXRlOiBjdXJyZW50RGVjbGFyYXRpb25TdWl0ZSxcXG4gICAgICAgIGV4cGVjdGF0aW9uRmFjdG9yeTogZXhwZWN0YXRpb25GYWN0b3J5LFxcbiAgICAgICAgZXhwZWN0YXRpb25SZXN1bHRGYWN0b3J5OiBleHBlY3RhdGlvblJlc3VsdEZhY3RvcnksXFxuICAgICAgICB0aHJvd09uRXhwZWN0YXRpb25GYWlsdXJlOiB0aHJvd09uRXhwZWN0YXRpb25GYWlsdXJlXFxuICAgICAgfSk7XFxuXFxuICAgICAgcnVubmFibGVMb29rdXBUYWJsZVtzdWl0ZS5pZF0gPSBzdWl0ZTtcXG4gICAgICByZXR1cm4gc3VpdGU7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuZGVzY3JpYmUgPSBmdW5jdGlvbihkZXNjcmlwdGlvbiwgc3BlY0RlZmluaXRpb25zKSB7XFxuICAgICAgdmFyIHN1aXRlID0gc3VpdGVGYWN0b3J5KGRlc2NyaXB0aW9uKTtcXG4gICAgICBpZiAoc3BlY0RlZmluaXRpb25zLmxlbmd0aCA+IDApIHtcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGVzY3JpYmUgZG9lcyBub3QgZXhwZWN0IGEgZG9uZSBwYXJhbWV0ZXInKTtcXG4gICAgICB9XFxuICAgICAgaWYgKGN1cnJlbnREZWNsYXJhdGlvblN1aXRlLm1hcmtlZFBlbmRpbmcpIHtcXG4gICAgICAgIHN1aXRlLnBlbmQoKTtcXG4gICAgICB9XFxuICAgICAgYWRkU3BlY3NUb1N1aXRlKHN1aXRlLCBzcGVjRGVmaW5pdGlvbnMpO1xcbiAgICAgIHJldHVybiBzdWl0ZTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy54ZGVzY3JpYmUgPSBmdW5jdGlvbihkZXNjcmlwdGlvbiwgc3BlY0RlZmluaXRpb25zKSB7XFxuICAgICAgdmFyIHN1aXRlID0gc3VpdGVGYWN0b3J5KGRlc2NyaXB0aW9uKTtcXG4gICAgICBzdWl0ZS5wZW5kKCk7XFxuICAgICAgYWRkU3BlY3NUb1N1aXRlKHN1aXRlLCBzcGVjRGVmaW5pdGlvbnMpO1xcbiAgICAgIHJldHVybiBzdWl0ZTtcXG4gICAgfTtcXG5cXG4gICAgdmFyIGZvY3VzZWRSdW5uYWJsZXMgPSBbXTtcXG5cXG4gICAgdGhpcy5mZGVzY3JpYmUgPSBmdW5jdGlvbihkZXNjcmlwdGlvbiwgc3BlY0RlZmluaXRpb25zKSB7XFxuICAgICAgdmFyIHN1aXRlID0gc3VpdGVGYWN0b3J5KGRlc2NyaXB0aW9uKTtcXG4gICAgICBzdWl0ZS5pc0ZvY3VzZWQgPSB0cnVlO1xcblxcbiAgICAgIGZvY3VzZWRSdW5uYWJsZXMucHVzaChzdWl0ZS5pZCk7XFxuICAgICAgdW5mb2N1c0FuY2VzdG9yKCk7XFxuICAgICAgYWRkU3BlY3NUb1N1aXRlKHN1aXRlLCBzcGVjRGVmaW5pdGlvbnMpO1xcblxcbiAgICAgIHJldHVybiBzdWl0ZTtcXG4gICAgfTtcXG5cXG4gICAgZnVuY3Rpb24gYWRkU3BlY3NUb1N1aXRlKHN1aXRlLCBzcGVjRGVmaW5pdGlvbnMpIHtcXG4gICAgICB2YXIgcGFyZW50U3VpdGUgPSBjdXJyZW50RGVjbGFyYXRpb25TdWl0ZTtcXG4gICAgICBwYXJlbnRTdWl0ZS5hZGRDaGlsZChzdWl0ZSk7XFxuICAgICAgY3VycmVudERlY2xhcmF0aW9uU3VpdGUgPSBzdWl0ZTtcXG5cXG4gICAgICB2YXIgZGVjbGFyYXRpb25FcnJvciA9IG51bGw7XFxuICAgICAgdHJ5IHtcXG4gICAgICAgIHNwZWNEZWZpbml0aW9ucy5jYWxsKHN1aXRlKTtcXG4gICAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICBkZWNsYXJhdGlvbkVycm9yID0gZTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGRlY2xhcmF0aW9uRXJyb3IpIHtcXG4gICAgICAgIHNlbGYuaXQoJ2VuY291bnRlcmVkIGEgZGVjbGFyYXRpb24gZXhjZXB0aW9uJywgZnVuY3Rpb24oKSB7XFxuICAgICAgICAgIHRocm93IGRlY2xhcmF0aW9uRXJyb3I7XFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuXFxuICAgICAgY3VycmVudERlY2xhcmF0aW9uU3VpdGUgPSBwYXJlbnRTdWl0ZTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBmaW5kRm9jdXNlZEFuY2VzdG9yKHN1aXRlKSB7XFxuICAgICAgd2hpbGUgKHN1aXRlKSB7XFxuICAgICAgICBpZiAoc3VpdGUuaXNGb2N1c2VkKSB7XFxuICAgICAgICAgIHJldHVybiBzdWl0ZS5pZDtcXG4gICAgICAgIH1cXG4gICAgICAgIHN1aXRlID0gc3VpdGUucGFyZW50U3VpdGU7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBudWxsO1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIHVuZm9jdXNBbmNlc3RvcigpIHtcXG4gICAgICB2YXIgZm9jdXNlZEFuY2VzdG9yID0gZmluZEZvY3VzZWRBbmNlc3RvcihjdXJyZW50RGVjbGFyYXRpb25TdWl0ZSk7XFxuICAgICAgaWYgKGZvY3VzZWRBbmNlc3Rvcikge1xcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb2N1c2VkUnVubmFibGVzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgIGlmIChmb2N1c2VkUnVubmFibGVzW2ldID09PSBmb2N1c2VkQW5jZXN0b3IpIHtcXG4gICAgICAgICAgICBmb2N1c2VkUnVubmFibGVzLnNwbGljZShpLCAxKTtcXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICB2YXIgc3BlY0ZhY3RvcnkgPSBmdW5jdGlvbihkZXNjcmlwdGlvbiwgZm4sIHN1aXRlLCB0aW1lb3V0KSB7XFxuICAgICAgdG90YWxTcGVjc0RlZmluZWQrKztcXG4gICAgICB2YXIgc3BlYyA9IG5ldyBqJC5TcGVjKHtcXG4gICAgICAgIGlkOiBnZXROZXh0U3BlY0lkKCksXFxuICAgICAgICBiZWZvcmVBbmRBZnRlckZuczogYmVmb3JlQW5kQWZ0ZXJGbnMoc3VpdGUpLFxcbiAgICAgICAgZXhwZWN0YXRpb25GYWN0b3J5OiBleHBlY3RhdGlvbkZhY3RvcnksXFxuICAgICAgICByZXN1bHRDYWxsYmFjazogc3BlY1Jlc3VsdENhbGxiYWNrLFxcbiAgICAgICAgZ2V0U3BlY05hbWU6IGZ1bmN0aW9uKHNwZWMpIHtcXG4gICAgICAgICAgcmV0dXJuIGdldFNwZWNOYW1lKHNwZWMsIHN1aXRlKTtcXG4gICAgICAgIH0sXFxuICAgICAgICBvblN0YXJ0OiBzcGVjU3RhcnRlZCxcXG4gICAgICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbixcXG4gICAgICAgIGV4cGVjdGF0aW9uUmVzdWx0RmFjdG9yeTogZXhwZWN0YXRpb25SZXN1bHRGYWN0b3J5LFxcbiAgICAgICAgcXVldWVSdW5uZXJGYWN0b3J5OiBxdWV1ZVJ1bm5lckZhY3RvcnksXFxuICAgICAgICB1c2VyQ29udGV4dDogZnVuY3Rpb24oKSB7IHJldHVybiBzdWl0ZS5jbG9uZWRTaGFyZWRVc2VyQ29udGV4dCgpOyB9LFxcbiAgICAgICAgcXVldWVhYmxlRm46IHtcXG4gICAgICAgICAgZm46IGZuLFxcbiAgICAgICAgICB0aW1lb3V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRpbWVvdXQgfHwgaiQuREVGQVVMVF9USU1FT1VUX0lOVEVSVkFMOyB9XFxuICAgICAgICB9LFxcbiAgICAgICAgdGhyb3dPbkV4cGVjdGF0aW9uRmFpbHVyZTogdGhyb3dPbkV4cGVjdGF0aW9uRmFpbHVyZVxcbiAgICAgIH0pO1xcblxcbiAgICAgIHJ1bm5hYmxlTG9va3VwVGFibGVbc3BlYy5pZF0gPSBzcGVjO1xcblxcbiAgICAgIGlmICghc2VsZi5zcGVjRmlsdGVyKHNwZWMpKSB7XFxuICAgICAgICBzcGVjLmRpc2FibGUoKTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHNwZWM7XFxuXFxuICAgICAgZnVuY3Rpb24gc3BlY1Jlc3VsdENhbGxiYWNrKHJlc3VsdCkge1xcbiAgICAgICAgY2xlYXJSZXNvdXJjZXNGb3JSdW5uYWJsZShzcGVjLmlkKTtcXG4gICAgICAgIGN1cnJlbnRTcGVjID0gbnVsbDtcXG4gICAgICAgIHJlcG9ydGVyLnNwZWNEb25lKHJlc3VsdCk7XFxuICAgICAgfVxcblxcbiAgICAgIGZ1bmN0aW9uIHNwZWNTdGFydGVkKHNwZWMpIHtcXG4gICAgICAgIGN1cnJlbnRTcGVjID0gc3BlYztcXG4gICAgICAgIGRlZmF1bHRSZXNvdXJjZXNGb3JSdW5uYWJsZShzcGVjLmlkLCBzdWl0ZS5pZCk7XFxuICAgICAgICByZXBvcnRlci5zcGVjU3RhcnRlZChzcGVjLnJlc3VsdCk7XFxuICAgICAgfVxcbiAgICB9O1xcblxcbiAgICB0aGlzLml0ID0gZnVuY3Rpb24oZGVzY3JpcHRpb24sIGZuLCB0aW1lb3V0KSB7XFxuICAgICAgdmFyIHNwZWMgPSBzcGVjRmFjdG9yeShkZXNjcmlwdGlvbiwgZm4sIGN1cnJlbnREZWNsYXJhdGlvblN1aXRlLCB0aW1lb3V0KTtcXG4gICAgICBpZiAoY3VycmVudERlY2xhcmF0aW9uU3VpdGUubWFya2VkUGVuZGluZykge1xcbiAgICAgICAgc3BlYy5wZW5kKCk7XFxuICAgICAgfVxcbiAgICAgIGN1cnJlbnREZWNsYXJhdGlvblN1aXRlLmFkZENoaWxkKHNwZWMpO1xcbiAgICAgIHJldHVybiBzcGVjO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLnhpdCA9IGZ1bmN0aW9uKCkge1xcbiAgICAgIHZhciBzcGVjID0gdGhpcy5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgICAgIHNwZWMucGVuZCgnVGVtcG9yYXJpbHkgZGlzYWJsZWQgd2l0aCB4aXQnKTtcXG4gICAgICByZXR1cm4gc3BlYztcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5maXQgPSBmdW5jdGlvbihkZXNjcmlwdGlvbiwgZm4sIHRpbWVvdXQpe1xcbiAgICAgIHZhciBzcGVjID0gc3BlY0ZhY3RvcnkoZGVzY3JpcHRpb24sIGZuLCBjdXJyZW50RGVjbGFyYXRpb25TdWl0ZSwgdGltZW91dCk7XFxuICAgICAgY3VycmVudERlY2xhcmF0aW9uU3VpdGUuYWRkQ2hpbGQoc3BlYyk7XFxuICAgICAgZm9jdXNlZFJ1bm5hYmxlcy5wdXNoKHNwZWMuaWQpO1xcbiAgICAgIHVuZm9jdXNBbmNlc3RvcigpO1xcbiAgICAgIHJldHVybiBzcGVjO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLmV4cGVjdCA9IGZ1bmN0aW9uKGFjdHVhbCkge1xcbiAgICAgIGlmICghY3VycmVudFJ1bm5hYmxlKCkpIHtcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignXFxcXCdleHBlY3RcXFxcJyB3YXMgdXNlZCB3aGVuIHRoZXJlIHdhcyBubyBjdXJyZW50IHNwZWMsIHRoaXMgY291bGQgYmUgYmVjYXVzZSBhbiBhc3luY2hyb25vdXMgdGVzdCB0aW1lZCBvdXQnKTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIGN1cnJlbnRSdW5uYWJsZSgpLmV4cGVjdChhY3R1YWwpO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLmJlZm9yZUVhY2ggPSBmdW5jdGlvbihiZWZvcmVFYWNoRnVuY3Rpb24sIHRpbWVvdXQpIHtcXG4gICAgICBjdXJyZW50RGVjbGFyYXRpb25TdWl0ZS5iZWZvcmVFYWNoKHtcXG4gICAgICAgIGZuOiBiZWZvcmVFYWNoRnVuY3Rpb24sXFxuICAgICAgICB0aW1lb3V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRpbWVvdXQgfHwgaiQuREVGQVVMVF9USU1FT1VUX0lOVEVSVkFMOyB9XFxuICAgICAgfSk7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuYmVmb3JlQWxsID0gZnVuY3Rpb24oYmVmb3JlQWxsRnVuY3Rpb24sIHRpbWVvdXQpIHtcXG4gICAgICBjdXJyZW50RGVjbGFyYXRpb25TdWl0ZS5iZWZvcmVBbGwoe1xcbiAgICAgICAgZm46IGJlZm9yZUFsbEZ1bmN0aW9uLFxcbiAgICAgICAgdGltZW91dDogZnVuY3Rpb24oKSB7IHJldHVybiB0aW1lb3V0IHx8IGokLkRFRkFVTFRfVElNRU9VVF9JTlRFUlZBTDsgfVxcbiAgICAgIH0pO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLmFmdGVyRWFjaCA9IGZ1bmN0aW9uKGFmdGVyRWFjaEZ1bmN0aW9uLCB0aW1lb3V0KSB7XFxuICAgICAgY3VycmVudERlY2xhcmF0aW9uU3VpdGUuYWZ0ZXJFYWNoKHtcXG4gICAgICAgIGZuOiBhZnRlckVhY2hGdW5jdGlvbixcXG4gICAgICAgIHRpbWVvdXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGltZW91dCB8fCBqJC5ERUZBVUxUX1RJTUVPVVRfSU5URVJWQUw7IH1cXG4gICAgICB9KTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5hZnRlckFsbCA9IGZ1bmN0aW9uKGFmdGVyQWxsRnVuY3Rpb24sIHRpbWVvdXQpIHtcXG4gICAgICBjdXJyZW50RGVjbGFyYXRpb25TdWl0ZS5hZnRlckFsbCh7XFxuICAgICAgICBmbjogYWZ0ZXJBbGxGdW5jdGlvbixcXG4gICAgICAgIHRpbWVvdXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGltZW91dCB8fCBqJC5ERUZBVUxUX1RJTUVPVVRfSU5URVJWQUw7IH1cXG4gICAgICB9KTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5wZW5kaW5nID0gZnVuY3Rpb24obWVzc2FnZSkge1xcbiAgICAgIHZhciBmdWxsTWVzc2FnZSA9IGokLlNwZWMucGVuZGluZ1NwZWNFeGNlcHRpb25NZXNzYWdlO1xcbiAgICAgIGlmKG1lc3NhZ2UpIHtcXG4gICAgICAgIGZ1bGxNZXNzYWdlICs9IG1lc3NhZ2U7XFxuICAgICAgfVxcbiAgICAgIHRocm93IGZ1bGxNZXNzYWdlO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLmZhaWwgPSBmdW5jdGlvbihlcnJvcikge1xcbiAgICAgIHZhciBtZXNzYWdlID0gJ0ZhaWxlZCc7XFxuICAgICAgaWYgKGVycm9yKSB7XFxuICAgICAgICBtZXNzYWdlICs9ICc6ICc7XFxuICAgICAgICBtZXNzYWdlICs9IGVycm9yLm1lc3NhZ2UgfHwgZXJyb3I7XFxuICAgICAgfVxcblxcbiAgICAgIGN1cnJlbnRSdW5uYWJsZSgpLmFkZEV4cGVjdGF0aW9uUmVzdWx0KGZhbHNlLCB7XFxuICAgICAgICBtYXRjaGVyTmFtZTogJycsXFxuICAgICAgICBwYXNzZWQ6IGZhbHNlLFxcbiAgICAgICAgZXhwZWN0ZWQ6ICcnLFxcbiAgICAgICAgYWN0dWFsOiAnJyxcXG4gICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXFxuICAgICAgICBlcnJvcjogZXJyb3IgJiYgZXJyb3IubWVzc2FnZSA/IGVycm9yIDogbnVsbFxcbiAgICAgIH0pO1xcbiAgICB9O1xcbiAgfVxcblxcbiAgcmV0dXJuIEVudjtcXG59O1xcblxcbmdldEphc21pbmVSZXF1aXJlT2JqKCkuSnNBcGlSZXBvcnRlciA9IGZ1bmN0aW9uKCkge1xcblxcbiAgdmFyIG5vb3BUaW1lciA9IHtcXG4gICAgc3RhcnQ6IGZ1bmN0aW9uKCl7fSxcXG4gICAgZWxhcHNlZDogZnVuY3Rpb24oKXsgcmV0dXJuIDA7IH1cXG4gIH07XFxuXFxuICBmdW5jdGlvbiBKc0FwaVJlcG9ydGVyKG9wdGlvbnMpIHtcXG4gICAgdmFyIHRpbWVyID0gb3B0aW9ucy50aW1lciB8fCBub29wVGltZXIsXFxuICAgICAgICBzdGF0dXMgPSAnbG9hZGVkJztcXG5cXG4gICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XFxuICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcXG4gICAgdGhpcy5ydW5EZXRhaWxzID0ge307XFxuXFxuICAgIHRoaXMuamFzbWluZVN0YXJ0ZWQgPSBmdW5jdGlvbigpIHtcXG4gICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xcbiAgICAgIHN0YXR1cyA9ICdzdGFydGVkJztcXG4gICAgICB0aW1lci5zdGFydCgpO1xcbiAgICB9O1xcblxcbiAgICB2YXIgZXhlY3V0aW9uVGltZTtcXG5cXG4gICAgdGhpcy5qYXNtaW5lRG9uZSA9IGZ1bmN0aW9uKHJ1bkRldGFpbHMpIHtcXG4gICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcXG4gICAgICB0aGlzLnJ1bkRldGFpbHMgPSBydW5EZXRhaWxzO1xcbiAgICAgIGV4ZWN1dGlvblRpbWUgPSB0aW1lci5lbGFwc2VkKCk7XFxuICAgICAgc3RhdHVzID0gJ2RvbmUnO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLnN0YXR1cyA9IGZ1bmN0aW9uKCkge1xcbiAgICAgIHJldHVybiBzdGF0dXM7XFxuICAgIH07XFxuXFxuICAgIHZhciBzdWl0ZXMgPSBbXSxcXG4gICAgICBzdWl0ZXNfaGFzaCA9IHt9O1xcblxcbiAgICB0aGlzLnN1aXRlU3RhcnRlZCA9IGZ1bmN0aW9uKHJlc3VsdCkge1xcbiAgICAgIHN1aXRlc19oYXNoW3Jlc3VsdC5pZF0gPSByZXN1bHQ7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuc3VpdGVEb25lID0gZnVuY3Rpb24ocmVzdWx0KSB7XFxuICAgICAgc3RvcmVTdWl0ZShyZXN1bHQpO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLnN1aXRlUmVzdWx0cyA9IGZ1bmN0aW9uKGluZGV4LCBsZW5ndGgpIHtcXG4gICAgICByZXR1cm4gc3VpdGVzLnNsaWNlKGluZGV4LCBpbmRleCArIGxlbmd0aCk7XFxuICAgIH07XFxuXFxuICAgIGZ1bmN0aW9uIHN0b3JlU3VpdGUocmVzdWx0KSB7XFxuICAgICAgc3VpdGVzLnB1c2gocmVzdWx0KTtcXG4gICAgICBzdWl0ZXNfaGFzaFtyZXN1bHQuaWRdID0gcmVzdWx0O1xcbiAgICB9XFxuXFxuICAgIHRoaXMuc3VpdGVzID0gZnVuY3Rpb24oKSB7XFxuICAgICAgcmV0dXJuIHN1aXRlc19oYXNoO1xcbiAgICB9O1xcblxcbiAgICB2YXIgc3BlY3MgPSBbXTtcXG5cXG4gICAgdGhpcy5zcGVjRG9uZSA9IGZ1bmN0aW9uKHJlc3VsdCkge1xcbiAgICAgIHNwZWNzLnB1c2gocmVzdWx0KTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5zcGVjUmVzdWx0cyA9IGZ1bmN0aW9uKGluZGV4LCBsZW5ndGgpIHtcXG4gICAgICByZXR1cm4gc3BlY3Muc2xpY2UoaW5kZXgsIGluZGV4ICsgbGVuZ3RoKTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5zcGVjcyA9IGZ1bmN0aW9uKCkge1xcbiAgICAgIHJldHVybiBzcGVjcztcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5leGVjdXRpb25UaW1lID0gZnVuY3Rpb24oKSB7XFxuICAgICAgcmV0dXJuIGV4ZWN1dGlvblRpbWU7XFxuICAgIH07XFxuXFxuICB9XFxuXFxuICByZXR1cm4gSnNBcGlSZXBvcnRlcjtcXG59O1xcblxcbmdldEphc21pbmVSZXF1aXJlT2JqKCkuQ2FsbFRyYWNrZXIgPSBmdW5jdGlvbigpIHtcXG5cXG4gIGZ1bmN0aW9uIENhbGxUcmFja2VyKCkge1xcbiAgICB2YXIgY2FsbHMgPSBbXTtcXG5cXG4gICAgdGhpcy50cmFjayA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcXG4gICAgICBjYWxscy5wdXNoKGNvbnRleHQpO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLmFueSA9IGZ1bmN0aW9uKCkge1xcbiAgICAgIHJldHVybiAhIWNhbGxzLmxlbmd0aDtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5jb3VudCA9IGZ1bmN0aW9uKCkge1xcbiAgICAgIHJldHVybiBjYWxscy5sZW5ndGg7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuYXJnc0ZvciA9IGZ1bmN0aW9uKGluZGV4KSB7XFxuICAgICAgdmFyIGNhbGwgPSBjYWxsc1tpbmRleF07XFxuICAgICAgcmV0dXJuIGNhbGwgPyBjYWxsLmFyZ3MgOiBbXTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5hbGwgPSBmdW5jdGlvbigpIHtcXG4gICAgICByZXR1cm4gY2FsbHM7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuYWxsQXJncyA9IGZ1bmN0aW9uKCkge1xcbiAgICAgIHZhciBjYWxsQXJncyA9IFtdO1xcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBjYWxscy5sZW5ndGg7IGkrKyl7XFxuICAgICAgICBjYWxsQXJncy5wdXNoKGNhbGxzW2ldLmFyZ3MpO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gY2FsbEFyZ3M7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuZmlyc3QgPSBmdW5jdGlvbigpIHtcXG4gICAgICByZXR1cm4gY2FsbHNbMF07XFxuICAgIH07XFxuXFxuICAgIHRoaXMubW9zdFJlY2VudCA9IGZ1bmN0aW9uKCkge1xcbiAgICAgIHJldHVybiBjYWxsc1tjYWxscy5sZW5ndGggLSAxXTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5yZXNldCA9IGZ1bmN0aW9uKCkge1xcbiAgICAgIGNhbGxzID0gW107XFxuICAgIH07XFxuICB9XFxuXFxuICByZXR1cm4gQ2FsbFRyYWNrZXI7XFxufTtcXG5cXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLkNsb2NrID0gZnVuY3Rpb24oKSB7XFxuICBmdW5jdGlvbiBDbG9jayhnbG9iYWwsIGRlbGF5ZWRGdW5jdGlvblNjaGVkdWxlckZhY3RvcnksIG1vY2tEYXRlKSB7XFxuICAgIHZhciBzZWxmID0gdGhpcyxcXG4gICAgICByZWFsVGltaW5nRnVuY3Rpb25zID0ge1xcbiAgICAgICAgc2V0VGltZW91dDogZ2xvYmFsLnNldFRpbWVvdXQsXFxuICAgICAgICBjbGVhclRpbWVvdXQ6IGdsb2JhbC5jbGVhclRpbWVvdXQsXFxuICAgICAgICBzZXRJbnRlcnZhbDogZ2xvYmFsLnNldEludGVydmFsLFxcbiAgICAgICAgY2xlYXJJbnRlcnZhbDogZ2xvYmFsLmNsZWFySW50ZXJ2YWxcXG4gICAgICB9LFxcbiAgICAgIGZha2VUaW1pbmdGdW5jdGlvbnMgPSB7XFxuICAgICAgICBzZXRUaW1lb3V0OiBzZXRUaW1lb3V0LFxcbiAgICAgICAgY2xlYXJUaW1lb3V0OiBjbGVhclRpbWVvdXQsXFxuICAgICAgICBzZXRJbnRlcnZhbDogc2V0SW50ZXJ2YWwsXFxuICAgICAgICBjbGVhckludGVydmFsOiBjbGVhckludGVydmFsXFxuICAgICAgfSxcXG4gICAgICBpbnN0YWxsZWQgPSBmYWxzZSxcXG4gICAgICBkZWxheWVkRnVuY3Rpb25TY2hlZHVsZXIsXFxuICAgICAgdGltZXI7XFxuXFxuXFxuICAgIHNlbGYuaW5zdGFsbCA9IGZ1bmN0aW9uKCkge1xcbiAgICAgIGlmKCFvcmlnaW5hbFRpbWluZ0Z1bmN0aW9uc0ludGFjdCgpKSB7XFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0phc21pbmUgQ2xvY2sgd2FzIHVuYWJsZSB0byBpbnN0YWxsIG92ZXIgY3VzdG9tIGdsb2JhbCB0aW1lciBmdW5jdGlvbnMuIElzIHRoZSBjbG9jayBhbHJlYWR5IGluc3RhbGxlZD8nKTtcXG4gICAgICB9XFxuICAgICAgcmVwbGFjZShnbG9iYWwsIGZha2VUaW1pbmdGdW5jdGlvbnMpO1xcbiAgICAgIHRpbWVyID0gZmFrZVRpbWluZ0Z1bmN0aW9ucztcXG4gICAgICBkZWxheWVkRnVuY3Rpb25TY2hlZHVsZXIgPSBkZWxheWVkRnVuY3Rpb25TY2hlZHVsZXJGYWN0b3J5KCk7XFxuICAgICAgaW5zdGFsbGVkID0gdHJ1ZTtcXG5cXG4gICAgICByZXR1cm4gc2VsZjtcXG4gICAgfTtcXG5cXG4gICAgc2VsZi51bmluc3RhbGwgPSBmdW5jdGlvbigpIHtcXG4gICAgICBkZWxheWVkRnVuY3Rpb25TY2hlZHVsZXIgPSBudWxsO1xcbiAgICAgIG1vY2tEYXRlLnVuaW5zdGFsbCgpO1xcbiAgICAgIHJlcGxhY2UoZ2xvYmFsLCByZWFsVGltaW5nRnVuY3Rpb25zKTtcXG5cXG4gICAgICB0aW1lciA9IHJlYWxUaW1pbmdGdW5jdGlvbnM7XFxuICAgICAgaW5zdGFsbGVkID0gZmFsc2U7XFxuICAgIH07XFxuXFxuICAgIHNlbGYud2l0aE1vY2sgPSBmdW5jdGlvbihjbG9zdXJlKSB7XFxuICAgICAgdGhpcy5pbnN0YWxsKCk7XFxuICAgICAgdHJ5IHtcXG4gICAgICAgIGNsb3N1cmUoKTtcXG4gICAgICB9IGZpbmFsbHkge1xcbiAgICAgICAgdGhpcy51bmluc3RhbGwoKTtcXG4gICAgICB9XFxuICAgIH07XFxuXFxuICAgIHNlbGYubW9ja0RhdGUgPSBmdW5jdGlvbihpbml0aWFsRGF0ZSkge1xcbiAgICAgIG1vY2tEYXRlLmluc3RhbGwoaW5pdGlhbERhdGUpO1xcbiAgICB9O1xcblxcbiAgICBzZWxmLnNldFRpbWVvdXQgPSBmdW5jdGlvbihmbiwgZGVsYXksIHBhcmFtcykge1xcbiAgICAgIGlmIChsZWdhY3lJRSgpKSB7XFxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJRSA8IDkgY2Fubm90IHN1cHBvcnQgZXh0cmEgcGFyYW1zIHRvIHNldFRpbWVvdXQgd2l0aG91dCBhIHBvbHlmaWxsJyk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gdGltZXIuc2V0VGltZW91dChmbiwgZGVsYXkpO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmFwcGx5KHRpbWVyLnNldFRpbWVvdXQsIFtnbG9iYWwsIGFyZ3VtZW50c10pO1xcbiAgICB9O1xcblxcbiAgICBzZWxmLnNldEludGVydmFsID0gZnVuY3Rpb24oZm4sIGRlbGF5LCBwYXJhbXMpIHtcXG4gICAgICBpZiAobGVnYWN5SUUoKSkge1xcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XFxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSUUgPCA5IGNhbm5vdCBzdXBwb3J0IGV4dHJhIHBhcmFtcyB0byBzZXRJbnRlcnZhbCB3aXRob3V0IGEgcG9seWZpbGwnKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiB0aW1lci5zZXRJbnRlcnZhbChmbiwgZGVsYXkpO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmFwcGx5KHRpbWVyLnNldEludGVydmFsLCBbZ2xvYmFsLCBhcmd1bWVudHNdKTtcXG4gICAgfTtcXG5cXG4gICAgc2VsZi5jbGVhclRpbWVvdXQgPSBmdW5jdGlvbihpZCkge1xcbiAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbC5hcHBseSh0aW1lci5jbGVhclRpbWVvdXQsIFtnbG9iYWwsIGlkXSk7XFxuICAgIH07XFxuXFxuICAgIHNlbGYuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKGlkKSB7XFxuICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsLmFwcGx5KHRpbWVyLmNsZWFySW50ZXJ2YWwsIFtnbG9iYWwsIGlkXSk7XFxuICAgIH07XFxuXFxuICAgIHNlbGYudGljayA9IGZ1bmN0aW9uKG1pbGxpcykge1xcbiAgICAgIGlmIChpbnN0YWxsZWQpIHtcXG4gICAgICAgIG1vY2tEYXRlLnRpY2sobWlsbGlzKTtcXG4gICAgICAgIGRlbGF5ZWRGdW5jdGlvblNjaGVkdWxlci50aWNrKG1pbGxpcyk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTW9jayBjbG9jayBpcyBub3QgaW5zdGFsbGVkLCB1c2UgamFzbWluZS5jbG9jaygpLmluc3RhbGwoKScpO1xcbiAgICAgIH1cXG4gICAgfTtcXG5cXG4gICAgcmV0dXJuIHNlbGY7XFxuXFxuICAgIGZ1bmN0aW9uIG9yaWdpbmFsVGltaW5nRnVuY3Rpb25zSW50YWN0KCkge1xcbiAgICAgIHJldHVybiBnbG9iYWwuc2V0VGltZW91dCA9PT0gcmVhbFRpbWluZ0Z1bmN0aW9ucy5zZXRUaW1lb3V0ICYmXFxuICAgICAgICBnbG9iYWwuY2xlYXJUaW1lb3V0ID09PSByZWFsVGltaW5nRnVuY3Rpb25zLmNsZWFyVGltZW91dCAmJlxcbiAgICAgICAgZ2xvYmFsLnNldEludGVydmFsID09PSByZWFsVGltaW5nRnVuY3Rpb25zLnNldEludGVydmFsICYmXFxuICAgICAgICBnbG9iYWwuY2xlYXJJbnRlcnZhbCA9PT0gcmVhbFRpbWluZ0Z1bmN0aW9ucy5jbGVhckludGVydmFsO1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIGxlZ2FjeUlFKCkge1xcbiAgICAgIC8vaWYgdGhlc2UgbWV0aG9kcyBhcmUgcG9seWZpbGxlZCwgYXBwbHkgd2lsbCBiZSBwcmVzZW50XFxuICAgICAgcmV0dXJuICEocmVhbFRpbWluZ0Z1bmN0aW9ucy5zZXRUaW1lb3V0IHx8IHJlYWxUaW1pbmdGdW5jdGlvbnMuc2V0SW50ZXJ2YWwpLmFwcGx5O1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIHJlcGxhY2UoZGVzdCwgc291cmNlKSB7XFxuICAgICAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpIHtcXG4gICAgICAgIGRlc3RbcHJvcF0gPSBzb3VyY2VbcHJvcF07XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIHNldFRpbWVvdXQoZm4sIGRlbGF5KSB7XFxuICAgICAgcmV0dXJuIGRlbGF5ZWRGdW5jdGlvblNjaGVkdWxlci5zY2hlZHVsZUZ1bmN0aW9uKGZuLCBkZWxheSwgYXJnU2xpY2UoYXJndW1lbnRzLCAyKSk7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gY2xlYXJUaW1lb3V0KGlkKSB7XFxuICAgICAgcmV0dXJuIGRlbGF5ZWRGdW5jdGlvblNjaGVkdWxlci5yZW1vdmVGdW5jdGlvbldpdGhJZChpZCk7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gc2V0SW50ZXJ2YWwoZm4sIGludGVydmFsKSB7XFxuICAgICAgcmV0dXJuIGRlbGF5ZWRGdW5jdGlvblNjaGVkdWxlci5zY2hlZHVsZUZ1bmN0aW9uKGZuLCBpbnRlcnZhbCwgYXJnU2xpY2UoYXJndW1lbnRzLCAyKSwgdHJ1ZSk7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gY2xlYXJJbnRlcnZhbChpZCkge1xcbiAgICAgIHJldHVybiBkZWxheWVkRnVuY3Rpb25TY2hlZHVsZXIucmVtb3ZlRnVuY3Rpb25XaXRoSWQoaWQpO1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIGFyZ1NsaWNlKGFyZ3NPYmosIG4pIHtcXG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJnc09iaiwgbik7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiBDbG9jaztcXG59O1xcblxcbmdldEphc21pbmVSZXF1aXJlT2JqKCkuRGVsYXllZEZ1bmN0aW9uU2NoZWR1bGVyID0gZnVuY3Rpb24oKSB7XFxuICBmdW5jdGlvbiBEZWxheWVkRnVuY3Rpb25TY2hlZHVsZXIoKSB7XFxuICAgIHZhciBzZWxmID0gdGhpcztcXG4gICAgdmFyIHNjaGVkdWxlZExvb2t1cCA9IFtdO1xcbiAgICB2YXIgc2NoZWR1bGVkRnVuY3Rpb25zID0ge307XFxuICAgIHZhciBjdXJyZW50VGltZSA9IDA7XFxuICAgIHZhciBkZWxheWVkRm5Db3VudCA9IDA7XFxuXFxuICAgIHNlbGYudGljayA9IGZ1bmN0aW9uKG1pbGxpcykge1xcbiAgICAgIG1pbGxpcyA9IG1pbGxpcyB8fCAwO1xcbiAgICAgIHZhciBlbmRUaW1lID0gY3VycmVudFRpbWUgKyBtaWxsaXM7XFxuXFxuICAgICAgcnVuU2NoZWR1bGVkRnVuY3Rpb25zKGVuZFRpbWUpO1xcbiAgICAgIGN1cnJlbnRUaW1lID0gZW5kVGltZTtcXG4gICAgfTtcXG5cXG4gICAgc2VsZi5zY2hlZHVsZUZ1bmN0aW9uID0gZnVuY3Rpb24oZnVuY1RvQ2FsbCwgbWlsbGlzLCBwYXJhbXMsIHJlY3VycmluZywgdGltZW91dEtleSwgcnVuQXRNaWxsaXMpIHtcXG4gICAgICB2YXIgZjtcXG4gICAgICBpZiAodHlwZW9mKGZ1bmNUb0NhbGwpID09PSAnc3RyaW5nJykge1xcbiAgICAgICAgLyoganNoaW50IGV2aWw6IHRydWUgKi9cXG4gICAgICAgIGYgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGV2YWwoZnVuY1RvQ2FsbCk7IH07XFxuICAgICAgICAvKiBqc2hpbnQgZXZpbDogZmFsc2UgKi9cXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgZiA9IGZ1bmNUb0NhbGw7XFxuICAgICAgfVxcblxcbiAgICAgIG1pbGxpcyA9IG1pbGxpcyB8fCAwO1xcbiAgICAgIHRpbWVvdXRLZXkgPSB0aW1lb3V0S2V5IHx8ICsrZGVsYXllZEZuQ291bnQ7XFxuICAgICAgcnVuQXRNaWxsaXMgPSBydW5BdE1pbGxpcyB8fCAoY3VycmVudFRpbWUgKyBtaWxsaXMpO1xcblxcbiAgICAgIHZhciBmdW5jVG9TY2hlZHVsZSA9IHtcXG4gICAgICAgIHJ1bkF0TWlsbGlzOiBydW5BdE1pbGxpcyxcXG4gICAgICAgIGZ1bmNUb0NhbGw6IGYsXFxuICAgICAgICByZWN1cnJpbmc6IHJlY3VycmluZyxcXG4gICAgICAgIHBhcmFtczogcGFyYW1zLFxcbiAgICAgICAgdGltZW91dEtleTogdGltZW91dEtleSxcXG4gICAgICAgIG1pbGxpczogbWlsbGlzXFxuICAgICAgfTtcXG5cXG4gICAgICBpZiAocnVuQXRNaWxsaXMgaW4gc2NoZWR1bGVkRnVuY3Rpb25zKSB7XFxuICAgICAgICBzY2hlZHVsZWRGdW5jdGlvbnNbcnVuQXRNaWxsaXNdLnB1c2goZnVuY1RvU2NoZWR1bGUpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBzY2hlZHVsZWRGdW5jdGlvbnNbcnVuQXRNaWxsaXNdID0gW2Z1bmNUb1NjaGVkdWxlXTtcXG4gICAgICAgIHNjaGVkdWxlZExvb2t1cC5wdXNoKHJ1bkF0TWlsbGlzKTtcXG4gICAgICAgIHNjaGVkdWxlZExvb2t1cC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgICAgICAgIHJldHVybiBhIC0gYjtcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gdGltZW91dEtleTtcXG4gICAgfTtcXG5cXG4gICAgc2VsZi5yZW1vdmVGdW5jdGlvbldpdGhJZCA9IGZ1bmN0aW9uKHRpbWVvdXRLZXkpIHtcXG4gICAgICBmb3IgKHZhciBydW5BdE1pbGxpcyBpbiBzY2hlZHVsZWRGdW5jdGlvbnMpIHtcXG4gICAgICAgIHZhciBmdW5jcyA9IHNjaGVkdWxlZEZ1bmN0aW9uc1tydW5BdE1pbGxpc107XFxuICAgICAgICB2YXIgaSA9IGluZGV4T2ZGaXJzdFRvUGFzcyhmdW5jcywgZnVuY3Rpb24gKGZ1bmMpIHtcXG4gICAgICAgICAgcmV0dXJuIGZ1bmMudGltZW91dEtleSA9PT0gdGltZW91dEtleTtcXG4gICAgICAgIH0pO1xcblxcbiAgICAgICAgaWYgKGkgPiAtMSkge1xcbiAgICAgICAgICBpZiAoZnVuY3MubGVuZ3RoID09PSAxKSB7XFxuICAgICAgICAgICAgZGVsZXRlIHNjaGVkdWxlZEZ1bmN0aW9uc1tydW5BdE1pbGxpc107XFxuICAgICAgICAgICAgZGVsZXRlRnJvbUxvb2t1cChydW5BdE1pbGxpcyk7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgZnVuY3Muc3BsaWNlKGksIDEpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIC8vIGludGVydmFscyBnZXQgcmVzY2hlZHVsZWQgd2hlbiBleGVjdXRlZCwgc28gdGhlcmUncyBuZXZlciBtb3JlXFxuICAgICAgICAgIC8vIHRoYW4gYSBzaW5nbGUgc2NoZWR1bGVkIGZ1bmN0aW9uIHdpdGggYSBnaXZlbiB0aW1lb3V0S2V5XFxuICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfTtcXG5cXG4gICAgcmV0dXJuIHNlbGY7XFxuXFxuICAgIGZ1bmN0aW9uIGluZGV4T2ZGaXJzdFRvUGFzcyhhcnJheSwgdGVzdEZuKSB7XFxuICAgICAgdmFyIGluZGV4ID0gLTE7XFxuXFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7ICsraSkge1xcbiAgICAgICAgaWYgKHRlc3RGbihhcnJheVtpXSkpIHtcXG4gICAgICAgICAgaW5kZXggPSBpO1xcbiAgICAgICAgICBicmVhaztcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIGluZGV4O1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIGRlbGV0ZUZyb21Mb29rdXAoa2V5KSB7XFxuICAgICAgdmFyIHZhbHVlID0gTnVtYmVyKGtleSk7XFxuICAgICAgdmFyIGkgPSBpbmRleE9mRmlyc3RUb1Bhc3Moc2NoZWR1bGVkTG9va3VwLCBmdW5jdGlvbiAobWlsbGlzKSB7XFxuICAgICAgICByZXR1cm4gbWlsbGlzID09PSB2YWx1ZTtcXG4gICAgICB9KTtcXG5cXG4gICAgICBpZiAoaSA+IC0xKSB7XFxuICAgICAgICBzY2hlZHVsZWRMb29rdXAuc3BsaWNlKGksIDEpO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiByZXNjaGVkdWxlKHNjaGVkdWxlZEZuKSB7XFxuICAgICAgc2VsZi5zY2hlZHVsZUZ1bmN0aW9uKHNjaGVkdWxlZEZuLmZ1bmNUb0NhbGwsXFxuICAgICAgICBzY2hlZHVsZWRGbi5taWxsaXMsXFxuICAgICAgICBzY2hlZHVsZWRGbi5wYXJhbXMsXFxuICAgICAgICB0cnVlLFxcbiAgICAgICAgc2NoZWR1bGVkRm4udGltZW91dEtleSxcXG4gICAgICAgIHNjaGVkdWxlZEZuLnJ1bkF0TWlsbGlzICsgc2NoZWR1bGVkRm4ubWlsbGlzKTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBmb3JFYWNoRnVuY3Rpb24oZnVuY3NUb1J1biwgY2FsbGJhY2spIHtcXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZ1bmNzVG9SdW4ubGVuZ3RoOyArK2kpIHtcXG4gICAgICAgIGNhbGxiYWNrKGZ1bmNzVG9SdW5baV0pO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBydW5TY2hlZHVsZWRGdW5jdGlvbnMoZW5kVGltZSkge1xcbiAgICAgIGlmIChzY2hlZHVsZWRMb29rdXAubGVuZ3RoID09PSAwIHx8IHNjaGVkdWxlZExvb2t1cFswXSA+IGVuZFRpbWUpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgZG8ge1xcbiAgICAgICAgY3VycmVudFRpbWUgPSBzY2hlZHVsZWRMb29rdXAuc2hpZnQoKTtcXG5cXG4gICAgICAgIHZhciBmdW5jc1RvUnVuID0gc2NoZWR1bGVkRnVuY3Rpb25zW2N1cnJlbnRUaW1lXTtcXG4gICAgICAgIGRlbGV0ZSBzY2hlZHVsZWRGdW5jdGlvbnNbY3VycmVudFRpbWVdO1xcblxcbiAgICAgICAgZm9yRWFjaEZ1bmN0aW9uKGZ1bmNzVG9SdW4sIGZ1bmN0aW9uKGZ1bmNUb1J1bikge1xcbiAgICAgICAgICBpZiAoZnVuY1RvUnVuLnJlY3VycmluZykge1xcbiAgICAgICAgICAgIHJlc2NoZWR1bGUoZnVuY1RvUnVuKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuXFxuICAgICAgICBmb3JFYWNoRnVuY3Rpb24oZnVuY3NUb1J1biwgZnVuY3Rpb24oZnVuY1RvUnVuKSB7XFxuICAgICAgICAgIGZ1bmNUb1J1bi5mdW5jVG9DYWxsLmFwcGx5KG51bGwsIGZ1bmNUb1J1bi5wYXJhbXMgfHwgW10pO1xcbiAgICAgICAgfSk7XFxuICAgICAgfSB3aGlsZSAoc2NoZWR1bGVkTG9va3VwLmxlbmd0aCA+IDAgJiZcXG4gICAgICAgICAgICAgIC8vIGNoZWNraW5nIGZpcnN0IGlmIHdlJ3JlIG91dCBvZiB0aW1lIHByZXZlbnRzIHNldFRpbWVvdXQoMClcXG4gICAgICAgICAgICAgIC8vIHNjaGVkdWxlZCBpbiBhIGZ1bmNUb1J1biBmcm9tIGZvcmNpbmcgYW4gZXh0cmEgaXRlcmF0aW9uXFxuICAgICAgICAgICAgICAgICBjdXJyZW50VGltZSAhPT0gZW5kVGltZSAgJiZcXG4gICAgICAgICAgICAgICAgIHNjaGVkdWxlZExvb2t1cFswXSA8PSBlbmRUaW1lKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgcmV0dXJuIERlbGF5ZWRGdW5jdGlvblNjaGVkdWxlcjtcXG59O1xcblxcbmdldEphc21pbmVSZXF1aXJlT2JqKCkuRXhjZXB0aW9uRm9ybWF0dGVyID0gZnVuY3Rpb24oKSB7XFxuICBmdW5jdGlvbiBFeGNlcHRpb25Gb3JtYXR0ZXIoKSB7XFxuICAgIHRoaXMubWVzc2FnZSA9IGZ1bmN0aW9uKGVycm9yKSB7XFxuICAgICAgdmFyIG1lc3NhZ2UgPSAnJztcXG5cXG4gICAgICBpZiAoZXJyb3IubmFtZSAmJiBlcnJvci5tZXNzYWdlKSB7XFxuICAgICAgICBtZXNzYWdlICs9IGVycm9yLm5hbWUgKyAnOiAnICsgZXJyb3IubWVzc2FnZTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgbWVzc2FnZSArPSBlcnJvci50b1N0cmluZygpICsgJyB0aHJvd24nO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoZXJyb3IuZmlsZU5hbWUgfHwgZXJyb3Iuc291cmNlVVJMKSB7XFxuICAgICAgICBtZXNzYWdlICs9ICcgaW4gJyArIChlcnJvci5maWxlTmFtZSB8fCBlcnJvci5zb3VyY2VVUkwpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoZXJyb3IubGluZSB8fCBlcnJvci5saW5lTnVtYmVyKSB7XFxuICAgICAgICBtZXNzYWdlICs9ICcgKGxpbmUgJyArIChlcnJvci5saW5lIHx8IGVycm9yLmxpbmVOdW1iZXIpICsgJyknO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gbWVzc2FnZTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5zdGFjayA9IGZ1bmN0aW9uKGVycm9yKSB7XFxuICAgICAgcmV0dXJuIGVycm9yID8gZXJyb3Iuc3RhY2sgOiBudWxsO1xcbiAgICB9O1xcbiAgfVxcblxcbiAgcmV0dXJuIEV4Y2VwdGlvbkZvcm1hdHRlcjtcXG59O1xcblxcbmdldEphc21pbmVSZXF1aXJlT2JqKCkuRXhwZWN0YXRpb24gPSBmdW5jdGlvbigpIHtcXG5cXG4gIGZ1bmN0aW9uIEV4cGVjdGF0aW9uKG9wdGlvbnMpIHtcXG4gICAgdGhpcy51dGlsID0gb3B0aW9ucy51dGlsIHx8IHsgYnVpbGRGYWlsdXJlTWVzc2FnZTogZnVuY3Rpb24oKSB7fSB9O1xcbiAgICB0aGlzLmN1c3RvbUVxdWFsaXR5VGVzdGVycyA9IG9wdGlvbnMuY3VzdG9tRXF1YWxpdHlUZXN0ZXJzIHx8IFtdO1xcbiAgICB0aGlzLmFjdHVhbCA9IG9wdGlvbnMuYWN0dWFsO1xcbiAgICB0aGlzLmFkZEV4cGVjdGF0aW9uUmVzdWx0ID0gb3B0aW9ucy5hZGRFeHBlY3RhdGlvblJlc3VsdCB8fCBmdW5jdGlvbigpe307XFxuICAgIHRoaXMuaXNOb3QgPSBvcHRpb25zLmlzTm90O1xcblxcbiAgICB2YXIgY3VzdG9tTWF0Y2hlcnMgPSBvcHRpb25zLmN1c3RvbU1hdGNoZXJzIHx8IHt9O1xcbiAgICBmb3IgKHZhciBtYXRjaGVyTmFtZSBpbiBjdXN0b21NYXRjaGVycykge1xcbiAgICAgIHRoaXNbbWF0Y2hlck5hbWVdID0gRXhwZWN0YXRpb24ucHJvdG90eXBlLndyYXBDb21wYXJlKG1hdGNoZXJOYW1lLCBjdXN0b21NYXRjaGVyc1ttYXRjaGVyTmFtZV0pO1xcbiAgICB9XFxuICB9XFxuXFxuICBFeHBlY3RhdGlvbi5wcm90b3R5cGUud3JhcENvbXBhcmUgPSBmdW5jdGlvbihuYW1lLCBtYXRjaGVyRmFjdG9yeSkge1xcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XFxuICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApLFxcbiAgICAgICAgZXhwZWN0ZWQgPSBhcmdzLnNsaWNlKDApLFxcbiAgICAgICAgbWVzc2FnZSA9ICcnO1xcblxcbiAgICAgIGFyZ3MudW5zaGlmdCh0aGlzLmFjdHVhbCk7XFxuXFxuICAgICAgdmFyIG1hdGNoZXIgPSBtYXRjaGVyRmFjdG9yeSh0aGlzLnV0aWwsIHRoaXMuY3VzdG9tRXF1YWxpdHlUZXN0ZXJzKSxcXG4gICAgICAgICAgbWF0Y2hlckNvbXBhcmUgPSBtYXRjaGVyLmNvbXBhcmU7XFxuXFxuICAgICAgZnVuY3Rpb24gZGVmYXVsdE5lZ2F0aXZlQ29tcGFyZSgpIHtcXG4gICAgICAgIHZhciByZXN1bHQgPSBtYXRjaGVyLmNvbXBhcmUuYXBwbHkobnVsbCwgYXJncyk7XFxuICAgICAgICByZXN1bHQucGFzcyA9ICFyZXN1bHQucGFzcztcXG4gICAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLmlzTm90KSB7XFxuICAgICAgICBtYXRjaGVyQ29tcGFyZSA9IG1hdGNoZXIubmVnYXRpdmVDb21wYXJlIHx8IGRlZmF1bHROZWdhdGl2ZUNvbXBhcmU7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciByZXN1bHQgPSBtYXRjaGVyQ29tcGFyZS5hcHBseShudWxsLCBhcmdzKTtcXG5cXG4gICAgICBpZiAoIXJlc3VsdC5wYXNzKSB7XFxuICAgICAgICBpZiAoIXJlc3VsdC5tZXNzYWdlKSB7XFxuICAgICAgICAgIGFyZ3MudW5zaGlmdCh0aGlzLmlzTm90KTtcXG4gICAgICAgICAgYXJncy51bnNoaWZ0KG5hbWUpO1xcbiAgICAgICAgICBtZXNzYWdlID0gdGhpcy51dGlsLmJ1aWxkRmFpbHVyZU1lc3NhZ2UuYXBwbHkobnVsbCwgYXJncyk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5hcHBseShyZXN1bHQubWVzc2FnZSkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXScpIHtcXG4gICAgICAgICAgICBtZXNzYWdlID0gcmVzdWx0Lm1lc3NhZ2UoKTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBtZXNzYWdlID0gcmVzdWx0Lm1lc3NhZ2U7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGV4cGVjdGVkLmxlbmd0aCA9PSAxKSB7XFxuICAgICAgICBleHBlY3RlZCA9IGV4cGVjdGVkWzBdO1xcbiAgICAgIH1cXG5cXG4gICAgICAvLyBUT0RPOiBob3cgbWFueSBvZiB0aGVzZSBwYXJhbXMgYXJlIG5lZWRlZD9cXG4gICAgICB0aGlzLmFkZEV4cGVjdGF0aW9uUmVzdWx0KFxcbiAgICAgICAgcmVzdWx0LnBhc3MsXFxuICAgICAgICB7XFxuICAgICAgICAgIG1hdGNoZXJOYW1lOiBuYW1lLFxcbiAgICAgICAgICBwYXNzZWQ6IHJlc3VsdC5wYXNzLFxcbiAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxcbiAgICAgICAgICBhY3R1YWw6IHRoaXMuYWN0dWFsLFxcbiAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWQgLy8gVE9ETzogdGhpcyBtYXkgbmVlZCB0byBiZSBhcnJheWlmaWVkL3NsaWNlZFxcbiAgICAgICAgfVxcbiAgICAgICk7XFxuICAgIH07XFxuICB9O1xcblxcbiAgRXhwZWN0YXRpb24uYWRkQ29yZU1hdGNoZXJzID0gZnVuY3Rpb24obWF0Y2hlcnMpIHtcXG4gICAgdmFyIHByb3RvdHlwZSA9IEV4cGVjdGF0aW9uLnByb3RvdHlwZTtcXG4gICAgZm9yICh2YXIgbWF0Y2hlck5hbWUgaW4gbWF0Y2hlcnMpIHtcXG4gICAgICB2YXIgbWF0Y2hlciA9IG1hdGNoZXJzW21hdGNoZXJOYW1lXTtcXG4gICAgICBwcm90b3R5cGVbbWF0Y2hlck5hbWVdID0gcHJvdG90eXBlLndyYXBDb21wYXJlKG1hdGNoZXJOYW1lLCBtYXRjaGVyKTtcXG4gICAgfVxcbiAgfTtcXG5cXG4gIEV4cGVjdGF0aW9uLkZhY3RvcnkgPSBmdW5jdGlvbihvcHRpb25zKSB7XFxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xcblxcbiAgICB2YXIgZXhwZWN0ID0gbmV3IEV4cGVjdGF0aW9uKG9wdGlvbnMpO1xcblxcbiAgICAvLyBUT0RPOiB0aGlzIHdvdWxkIGJlIG5pY2UgYXMgaXRzIG93biBPYmplY3QgLSBOZWdhdGl2ZUV4cGVjdGF0aW9uXFxuICAgIC8vIFRPRE86IGNvcHkgaW5zdGVhZCBvZiBtdXRhdGUgb3B0aW9uc1xcbiAgICBvcHRpb25zLmlzTm90ID0gdHJ1ZTtcXG4gICAgZXhwZWN0Lm5vdCA9IG5ldyBFeHBlY3RhdGlvbihvcHRpb25zKTtcXG5cXG4gICAgcmV0dXJuIGV4cGVjdDtcXG4gIH07XFxuXFxuICByZXR1cm4gRXhwZWN0YXRpb247XFxufTtcXG5cXG4vL1RPRE86IGV4cGVjdGF0aW9uIHJlc3VsdCBtYXkgbWFrZSBtb3JlIHNlbnNlIGFzIGEgcHJlc2VudGF0aW9uIG9mIGFuIGV4cGVjdGF0aW9uLlxcbmdldEphc21pbmVSZXF1aXJlT2JqKCkuYnVpbGRFeHBlY3RhdGlvblJlc3VsdCA9IGZ1bmN0aW9uKCkge1xcbiAgZnVuY3Rpb24gYnVpbGRFeHBlY3RhdGlvblJlc3VsdChvcHRpb25zKSB7XFxuICAgIHZhciBtZXNzYWdlRm9ybWF0dGVyID0gb3B0aW9ucy5tZXNzYWdlRm9ybWF0dGVyIHx8IGZ1bmN0aW9uKCkge30sXFxuICAgICAgc3RhY2tGb3JtYXR0ZXIgPSBvcHRpb25zLnN0YWNrRm9ybWF0dGVyIHx8IGZ1bmN0aW9uKCkge307XFxuXFxuICAgIHZhciByZXN1bHQgPSB7XFxuICAgICAgbWF0Y2hlck5hbWU6IG9wdGlvbnMubWF0Y2hlck5hbWUsXFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSgpLFxcbiAgICAgIHN0YWNrOiBzdGFjaygpLFxcbiAgICAgIHBhc3NlZDogb3B0aW9ucy5wYXNzZWRcXG4gICAgfTtcXG5cXG4gICAgaWYoIXJlc3VsdC5wYXNzZWQpIHtcXG4gICAgICByZXN1bHQuZXhwZWN0ZWQgPSBvcHRpb25zLmV4cGVjdGVkO1xcbiAgICAgIHJlc3VsdC5hY3R1YWwgPSBvcHRpb25zLmFjdHVhbDtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gcmVzdWx0O1xcblxcbiAgICBmdW5jdGlvbiBtZXNzYWdlKCkge1xcbiAgICAgIGlmIChvcHRpb25zLnBhc3NlZCkge1xcbiAgICAgICAgcmV0dXJuICdQYXNzZWQuJztcXG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMubWVzc2FnZSkge1xcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMubWVzc2FnZTtcXG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuZXJyb3IpIHtcXG4gICAgICAgIHJldHVybiBtZXNzYWdlRm9ybWF0dGVyKG9wdGlvbnMuZXJyb3IpO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gJyc7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gc3RhY2soKSB7XFxuICAgICAgaWYgKG9wdGlvbnMucGFzc2VkKSB7XFxuICAgICAgICByZXR1cm4gJyc7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBlcnJvciA9IG9wdGlvbnMuZXJyb3I7XFxuICAgICAgaWYgKCFlcnJvcikge1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UoKSk7XFxuICAgICAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICAgIGVycm9yID0gZTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHN0YWNrRm9ybWF0dGVyKGVycm9yKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgcmV0dXJuIGJ1aWxkRXhwZWN0YXRpb25SZXN1bHQ7XFxufTtcXG5cXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLk1vY2tEYXRlID0gZnVuY3Rpb24oKSB7XFxuICBmdW5jdGlvbiBNb2NrRGF0ZShnbG9iYWwpIHtcXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgICB2YXIgY3VycmVudFRpbWUgPSAwO1xcblxcbiAgICBpZiAoIWdsb2JhbCB8fCAhZ2xvYmFsLkRhdGUpIHtcXG4gICAgICBzZWxmLmluc3RhbGwgPSBmdW5jdGlvbigpIHt9O1xcbiAgICAgIHNlbGYudGljayA9IGZ1bmN0aW9uKCkge307XFxuICAgICAgc2VsZi51bmluc3RhbGwgPSBmdW5jdGlvbigpIHt9O1xcbiAgICAgIHJldHVybiBzZWxmO1xcbiAgICB9XFxuXFxuICAgIHZhciBHbG9iYWxEYXRlID0gZ2xvYmFsLkRhdGU7XFxuXFxuICAgIHNlbGYuaW5zdGFsbCA9IGZ1bmN0aW9uKG1vY2tEYXRlKSB7XFxuICAgICAgaWYgKG1vY2tEYXRlIGluc3RhbmNlb2YgR2xvYmFsRGF0ZSkge1xcbiAgICAgICAgY3VycmVudFRpbWUgPSBtb2NrRGF0ZS5nZXRUaW1lKCk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGN1cnJlbnRUaW1lID0gbmV3IEdsb2JhbERhdGUoKS5nZXRUaW1lKCk7XFxuICAgICAgfVxcblxcbiAgICAgIGdsb2JhbC5EYXRlID0gRmFrZURhdGU7XFxuICAgIH07XFxuXFxuICAgIHNlbGYudGljayA9IGZ1bmN0aW9uKG1pbGxpcykge1xcbiAgICAgIG1pbGxpcyA9IG1pbGxpcyB8fCAwO1xcbiAgICAgIGN1cnJlbnRUaW1lID0gY3VycmVudFRpbWUgKyBtaWxsaXM7XFxuICAgIH07XFxuXFxuICAgIHNlbGYudW5pbnN0YWxsID0gZnVuY3Rpb24oKSB7XFxuICAgICAgY3VycmVudFRpbWUgPSAwO1xcbiAgICAgIGdsb2JhbC5EYXRlID0gR2xvYmFsRGF0ZTtcXG4gICAgfTtcXG5cXG4gICAgY3JlYXRlRGF0ZVByb3BlcnRpZXMoKTtcXG5cXG4gICAgcmV0dXJuIHNlbGY7XFxuXFxuICAgIGZ1bmN0aW9uIEZha2VEYXRlKCkge1xcbiAgICAgIHN3aXRjaChhcmd1bWVudHMubGVuZ3RoKSB7XFxuICAgICAgICBjYXNlIDA6XFxuICAgICAgICAgIHJldHVybiBuZXcgR2xvYmFsRGF0ZShjdXJyZW50VGltZSk7XFxuICAgICAgICBjYXNlIDE6XFxuICAgICAgICAgIHJldHVybiBuZXcgR2xvYmFsRGF0ZShhcmd1bWVudHNbMF0pO1xcbiAgICAgICAgY2FzZSAyOlxcbiAgICAgICAgICByZXR1cm4gbmV3IEdsb2JhbERhdGUoYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0pO1xcbiAgICAgICAgY2FzZSAzOlxcbiAgICAgICAgICByZXR1cm4gbmV3IEdsb2JhbERhdGUoYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XFxuICAgICAgICBjYXNlIDQ6XFxuICAgICAgICAgIHJldHVybiBuZXcgR2xvYmFsRGF0ZShhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdLCBhcmd1bWVudHNbM10pO1xcbiAgICAgICAgY2FzZSA1OlxcbiAgICAgICAgICByZXR1cm4gbmV3IEdsb2JhbERhdGUoYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSwgYXJndW1lbnRzWzNdLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzWzRdKTtcXG4gICAgICAgIGNhc2UgNjpcXG4gICAgICAgICAgcmV0dXJuIG5ldyBHbG9iYWxEYXRlKGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0sIGFyZ3VtZW50c1szXSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50c1s0XSwgYXJndW1lbnRzWzVdKTtcXG4gICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgIHJldHVybiBuZXcgR2xvYmFsRGF0ZShhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdLCBhcmd1bWVudHNbM10sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHNbNF0sIGFyZ3VtZW50c1s1XSwgYXJndW1lbnRzWzZdKTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gY3JlYXRlRGF0ZVByb3BlcnRpZXMoKSB7XFxuICAgICAgRmFrZURhdGUucHJvdG90eXBlID0gR2xvYmFsRGF0ZS5wcm90b3R5cGU7XFxuXFxuICAgICAgRmFrZURhdGUubm93ID0gZnVuY3Rpb24oKSB7XFxuICAgICAgICBpZiAoR2xvYmFsRGF0ZS5ub3cpIHtcXG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnRUaW1lO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCcm93c2VyIGRvZXMgbm90IHN1cHBvcnQgRGF0ZS5ub3coKScpO1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuXFxuICAgICAgRmFrZURhdGUudG9Tb3VyY2UgPSBHbG9iYWxEYXRlLnRvU291cmNlO1xcbiAgICAgIEZha2VEYXRlLnRvU3RyaW5nID0gR2xvYmFsRGF0ZS50b1N0cmluZztcXG4gICAgICBGYWtlRGF0ZS5wYXJzZSA9IEdsb2JhbERhdGUucGFyc2U7XFxuICAgICAgRmFrZURhdGUuVVRDID0gR2xvYmFsRGF0ZS5VVEM7XFxuICAgIH1cXG5cXHR9XFxuXFxuICByZXR1cm4gTW9ja0RhdGU7XFxufTtcXG5cXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnBwID0gZnVuY3Rpb24oaiQpIHtcXG5cXG4gIGZ1bmN0aW9uIFByZXR0eVByaW50ZXIoKSB7XFxuICAgIHRoaXMucHBOZXN0TGV2ZWxfID0gMDtcXG4gICAgdGhpcy5zZWVuID0gW107XFxuICB9XFxuXFxuICBQcmV0dHlQcmludGVyLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbih2YWx1ZSkge1xcbiAgICB0aGlzLnBwTmVzdExldmVsXysrO1xcbiAgICB0cnkge1xcbiAgICAgIGlmIChqJC51dGlsLmlzVW5kZWZpbmVkKHZhbHVlKSkge1xcbiAgICAgICAgdGhpcy5lbWl0U2NhbGFyKCd1bmRlZmluZWQnKTtcXG4gICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSBudWxsKSB7XFxuICAgICAgICB0aGlzLmVtaXRTY2FsYXIoJ251bGwnKTtcXG4gICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAwICYmIDEvdmFsdWUgPT09IC1JbmZpbml0eSkge1xcbiAgICAgICAgdGhpcy5lbWl0U2NhbGFyKCctMCcpO1xcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IGokLmdldEdsb2JhbCgpKSB7XFxuICAgICAgICB0aGlzLmVtaXRTY2FsYXIoJzxnbG9iYWw+Jyk7XFxuICAgICAgfSBlbHNlIGlmICh2YWx1ZS5qYXNtaW5lVG9TdHJpbmcpIHtcXG4gICAgICAgIHRoaXMuZW1pdFNjYWxhcih2YWx1ZS5qYXNtaW5lVG9TdHJpbmcoKSk7XFxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XFxuICAgICAgICB0aGlzLmVtaXRTdHJpbmcodmFsdWUpO1xcbiAgICAgIH0gZWxzZSBpZiAoaiQuaXNTcHkodmFsdWUpKSB7XFxuICAgICAgICB0aGlzLmVtaXRTY2FsYXIoJ3NweSBvbiAnICsgdmFsdWUuYW5kLmlkZW50aXR5KCkpO1xcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcXG4gICAgICAgIHRoaXMuZW1pdFNjYWxhcih2YWx1ZS50b1N0cmluZygpKTtcXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgdGhpcy5lbWl0U2NhbGFyKCdGdW5jdGlvbicpO1xcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlLm5vZGVUeXBlID09PSAnbnVtYmVyJykge1xcbiAgICAgICAgdGhpcy5lbWl0U2NhbGFyKCdIVE1MTm9kZScpO1xcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XFxuICAgICAgICB0aGlzLmVtaXRTY2FsYXIoJ0RhdGUoJyArIHZhbHVlICsgJyknKTtcXG4gICAgICB9IGVsc2UgaWYgKHZhbHVlLnRvU3RyaW5nICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSAmJiB2YWx1ZS50b1N0cmluZyAhPT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZykge1xcbiAgICAgICAgdGhpcy5lbWl0U2NhbGFyKHZhbHVlLnRvU3RyaW5nKCkpO1xcbiAgICAgIH0gZWxzZSBpZiAoaiQudXRpbC5hcnJheUNvbnRhaW5zKHRoaXMuc2VlbiwgdmFsdWUpKSB7XFxuICAgICAgICB0aGlzLmVtaXRTY2FsYXIoJzxjaXJjdWxhciByZWZlcmVuY2U6ICcgKyAoaiQuaXNBcnJheV8odmFsdWUpID8gJ0FycmF5JyA6ICdPYmplY3QnKSArICc+Jyk7XFxuICAgICAgfSBlbHNlIGlmIChqJC5pc0FycmF5Xyh2YWx1ZSkgfHwgaiQuaXNBXygnT2JqZWN0JywgdmFsdWUpKSB7XFxuICAgICAgICB0aGlzLnNlZW4ucHVzaCh2YWx1ZSk7XFxuICAgICAgICBpZiAoaiQuaXNBcnJheV8odmFsdWUpKSB7XFxuICAgICAgICAgIHRoaXMuZW1pdEFycmF5KHZhbHVlKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHRoaXMuZW1pdE9iamVjdCh2YWx1ZSk7XFxuICAgICAgICB9XFxuICAgICAgICB0aGlzLnNlZW4ucG9wKCk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRoaXMuZW1pdFNjYWxhcih2YWx1ZS50b1N0cmluZygpKTtcXG4gICAgICB9XFxuICAgIH0gZmluYWxseSB7XFxuICAgICAgdGhpcy5wcE5lc3RMZXZlbF8tLTtcXG4gICAgfVxcbiAgfTtcXG5cXG4gIFByZXR0eVByaW50ZXIucHJvdG90eXBlLml0ZXJhdGVPYmplY3QgPSBmdW5jdGlvbihvYmosIGZuKSB7XFxuICAgIGZvciAodmFyIHByb3BlcnR5IGluIG9iaikge1xcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcGVydHkpKSB7IGNvbnRpbnVlOyB9XFxuICAgICAgZm4ocHJvcGVydHksIG9iai5fX2xvb2t1cEdldHRlcl9fID8gKCFqJC51dGlsLmlzVW5kZWZpbmVkKG9iai5fX2xvb2t1cEdldHRlcl9fKHByb3BlcnR5KSkgJiZcXG4gICAgICAgICAgb2JqLl9fbG9va3VwR2V0dGVyX18ocHJvcGVydHkpICE9PSBudWxsKSA6IGZhbHNlKTtcXG4gICAgfVxcbiAgfTtcXG5cXG4gIFByZXR0eVByaW50ZXIucHJvdG90eXBlLmVtaXRBcnJheSA9IGokLnVuaW1wbGVtZW50ZWRNZXRob2RfO1xcbiAgUHJldHR5UHJpbnRlci5wcm90b3R5cGUuZW1pdE9iamVjdCA9IGokLnVuaW1wbGVtZW50ZWRNZXRob2RfO1xcbiAgUHJldHR5UHJpbnRlci5wcm90b3R5cGUuZW1pdFNjYWxhciA9IGokLnVuaW1wbGVtZW50ZWRNZXRob2RfO1xcbiAgUHJldHR5UHJpbnRlci5wcm90b3R5cGUuZW1pdFN0cmluZyA9IGokLnVuaW1wbGVtZW50ZWRNZXRob2RfO1xcblxcbiAgZnVuY3Rpb24gU3RyaW5nUHJldHR5UHJpbnRlcigpIHtcXG4gICAgUHJldHR5UHJpbnRlci5jYWxsKHRoaXMpO1xcblxcbiAgICB0aGlzLnN0cmluZyA9ICcnO1xcbiAgfVxcblxcbiAgaiQudXRpbC5pbmhlcml0KFN0cmluZ1ByZXR0eVByaW50ZXIsIFByZXR0eVByaW50ZXIpO1xcblxcbiAgU3RyaW5nUHJldHR5UHJpbnRlci5wcm90b3R5cGUuZW1pdFNjYWxhciA9IGZ1bmN0aW9uKHZhbHVlKSB7XFxuICAgIHRoaXMuYXBwZW5kKHZhbHVlKTtcXG4gIH07XFxuXFxuICBTdHJpbmdQcmV0dHlQcmludGVyLnByb3RvdHlwZS5lbWl0U3RyaW5nID0gZnVuY3Rpb24odmFsdWUpIHtcXG4gICAgdGhpcy5hcHBlbmQoJ1xcXFwnJyArIHZhbHVlICsgJ1xcXFwnJyk7XFxuICB9O1xcblxcbiAgU3RyaW5nUHJldHR5UHJpbnRlci5wcm90b3R5cGUuZW1pdEFycmF5ID0gZnVuY3Rpb24oYXJyYXkpIHtcXG4gICAgaWYgKHRoaXMucHBOZXN0TGV2ZWxfID4gaiQuTUFYX1BSRVRUWV9QUklOVF9ERVBUSCkge1xcbiAgICAgIHRoaXMuYXBwZW5kKCdBcnJheScpO1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oYXJyYXkubGVuZ3RoLCBqJC5NQVhfUFJFVFRZX1BSSU5UX0FSUkFZX0xFTkdUSCk7XFxuICAgIHRoaXMuYXBwZW5kKCdbICcpO1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XFxuICAgICAgaWYgKGkgPiAwKSB7XFxuICAgICAgICB0aGlzLmFwcGVuZCgnLCAnKTtcXG4gICAgICB9XFxuICAgICAgdGhpcy5mb3JtYXQoYXJyYXlbaV0pO1xcbiAgICB9XFxuICAgIGlmKGFycmF5Lmxlbmd0aCA+IGxlbmd0aCl7XFxuICAgICAgdGhpcy5hcHBlbmQoJywgLi4uJyk7XFxuICAgIH1cXG5cXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgICB2YXIgZmlyc3QgPSBhcnJheS5sZW5ndGggPT09IDA7XFxuICAgIHRoaXMuaXRlcmF0ZU9iamVjdChhcnJheSwgZnVuY3Rpb24ocHJvcGVydHksIGlzR2V0dGVyKSB7XFxuICAgICAgaWYgKHByb3BlcnR5Lm1hdGNoKC9eXFxcXGQrJC8pKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChmaXJzdCkge1xcbiAgICAgICAgZmlyc3QgPSBmYWxzZTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgc2VsZi5hcHBlbmQoJywgJyk7XFxuICAgICAgfVxcblxcbiAgICAgIHNlbGYuZm9ybWF0UHJvcGVydHkoYXJyYXksIHByb3BlcnR5LCBpc0dldHRlcik7XFxuICAgIH0pO1xcblxcbiAgICB0aGlzLmFwcGVuZCgnIF0nKTtcXG4gIH07XFxuXFxuICBTdHJpbmdQcmV0dHlQcmludGVyLnByb3RvdHlwZS5lbWl0T2JqZWN0ID0gZnVuY3Rpb24ob2JqKSB7XFxuICAgIHZhciBjb25zdHJ1Y3Rvck5hbWUgPSBvYmouY29uc3RydWN0b3IgPyBqJC5mbk5hbWVGb3Iob2JqLmNvbnN0cnVjdG9yKSA6ICdudWxsJztcXG4gICAgdGhpcy5hcHBlbmQoY29uc3RydWN0b3JOYW1lKTtcXG5cXG4gICAgaWYgKHRoaXMucHBOZXN0TGV2ZWxfID4gaiQuTUFYX1BSRVRUWV9QUklOVF9ERVBUSCkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICB2YXIgc2VsZiA9IHRoaXM7XFxuICAgIHRoaXMuYXBwZW5kKCcoeyAnKTtcXG4gICAgdmFyIGZpcnN0ID0gdHJ1ZTtcXG5cXG4gICAgdGhpcy5pdGVyYXRlT2JqZWN0KG9iaiwgZnVuY3Rpb24ocHJvcGVydHksIGlzR2V0dGVyKSB7XFxuICAgICAgaWYgKGZpcnN0KSB7XFxuICAgICAgICBmaXJzdCA9IGZhbHNlO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBzZWxmLmFwcGVuZCgnLCAnKTtcXG4gICAgICB9XFxuXFxuICAgICAgc2VsZi5mb3JtYXRQcm9wZXJ0eShvYmosIHByb3BlcnR5LCBpc0dldHRlcik7XFxuICAgIH0pO1xcblxcbiAgICB0aGlzLmFwcGVuZCgnIH0pJyk7XFxuICB9O1xcblxcbiAgU3RyaW5nUHJldHR5UHJpbnRlci5wcm90b3R5cGUuZm9ybWF0UHJvcGVydHkgPSBmdW5jdGlvbihvYmosIHByb3BlcnR5LCBpc0dldHRlcikge1xcbiAgICAgIHRoaXMuYXBwZW5kKHByb3BlcnR5KTtcXG4gICAgICB0aGlzLmFwcGVuZCgnOiAnKTtcXG4gICAgICBpZiAoaXNHZXR0ZXIpIHtcXG4gICAgICAgIHRoaXMuYXBwZW5kKCc8Z2V0dGVyPicpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0aGlzLmZvcm1hdChvYmpbcHJvcGVydHldKTtcXG4gICAgICB9XFxuICB9O1xcblxcbiAgU3RyaW5nUHJldHR5UHJpbnRlci5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24odmFsdWUpIHtcXG4gICAgdGhpcy5zdHJpbmcgKz0gdmFsdWU7XFxuICB9O1xcblxcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XFxuICAgIHZhciBzdHJpbmdQcmV0dHlQcmludGVyID0gbmV3IFN0cmluZ1ByZXR0eVByaW50ZXIoKTtcXG4gICAgc3RyaW5nUHJldHR5UHJpbnRlci5mb3JtYXQodmFsdWUpO1xcbiAgICByZXR1cm4gc3RyaW5nUHJldHR5UHJpbnRlci5zdHJpbmc7XFxuICB9O1xcbn07XFxuXFxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5RdWV1ZVJ1bm5lciA9IGZ1bmN0aW9uKGokKSB7XFxuXFxuICBmdW5jdGlvbiBvbmNlKGZuKSB7XFxuICAgIHZhciBjYWxsZWQgPSBmYWxzZTtcXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xcbiAgICAgIGlmICghY2FsbGVkKSB7XFxuICAgICAgICBjYWxsZWQgPSB0cnVlO1xcbiAgICAgICAgZm4oKTtcXG4gICAgICB9XFxuICAgIH07XFxuICB9XFxuXFxuICBmdW5jdGlvbiBRdWV1ZVJ1bm5lcihhdHRycykge1xcbiAgICB0aGlzLnF1ZXVlYWJsZUZucyA9IGF0dHJzLnF1ZXVlYWJsZUZucyB8fCBbXTtcXG4gICAgdGhpcy5vbkNvbXBsZXRlID0gYXR0cnMub25Db21wbGV0ZSB8fCBmdW5jdGlvbigpIHt9O1xcbiAgICB0aGlzLmNsZWFyU3RhY2sgPSBhdHRycy5jbGVhclN0YWNrIHx8IGZ1bmN0aW9uKGZuKSB7Zm4oKTt9O1xcbiAgICB0aGlzLm9uRXhjZXB0aW9uID0gYXR0cnMub25FeGNlcHRpb24gfHwgZnVuY3Rpb24oKSB7fTtcXG4gICAgdGhpcy5jYXRjaEV4Y2VwdGlvbiA9IGF0dHJzLmNhdGNoRXhjZXB0aW9uIHx8IGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfTtcXG4gICAgdGhpcy51c2VyQ29udGV4dCA9IGF0dHJzLnVzZXJDb250ZXh0IHx8IHt9O1xcbiAgICB0aGlzLnRpbWVvdXQgPSBhdHRycy50aW1lb3V0IHx8IHtzZXRUaW1lb3V0OiBzZXRUaW1lb3V0LCBjbGVhclRpbWVvdXQ6IGNsZWFyVGltZW91dH07XFxuICAgIHRoaXMuZmFpbCA9IGF0dHJzLmZhaWwgfHwgZnVuY3Rpb24oKSB7fTtcXG4gIH1cXG5cXG4gIFF1ZXVlUnVubmVyLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24oKSB7XFxuICAgIHRoaXMucnVuKHRoaXMucXVldWVhYmxlRm5zLCAwKTtcXG4gIH07XFxuXFxuICBRdWV1ZVJ1bm5lci5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24ocXVldWVhYmxlRm5zLCByZWN1cnNpdmVJbmRleCkge1xcbiAgICB2YXIgbGVuZ3RoID0gcXVldWVhYmxlRm5zLmxlbmd0aCxcXG4gICAgICBzZWxmID0gdGhpcyxcXG4gICAgICBpdGVyYXRpdmVJbmRleDtcXG5cXG5cXG4gICAgZm9yKGl0ZXJhdGl2ZUluZGV4ID0gcmVjdXJzaXZlSW5kZXg7IGl0ZXJhdGl2ZUluZGV4IDwgbGVuZ3RoOyBpdGVyYXRpdmVJbmRleCsrKSB7XFxuICAgICAgdmFyIHF1ZXVlYWJsZUZuID0gcXVldWVhYmxlRm5zW2l0ZXJhdGl2ZUluZGV4XTtcXG4gICAgICBpZiAocXVldWVhYmxlRm4uZm4ubGVuZ3RoID4gMCkge1xcbiAgICAgICAgYXR0ZW1wdEFzeW5jKHF1ZXVlYWJsZUZuKTtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgYXR0ZW1wdFN5bmMocXVldWVhYmxlRm4pO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICB2YXIgcnVubmVyRG9uZSA9IGl0ZXJhdGl2ZUluZGV4ID49IGxlbmd0aDtcXG5cXG4gICAgaWYgKHJ1bm5lckRvbmUpIHtcXG4gICAgICB0aGlzLmNsZWFyU3RhY2sodGhpcy5vbkNvbXBsZXRlKTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBhdHRlbXB0U3luYyhxdWV1ZWFibGVGbikge1xcbiAgICAgIHRyeSB7XFxuICAgICAgICBxdWV1ZWFibGVGbi5mbi5jYWxsKHNlbGYudXNlckNvbnRleHQpO1xcbiAgICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgIGhhbmRsZUV4Y2VwdGlvbihlLCBxdWV1ZWFibGVGbik7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIGF0dGVtcHRBc3luYyhxdWV1ZWFibGVGbikge1xcbiAgICAgIHZhciBjbGVhclRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5hcHBseShzZWxmLnRpbWVvdXQuY2xlYXJUaW1lb3V0LCBbaiQuZ2V0R2xvYmFsKCksIFt0aW1lb3V0SWRdXSk7XFxuICAgICAgICB9LFxcbiAgICAgICAgbmV4dCA9IG9uY2UoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcXG4gICAgICAgICAgc2VsZi5ydW4ocXVldWVhYmxlRm5zLCBpdGVyYXRpdmVJbmRleCArIDEpO1xcbiAgICAgICAgfSksXFxuICAgICAgICB0aW1lb3V0SWQ7XFxuXFxuICAgICAgbmV4dC5mYWlsID0gZnVuY3Rpb24oKSB7XFxuICAgICAgICBzZWxmLmZhaWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcXG4gICAgICAgIG5leHQoKTtcXG4gICAgICB9O1xcblxcbiAgICAgIGlmIChxdWV1ZWFibGVGbi50aW1lb3V0KSB7XFxuICAgICAgICB0aW1lb3V0SWQgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkoc2VsZi50aW1lb3V0LnNldFRpbWVvdXQsIFtqJC5nZXRHbG9iYWwoKSwgW2Z1bmN0aW9uKCkge1xcbiAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ1RpbWVvdXQgLSBBc3luYyBjYWxsYmFjayB3YXMgbm90IGludm9rZWQgd2l0aGluIHRpbWVvdXQgc3BlY2lmaWVkIGJ5IGphc21pbmUuREVGQVVMVF9USU1FT1VUX0lOVEVSVkFMLicpO1xcbiAgICAgICAgICBvbkV4Y2VwdGlvbihlcnJvcik7XFxuICAgICAgICAgIG5leHQoKTtcXG4gICAgICAgIH0sIHF1ZXVlYWJsZUZuLnRpbWVvdXQoKV1dKTtcXG4gICAgICB9XFxuXFxuICAgICAgdHJ5IHtcXG4gICAgICAgIHF1ZXVlYWJsZUZuLmZuLmNhbGwoc2VsZi51c2VyQ29udGV4dCwgbmV4dCk7XFxuICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgaGFuZGxlRXhjZXB0aW9uKGUsIHF1ZXVlYWJsZUZuKTtcXG4gICAgICAgIG5leHQoKTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gb25FeGNlcHRpb24oZSkge1xcbiAgICAgIHNlbGYub25FeGNlcHRpb24oZSk7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gaGFuZGxlRXhjZXB0aW9uKGUsIHF1ZXVlYWJsZUZuKSB7XFxuICAgICAgb25FeGNlcHRpb24oZSk7XFxuICAgICAgaWYgKCFzZWxmLmNhdGNoRXhjZXB0aW9uKGUpKSB7XFxuICAgICAgICAvL1RPRE86IHNldCBhIHZhciB3aGVuIHdlIGNhdGNoIGFuIGV4Y2VwdGlvbiBhbmRcXG4gICAgICAgIC8vdXNlIGEgZmluYWxseSBibG9jayB0byBjbG9zZSB0aGUgbG9vcCBpbiBhIG5pY2Ugd2F5Li5cXG4gICAgICAgIHRocm93IGU7XFxuICAgICAgfVxcbiAgICB9XFxuICB9O1xcblxcbiAgcmV0dXJuIFF1ZXVlUnVubmVyO1xcbn07XFxuXFxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5SZXBvcnREaXNwYXRjaGVyID0gZnVuY3Rpb24oKSB7XFxuICBmdW5jdGlvbiBSZXBvcnREaXNwYXRjaGVyKG1ldGhvZHMpIHtcXG5cXG4gICAgdmFyIGRpc3BhdGNoZWRNZXRob2RzID0gbWV0aG9kcyB8fCBbXTtcXG5cXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXNwYXRjaGVkTWV0aG9kcy5sZW5ndGg7IGkrKykge1xcbiAgICAgIHZhciBtZXRob2QgPSBkaXNwYXRjaGVkTWV0aG9kc1tpXTtcXG4gICAgICB0aGlzW21ldGhvZF0gPSAoZnVuY3Rpb24obSkge1xcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xcbiAgICAgICAgICBkaXNwYXRjaChtLCBhcmd1bWVudHMpO1xcbiAgICAgICAgfTtcXG4gICAgICB9KG1ldGhvZCkpO1xcbiAgICB9XFxuXFxuICAgIHZhciByZXBvcnRlcnMgPSBbXTtcXG5cXG4gICAgdGhpcy5hZGRSZXBvcnRlciA9IGZ1bmN0aW9uKHJlcG9ydGVyKSB7XFxuICAgICAgcmVwb3J0ZXJzLnB1c2gocmVwb3J0ZXIpO1xcbiAgICB9O1xcblxcbiAgICByZXR1cm4gdGhpcztcXG5cXG4gICAgZnVuY3Rpb24gZGlzcGF0Y2gobWV0aG9kLCBhcmdzKSB7XFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXBvcnRlcnMubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgIHZhciByZXBvcnRlciA9IHJlcG9ydGVyc1tpXTtcXG4gICAgICAgIGlmIChyZXBvcnRlclttZXRob2RdKSB7XFxuICAgICAgICAgIHJlcG9ydGVyW21ldGhvZF0uYXBwbHkocmVwb3J0ZXIsIGFyZ3MpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcblxcbiAgcmV0dXJuIFJlcG9ydERpc3BhdGNoZXI7XFxufTtcXG5cXG5cXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLlNweVJlZ2lzdHJ5ID0gZnVuY3Rpb24oaiQpIHtcXG5cXG4gIGZ1bmN0aW9uIFNweVJlZ2lzdHJ5KG9wdGlvbnMpIHtcXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XFxuICAgIHZhciBjdXJyZW50U3BpZXMgPSBvcHRpb25zLmN1cnJlbnRTcGllcyB8fCBmdW5jdGlvbigpIHsgcmV0dXJuIFtdOyB9O1xcblxcbiAgICB0aGlzLnNweU9uID0gZnVuY3Rpb24ob2JqLCBtZXRob2ROYW1lKSB7XFxuICAgICAgaWYgKGokLnV0aWwuaXNVbmRlZmluZWQob2JqKSkge1xcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzcHlPbiBjb3VsZCBub3QgZmluZCBhbiBvYmplY3QgdG8gc3B5IHVwb24gZm9yICcgKyBtZXRob2ROYW1lICsgJygpJyk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChqJC51dGlsLmlzVW5kZWZpbmVkKG1ldGhvZE5hbWUpKSB7XFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG1ldGhvZCBuYW1lIHN1cHBsaWVkJyk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChqJC51dGlsLmlzVW5kZWZpbmVkKG9ialttZXRob2ROYW1lXSkpIHtcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXRob2ROYW1lICsgJygpIG1ldGhvZCBkb2VzIG5vdCBleGlzdCcpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAob2JqW21ldGhvZE5hbWVdICYmIGokLmlzU3B5KG9ialttZXRob2ROYW1lXSkpIHtcXG4gICAgICAgIC8vVE9ETz86IHNob3VsZCB0aGlzIHJldHVybiB0aGUgY3VycmVudCBzcHk/IERvd25zaWRlOiBtYXkgY2F1c2UgdXNlciBjb25mdXNpb24gYWJvdXQgc3B5IHN0YXRlXFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWV0aG9kTmFtZSArICcgaGFzIGFscmVhZHkgYmVlbiBzcGllZCB1cG9uJyk7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBkZXNjcmlwdG9yO1xcbiAgICAgIHRyeSB7XFxuICAgICAgICBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIG1ldGhvZE5hbWUpO1xcbiAgICAgIH0gY2F0Y2goZSkge1xcbiAgICAgICAgLy8gSUUgOCBkb2Vzbid0IHN1cHBvcnQgYGRlZmluZVByb3BlcnlgIG9uIG5vbi1ET00gbm9kZXNcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGRlc2NyaXB0b3IgJiYgIShkZXNjcmlwdG9yLndyaXRhYmxlIHx8IGRlc2NyaXB0b3Iuc2V0KSkge1xcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1ldGhvZE5hbWUgKyAnIGlzIG5vdCBkZWNsYXJlZCB3cml0YWJsZSBvciBoYXMgbm8gc2V0dGVyJyk7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBzcHkgPSBqJC5jcmVhdGVTcHkobWV0aG9kTmFtZSwgb2JqW21ldGhvZE5hbWVdKTtcXG5cXG4gICAgICBjdXJyZW50U3BpZXMoKS5wdXNoKHtcXG4gICAgICAgIHNweTogc3B5LFxcbiAgICAgICAgYmFzZU9iajogb2JqLFxcbiAgICAgICAgbWV0aG9kTmFtZTogbWV0aG9kTmFtZSxcXG4gICAgICAgIG9yaWdpbmFsVmFsdWU6IG9ialttZXRob2ROYW1lXVxcbiAgICAgIH0pO1xcblxcbiAgICAgIG9ialttZXRob2ROYW1lXSA9IHNweTtcXG5cXG4gICAgICByZXR1cm4gc3B5O1xcbiAgICB9O1xcblxcbiAgICB0aGlzLmNsZWFyU3BpZXMgPSBmdW5jdGlvbigpIHtcXG4gICAgICB2YXIgc3BpZXMgPSBjdXJyZW50U3BpZXMoKTtcXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwaWVzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICB2YXIgc3B5RW50cnkgPSBzcGllc1tpXTtcXG4gICAgICAgIHNweUVudHJ5LmJhc2VPYmpbc3B5RW50cnkubWV0aG9kTmFtZV0gPSBzcHlFbnRyeS5vcmlnaW5hbFZhbHVlO1xcbiAgICAgIH1cXG4gICAgfTtcXG4gIH1cXG5cXG4gIHJldHVybiBTcHlSZWdpc3RyeTtcXG59O1xcblxcbmdldEphc21pbmVSZXF1aXJlT2JqKCkuU3B5U3RyYXRlZ3kgPSBmdW5jdGlvbigpIHtcXG5cXG4gIGZ1bmN0aW9uIFNweVN0cmF0ZWd5KG9wdGlvbnMpIHtcXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XFxuXFxuICAgIHZhciBpZGVudGl0eSA9IG9wdGlvbnMubmFtZSB8fCAndW5rbm93bicsXFxuICAgICAgICBvcmlnaW5hbEZuID0gb3B0aW9ucy5mbiB8fCBmdW5jdGlvbigpIHt9LFxcbiAgICAgICAgZ2V0U3B5ID0gb3B0aW9ucy5nZXRTcHkgfHwgZnVuY3Rpb24oKSB7fSxcXG4gICAgICAgIHBsYW4gPSBmdW5jdGlvbigpIHt9O1xcblxcbiAgICB0aGlzLmlkZW50aXR5ID0gZnVuY3Rpb24oKSB7XFxuICAgICAgcmV0dXJuIGlkZW50aXR5O1xcbiAgICB9O1xcblxcbiAgICB0aGlzLmV4ZWMgPSBmdW5jdGlvbigpIHtcXG4gICAgICByZXR1cm4gcGxhbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLmNhbGxUaHJvdWdoID0gZnVuY3Rpb24oKSB7XFxuICAgICAgcGxhbiA9IG9yaWdpbmFsRm47XFxuICAgICAgcmV0dXJuIGdldFNweSgpO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLnJldHVyblZhbHVlID0gZnVuY3Rpb24odmFsdWUpIHtcXG4gICAgICBwbGFuID0gZnVuY3Rpb24oKSB7XFxuICAgICAgICByZXR1cm4gdmFsdWU7XFxuICAgICAgfTtcXG4gICAgICByZXR1cm4gZ2V0U3B5KCk7XFxuICAgIH07XFxuXFxuICAgIHRoaXMucmV0dXJuVmFsdWVzID0gZnVuY3Rpb24oKSB7XFxuICAgICAgdmFyIHZhbHVlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XFxuICAgICAgcGxhbiA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHJldHVybiB2YWx1ZXMuc2hpZnQoKTtcXG4gICAgICB9O1xcbiAgICAgIHJldHVybiBnZXRTcHkoKTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy50aHJvd0Vycm9yID0gZnVuY3Rpb24oc29tZXRoaW5nKSB7XFxuICAgICAgdmFyIGVycm9yID0gKHNvbWV0aGluZyBpbnN0YW5jZW9mIEVycm9yKSA/IHNvbWV0aGluZyA6IG5ldyBFcnJvcihzb21ldGhpbmcpO1xcbiAgICAgIHBsYW4gPSBmdW5jdGlvbigpIHtcXG4gICAgICAgIHRocm93IGVycm9yO1xcbiAgICAgIH07XFxuICAgICAgcmV0dXJuIGdldFNweSgpO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLmNhbGxGYWtlID0gZnVuY3Rpb24oZm4pIHtcXG4gICAgICBwbGFuID0gZm47XFxuICAgICAgcmV0dXJuIGdldFNweSgpO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLnN0dWIgPSBmdW5jdGlvbihmbikge1xcbiAgICAgIHBsYW4gPSBmdW5jdGlvbigpIHt9O1xcbiAgICAgIHJldHVybiBnZXRTcHkoKTtcXG4gICAgfTtcXG4gIH1cXG5cXG4gIHJldHVybiBTcHlTdHJhdGVneTtcXG59O1xcblxcbmdldEphc21pbmVSZXF1aXJlT2JqKCkuU3VpdGUgPSBmdW5jdGlvbihqJCkge1xcbiAgZnVuY3Rpb24gU3VpdGUoYXR0cnMpIHtcXG4gICAgdGhpcy5lbnYgPSBhdHRycy5lbnY7XFxuICAgIHRoaXMuaWQgPSBhdHRycy5pZDtcXG4gICAgdGhpcy5wYXJlbnRTdWl0ZSA9IGF0dHJzLnBhcmVudFN1aXRlO1xcbiAgICB0aGlzLmRlc2NyaXB0aW9uID0gYXR0cnMuZGVzY3JpcHRpb247XFxuICAgIHRoaXMuZXhwZWN0YXRpb25GYWN0b3J5ID0gYXR0cnMuZXhwZWN0YXRpb25GYWN0b3J5O1xcbiAgICB0aGlzLmV4cGVjdGF0aW9uUmVzdWx0RmFjdG9yeSA9IGF0dHJzLmV4cGVjdGF0aW9uUmVzdWx0RmFjdG9yeTtcXG4gICAgdGhpcy50aHJvd09uRXhwZWN0YXRpb25GYWlsdXJlID0gISFhdHRycy50aHJvd09uRXhwZWN0YXRpb25GYWlsdXJlO1xcblxcbiAgICB0aGlzLmJlZm9yZUZucyA9IFtdO1xcbiAgICB0aGlzLmFmdGVyRm5zID0gW107XFxuICAgIHRoaXMuYmVmb3JlQWxsRm5zID0gW107XFxuICAgIHRoaXMuYWZ0ZXJBbGxGbnMgPSBbXTtcXG4gICAgdGhpcy5kaXNhYmxlZCA9IGZhbHNlO1xcblxcbiAgICB0aGlzLmNoaWxkcmVuID0gW107XFxuXFxuICAgIHRoaXMucmVzdWx0ID0ge1xcbiAgICAgIGlkOiB0aGlzLmlkLFxcbiAgICAgIGRlc2NyaXB0aW9uOiB0aGlzLmRlc2NyaXB0aW9uLFxcbiAgICAgIGZ1bGxOYW1lOiB0aGlzLmdldEZ1bGxOYW1lKCksXFxuICAgICAgZmFpbGVkRXhwZWN0YXRpb25zOiBbXVxcbiAgICB9O1xcbiAgfVxcblxcbiAgU3VpdGUucHJvdG90eXBlLmV4cGVjdCA9IGZ1bmN0aW9uKGFjdHVhbCkge1xcbiAgICByZXR1cm4gdGhpcy5leHBlY3RhdGlvbkZhY3RvcnkoYWN0dWFsLCB0aGlzKTtcXG4gIH07XFxuXFxuICBTdWl0ZS5wcm90b3R5cGUuZ2V0RnVsbE5hbWUgPSBmdW5jdGlvbigpIHtcXG4gICAgdmFyIGZ1bGxOYW1lID0gdGhpcy5kZXNjcmlwdGlvbjtcXG4gICAgZm9yICh2YXIgcGFyZW50U3VpdGUgPSB0aGlzLnBhcmVudFN1aXRlOyBwYXJlbnRTdWl0ZTsgcGFyZW50U3VpdGUgPSBwYXJlbnRTdWl0ZS5wYXJlbnRTdWl0ZSkge1xcbiAgICAgIGlmIChwYXJlbnRTdWl0ZS5wYXJlbnRTdWl0ZSkge1xcbiAgICAgICAgZnVsbE5hbWUgPSBwYXJlbnRTdWl0ZS5kZXNjcmlwdGlvbiArICcgJyArIGZ1bGxOYW1lO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICByZXR1cm4gZnVsbE5hbWU7XFxuICB9O1xcblxcbiAgU3VpdGUucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbigpIHtcXG4gICAgdGhpcy5kaXNhYmxlZCA9IHRydWU7XFxuICB9O1xcblxcbiAgU3VpdGUucHJvdG90eXBlLnBlbmQgPSBmdW5jdGlvbihtZXNzYWdlKSB7XFxuICAgIHRoaXMubWFya2VkUGVuZGluZyA9IHRydWU7XFxuICB9O1xcblxcbiAgU3VpdGUucHJvdG90eXBlLmJlZm9yZUVhY2ggPSBmdW5jdGlvbihmbikge1xcbiAgICB0aGlzLmJlZm9yZUZucy51bnNoaWZ0KGZuKTtcXG4gIH07XFxuXFxuICBTdWl0ZS5wcm90b3R5cGUuYmVmb3JlQWxsID0gZnVuY3Rpb24oZm4pIHtcXG4gICAgdGhpcy5iZWZvcmVBbGxGbnMucHVzaChmbik7XFxuICB9O1xcblxcbiAgU3VpdGUucHJvdG90eXBlLmFmdGVyRWFjaCA9IGZ1bmN0aW9uKGZuKSB7XFxuICAgIHRoaXMuYWZ0ZXJGbnMudW5zaGlmdChmbik7XFxuICB9O1xcblxcbiAgU3VpdGUucHJvdG90eXBlLmFmdGVyQWxsID0gZnVuY3Rpb24oZm4pIHtcXG4gICAgdGhpcy5hZnRlckFsbEZucy5wdXNoKGZuKTtcXG4gIH07XFxuXFxuICBTdWl0ZS5wcm90b3R5cGUuYWRkQ2hpbGQgPSBmdW5jdGlvbihjaGlsZCkge1xcbiAgICB0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xcbiAgfTtcXG5cXG4gIFN1aXRlLnByb3RvdHlwZS5zdGF0dXMgPSBmdW5jdGlvbigpIHtcXG4gICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcXG4gICAgICByZXR1cm4gJ2Rpc2FibGVkJztcXG4gICAgfVxcblxcbiAgICBpZiAodGhpcy5tYXJrZWRQZW5kaW5nKSB7XFxuICAgICAgcmV0dXJuICdwZW5kaW5nJztcXG4gICAgfVxcblxcbiAgICBpZiAodGhpcy5yZXN1bHQuZmFpbGVkRXhwZWN0YXRpb25zLmxlbmd0aCA+IDApIHtcXG4gICAgICByZXR1cm4gJ2ZhaWxlZCc7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgcmV0dXJuICdmaW5pc2hlZCc7XFxuICAgIH1cXG4gIH07XFxuXFxuICBTdWl0ZS5wcm90b3R5cGUuaXNFeGVjdXRhYmxlID0gZnVuY3Rpb24oKSB7XFxuICAgIHJldHVybiAhdGhpcy5kaXNhYmxlZDtcXG4gIH07XFxuXFxuICBTdWl0ZS5wcm90b3R5cGUuY2FuQmVSZWVudGVyZWQgPSBmdW5jdGlvbigpIHtcXG4gICAgcmV0dXJuIHRoaXMuYmVmb3JlQWxsRm5zLmxlbmd0aCA9PT0gMCAmJiB0aGlzLmFmdGVyQWxsRm5zLmxlbmd0aCA9PT0gMDtcXG4gIH07XFxuXFxuICBTdWl0ZS5wcm90b3R5cGUuZ2V0UmVzdWx0ID0gZnVuY3Rpb24oKSB7XFxuICAgIHRoaXMucmVzdWx0LnN0YXR1cyA9IHRoaXMuc3RhdHVzKCk7XFxuICAgIHJldHVybiB0aGlzLnJlc3VsdDtcXG4gIH07XFxuXFxuICBTdWl0ZS5wcm90b3R5cGUuc2hhcmVkVXNlckNvbnRleHQgPSBmdW5jdGlvbigpIHtcXG4gICAgaWYgKCF0aGlzLnNoYXJlZENvbnRleHQpIHtcXG4gICAgICB0aGlzLnNoYXJlZENvbnRleHQgPSB0aGlzLnBhcmVudFN1aXRlID8gY2xvbmUodGhpcy5wYXJlbnRTdWl0ZS5zaGFyZWRVc2VyQ29udGV4dCgpKSA6IHt9O1xcbiAgICB9XFxuXFxuICAgIHJldHVybiB0aGlzLnNoYXJlZENvbnRleHQ7XFxuICB9O1xcblxcbiAgU3VpdGUucHJvdG90eXBlLmNsb25lZFNoYXJlZFVzZXJDb250ZXh0ID0gZnVuY3Rpb24oKSB7XFxuICAgIHJldHVybiBjbG9uZSh0aGlzLnNoYXJlZFVzZXJDb250ZXh0KCkpO1xcbiAgfTtcXG5cXG4gIFN1aXRlLnByb3RvdHlwZS5vbkV4Y2VwdGlvbiA9IGZ1bmN0aW9uKCkge1xcbiAgICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgaiQuZXJyb3JzLkV4cGVjdGF0aW9uRmFpbGVkKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGlmKGlzQWZ0ZXJBbGwodGhpcy5jaGlsZHJlbikpIHtcXG4gICAgICB2YXIgZGF0YSA9IHtcXG4gICAgICAgIG1hdGNoZXJOYW1lOiAnJyxcXG4gICAgICAgIHBhc3NlZDogZmFsc2UsXFxuICAgICAgICBleHBlY3RlZDogJycsXFxuICAgICAgICBhY3R1YWw6ICcnLFxcbiAgICAgICAgZXJyb3I6IGFyZ3VtZW50c1swXVxcbiAgICAgIH07XFxuICAgICAgdGhpcy5yZXN1bHQuZmFpbGVkRXhwZWN0YXRpb25zLnB1c2godGhpcy5leHBlY3RhdGlvblJlc3VsdEZhY3RvcnkoZGF0YSkpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcXG4gICAgICAgIGNoaWxkLm9uRXhjZXB0aW9uLmFwcGx5KGNoaWxkLCBhcmd1bWVudHMpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfTtcXG5cXG4gIFN1aXRlLnByb3RvdHlwZS5hZGRFeHBlY3RhdGlvblJlc3VsdCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgaWYoaXNBZnRlckFsbCh0aGlzLmNoaWxkcmVuKSAmJiBpc0ZhaWx1cmUoYXJndW1lbnRzKSl7XFxuICAgICAgdmFyIGRhdGEgPSBhcmd1bWVudHNbMV07XFxuICAgICAgdGhpcy5yZXN1bHQuZmFpbGVkRXhwZWN0YXRpb25zLnB1c2godGhpcy5leHBlY3RhdGlvblJlc3VsdEZhY3RvcnkoZGF0YSkpO1xcbiAgICAgIGlmKHRoaXMudGhyb3dPbkV4cGVjdGF0aW9uRmFpbHVyZSkge1xcbiAgICAgICAgdGhyb3cgbmV3IGokLmVycm9ycy5FeHBlY3RhdGlvbkZhaWxlZCgpO1xcbiAgICAgIH1cXG4gICAgfSBlbHNlIHtcXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICBjaGlsZC5hZGRFeHBlY3RhdGlvblJlc3VsdC5hcHBseShjaGlsZCwgYXJndW1lbnRzKTtcXG4gICAgICAgIH0gY2F0Y2goZSkge1xcbiAgICAgICAgICAvLyBrZWVwIGdvaW5nXFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuICB9O1xcblxcbiAgZnVuY3Rpb24gaXNBZnRlckFsbChjaGlsZHJlbikge1xcbiAgICByZXR1cm4gY2hpbGRyZW4gJiYgY2hpbGRyZW5bMF0ucmVzdWx0LnN0YXR1cztcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGlzRmFpbHVyZShhcmdzKSB7XFxuICAgIHJldHVybiAhYXJnc1swXTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGNsb25lKG9iaikge1xcbiAgICB2YXIgY2xvbmVkT2JqID0ge307XFxuICAgIGZvciAodmFyIHByb3AgaW4gb2JqKSB7XFxuICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xcbiAgICAgICAgY2xvbmVkT2JqW3Byb3BdID0gb2JqW3Byb3BdO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICByZXR1cm4gY2xvbmVkT2JqO1xcbiAgfVxcblxcbiAgcmV0dXJuIFN1aXRlO1xcbn07XFxuXFxuaWYgKHR5cGVvZiB3aW5kb3cgPT0gdm9pZCAwICYmIHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnKSB7XFxuICBleHBvcnRzLlN1aXRlID0gamFzbWluZVJlcXVpcmUuU3VpdGU7XFxufVxcblxcbmdldEphc21pbmVSZXF1aXJlT2JqKCkuVGltZXIgPSBmdW5jdGlvbigpIHtcXG4gIHZhciBkZWZhdWx0Tm93ID0gKGZ1bmN0aW9uKERhdGUpIHtcXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkgeyByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7IH07XFxuICB9KShEYXRlKTtcXG5cXG4gIGZ1bmN0aW9uIFRpbWVyKG9wdGlvbnMpIHtcXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XFxuXFxuICAgIHZhciBub3cgPSBvcHRpb25zLm5vdyB8fCBkZWZhdWx0Tm93LFxcbiAgICAgIHN0YXJ0VGltZTtcXG5cXG4gICAgdGhpcy5zdGFydCA9IGZ1bmN0aW9uKCkge1xcbiAgICAgIHN0YXJ0VGltZSA9IG5vdygpO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLmVsYXBzZWQgPSBmdW5jdGlvbigpIHtcXG4gICAgICByZXR1cm4gbm93KCkgLSBzdGFydFRpbWU7XFxuICAgIH07XFxuICB9XFxuXFxuICByZXR1cm4gVGltZXI7XFxufTtcXG5cXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLlRyZWVQcm9jZXNzb3IgPSBmdW5jdGlvbigpIHtcXG4gIGZ1bmN0aW9uIFRyZWVQcm9jZXNzb3IoYXR0cnMpIHtcXG4gICAgdmFyIHRyZWUgPSBhdHRycy50cmVlLFxcbiAgICAgICAgcnVubmFibGVJZHMgPSBhdHRycy5ydW5uYWJsZUlkcyxcXG4gICAgICAgIHF1ZXVlUnVubmVyRmFjdG9yeSA9IGF0dHJzLnF1ZXVlUnVubmVyRmFjdG9yeSxcXG4gICAgICAgIG5vZGVTdGFydCA9IGF0dHJzLm5vZGVTdGFydCB8fCBmdW5jdGlvbigpIHt9LFxcbiAgICAgICAgbm9kZUNvbXBsZXRlID0gYXR0cnMubm9kZUNvbXBsZXRlIHx8IGZ1bmN0aW9uKCkge30sXFxuICAgICAgICBvcmRlckNoaWxkcmVuID0gYXR0cnMub3JkZXJDaGlsZHJlbiB8fCBmdW5jdGlvbihub2RlKSB7IHJldHVybiBub2RlLmNoaWxkcmVuOyB9LFxcbiAgICAgICAgc3RhdHMgPSB7IHZhbGlkOiB0cnVlIH0sXFxuICAgICAgICBwcm9jZXNzZWQgPSBmYWxzZSxcXG4gICAgICAgIGRlZmF1bHRNaW4gPSBJbmZpbml0eSxcXG4gICAgICAgIGRlZmF1bHRNYXggPSAxIC0gSW5maW5pdHk7XFxuXFxuICAgIHRoaXMucHJvY2Vzc1RyZWUgPSBmdW5jdGlvbigpIHtcXG4gICAgICBwcm9jZXNzTm9kZSh0cmVlLCBmYWxzZSk7XFxuICAgICAgcHJvY2Vzc2VkID0gdHJ1ZTtcXG4gICAgICByZXR1cm4gc3RhdHM7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuZXhlY3V0ZSA9IGZ1bmN0aW9uKGRvbmUpIHtcXG4gICAgICBpZiAoIXByb2Nlc3NlZCkge1xcbiAgICAgICAgdGhpcy5wcm9jZXNzVHJlZSgpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIXN0YXRzLnZhbGlkKSB7XFxuICAgICAgICB0aHJvdyAnaW52YWxpZCBvcmRlcic7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBjaGlsZEZucyA9IHdyYXBDaGlsZHJlbih0cmVlLCAwKTtcXG5cXG4gICAgICBxdWV1ZVJ1bm5lckZhY3Rvcnkoe1xcbiAgICAgICAgcXVldWVhYmxlRm5zOiBjaGlsZEZucyxcXG4gICAgICAgIHVzZXJDb250ZXh0OiB0cmVlLnNoYXJlZFVzZXJDb250ZXh0KCksXFxuICAgICAgICBvbkV4Y2VwdGlvbjogZnVuY3Rpb24oKSB7XFxuICAgICAgICAgIHRyZWUub25FeGNlcHRpb24uYXBwbHkodHJlZSwgYXJndW1lbnRzKTtcXG4gICAgICAgIH0sXFxuICAgICAgICBvbkNvbXBsZXRlOiBkb25lXFxuICAgICAgfSk7XFxuICAgIH07XFxuXFxuICAgIGZ1bmN0aW9uIHJ1bm5hYmxlSW5kZXgoaWQpIHtcXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJ1bm5hYmxlSWRzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICBpZiAocnVubmFibGVJZHNbaV0gPT09IGlkKSB7XFxuICAgICAgICAgIHJldHVybiBpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBwcm9jZXNzTm9kZShub2RlLCBwYXJlbnRFbmFibGVkKSB7XFxuICAgICAgdmFyIGV4ZWN1dGFibGVJbmRleCA9IHJ1bm5hYmxlSW5kZXgobm9kZS5pZCk7XFxuXFxuICAgICAgaWYgKGV4ZWN1dGFibGVJbmRleCAhPT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICBwYXJlbnRFbmFibGVkID0gdHJ1ZTtcXG4gICAgICB9XFxuXFxuICAgICAgcGFyZW50RW5hYmxlZCA9IHBhcmVudEVuYWJsZWQgJiYgbm9kZS5pc0V4ZWN1dGFibGUoKTtcXG5cXG4gICAgICBpZiAoIW5vZGUuY2hpbGRyZW4pIHtcXG4gICAgICAgIHN0YXRzW25vZGUuaWRdID0ge1xcbiAgICAgICAgICBleGVjdXRhYmxlOiBwYXJlbnRFbmFibGVkICYmIG5vZGUuaXNFeGVjdXRhYmxlKCksXFxuICAgICAgICAgIHNlZ21lbnRzOiBbe1xcbiAgICAgICAgICAgIGluZGV4OiAwLFxcbiAgICAgICAgICAgIG93bmVyOiBub2RlLFxcbiAgICAgICAgICAgIG5vZGVzOiBbbm9kZV0sXFxuICAgICAgICAgICAgbWluOiBzdGFydGluZ01pbihleGVjdXRhYmxlSW5kZXgpLFxcbiAgICAgICAgICAgIG1heDogc3RhcnRpbmdNYXgoZXhlY3V0YWJsZUluZGV4KVxcbiAgICAgICAgICB9XVxcbiAgICAgICAgfTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdmFyIGhhc0V4ZWN1dGFibGVDaGlsZCA9IGZhbHNlO1xcblxcbiAgICAgICAgdmFyIG9yZGVyZWRDaGlsZHJlbiA9IG9yZGVyQ2hpbGRyZW4obm9kZSk7XFxuXFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9yZGVyZWRDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgICB2YXIgY2hpbGQgPSBvcmRlcmVkQ2hpbGRyZW5baV07XFxuXFxuICAgICAgICAgIHByb2Nlc3NOb2RlKGNoaWxkLCBwYXJlbnRFbmFibGVkKTtcXG5cXG4gICAgICAgICAgaWYgKCFzdGF0cy52YWxpZCkge1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICB2YXIgY2hpbGRTdGF0cyA9IHN0YXRzW2NoaWxkLmlkXTtcXG5cXG4gICAgICAgICAgaGFzRXhlY3V0YWJsZUNoaWxkID0gaGFzRXhlY3V0YWJsZUNoaWxkIHx8IGNoaWxkU3RhdHMuZXhlY3V0YWJsZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHN0YXRzW25vZGUuaWRdID0ge1xcbiAgICAgICAgICBleGVjdXRhYmxlOiBoYXNFeGVjdXRhYmxlQ2hpbGRcXG4gICAgICAgIH07XFxuXFxuICAgICAgICBzZWdtZW50Q2hpbGRyZW4obm9kZSwgb3JkZXJlZENoaWxkcmVuLCBzdGF0c1tub2RlLmlkXSwgZXhlY3V0YWJsZUluZGV4KTtcXG5cXG4gICAgICAgIGlmICghbm9kZS5jYW5CZVJlZW50ZXJlZCgpICYmIHN0YXRzW25vZGUuaWRdLnNlZ21lbnRzLmxlbmd0aCA+IDEpIHtcXG4gICAgICAgICAgc3RhdHMgPSB7IHZhbGlkOiBmYWxzZSB9O1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBzdGFydGluZ01pbihleGVjdXRhYmxlSW5kZXgpIHtcXG4gICAgICByZXR1cm4gZXhlY3V0YWJsZUluZGV4ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0TWluIDogZXhlY3V0YWJsZUluZGV4O1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIHN0YXJ0aW5nTWF4KGV4ZWN1dGFibGVJbmRleCkge1xcbiAgICAgIHJldHVybiBleGVjdXRhYmxlSW5kZXggPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRNYXggOiBleGVjdXRhYmxlSW5kZXg7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gc2VnbWVudENoaWxkcmVuKG5vZGUsIG9yZGVyZWRDaGlsZHJlbiwgbm9kZVN0YXRzLCBleGVjdXRhYmxlSW5kZXgpIHtcXG4gICAgICB2YXIgY3VycmVudFNlZ21lbnQgPSB7IGluZGV4OiAwLCBvd25lcjogbm9kZSwgbm9kZXM6IFtdLCBtaW46IHN0YXJ0aW5nTWluKGV4ZWN1dGFibGVJbmRleCksIG1heDogc3RhcnRpbmdNYXgoZXhlY3V0YWJsZUluZGV4KSB9LFxcbiAgICAgICAgICByZXN1bHQgPSBbY3VycmVudFNlZ21lbnRdLFxcbiAgICAgICAgICBsYXN0TWF4ID0gZGVmYXVsdE1heCxcXG4gICAgICAgICAgb3JkZXJlZENoaWxkU2VnbWVudHMgPSBvcmRlckNoaWxkU2VnbWVudHMob3JkZXJlZENoaWxkcmVuKTtcXG5cXG4gICAgICBmdW5jdGlvbiBpc1NlZ21lbnRCb3VuZGFyeShtaW5JbmRleCkge1xcbiAgICAgICAgcmV0dXJuIGxhc3RNYXggIT09IGRlZmF1bHRNYXggJiYgbWluSW5kZXggIT09IGRlZmF1bHRNaW4gJiYgbGFzdE1heCA8IG1pbkluZGV4IC0gMTtcXG4gICAgICB9XFxuXFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmRlcmVkQ2hpbGRTZWdtZW50cy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgdmFyIGNoaWxkU2VnbWVudCA9IG9yZGVyZWRDaGlsZFNlZ21lbnRzW2ldLFxcbiAgICAgICAgICBtYXhJbmRleCA9IGNoaWxkU2VnbWVudC5tYXgsXFxuICAgICAgICAgIG1pbkluZGV4ID0gY2hpbGRTZWdtZW50Lm1pbjtcXG5cXG4gICAgICAgIGlmIChpc1NlZ21lbnRCb3VuZGFyeShtaW5JbmRleCkpIHtcXG4gICAgICAgICAgY3VycmVudFNlZ21lbnQgPSB7aW5kZXg6IHJlc3VsdC5sZW5ndGgsIG93bmVyOiBub2RlLCBub2RlczogW10sIG1pbjogZGVmYXVsdE1pbiwgbWF4OiBkZWZhdWx0TWF4fTtcXG4gICAgICAgICAgcmVzdWx0LnB1c2goY3VycmVudFNlZ21lbnQpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgY3VycmVudFNlZ21lbnQubm9kZXMucHVzaChjaGlsZFNlZ21lbnQpO1xcbiAgICAgICAgY3VycmVudFNlZ21lbnQubWluID0gTWF0aC5taW4oY3VycmVudFNlZ21lbnQubWluLCBtaW5JbmRleCk7XFxuICAgICAgICBjdXJyZW50U2VnbWVudC5tYXggPSBNYXRoLm1heChjdXJyZW50U2VnbWVudC5tYXgsIG1heEluZGV4KTtcXG4gICAgICAgIGxhc3RNYXggPSBtYXhJbmRleDtcXG4gICAgICB9XFxuXFxuICAgICAgbm9kZVN0YXRzLnNlZ21lbnRzID0gcmVzdWx0O1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIG9yZGVyQ2hpbGRTZWdtZW50cyhjaGlsZHJlbikge1xcbiAgICAgIHZhciBzcGVjaWZpZWRPcmRlciA9IFtdLFxcbiAgICAgICAgICB1bnNwZWNpZmllZE9yZGVyID0gW107XFxuXFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV0sXFxuICAgICAgICAgICAgc2VnbWVudHMgPSBzdGF0c1tjaGlsZC5pZF0uc2VnbWVudHM7XFxuXFxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNlZ21lbnRzLmxlbmd0aDsgaisrKSB7XFxuICAgICAgICAgIHZhciBzZWcgPSBzZWdtZW50c1tqXTtcXG5cXG4gICAgICAgICAgaWYgKHNlZy5taW4gPT09IGRlZmF1bHRNaW4pIHtcXG4gICAgICAgICAgICB1bnNwZWNpZmllZE9yZGVyLnB1c2goc2VnKTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBzcGVjaWZpZWRPcmRlci5wdXNoKHNlZyk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgc3BlY2lmaWVkT3JkZXIuc29ydChmdW5jdGlvbihhLCBiKSB7XFxuICAgICAgICByZXR1cm4gYS5taW4gLSBiLm1pbjtcXG4gICAgICB9KTtcXG5cXG4gICAgICByZXR1cm4gc3BlY2lmaWVkT3JkZXIuY29uY2F0KHVuc3BlY2lmaWVkT3JkZXIpO1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIGV4ZWN1dGVOb2RlKG5vZGUsIHNlZ21lbnROdW1iZXIpIHtcXG4gICAgICBpZiAobm9kZS5jaGlsZHJlbikge1xcbiAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgZm46IGZ1bmN0aW9uKGRvbmUpIHtcXG4gICAgICAgICAgICBub2RlU3RhcnQobm9kZSk7XFxuXFxuICAgICAgICAgICAgcXVldWVSdW5uZXJGYWN0b3J5KHtcXG4gICAgICAgICAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgICAgICAgICBub2RlQ29tcGxldGUobm9kZSwgbm9kZS5nZXRSZXN1bHQoKSk7XFxuICAgICAgICAgICAgICAgIGRvbmUoKTtcXG4gICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICBxdWV1ZWFibGVGbnM6IHdyYXBDaGlsZHJlbihub2RlLCBzZWdtZW50TnVtYmVyKSxcXG4gICAgICAgICAgICAgIHVzZXJDb250ZXh0OiBub2RlLnNoYXJlZFVzZXJDb250ZXh0KCksXFxuICAgICAgICAgICAgICBvbkV4Y2VwdGlvbjogZnVuY3Rpb24oKSB7XFxuICAgICAgICAgICAgICAgIG5vZGUub25FeGNlcHRpb24uYXBwbHkobm9kZSwgYXJndW1lbnRzKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgZm46IGZ1bmN0aW9uKGRvbmUpIHsgbm9kZS5leGVjdXRlKGRvbmUsIHN0YXRzW25vZGUuaWRdLmV4ZWN1dGFibGUpOyB9XFxuICAgICAgICB9O1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiB3cmFwQ2hpbGRyZW4obm9kZSwgc2VnbWVudE51bWJlcikge1xcbiAgICAgIHZhciByZXN1bHQgPSBbXSxcXG4gICAgICAgICAgc2VnbWVudENoaWxkcmVuID0gc3RhdHNbbm9kZS5pZF0uc2VnbWVudHNbc2VnbWVudE51bWJlcl0ubm9kZXM7XFxuXFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgIHJlc3VsdC5wdXNoKGV4ZWN1dGVOb2RlKHNlZ21lbnRDaGlsZHJlbltpXS5vd25lciwgc2VnbWVudENoaWxkcmVuW2ldLmluZGV4KSk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghc3RhdHNbbm9kZS5pZF0uZXhlY3V0YWJsZSkge1xcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIG5vZGUuYmVmb3JlQWxsRm5zLmNvbmNhdChyZXN1bHQpLmNvbmNhdChub2RlLmFmdGVyQWxsRm5zKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgcmV0dXJuIFRyZWVQcm9jZXNzb3I7XFxufTtcXG5cXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLkFueSA9IGZ1bmN0aW9uKGokKSB7XFxuXFxuICBmdW5jdGlvbiBBbnkoZXhwZWN0ZWRPYmplY3QpIHtcXG4gICAgaWYgKHR5cGVvZiBleHBlY3RlZE9iamVjdCA9PT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxcbiAgICAgICAgJ2phc21pbmUuYW55KCkgZXhwZWN0cyB0byBiZSBwYXNzZWQgYSBjb25zdHJ1Y3RvciBmdW5jdGlvbi4gJyArXFxuICAgICAgICAnUGxlYXNlIHBhc3Mgb25lIG9yIHVzZSBqYXNtaW5lLmFueXRoaW5nKCkgdG8gbWF0Y2ggYW55IG9iamVjdC4nXFxuICAgICAgKTtcXG4gICAgfVxcbiAgICB0aGlzLmV4cGVjdGVkT2JqZWN0ID0gZXhwZWN0ZWRPYmplY3Q7XFxuICB9XFxuXFxuICBBbnkucHJvdG90eXBlLmFzeW1tZXRyaWNNYXRjaCA9IGZ1bmN0aW9uKG90aGVyKSB7XFxuICAgIGlmICh0aGlzLmV4cGVjdGVkT2JqZWN0ID09IFN0cmluZykge1xcbiAgICAgIHJldHVybiB0eXBlb2Ygb3RoZXIgPT0gJ3N0cmluZycgfHwgb3RoZXIgaW5zdGFuY2VvZiBTdHJpbmc7XFxuICAgIH1cXG5cXG4gICAgaWYgKHRoaXMuZXhwZWN0ZWRPYmplY3QgPT0gTnVtYmVyKSB7XFxuICAgICAgcmV0dXJuIHR5cGVvZiBvdGhlciA9PSAnbnVtYmVyJyB8fCBvdGhlciBpbnN0YW5jZW9mIE51bWJlcjtcXG4gICAgfVxcblxcbiAgICBpZiAodGhpcy5leHBlY3RlZE9iamVjdCA9PSBGdW5jdGlvbikge1xcbiAgICAgIHJldHVybiB0eXBlb2Ygb3RoZXIgPT0gJ2Z1bmN0aW9uJyB8fCBvdGhlciBpbnN0YW5jZW9mIEZ1bmN0aW9uO1xcbiAgICB9XFxuXFxuICAgIGlmICh0aGlzLmV4cGVjdGVkT2JqZWN0ID09IE9iamVjdCkge1xcbiAgICAgIHJldHVybiB0eXBlb2Ygb3RoZXIgPT0gJ29iamVjdCc7XFxuICAgIH1cXG5cXG4gICAgaWYgKHRoaXMuZXhwZWN0ZWRPYmplY3QgPT0gQm9vbGVhbikge1xcbiAgICAgIHJldHVybiB0eXBlb2Ygb3RoZXIgPT0gJ2Jvb2xlYW4nO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIHRoaXMuZXhwZWN0ZWRPYmplY3Q7XFxuICB9O1xcblxcbiAgQW55LnByb3RvdHlwZS5qYXNtaW5lVG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcXG4gICAgcmV0dXJuICc8amFzbWluZS5hbnkoJyArIGokLmZuTmFtZUZvcih0aGlzLmV4cGVjdGVkT2JqZWN0KSArICcpPic7XFxuICB9O1xcblxcbiAgcmV0dXJuIEFueTtcXG59O1xcblxcbmdldEphc21pbmVSZXF1aXJlT2JqKCkuQW55dGhpbmcgPSBmdW5jdGlvbihqJCkge1xcblxcbiAgZnVuY3Rpb24gQW55dGhpbmcoKSB7fVxcblxcbiAgQW55dGhpbmcucHJvdG90eXBlLmFzeW1tZXRyaWNNYXRjaCA9IGZ1bmN0aW9uKG90aGVyKSB7XFxuICAgIHJldHVybiAhaiQudXRpbC5pc1VuZGVmaW5lZChvdGhlcikgJiYgb3RoZXIgIT09IG51bGw7XFxuICB9O1xcblxcbiAgQW55dGhpbmcucHJvdG90eXBlLmphc21pbmVUb1N0cmluZyA9IGZ1bmN0aW9uKCkge1xcbiAgICByZXR1cm4gJzxqYXNtaW5lLmFueXRoaW5nPic7XFxuICB9O1xcblxcbiAgcmV0dXJuIEFueXRoaW5nO1xcbn07XFxuXFxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5BcnJheUNvbnRhaW5pbmcgPSBmdW5jdGlvbihqJCkge1xcbiAgZnVuY3Rpb24gQXJyYXlDb250YWluaW5nKHNhbXBsZSkge1xcbiAgICB0aGlzLnNhbXBsZSA9IHNhbXBsZTtcXG4gIH1cXG5cXG4gIEFycmF5Q29udGFpbmluZy5wcm90b3R5cGUuYXN5bW1ldHJpY01hdGNoID0gZnVuY3Rpb24ob3RoZXIpIHtcXG4gICAgdmFyIGNsYXNzTmFtZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0aGlzLnNhbXBsZSk7XFxuICAgIGlmIChjbGFzc05hbWUgIT09ICdbb2JqZWN0IEFycmF5XScpIHsgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBwcm92aWRlIGFuIGFycmF5IHRvIGFycmF5Q29udGFpbmluZywgbm90IFxcXFwnJyArIHRoaXMuc2FtcGxlICsgJ1xcXFwnLicpOyB9XFxuXFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zYW1wbGUubGVuZ3RoOyBpKyspIHtcXG4gICAgICB2YXIgaXRlbSA9IHRoaXMuc2FtcGxlW2ldO1xcbiAgICAgIGlmICghaiQubWF0Y2hlcnNVdGlsLmNvbnRhaW5zKG90aGVyLCBpdGVtKSkge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICByZXR1cm4gdHJ1ZTtcXG4gIH07XFxuXFxuICBBcnJheUNvbnRhaW5pbmcucHJvdG90eXBlLmphc21pbmVUb1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcXG4gICAgcmV0dXJuICc8amFzbWluZS5hcnJheUNvbnRhaW5pbmcoJyArIGphc21pbmUucHAodGhpcy5zYW1wbGUpICsnKT4nO1xcbiAgfTtcXG5cXG4gIHJldHVybiBBcnJheUNvbnRhaW5pbmc7XFxufTtcXG5cXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLk9iamVjdENvbnRhaW5pbmcgPSBmdW5jdGlvbihqJCkge1xcblxcbiAgZnVuY3Rpb24gT2JqZWN0Q29udGFpbmluZyhzYW1wbGUpIHtcXG4gICAgdGhpcy5zYW1wbGUgPSBzYW1wbGU7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBnZXRQcm90b3R5cGUob2JqKSB7XFxuICAgIGlmIChPYmplY3QuZ2V0UHJvdG90eXBlT2YpIHtcXG4gICAgICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaik7XFxuICAgIH1cXG5cXG4gICAgaWYgKG9iai5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT0gb2JqKSB7XFxuICAgICAgcmV0dXJuIG51bGw7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIG9iai5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBoYXNQcm9wZXJ0eShvYmosIHByb3BlcnR5KSB7XFxuICAgIGlmICghb2JqKSB7XFxuICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxuXFxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wZXJ0eSkpIHtcXG4gICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gaGFzUHJvcGVydHkoZ2V0UHJvdG90eXBlKG9iaiksIHByb3BlcnR5KTtcXG4gIH1cXG5cXG4gIE9iamVjdENvbnRhaW5pbmcucHJvdG90eXBlLmFzeW1tZXRyaWNNYXRjaCA9IGZ1bmN0aW9uKG90aGVyKSB7XFxuICAgIGlmICh0eXBlb2YodGhpcy5zYW1wbGUpICE9PSAnb2JqZWN0JykgeyB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IHByb3ZpZGUgYW4gb2JqZWN0IHRvIG9iamVjdENvbnRhaW5pbmcsIG5vdCBcXFxcJycrdGhpcy5zYW1wbGUrJ1xcXFwnLicpOyB9XFxuXFxuICAgIGZvciAodmFyIHByb3BlcnR5IGluIHRoaXMuc2FtcGxlKSB7XFxuICAgICAgaWYgKCFoYXNQcm9wZXJ0eShvdGhlciwgcHJvcGVydHkpIHx8XFxuICAgICAgICAgICFqJC5tYXRjaGVyc1V0aWwuZXF1YWxzKHRoaXMuc2FtcGxlW3Byb3BlcnR5XSwgb3RoZXJbcHJvcGVydHldKSkge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICByZXR1cm4gdHJ1ZTtcXG4gIH07XFxuXFxuICBPYmplY3RDb250YWluaW5nLnByb3RvdHlwZS5qYXNtaW5lVG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcXG4gICAgcmV0dXJuICc8amFzbWluZS5vYmplY3RDb250YWluaW5nKCcgKyBqJC5wcCh0aGlzLnNhbXBsZSkgKyAnKT4nO1xcbiAgfTtcXG5cXG4gIHJldHVybiBPYmplY3RDb250YWluaW5nO1xcbn07XFxuXFxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5TdHJpbmdNYXRjaGluZyA9IGZ1bmN0aW9uKGokKSB7XFxuXFxuICBmdW5jdGlvbiBTdHJpbmdNYXRjaGluZyhleHBlY3RlZCkge1xcbiAgICBpZiAoIWokLmlzU3RyaW5nXyhleHBlY3RlZCkgJiYgIWokLmlzQV8oJ1JlZ0V4cCcsIGV4cGVjdGVkKSkge1xcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgaXMgbm90IGEgU3RyaW5nIG9yIGEgUmVnRXhwJyk7XFxuICAgIH1cXG5cXG4gICAgdGhpcy5yZWdleHAgPSBuZXcgUmVnRXhwKGV4cGVjdGVkKTtcXG4gIH1cXG5cXG4gIFN0cmluZ01hdGNoaW5nLnByb3RvdHlwZS5hc3ltbWV0cmljTWF0Y2ggPSBmdW5jdGlvbihvdGhlcikge1xcbiAgICByZXR1cm4gdGhpcy5yZWdleHAudGVzdChvdGhlcik7XFxuICB9O1xcblxcbiAgU3RyaW5nTWF0Y2hpbmcucHJvdG90eXBlLmphc21pbmVUb1N0cmluZyA9IGZ1bmN0aW9uKCkge1xcbiAgICByZXR1cm4gJzxqYXNtaW5lLnN0cmluZ01hdGNoaW5nKCcgKyB0aGlzLnJlZ2V4cCArICcpPic7XFxuICB9O1xcblxcbiAgcmV0dXJuIFN0cmluZ01hdGNoaW5nO1xcbn07XFxuXFxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5lcnJvcnMgPSBmdW5jdGlvbigpIHtcXG4gIGZ1bmN0aW9uIEV4cGVjdGF0aW9uRmFpbGVkKCkge31cXG5cXG4gIEV4cGVjdGF0aW9uRmFpbGVkLnByb3RvdHlwZSA9IG5ldyBFcnJvcigpO1xcbiAgRXhwZWN0YXRpb25GYWlsZWQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRXhwZWN0YXRpb25GYWlsZWQ7XFxuXFxuICByZXR1cm4ge1xcbiAgICBFeHBlY3RhdGlvbkZhaWxlZDogRXhwZWN0YXRpb25GYWlsZWRcXG4gIH07XFxufTtcXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLm1hdGNoZXJzVXRpbCA9IGZ1bmN0aW9uKGokKSB7XFxuICAvLyBUT0RPOiB3aGF0IHRvIGRvIGFib3V0IGphc21pbmUucHAgbm90IGJlaW5nIGluamVjdD8gbW92ZSB0byBKU09OLnN0cmluZ2lmeT8gZ3V0IFByZXR0eVByaW50ZXI/XFxuXFxuICByZXR1cm4ge1xcbiAgICBlcXVhbHM6IGZ1bmN0aW9uKGEsIGIsIGN1c3RvbVRlc3RlcnMpIHtcXG4gICAgICBjdXN0b21UZXN0ZXJzID0gY3VzdG9tVGVzdGVycyB8fCBbXTtcXG5cXG4gICAgICByZXR1cm4gZXEoYSwgYiwgW10sIFtdLCBjdXN0b21UZXN0ZXJzKTtcXG4gICAgfSxcXG5cXG4gICAgY29udGFpbnM6IGZ1bmN0aW9uKGhheXN0YWNrLCBuZWVkbGUsIGN1c3RvbVRlc3RlcnMpIHtcXG4gICAgICBjdXN0b21UZXN0ZXJzID0gY3VzdG9tVGVzdGVycyB8fCBbXTtcXG5cXG4gICAgICBpZiAoKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkoaGF5c3RhY2spID09PSAnW29iamVjdCBBcnJheV0nKSB8fFxcbiAgICAgICAgKCEhaGF5c3RhY2sgJiYgIWhheXN0YWNrLmluZGV4T2YpKVxcbiAgICAgIHtcXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGF5c3RhY2subGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgaWYgKGVxKGhheXN0YWNrW2ldLCBuZWVkbGUsIFtdLCBbXSwgY3VzdG9tVGVzdGVycykpIHtcXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gISFoYXlzdGFjayAmJiBoYXlzdGFjay5pbmRleE9mKG5lZWRsZSkgPj0gMDtcXG4gICAgfSxcXG5cXG4gICAgYnVpbGRGYWlsdXJlTWVzc2FnZTogZnVuY3Rpb24oKSB7XFxuICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApLFxcbiAgICAgICAgbWF0Y2hlck5hbWUgPSBhcmdzWzBdLFxcbiAgICAgICAgaXNOb3QgPSBhcmdzWzFdLFxcbiAgICAgICAgYWN0dWFsID0gYXJnc1syXSxcXG4gICAgICAgIGV4cGVjdGVkID0gYXJncy5zbGljZSgzKSxcXG4gICAgICAgIGVuZ2xpc2h5UHJlZGljYXRlID0gbWF0Y2hlck5hbWUucmVwbGFjZSgvW0EtWl0vZywgZnVuY3Rpb24ocykgeyByZXR1cm4gJyAnICsgcy50b0xvd2VyQ2FzZSgpOyB9KTtcXG5cXG4gICAgICB2YXIgbWVzc2FnZSA9ICdFeHBlY3RlZCAnICtcXG4gICAgICAgIGokLnBwKGFjdHVhbCkgK1xcbiAgICAgICAgKGlzTm90ID8gJyBub3QgJyA6ICcgJykgK1xcbiAgICAgICAgZW5nbGlzaHlQcmVkaWNhdGU7XFxuXFxuICAgICAgaWYgKGV4cGVjdGVkLmxlbmd0aCA+IDApIHtcXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwZWN0ZWQubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgaWYgKGkgPiAwKSB7XFxuICAgICAgICAgICAgbWVzc2FnZSArPSAnLCc7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgbWVzc2FnZSArPSAnICcgKyBqJC5wcChleHBlY3RlZFtpXSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBtZXNzYWdlICsgJy4nO1xcbiAgICB9XFxuICB9O1xcblxcbiAgZnVuY3Rpb24gaXNBc3ltbWV0cmljKG9iaikge1xcbiAgICByZXR1cm4gb2JqICYmIGokLmlzQV8oJ0Z1bmN0aW9uJywgb2JqLmFzeW1tZXRyaWNNYXRjaCk7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBhc3ltbWV0cmljTWF0Y2goYSwgYikge1xcbiAgICB2YXIgYXN5bW1ldHJpY0EgPSBpc0FzeW1tZXRyaWMoYSksXFxuICAgICAgICBhc3ltbWV0cmljQiA9IGlzQXN5bW1ldHJpYyhiKTtcXG5cXG4gICAgaWYgKGFzeW1tZXRyaWNBICYmIGFzeW1tZXRyaWNCKSB7XFxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcXG4gICAgfVxcblxcbiAgICBpZiAoYXN5bW1ldHJpY0EpIHtcXG4gICAgICByZXR1cm4gYS5hc3ltbWV0cmljTWF0Y2goYik7XFxuICAgIH1cXG5cXG4gICAgaWYgKGFzeW1tZXRyaWNCKSB7XFxuICAgICAgcmV0dXJuIGIuYXN5bW1ldHJpY01hdGNoKGEpO1xcbiAgICB9XFxuICB9XFxuXFxuICAvLyBFcXVhbGl0eSBmdW5jdGlvbiBsb3ZpbmdseSBhZGFwdGVkIGZyb20gaXNFcXVhbCBpblxcbiAgLy8gICBbVW5kZXJzY29yZV0oaHR0cDovL3VuZGVyc2NvcmVqcy5vcmcpXFxuICBmdW5jdGlvbiBlcShhLCBiLCBhU3RhY2ssIGJTdGFjaywgY3VzdG9tVGVzdGVycykge1xcbiAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcXG5cXG4gICAgdmFyIGFzeW1tZXRyaWNSZXN1bHQgPSBhc3ltbWV0cmljTWF0Y2goYSwgYik7XFxuICAgIGlmICghaiQudXRpbC5pc1VuZGVmaW5lZChhc3ltbWV0cmljUmVzdWx0KSkge1xcbiAgICAgIHJldHVybiBhc3ltbWV0cmljUmVzdWx0O1xcbiAgICB9XFxuXFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3VzdG9tVGVzdGVycy5sZW5ndGg7IGkrKykge1xcbiAgICAgIHZhciBjdXN0b21UZXN0ZXJSZXN1bHQgPSBjdXN0b21UZXN0ZXJzW2ldKGEsIGIpO1xcbiAgICAgIGlmICghaiQudXRpbC5pc1VuZGVmaW5lZChjdXN0b21UZXN0ZXJSZXN1bHQpKSB7XFxuICAgICAgICByZXR1cm4gY3VzdG9tVGVzdGVyUmVzdWx0O1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBpZiAoYSBpbnN0YW5jZW9mIEVycm9yICYmIGIgaW5zdGFuY2VvZiBFcnJvcikge1xcbiAgICAgIHJldHVybiBhLm1lc3NhZ2UgPT0gYi5tZXNzYWdlO1xcbiAgICB9XFxuXFxuICAgIC8vIElkZW50aWNhbCBvYmplY3RzIGFyZSBlcXVhbC4gYDAgPT09IC0wYCwgYnV0IHRoZXkgYXJlbid0IGlkZW50aWNhbC5cXG4gICAgLy8gU2VlIHRoZSBbSGFybW9ueSBgZWdhbGAgcHJvcG9zYWxdKGh0dHA6Ly93aWtpLmVjbWFzY3JpcHQub3JnL2Rva3UucGhwP2lkPWhhcm1vbnk6ZWdhbCkuXFxuICAgIGlmIChhID09PSBiKSB7IHJldHVybiBhICE9PSAwIHx8IDEgLyBhID09IDEgLyBiOyB9XFxuICAgIC8vIEEgc3RyaWN0IGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5IGJlY2F1c2UgYG51bGwgPT0gdW5kZWZpbmVkYC5cXG4gICAgaWYgKGEgPT09IG51bGwgfHwgYiA9PT0gbnVsbCkgeyByZXR1cm4gYSA9PT0gYjsgfVxcbiAgICB2YXIgY2xhc3NOYW1lID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGEpO1xcbiAgICBpZiAoY2xhc3NOYW1lICE9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChiKSkgeyByZXR1cm4gZmFsc2U7IH1cXG4gICAgc3dpdGNoIChjbGFzc05hbWUpIHtcXG4gICAgICAvLyBTdHJpbmdzLCBudW1iZXJzLCBkYXRlcywgYW5kIGJvb2xlYW5zIGFyZSBjb21wYXJlZCBieSB2YWx1ZS5cXG4gICAgICBjYXNlICdbb2JqZWN0IFN0cmluZ10nOlxcbiAgICAgICAgLy8gUHJpbWl0aXZlcyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBvYmplY3Qgd3JhcHBlcnMgYXJlIGVxdWl2YWxlbnQ7IHRodXMsIGBcXFwiNVxcXCJgIGlzXFxuICAgICAgICAvLyBlcXVpdmFsZW50IHRvIGBuZXcgU3RyaW5nKFxcXCI1XFxcIilgLlxcbiAgICAgICAgcmV0dXJuIGEgPT0gU3RyaW5nKGIpO1xcbiAgICAgIGNhc2UgJ1tvYmplY3QgTnVtYmVyXSc6XFxuICAgICAgICAvLyBgTmFOYHMgYXJlIGVxdWl2YWxlbnQsIGJ1dCBub24tcmVmbGV4aXZlLiBBbiBgZWdhbGAgY29tcGFyaXNvbiBpcyBwZXJmb3JtZWQgZm9yXFxuICAgICAgICAvLyBvdGhlciBudW1lcmljIHZhbHVlcy5cXG4gICAgICAgIHJldHVybiBhICE9ICthID8gYiAhPSArYiA6IChhID09PSAwID8gMSAvIGEgPT0gMSAvIGIgOiBhID09ICtiKTtcXG4gICAgICBjYXNlICdbb2JqZWN0IERhdGVdJzpcXG4gICAgICBjYXNlICdbb2JqZWN0IEJvb2xlYW5dJzpcXG4gICAgICAgIC8vIENvZXJjZSBkYXRlcyBhbmQgYm9vbGVhbnMgdG8gbnVtZXJpYyBwcmltaXRpdmUgdmFsdWVzLiBEYXRlcyBhcmUgY29tcGFyZWQgYnkgdGhlaXJcXG4gICAgICAgIC8vIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9ucy4gTm90ZSB0aGF0IGludmFsaWQgZGF0ZXMgd2l0aCBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnNcXG4gICAgICAgIC8vIG9mIGBOYU5gIGFyZSBub3QgZXF1aXZhbGVudC5cXG4gICAgICAgIHJldHVybiArYSA9PSArYjtcXG4gICAgICAvLyBSZWdFeHBzIGFyZSBjb21wYXJlZCBieSB0aGVpciBzb3VyY2UgcGF0dGVybnMgYW5kIGZsYWdzLlxcbiAgICAgIGNhc2UgJ1tvYmplY3QgUmVnRXhwXSc6XFxuICAgICAgICByZXR1cm4gYS5zb3VyY2UgPT0gYi5zb3VyY2UgJiZcXG4gICAgICAgICAgYS5nbG9iYWwgPT0gYi5nbG9iYWwgJiZcXG4gICAgICAgICAgYS5tdWx0aWxpbmUgPT0gYi5tdWx0aWxpbmUgJiZcXG4gICAgICAgICAgYS5pZ25vcmVDYXNlID09IGIuaWdub3JlQ2FzZTtcXG4gICAgfVxcbiAgICBpZiAodHlwZW9mIGEgIT0gJ29iamVjdCcgfHwgdHlwZW9mIGIgIT0gJ29iamVjdCcpIHsgcmV0dXJuIGZhbHNlOyB9XFxuXFxuICAgIHZhciBhSXNEb21Ob2RlID0gaiQuaXNEb21Ob2RlKGEpO1xcbiAgICB2YXIgYklzRG9tTm9kZSA9IGokLmlzRG9tTm9kZShiKTtcXG4gICAgaWYgKGFJc0RvbU5vZGUgJiYgYklzRG9tTm9kZSkge1xcbiAgICAgIC8vIEF0IGZpcnN0IHRyeSB0byB1c2UgRE9NMyBtZXRob2QgaXNFcXVhbE5vZGVcXG4gICAgICBpZiAoYS5pc0VxdWFsTm9kZSkge1xcbiAgICAgICAgcmV0dXJuIGEuaXNFcXVhbE5vZGUoYik7XFxuICAgICAgfVxcbiAgICAgIC8vIElFOCBkb2Vzbid0IHN1cHBvcnQgaXNFcXVhbE5vZGUsIHRyeSB0byB1c2Ugb3V0ZXJIVE1MICYmIGlubmVyVGV4dFxcbiAgICAgIHZhciBhSXNFbGVtZW50ID0gYSBpbnN0YW5jZW9mIEVsZW1lbnQ7XFxuICAgICAgdmFyIGJJc0VsZW1lbnQgPSBiIGluc3RhbmNlb2YgRWxlbWVudDtcXG4gICAgICBpZiAoYUlzRWxlbWVudCAmJiBiSXNFbGVtZW50KSB7XFxuICAgICAgICByZXR1cm4gYS5vdXRlckhUTUwgPT0gYi5vdXRlckhUTUw7XFxuICAgICAgfVxcbiAgICAgIGlmIChhSXNFbGVtZW50IHx8IGJJc0VsZW1lbnQpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIGEuaW5uZXJUZXh0ID09IGIuaW5uZXJUZXh0ICYmIGEudGV4dENvbnRlbnQgPT0gYi50ZXh0Q29udGVudDtcXG4gICAgfVxcbiAgICBpZiAoYUlzRG9tTm9kZSB8fCBiSXNEb21Ob2RlKSB7XFxuICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxuXFxuICAgIC8vIEFzc3VtZSBlcXVhbGl0eSBmb3IgY3ljbGljIHN0cnVjdHVyZXMuIFRoZSBhbGdvcml0aG0gZm9yIGRldGVjdGluZyBjeWNsaWNcXG4gICAgLy8gc3RydWN0dXJlcyBpcyBhZGFwdGVkIGZyb20gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMywgYWJzdHJhY3Qgb3BlcmF0aW9uIGBKT2AuXFxuICAgIHZhciBsZW5ndGggPSBhU3RhY2subGVuZ3RoO1xcbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcXG4gICAgICAvLyBMaW5lYXIgc2VhcmNoLiBQZXJmb3JtYW5jZSBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2ZcXG4gICAgICAvLyB1bmlxdWUgbmVzdGVkIHN0cnVjdHVyZXMuXFxuICAgICAgaWYgKGFTdGFja1tsZW5ndGhdID09IGEpIHsgcmV0dXJuIGJTdGFja1tsZW5ndGhdID09IGI7IH1cXG4gICAgfVxcbiAgICAvLyBBZGQgdGhlIGZpcnN0IG9iamVjdCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXFxuICAgIGFTdGFjay5wdXNoKGEpO1xcbiAgICBiU3RhY2sucHVzaChiKTtcXG4gICAgdmFyIHNpemUgPSAwO1xcbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgYW5kIGFycmF5cy5cXG4gICAgLy8gQ29tcGFyZSBhcnJheSBsZW5ndGhzIHRvIGRldGVybWluZSBpZiBhIGRlZXAgY29tcGFyaXNvbiBpcyBuZWNlc3NhcnkuXFxuICAgIGlmIChjbGFzc05hbWUgPT0gJ1tvYmplY3QgQXJyYXldJyAmJiBhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcXG4gICAgICByZXN1bHQgPSBmYWxzZTtcXG4gICAgfVxcblxcbiAgICBpZiAocmVzdWx0KSB7XFxuICAgICAgLy8gT2JqZWN0cyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVpdmFsZW50LCBidXQgYE9iamVjdGBzXFxuICAgICAgLy8gb3IgYEFycmF5YHMgZnJvbSBkaWZmZXJlbnQgZnJhbWVzIGFyZS5cXG4gICAgICBpZiAoY2xhc3NOYW1lICE9PSAnW29iamVjdCBBcnJheV0nKSB7XFxuICAgICAgICB2YXIgYUN0b3IgPSBhLmNvbnN0cnVjdG9yLCBiQ3RvciA9IGIuY29uc3RydWN0b3I7XFxuICAgICAgICBpZiAoYUN0b3IgIT09IGJDdG9yICYmICEoaXNGdW5jdGlvbihhQ3RvcikgJiYgYUN0b3IgaW5zdGFuY2VvZiBhQ3RvciAmJlxcbiAgICAgICAgICAgICAgIGlzRnVuY3Rpb24oYkN0b3IpICYmIGJDdG9yIGluc3RhbmNlb2YgYkN0b3IpKSB7XFxuICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgLy8gRGVlcCBjb21wYXJlIG9iamVjdHMuXFxuICAgICAgZm9yICh2YXIga2V5IGluIGEpIHtcXG4gICAgICAgIGlmIChoYXMoYSwga2V5KSkge1xcbiAgICAgICAgICAvLyBDb3VudCB0aGUgZXhwZWN0ZWQgbnVtYmVyIG9mIHByb3BlcnRpZXMuXFxuICAgICAgICAgIHNpemUrKztcXG4gICAgICAgICAgLy8gRGVlcCBjb21wYXJlIGVhY2ggbWVtYmVyLlxcbiAgICAgICAgICBpZiAoIShyZXN1bHQgPSBoYXMoYiwga2V5KSAmJiBlcShhW2tleV0sIGJba2V5XSwgYVN0YWNrLCBiU3RhY2ssIGN1c3RvbVRlc3RlcnMpKSkgeyBicmVhazsgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICAvLyBFbnN1cmUgdGhhdCBib3RoIG9iamVjdHMgY29udGFpbiB0aGUgc2FtZSBudW1iZXIgb2YgcHJvcGVydGllcy5cXG4gICAgICBpZiAocmVzdWx0KSB7XFxuICAgICAgICBmb3IgKGtleSBpbiBiKSB7XFxuICAgICAgICAgIGlmIChoYXMoYiwga2V5KSAmJiAhKHNpemUtLSkpIHsgYnJlYWs7IH1cXG4gICAgICAgIH1cXG4gICAgICAgIHJlc3VsdCA9ICFzaXplO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICAvLyBSZW1vdmUgdGhlIGZpcnN0IG9iamVjdCBmcm9tIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cXG4gICAgYVN0YWNrLnBvcCgpO1xcbiAgICBiU3RhY2sucG9wKCk7XFxuXFxuICAgIHJldHVybiByZXN1bHQ7XFxuXFxuICAgIGZ1bmN0aW9uIGhhcyhvYmosIGtleSkge1xcbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb24ob2JqKSB7XFxuICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbic7XFxuICAgIH1cXG4gIH1cXG59O1xcblxcbmdldEphc21pbmVSZXF1aXJlT2JqKCkudG9CZSA9IGZ1bmN0aW9uKCkge1xcbiAgZnVuY3Rpb24gdG9CZSgpIHtcXG4gICAgcmV0dXJuIHtcXG4gICAgICBjb21wYXJlOiBmdW5jdGlvbihhY3R1YWwsIGV4cGVjdGVkKSB7XFxuICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICBwYXNzOiBhY3R1YWwgPT09IGV4cGVjdGVkXFxuICAgICAgICB9O1xcbiAgICAgIH1cXG4gICAgfTtcXG4gIH1cXG5cXG4gIHJldHVybiB0b0JlO1xcbn07XFxuXFxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS50b0JlQ2xvc2VUbyA9IGZ1bmN0aW9uKCkge1xcblxcbiAgZnVuY3Rpb24gdG9CZUNsb3NlVG8oKSB7XFxuICAgIHJldHVybiB7XFxuICAgICAgY29tcGFyZTogZnVuY3Rpb24oYWN0dWFsLCBleHBlY3RlZCwgcHJlY2lzaW9uKSB7XFxuICAgICAgICBpZiAocHJlY2lzaW9uICE9PSAwKSB7XFxuICAgICAgICAgIHByZWNpc2lvbiA9IHByZWNpc2lvbiB8fCAyO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgcGFzczogTWF0aC5hYnMoZXhwZWN0ZWQgLSBhY3R1YWwpIDwgKE1hdGgucG93KDEwLCAtcHJlY2lzaW9uKSAvIDIpXFxuICAgICAgICB9O1xcbiAgICAgIH1cXG4gICAgfTtcXG4gIH1cXG5cXG4gIHJldHVybiB0b0JlQ2xvc2VUbztcXG59O1xcblxcbmdldEphc21pbmVSZXF1aXJlT2JqKCkudG9CZURlZmluZWQgPSBmdW5jdGlvbigpIHtcXG4gIGZ1bmN0aW9uIHRvQmVEZWZpbmVkKCkge1xcbiAgICByZXR1cm4ge1xcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGFjdHVhbCkge1xcbiAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgcGFzczogKHZvaWQgMCAhPT0gYWN0dWFsKVxcbiAgICAgICAgfTtcXG4gICAgICB9XFxuICAgIH07XFxuICB9XFxuXFxuICByZXR1cm4gdG9CZURlZmluZWQ7XFxufTtcXG5cXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvQmVGYWxzeSA9IGZ1bmN0aW9uKCkge1xcbiAgZnVuY3Rpb24gdG9CZUZhbHN5KCkge1xcbiAgICByZXR1cm4ge1xcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGFjdHVhbCkge1xcbiAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgcGFzczogISEhYWN0dWFsXFxuICAgICAgICB9O1xcbiAgICAgIH1cXG4gICAgfTtcXG4gIH1cXG5cXG4gIHJldHVybiB0b0JlRmFsc3k7XFxufTtcXG5cXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvQmVHcmVhdGVyVGhhbiA9IGZ1bmN0aW9uKCkge1xcblxcbiAgZnVuY3Rpb24gdG9CZUdyZWF0ZXJUaGFuKCkge1xcbiAgICByZXR1cm4ge1xcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpIHtcXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgIHBhc3M6IGFjdHVhbCA+IGV4cGVjdGVkXFxuICAgICAgICB9O1xcbiAgICAgIH1cXG4gICAgfTtcXG4gIH1cXG5cXG4gIHJldHVybiB0b0JlR3JlYXRlclRoYW47XFxufTtcXG5cXG5cXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvQmVMZXNzVGhhbiA9IGZ1bmN0aW9uKCkge1xcbiAgZnVuY3Rpb24gdG9CZUxlc3NUaGFuKCkge1xcbiAgICByZXR1cm4ge1xcblxcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpIHtcXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgIHBhc3M6IGFjdHVhbCA8IGV4cGVjdGVkXFxuICAgICAgICB9O1xcbiAgICAgIH1cXG4gICAgfTtcXG4gIH1cXG5cXG4gIHJldHVybiB0b0JlTGVzc1RoYW47XFxufTtcXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvQmVOYU4gPSBmdW5jdGlvbihqJCkge1xcblxcbiAgZnVuY3Rpb24gdG9CZU5hTigpIHtcXG4gICAgcmV0dXJuIHtcXG4gICAgICBjb21wYXJlOiBmdW5jdGlvbihhY3R1YWwpIHtcXG4gICAgICAgIHZhciByZXN1bHQgPSB7XFxuICAgICAgICAgIHBhc3M6IChhY3R1YWwgIT09IGFjdHVhbClcXG4gICAgICAgIH07XFxuXFxuICAgICAgICBpZiAocmVzdWx0LnBhc3MpIHtcXG4gICAgICAgICAgcmVzdWx0Lm1lc3NhZ2UgPSAnRXhwZWN0ZWQgYWN0dWFsIG5vdCB0byBiZSBOYU4uJztcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHJlc3VsdC5tZXNzYWdlID0gZnVuY3Rpb24oKSB7IHJldHVybiAnRXhwZWN0ZWQgJyArIGokLnBwKGFjdHVhbCkgKyAnIHRvIGJlIE5hTi4nOyB9O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgICB9XFxuICAgIH07XFxuICB9XFxuXFxuICByZXR1cm4gdG9CZU5hTjtcXG59O1xcblxcbmdldEphc21pbmVSZXF1aXJlT2JqKCkudG9CZU51bGwgPSBmdW5jdGlvbigpIHtcXG5cXG4gIGZ1bmN0aW9uIHRvQmVOdWxsKCkge1xcbiAgICByZXR1cm4ge1xcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGFjdHVhbCkge1xcbiAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgcGFzczogYWN0dWFsID09PSBudWxsXFxuICAgICAgICB9O1xcbiAgICAgIH1cXG4gICAgfTtcXG4gIH1cXG5cXG4gIHJldHVybiB0b0JlTnVsbDtcXG59O1xcblxcbmdldEphc21pbmVSZXF1aXJlT2JqKCkudG9CZVRydXRoeSA9IGZ1bmN0aW9uKCkge1xcblxcbiAgZnVuY3Rpb24gdG9CZVRydXRoeSgpIHtcXG4gICAgcmV0dXJuIHtcXG4gICAgICBjb21wYXJlOiBmdW5jdGlvbihhY3R1YWwpIHtcXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgIHBhc3M6ICEhYWN0dWFsXFxuICAgICAgICB9O1xcbiAgICAgIH1cXG4gICAgfTtcXG4gIH1cXG5cXG4gIHJldHVybiB0b0JlVHJ1dGh5O1xcbn07XFxuXFxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS50b0JlVW5kZWZpbmVkID0gZnVuY3Rpb24oKSB7XFxuXFxuICBmdW5jdGlvbiB0b0JlVW5kZWZpbmVkKCkge1xcbiAgICByZXR1cm4ge1xcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGFjdHVhbCkge1xcbiAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgcGFzczogdm9pZCAwID09PSBhY3R1YWxcXG4gICAgICAgIH07XFxuICAgICAgfVxcbiAgICB9O1xcbiAgfVxcblxcbiAgcmV0dXJuIHRvQmVVbmRlZmluZWQ7XFxufTtcXG5cXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvQ29udGFpbiA9IGZ1bmN0aW9uKCkge1xcbiAgZnVuY3Rpb24gdG9Db250YWluKHV0aWwsIGN1c3RvbUVxdWFsaXR5VGVzdGVycykge1xcbiAgICBjdXN0b21FcXVhbGl0eVRlc3RlcnMgPSBjdXN0b21FcXVhbGl0eVRlc3RlcnMgfHwgW107XFxuXFxuICAgIHJldHVybiB7XFxuICAgICAgY29tcGFyZTogZnVuY3Rpb24oYWN0dWFsLCBleHBlY3RlZCkge1xcblxcbiAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgcGFzczogdXRpbC5jb250YWlucyhhY3R1YWwsIGV4cGVjdGVkLCBjdXN0b21FcXVhbGl0eVRlc3RlcnMpXFxuICAgICAgICB9O1xcbiAgICAgIH1cXG4gICAgfTtcXG4gIH1cXG5cXG4gIHJldHVybiB0b0NvbnRhaW47XFxufTtcXG5cXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvRXF1YWwgPSBmdW5jdGlvbigpIHtcXG5cXG4gIGZ1bmN0aW9uIHRvRXF1YWwodXRpbCwgY3VzdG9tRXF1YWxpdHlUZXN0ZXJzKSB7XFxuICAgIGN1c3RvbUVxdWFsaXR5VGVzdGVycyA9IGN1c3RvbUVxdWFsaXR5VGVzdGVycyB8fCBbXTtcXG5cXG4gICAgcmV0dXJuIHtcXG4gICAgICBjb21wYXJlOiBmdW5jdGlvbihhY3R1YWwsIGV4cGVjdGVkKSB7XFxuICAgICAgICB2YXIgcmVzdWx0ID0ge1xcbiAgICAgICAgICBwYXNzOiBmYWxzZVxcbiAgICAgICAgfTtcXG5cXG4gICAgICAgIHJlc3VsdC5wYXNzID0gdXRpbC5lcXVhbHMoYWN0dWFsLCBleHBlY3RlZCwgY3VzdG9tRXF1YWxpdHlUZXN0ZXJzKTtcXG5cXG4gICAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgICAgfVxcbiAgICB9O1xcbiAgfVxcblxcbiAgcmV0dXJuIHRvRXF1YWw7XFxufTtcXG5cXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvSGF2ZUJlZW5DYWxsZWQgPSBmdW5jdGlvbihqJCkge1xcblxcbiAgZnVuY3Rpb24gdG9IYXZlQmVlbkNhbGxlZCgpIHtcXG4gICAgcmV0dXJuIHtcXG4gICAgICBjb21wYXJlOiBmdW5jdGlvbihhY3R1YWwpIHtcXG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcXG5cXG4gICAgICAgIGlmICghaiQuaXNTcHkoYWN0dWFsKSkge1xcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGEgc3B5LCBidXQgZ290ICcgKyBqJC5wcChhY3R1YWwpICsgJy4nKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RvSGF2ZUJlZW5DYWxsZWQgZG9lcyBub3QgdGFrZSBhcmd1bWVudHMsIHVzZSB0b0hhdmVCZWVuQ2FsbGVkV2l0aCcpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmVzdWx0LnBhc3MgPSBhY3R1YWwuY2FsbHMuYW55KCk7XFxuXFxuICAgICAgICByZXN1bHQubWVzc2FnZSA9IHJlc3VsdC5wYXNzID9cXG4gICAgICAgICAgJ0V4cGVjdGVkIHNweSAnICsgYWN0dWFsLmFuZC5pZGVudGl0eSgpICsgJyBub3QgdG8gaGF2ZSBiZWVuIGNhbGxlZC4nIDpcXG4gICAgICAgICAgJ0V4cGVjdGVkIHNweSAnICsgYWN0dWFsLmFuZC5pZGVudGl0eSgpICsgJyB0byBoYXZlIGJlZW4gY2FsbGVkLic7XFxuXFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICAgIH1cXG4gICAgfTtcXG4gIH1cXG5cXG4gIHJldHVybiB0b0hhdmVCZWVuQ2FsbGVkO1xcbn07XFxuXFxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMgPSBmdW5jdGlvbihqJCkge1xcblxcbiAgZnVuY3Rpb24gdG9IYXZlQmVlbkNhbGxlZFRpbWVzKCkge1xcbiAgICByZXR1cm4ge1xcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpIHtcXG4gICAgICAgIGlmICghaiQuaXNTcHkoYWN0dWFsKSkge1xcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGEgc3B5LCBidXQgZ290ICcgKyBqJC5wcChhY3R1YWwpICsgJy4nKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSxcXG4gICAgICAgICAgcmVzdWx0ID0geyBwYXNzOiBmYWxzZSB9O1xcblxcbiAgICAgICAgaWYoIWV4cGVjdGVkKXtcXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0aW1lcyBmYWlsZWQgaXMgcmVxdWlyZWQgYXMgYW4gYXJndW1lbnQuJyk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBhY3R1YWwgPSBhcmdzWzBdO1xcbiAgICAgICAgdmFyIGNhbGxzID0gYWN0dWFsLmNhbGxzLmNvdW50KCk7XFxuICAgICAgICB2YXIgdGltZXNNZXNzYWdlID0gZXhwZWN0ZWQgPT09IDEgPyAnb25jZScgOiBleHBlY3RlZCArICcgdGltZXMnO1xcbiAgICAgICAgcmVzdWx0LnBhc3MgPSBjYWxscyA9PT0gZXhwZWN0ZWQ7XFxuICAgICAgICByZXN1bHQubWVzc2FnZSA9IHJlc3VsdC5wYXNzID9cXG4gICAgICAgICAgJ0V4cGVjdGVkIHNweSAnICsgYWN0dWFsLmFuZC5pZGVudGl0eSgpICsgJyBub3QgdG8gaGF2ZSBiZWVuIGNhbGxlZCAnICsgdGltZXNNZXNzYWdlICsgJy4gSXQgd2FzIGNhbGxlZCAnICsgIGNhbGxzICsgJyB0aW1lcy4nIDpcXG4gICAgICAgICAgJ0V4cGVjdGVkIHNweSAnICsgYWN0dWFsLmFuZC5pZGVudGl0eSgpICsgJyB0byBoYXZlIGJlZW4gY2FsbGVkICcgKyB0aW1lc01lc3NhZ2UgKyAnLiBJdCB3YXMgY2FsbGVkICcgKyAgY2FsbHMgKyAnIHRpbWVzLic7XFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICAgIH1cXG4gICAgfTtcXG4gIH1cXG5cXG4gIHJldHVybiB0b0hhdmVCZWVuQ2FsbGVkVGltZXM7XFxufTtcXG5cXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoID0gZnVuY3Rpb24oaiQpIHtcXG5cXG4gIGZ1bmN0aW9uIHRvSGF2ZUJlZW5DYWxsZWRXaXRoKHV0aWwsIGN1c3RvbUVxdWFsaXR5VGVzdGVycykge1xcbiAgICByZXR1cm4ge1xcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApLFxcbiAgICAgICAgICBhY3R1YWwgPSBhcmdzWzBdLFxcbiAgICAgICAgICBleHBlY3RlZEFyZ3MgPSBhcmdzLnNsaWNlKDEpLFxcbiAgICAgICAgICByZXN1bHQgPSB7IHBhc3M6IGZhbHNlIH07XFxuXFxuICAgICAgICBpZiAoIWokLmlzU3B5KGFjdHVhbCkpIHtcXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBhIHNweSwgYnV0IGdvdCAnICsgaiQucHAoYWN0dWFsKSArICcuJyk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoIWFjdHVhbC5jYWxscy5hbnkoKSkge1xcbiAgICAgICAgICByZXN1bHQubWVzc2FnZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gJ0V4cGVjdGVkIHNweSAnICsgYWN0dWFsLmFuZC5pZGVudGl0eSgpICsgJyB0byBoYXZlIGJlZW4gY2FsbGVkIHdpdGggJyArIGokLnBwKGV4cGVjdGVkQXJncykgKyAnIGJ1dCBpdCB3YXMgbmV2ZXIgY2FsbGVkLic7IH07XFxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAodXRpbC5jb250YWlucyhhY3R1YWwuY2FsbHMuYWxsQXJncygpLCBleHBlY3RlZEFyZ3MsIGN1c3RvbUVxdWFsaXR5VGVzdGVycykpIHtcXG4gICAgICAgICAgcmVzdWx0LnBhc3MgPSB0cnVlO1xcbiAgICAgICAgICByZXN1bHQubWVzc2FnZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gJ0V4cGVjdGVkIHNweSAnICsgYWN0dWFsLmFuZC5pZGVudGl0eSgpICsgJyBub3QgdG8gaGF2ZSBiZWVuIGNhbGxlZCB3aXRoICcgKyBqJC5wcChleHBlY3RlZEFyZ3MpICsgJyBidXQgaXQgd2FzLic7IH07XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICByZXN1bHQubWVzc2FnZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gJ0V4cGVjdGVkIHNweSAnICsgYWN0dWFsLmFuZC5pZGVudGl0eSgpICsgJyB0byBoYXZlIGJlZW4gY2FsbGVkIHdpdGggJyArIGokLnBwKGV4cGVjdGVkQXJncykgKyAnIGJ1dCBhY3R1YWwgY2FsbHMgd2VyZSAnICsgaiQucHAoYWN0dWFsLmNhbGxzLmFsbEFyZ3MoKSkucmVwbGFjZSgvXlxcXFxbIHwgXFxcXF0kL2csICcnKSArICcuJzsgfTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgICAgfVxcbiAgICB9O1xcbiAgfVxcblxcbiAgcmV0dXJuIHRvSGF2ZUJlZW5DYWxsZWRXaXRoO1xcbn07XFxuXFxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS50b01hdGNoID0gZnVuY3Rpb24oaiQpIHtcXG5cXG4gIGZ1bmN0aW9uIHRvTWF0Y2goKSB7XFxuICAgIHJldHVybiB7XFxuICAgICAgY29tcGFyZTogZnVuY3Rpb24oYWN0dWFsLCBleHBlY3RlZCkge1xcbiAgICAgICAgaWYgKCFqJC5pc1N0cmluZ18oZXhwZWN0ZWQpICYmICFqJC5pc0FfKCdSZWdFeHAnLCBleHBlY3RlZCkpIHtcXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBpcyBub3QgYSBTdHJpbmcgb3IgYSBSZWdFeHAnKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHZhciByZWdleHAgPSBuZXcgUmVnRXhwKGV4cGVjdGVkKTtcXG5cXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgIHBhc3M6IHJlZ2V4cC50ZXN0KGFjdHVhbClcXG4gICAgICAgIH07XFxuICAgICAgfVxcbiAgICB9O1xcbiAgfVxcblxcbiAgcmV0dXJuIHRvTWF0Y2g7XFxufTtcXG5cXG5nZXRKYXNtaW5lUmVxdWlyZU9iaigpLnRvVGhyb3cgPSBmdW5jdGlvbihqJCkge1xcblxcbiAgZnVuY3Rpb24gdG9UaHJvdyh1dGlsKSB7XFxuICAgIHJldHVybiB7XFxuICAgICAgY29tcGFyZTogZnVuY3Rpb24oYWN0dWFsLCBleHBlY3RlZCkge1xcbiAgICAgICAgdmFyIHJlc3VsdCA9IHsgcGFzczogZmFsc2UgfSxcXG4gICAgICAgICAgdGhyZXcgPSBmYWxzZSxcXG4gICAgICAgICAgdGhyb3duO1xcblxcbiAgICAgICAgaWYgKHR5cGVvZiBhY3R1YWwgIT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjdHVhbCBpcyBub3QgYSBGdW5jdGlvbicpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgYWN0dWFsKCk7XFxuICAgICAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICAgIHRocmV3ID0gdHJ1ZTtcXG4gICAgICAgICAgdGhyb3duID0gZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICghdGhyZXcpIHtcXG4gICAgICAgICAgcmVzdWx0Lm1lc3NhZ2UgPSAnRXhwZWN0ZWQgZnVuY3Rpb24gdG8gdGhyb3cgYW4gZXhjZXB0aW9uLic7XFxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSB7XFxuICAgICAgICAgIHJlc3VsdC5wYXNzID0gdHJ1ZTtcXG4gICAgICAgICAgcmVzdWx0Lm1lc3NhZ2UgPSBmdW5jdGlvbigpIHsgcmV0dXJuICdFeHBlY3RlZCBmdW5jdGlvbiBub3QgdG8gdGhyb3csIGJ1dCBpdCB0aHJldyAnICsgaiQucHAodGhyb3duKSArICcuJzsgfTtcXG5cXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICh1dGlsLmVxdWFscyh0aHJvd24sIGV4cGVjdGVkKSkge1xcbiAgICAgICAgICByZXN1bHQucGFzcyA9IHRydWU7XFxuICAgICAgICAgIHJlc3VsdC5tZXNzYWdlID0gZnVuY3Rpb24oKSB7IHJldHVybiAnRXhwZWN0ZWQgZnVuY3Rpb24gbm90IHRvIHRocm93ICcgKyBqJC5wcChleHBlY3RlZCkgKyAnLic7IH07XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICByZXN1bHQubWVzc2FnZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gJ0V4cGVjdGVkIGZ1bmN0aW9uIHRvIHRocm93ICcgKyBqJC5wcChleHBlY3RlZCkgKyAnLCBidXQgaXQgdGhyZXcgJyArICBqJC5wcCh0aHJvd24pICsgJy4nOyB9O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgICB9XFxuICAgIH07XFxuICB9XFxuXFxuICByZXR1cm4gdG9UaHJvdztcXG59O1xcblxcbmdldEphc21pbmVSZXF1aXJlT2JqKCkudG9UaHJvd0Vycm9yID0gZnVuY3Rpb24oaiQpIHtcXG4gIGZ1bmN0aW9uIHRvVGhyb3dFcnJvciAoKSB7XFxuICAgIHJldHVybiB7XFxuICAgICAgY29tcGFyZTogZnVuY3Rpb24oYWN0dWFsKSB7XFxuICAgICAgICB2YXIgdGhyZXcgPSBmYWxzZSxcXG4gICAgICAgICAgcGFzcyA9IHtwYXNzOiB0cnVlfSxcXG4gICAgICAgICAgZmFpbCA9IHtwYXNzOiBmYWxzZX0sXFxuICAgICAgICAgIHRocm93bjtcXG5cXG4gICAgICAgIGlmICh0eXBlb2YgYWN0dWFsICE9ICdmdW5jdGlvbicpIHtcXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBY3R1YWwgaXMgbm90IGEgRnVuY3Rpb24nKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHZhciBlcnJvck1hdGNoZXIgPSBnZXRNYXRjaGVyLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XFxuXFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICBhY3R1YWwoKTtcXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgICAgdGhyZXcgPSB0cnVlO1xcbiAgICAgICAgICB0aHJvd24gPSBlO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKCF0aHJldykge1xcbiAgICAgICAgICBmYWlsLm1lc3NhZ2UgPSAnRXhwZWN0ZWQgZnVuY3Rpb24gdG8gdGhyb3cgYW4gRXJyb3IuJztcXG4gICAgICAgICAgcmV0dXJuIGZhaWw7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoISh0aHJvd24gaW5zdGFuY2VvZiBFcnJvcikpIHtcXG4gICAgICAgICAgZmFpbC5tZXNzYWdlID0gZnVuY3Rpb24oKSB7IHJldHVybiAnRXhwZWN0ZWQgZnVuY3Rpb24gdG8gdGhyb3cgYW4gRXJyb3IsIGJ1dCBpdCB0aHJldyAnICsgaiQucHAodGhyb3duKSArICcuJzsgfTtcXG4gICAgICAgICAgcmV0dXJuIGZhaWw7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoZXJyb3JNYXRjaGVyLmhhc05vU3BlY2lmaWNzKCkpIHtcXG4gICAgICAgICAgcGFzcy5tZXNzYWdlID0gJ0V4cGVjdGVkIGZ1bmN0aW9uIG5vdCB0byB0aHJvdyBhbiBFcnJvciwgYnV0IGl0IHRocmV3ICcgKyBqJC5mbk5hbWVGb3IodGhyb3duKSArICcuJztcXG4gICAgICAgICAgcmV0dXJuIHBhc3M7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoZXJyb3JNYXRjaGVyLm1hdGNoZXModGhyb3duKSkge1xcbiAgICAgICAgICBwYXNzLm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcXG4gICAgICAgICAgICByZXR1cm4gJ0V4cGVjdGVkIGZ1bmN0aW9uIG5vdCB0byB0aHJvdyAnICsgZXJyb3JNYXRjaGVyLmVycm9yVHlwZURlc2NyaXB0aW9uICsgZXJyb3JNYXRjaGVyLm1lc3NhZ2VEZXNjcmlwdGlvbigpICsgJy4nO1xcbiAgICAgICAgICB9O1xcbiAgICAgICAgICByZXR1cm4gcGFzcztcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGZhaWwubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgICAgIHJldHVybiAnRXhwZWN0ZWQgZnVuY3Rpb24gdG8gdGhyb3cgJyArIGVycm9yTWF0Y2hlci5lcnJvclR5cGVEZXNjcmlwdGlvbiArIGVycm9yTWF0Y2hlci5tZXNzYWdlRGVzY3JpcHRpb24oKSArXFxuICAgICAgICAgICAgICAnLCBidXQgaXQgdGhyZXcgJyArIGVycm9yTWF0Y2hlci50aHJvd25EZXNjcmlwdGlvbih0aHJvd24pICsgJy4nO1xcbiAgICAgICAgICB9O1xcbiAgICAgICAgICByZXR1cm4gZmFpbDtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH07XFxuXFxuICAgIGZ1bmN0aW9uIGdldE1hdGNoZXIoKSB7XFxuICAgICAgdmFyIGV4cGVjdGVkID0gbnVsbCxcXG4gICAgICAgICAgZXJyb3JUeXBlID0gbnVsbDtcXG5cXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAyKSB7XFxuICAgICAgICBleHBlY3RlZCA9IGFyZ3VtZW50c1sxXTtcXG4gICAgICAgIGlmIChpc0FuRXJyb3JUeXBlKGV4cGVjdGVkKSkge1xcbiAgICAgICAgICBlcnJvclR5cGUgPSBleHBlY3RlZDtcXG4gICAgICAgICAgZXhwZWN0ZWQgPSBudWxsO1xcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcXG4gICAgICAgIGVycm9yVHlwZSA9IGFyZ3VtZW50c1sxXTtcXG4gICAgICAgIGV4cGVjdGVkID0gYXJndW1lbnRzWzJdO1xcbiAgICAgICAgaWYgKCFpc0FuRXJyb3JUeXBlKGVycm9yVHlwZSkpIHtcXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBlcnJvciB0eXBlIGlzIG5vdCBhbiBFcnJvci4nKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGV4cGVjdGVkICYmICFpc1N0cmluZ09yUmVnRXhwKGV4cGVjdGVkKSkge1xcbiAgICAgICAgaWYgKGVycm9yVHlwZSkge1xcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGVycm9yIG1lc3NhZ2UgaXMgbm90IGEgc3RyaW5nIG9yIFJlZ0V4cC4nKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgaXMgbm90IGFuIEVycm9yLCBzdHJpbmcsIG9yIFJlZ0V4cC4nKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgZnVuY3Rpb24gbWVzc2FnZU1hdGNoKG1lc3NhZ2UpIHtcXG4gICAgICAgIGlmICh0eXBlb2YgZXhwZWN0ZWQgPT0gJ3N0cmluZycpIHtcXG4gICAgICAgICAgcmV0dXJuIGV4cGVjdGVkID09IG1lc3NhZ2U7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICByZXR1cm4gZXhwZWN0ZWQudGVzdChtZXNzYWdlKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHtcXG4gICAgICAgIGVycm9yVHlwZURlc2NyaXB0aW9uOiBlcnJvclR5cGUgPyBqJC5mbk5hbWVGb3IoZXJyb3JUeXBlKSA6ICdhbiBleGNlcHRpb24nLFxcbiAgICAgICAgdGhyb3duRGVzY3JpcHRpb246IGZ1bmN0aW9uKHRocm93bikge1xcbiAgICAgICAgICB2YXIgdGhyb3duTmFtZSA9IGVycm9yVHlwZSA/IGokLmZuTmFtZUZvcih0aHJvd24uY29uc3RydWN0b3IpIDogJ2FuIGV4Y2VwdGlvbicsXFxuICAgICAgICAgICAgICB0aHJvd25NZXNzYWdlID0gJyc7XFxuXFxuICAgICAgICAgIGlmIChleHBlY3RlZCkge1xcbiAgICAgICAgICAgIHRocm93bk1lc3NhZ2UgPSAnIHdpdGggbWVzc2FnZSAnICsgaiQucHAodGhyb3duLm1lc3NhZ2UpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHJldHVybiB0aHJvd25OYW1lICsgdGhyb3duTWVzc2FnZTtcXG4gICAgICAgIH0sXFxuICAgICAgICBtZXNzYWdlRGVzY3JpcHRpb246IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgICBpZiAoZXhwZWN0ZWQgPT09IG51bGwpIHtcXG4gICAgICAgICAgICByZXR1cm4gJyc7XFxuICAgICAgICAgIH0gZWxzZSBpZiAoZXhwZWN0ZWQgaW5zdGFuY2VvZiBSZWdFeHApIHtcXG4gICAgICAgICAgICByZXR1cm4gJyB3aXRoIGEgbWVzc2FnZSBtYXRjaGluZyAnICsgaiQucHAoZXhwZWN0ZWQpO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHJldHVybiAnIHdpdGggbWVzc2FnZSAnICsgaiQucHAoZXhwZWN0ZWQpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgaGFzTm9TcGVjaWZpY3M6IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgICByZXR1cm4gZXhwZWN0ZWQgPT09IG51bGwgJiYgZXJyb3JUeXBlID09PSBudWxsO1xcbiAgICAgICAgfSxcXG4gICAgICAgIG1hdGNoZXM6IGZ1bmN0aW9uKGVycm9yKSB7XFxuICAgICAgICAgIHJldHVybiAoZXJyb3JUeXBlID09PSBudWxsIHx8IGVycm9yIGluc3RhbmNlb2YgZXJyb3JUeXBlKSAmJlxcbiAgICAgICAgICAgIChleHBlY3RlZCA9PT0gbnVsbCB8fCBtZXNzYWdlTWF0Y2goZXJyb3IubWVzc2FnZSkpO1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gaXNTdHJpbmdPclJlZ0V4cChwb3RlbnRpYWwpIHtcXG4gICAgICByZXR1cm4gcG90ZW50aWFsIGluc3RhbmNlb2YgUmVnRXhwIHx8ICh0eXBlb2YgcG90ZW50aWFsID09ICdzdHJpbmcnKTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBpc0FuRXJyb3JUeXBlKHR5cGUpIHtcXG4gICAgICBpZiAodHlwZW9mIHR5cGUgIT09ICdmdW5jdGlvbicpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIFN1cnJvZ2F0ZSA9IGZ1bmN0aW9uKCkge307XFxuICAgICAgU3Vycm9nYXRlLnByb3RvdHlwZSA9IHR5cGUucHJvdG90eXBlO1xcbiAgICAgIHJldHVybiAobmV3IFN1cnJvZ2F0ZSgpKSBpbnN0YW5jZW9mIEVycm9yO1xcbiAgICB9XFxuICB9XFxuXFxuICByZXR1cm4gdG9UaHJvd0Vycm9yO1xcbn07XFxuXFxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS5pbnRlcmZhY2UgPSBmdW5jdGlvbihqYXNtaW5lLCBlbnYpIHtcXG4gIHZhciBqYXNtaW5lSW50ZXJmYWNlID0ge1xcbiAgICBkZXNjcmliZTogZnVuY3Rpb24oZGVzY3JpcHRpb24sIHNwZWNEZWZpbml0aW9ucykge1xcbiAgICAgIHJldHVybiBlbnYuZGVzY3JpYmUoZGVzY3JpcHRpb24sIHNwZWNEZWZpbml0aW9ucyk7XFxuICAgIH0sXFxuXFxuICAgIHhkZXNjcmliZTogZnVuY3Rpb24oZGVzY3JpcHRpb24sIHNwZWNEZWZpbml0aW9ucykge1xcbiAgICAgIHJldHVybiBlbnYueGRlc2NyaWJlKGRlc2NyaXB0aW9uLCBzcGVjRGVmaW5pdGlvbnMpO1xcbiAgICB9LFxcblxcbiAgICBmZGVzY3JpYmU6IGZ1bmN0aW9uKGRlc2NyaXB0aW9uLCBzcGVjRGVmaW5pdGlvbnMpIHtcXG4gICAgICByZXR1cm4gZW52LmZkZXNjcmliZShkZXNjcmlwdGlvbiwgc3BlY0RlZmluaXRpb25zKTtcXG4gICAgfSxcXG5cXG4gICAgaXQ6IGZ1bmN0aW9uKCkge1xcbiAgICAgIHJldHVybiBlbnYuaXQuYXBwbHkoZW52LCBhcmd1bWVudHMpO1xcbiAgICB9LFxcblxcbiAgICB4aXQ6IGZ1bmN0aW9uKCkge1xcbiAgICAgIHJldHVybiBlbnYueGl0LmFwcGx5KGVudiwgYXJndW1lbnRzKTtcXG4gICAgfSxcXG5cXG4gICAgZml0OiBmdW5jdGlvbigpIHtcXG4gICAgICByZXR1cm4gZW52LmZpdC5hcHBseShlbnYsIGFyZ3VtZW50cyk7XFxuICAgIH0sXFxuXFxuICAgIGJlZm9yZUVhY2g6IGZ1bmN0aW9uKCkge1xcbiAgICAgIHJldHVybiBlbnYuYmVmb3JlRWFjaC5hcHBseShlbnYsIGFyZ3VtZW50cyk7XFxuICAgIH0sXFxuXFxuICAgIGFmdGVyRWFjaDogZnVuY3Rpb24oKSB7XFxuICAgICAgcmV0dXJuIGVudi5hZnRlckVhY2guYXBwbHkoZW52LCBhcmd1bWVudHMpO1xcbiAgICB9LFxcblxcbiAgICBiZWZvcmVBbGw6IGZ1bmN0aW9uKCkge1xcbiAgICAgIHJldHVybiBlbnYuYmVmb3JlQWxsLmFwcGx5KGVudiwgYXJndW1lbnRzKTtcXG4gICAgfSxcXG5cXG4gICAgYWZ0ZXJBbGw6IGZ1bmN0aW9uKCkge1xcbiAgICAgIHJldHVybiBlbnYuYWZ0ZXJBbGwuYXBwbHkoZW52LCBhcmd1bWVudHMpO1xcbiAgICB9LFxcblxcbiAgICBleHBlY3Q6IGZ1bmN0aW9uKGFjdHVhbCkge1xcbiAgICAgIHJldHVybiBlbnYuZXhwZWN0KGFjdHVhbCk7XFxuICAgIH0sXFxuXFxuICAgIHBlbmRpbmc6IGZ1bmN0aW9uKCkge1xcbiAgICAgIHJldHVybiBlbnYucGVuZGluZy5hcHBseShlbnYsIGFyZ3VtZW50cyk7XFxuICAgIH0sXFxuXFxuICAgIGZhaWw6IGZ1bmN0aW9uKCkge1xcbiAgICAgIHJldHVybiBlbnYuZmFpbC5hcHBseShlbnYsIGFyZ3VtZW50cyk7XFxuICAgIH0sXFxuXFxuICAgIHNweU9uOiBmdW5jdGlvbihvYmosIG1ldGhvZE5hbWUpIHtcXG4gICAgICByZXR1cm4gZW52LnNweU9uKG9iaiwgbWV0aG9kTmFtZSk7XFxuICAgIH0sXFxuXFxuICAgIGpzQXBpUmVwb3J0ZXI6IG5ldyBqYXNtaW5lLkpzQXBpUmVwb3J0ZXIoe1xcbiAgICAgIHRpbWVyOiBuZXcgamFzbWluZS5UaW1lcigpXFxuICAgIH0pLFxcblxcbiAgICBqYXNtaW5lOiBqYXNtaW5lXFxuICB9O1xcblxcbiAgamFzbWluZS5hZGRDdXN0b21FcXVhbGl0eVRlc3RlciA9IGZ1bmN0aW9uKHRlc3Rlcikge1xcbiAgICBlbnYuYWRkQ3VzdG9tRXF1YWxpdHlUZXN0ZXIodGVzdGVyKTtcXG4gIH07XFxuXFxuICBqYXNtaW5lLmFkZE1hdGNoZXJzID0gZnVuY3Rpb24obWF0Y2hlcnMpIHtcXG4gICAgcmV0dXJuIGVudi5hZGRNYXRjaGVycyhtYXRjaGVycyk7XFxuICB9O1xcblxcbiAgamFzbWluZS5jbG9jayA9IGZ1bmN0aW9uKCkge1xcbiAgICByZXR1cm4gZW52LmNsb2NrO1xcbiAgfTtcXG5cXG4gIHJldHVybiBqYXNtaW5lSW50ZXJmYWNlO1xcbn07XFxuXFxuZ2V0SmFzbWluZVJlcXVpcmVPYmooKS52ZXJzaW9uID0gZnVuY3Rpb24oKSB7XFxuICByZXR1cm4gJzIuNC4xJztcXG59O1xcblwiXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvbGliL2phc21pbmUtMi40LjEvamFzbWluZS5qc1xuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCIvKlxcbkNvcHlyaWdodCAoYykgMjAwOC0yMDE1IFBpdm90YWwgTGFic1xcblxcblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZ1xcbmEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxcblxcXCJTb2Z0d2FyZVxcXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcXG53aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXFxuZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXFxucGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvXFxudGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxcblxcblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXFxuaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXFxuXFxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFxcXCJBUyBJU1xcXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXFxuRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXFxuTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcXG5OT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFXFxuTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTlxcbk9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTlxcbldJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxcbiovXFxuamFzbWluZVJlcXVpcmUuaHRtbCA9IGZ1bmN0aW9uKGokKSB7XFxuICBqJC5SZXN1bHRzTm9kZSA9IGphc21pbmVSZXF1aXJlLlJlc3VsdHNOb2RlKCk7XFxuICBqJC5IdG1sUmVwb3J0ZXIgPSBqYXNtaW5lUmVxdWlyZS5IdG1sUmVwb3J0ZXIoaiQpO1xcbiAgaiQuUXVlcnlTdHJpbmcgPSBqYXNtaW5lUmVxdWlyZS5RdWVyeVN0cmluZygpO1xcbiAgaiQuSHRtbFNwZWNGaWx0ZXIgPSBqYXNtaW5lUmVxdWlyZS5IdG1sU3BlY0ZpbHRlcigpO1xcbn07XFxuXFxuamFzbWluZVJlcXVpcmUuSHRtbFJlcG9ydGVyID0gZnVuY3Rpb24oaiQpIHtcXG5cXG4gIHZhciBub29wVGltZXIgPSB7XFxuICAgIHN0YXJ0OiBmdW5jdGlvbigpIHt9LFxcbiAgICBlbGFwc2VkOiBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH1cXG4gIH07XFxuXFxuICBmdW5jdGlvbiBIdG1sUmVwb3J0ZXIob3B0aW9ucykge1xcbiAgICB2YXIgZW52ID0gb3B0aW9ucy5lbnYgfHwge30sXFxuICAgICAgZ2V0Q29udGFpbmVyID0gb3B0aW9ucy5nZXRDb250YWluZXIsXFxuICAgICAgY3JlYXRlRWxlbWVudCA9IG9wdGlvbnMuY3JlYXRlRWxlbWVudCxcXG4gICAgICBjcmVhdGVUZXh0Tm9kZSA9IG9wdGlvbnMuY3JlYXRlVGV4dE5vZGUsXFxuICAgICAgb25SYWlzZUV4Y2VwdGlvbnNDbGljayA9IG9wdGlvbnMub25SYWlzZUV4Y2VwdGlvbnNDbGljayB8fCBmdW5jdGlvbigpIHt9LFxcbiAgICAgIG9uVGhyb3dFeHBlY3RhdGlvbnNDbGljayA9IG9wdGlvbnMub25UaHJvd0V4cGVjdGF0aW9uc0NsaWNrIHx8IGZ1bmN0aW9uKCkge30sXFxuICAgICAgb25SYW5kb21DbGljayA9IG9wdGlvbnMub25SYW5kb21DbGljayB8fCBmdW5jdGlvbigpIHt9LFxcbiAgICAgIGFkZFRvRXhpc3RpbmdRdWVyeVN0cmluZyA9IG9wdGlvbnMuYWRkVG9FeGlzdGluZ1F1ZXJ5U3RyaW5nIHx8IGRlZmF1bHRRdWVyeVN0cmluZyxcXG4gICAgICB0aW1lciA9IG9wdGlvbnMudGltZXIgfHwgbm9vcFRpbWVyLFxcbiAgICAgIHJlc3VsdHMgPSBbXSxcXG4gICAgICBzcGVjc0V4ZWN1dGVkID0gMCxcXG4gICAgICBmYWlsdXJlQ291bnQgPSAwLFxcbiAgICAgIHBlbmRpbmdTcGVjQ291bnQgPSAwLFxcbiAgICAgIGh0bWxSZXBvcnRlck1haW4sXFxuICAgICAgc3ltYm9scyxcXG4gICAgICBmYWlsZWRTdWl0ZXMgPSBbXTtcXG5cXG4gICAgdGhpcy5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7XFxuICAgICAgY2xlYXJQcmlvcigpO1xcbiAgICAgIGh0bWxSZXBvcnRlck1haW4gPSBjcmVhdGVEb20oJ2RpdicsIHtjbGFzc05hbWU6ICdqYXNtaW5lX2h0bWwtcmVwb3J0ZXInfSxcXG4gICAgICAgIGNyZWF0ZURvbSgnZGl2Jywge2NsYXNzTmFtZTogJ2phc21pbmUtYmFubmVyJ30sXFxuICAgICAgICAgIGNyZWF0ZURvbSgnYScsIHtjbGFzc05hbWU6ICdqYXNtaW5lLXRpdGxlJywgaHJlZjogJ2h0dHA6Ly9qYXNtaW5lLmdpdGh1Yi5pby8nLCB0YXJnZXQ6ICdfYmxhbmsnfSksXFxuICAgICAgICAgIGNyZWF0ZURvbSgnc3BhbicsIHtjbGFzc05hbWU6ICdqYXNtaW5lLXZlcnNpb24nfSwgaiQudmVyc2lvbilcXG4gICAgICAgICksXFxuICAgICAgICBjcmVhdGVEb20oJ3VsJywge2NsYXNzTmFtZTogJ2phc21pbmUtc3ltYm9sLXN1bW1hcnknfSksXFxuICAgICAgICBjcmVhdGVEb20oJ2RpdicsIHtjbGFzc05hbWU6ICdqYXNtaW5lLWFsZXJ0J30pLFxcbiAgICAgICAgY3JlYXRlRG9tKCdkaXYnLCB7Y2xhc3NOYW1lOiAnamFzbWluZS1yZXN1bHRzJ30sXFxuICAgICAgICAgIGNyZWF0ZURvbSgnZGl2Jywge2NsYXNzTmFtZTogJ2phc21pbmUtZmFpbHVyZXMnfSlcXG4gICAgICAgIClcXG4gICAgICApO1xcbiAgICAgIGdldENvbnRhaW5lcigpLmFwcGVuZENoaWxkKGh0bWxSZXBvcnRlck1haW4pO1xcbiAgICB9O1xcblxcbiAgICB2YXIgdG90YWxTcGVjc0RlZmluZWQ7XFxuICAgIHRoaXMuamFzbWluZVN0YXJ0ZWQgPSBmdW5jdGlvbihvcHRpb25zKSB7XFxuICAgICAgdG90YWxTcGVjc0RlZmluZWQgPSBvcHRpb25zLnRvdGFsU3BlY3NEZWZpbmVkIHx8IDA7XFxuICAgICAgdGltZXIuc3RhcnQoKTtcXG4gICAgfTtcXG5cXG4gICAgdmFyIHN1bW1hcnkgPSBjcmVhdGVEb20oJ2RpdicsIHtjbGFzc05hbWU6ICdqYXNtaW5lLXN1bW1hcnknfSk7XFxuXFxuICAgIHZhciB0b3BSZXN1bHRzID0gbmV3IGokLlJlc3VsdHNOb2RlKHt9LCAnJywgbnVsbCksXFxuICAgICAgY3VycmVudFBhcmVudCA9IHRvcFJlc3VsdHM7XFxuXFxuICAgIHRoaXMuc3VpdGVTdGFydGVkID0gZnVuY3Rpb24ocmVzdWx0KSB7XFxuICAgICAgY3VycmVudFBhcmVudC5hZGRDaGlsZChyZXN1bHQsICdzdWl0ZScpO1xcbiAgICAgIGN1cnJlbnRQYXJlbnQgPSBjdXJyZW50UGFyZW50Lmxhc3QoKTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5zdWl0ZURvbmUgPSBmdW5jdGlvbihyZXN1bHQpIHtcXG4gICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PSAnZmFpbGVkJykge1xcbiAgICAgICAgZmFpbGVkU3VpdGVzLnB1c2gocmVzdWx0KTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGN1cnJlbnRQYXJlbnQgPT0gdG9wUmVzdWx0cykge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBjdXJyZW50UGFyZW50ID0gY3VycmVudFBhcmVudC5wYXJlbnQ7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuc3BlY1N0YXJ0ZWQgPSBmdW5jdGlvbihyZXN1bHQpIHtcXG4gICAgICBjdXJyZW50UGFyZW50LmFkZENoaWxkKHJlc3VsdCwgJ3NwZWMnKTtcXG4gICAgfTtcXG5cXG4gICAgdmFyIGZhaWx1cmVzID0gW107XFxuICAgIHRoaXMuc3BlY0RvbmUgPSBmdW5jdGlvbihyZXN1bHQpIHtcXG4gICAgICBpZihub0V4cGVjdGF0aW9ucyhyZXN1bHQpICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29uc29sZS5lcnJvciAhPT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1NwZWMgXFxcXCcnICsgcmVzdWx0LmZ1bGxOYW1lICsgJ1xcXFwnIGhhcyBubyBleHBlY3RhdGlvbnMuJyk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChyZXN1bHQuc3RhdHVzICE9ICdkaXNhYmxlZCcpIHtcXG4gICAgICAgIHNwZWNzRXhlY3V0ZWQrKztcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCFzeW1ib2xzKXtcXG4gICAgICAgIHN5bWJvbHMgPSBmaW5kKCcuamFzbWluZS1zeW1ib2wtc3VtbWFyeScpO1xcbiAgICAgIH1cXG5cXG4gICAgICBzeW1ib2xzLmFwcGVuZENoaWxkKGNyZWF0ZURvbSgnbGknLCB7XFxuICAgICAgICAgIGNsYXNzTmFtZTogbm9FeHBlY3RhdGlvbnMocmVzdWx0KSA/ICdqYXNtaW5lLWVtcHR5JyA6ICdqYXNtaW5lLScgKyByZXN1bHQuc3RhdHVzLFxcbiAgICAgICAgICBpZDogJ3NwZWNfJyArIHJlc3VsdC5pZCxcXG4gICAgICAgICAgdGl0bGU6IHJlc3VsdC5mdWxsTmFtZVxcbiAgICAgICAgfVxcbiAgICAgICkpO1xcblxcbiAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09ICdmYWlsZWQnKSB7XFxuICAgICAgICBmYWlsdXJlQ291bnQrKztcXG5cXG4gICAgICAgIHZhciBmYWlsdXJlID1cXG4gICAgICAgICAgY3JlYXRlRG9tKCdkaXYnLCB7Y2xhc3NOYW1lOiAnamFzbWluZS1zcGVjLWRldGFpbCBqYXNtaW5lLWZhaWxlZCd9LFxcbiAgICAgICAgICAgIGNyZWF0ZURvbSgnZGl2Jywge2NsYXNzTmFtZTogJ2phc21pbmUtZGVzY3JpcHRpb24nfSxcXG4gICAgICAgICAgICAgIGNyZWF0ZURvbSgnYScsIHt0aXRsZTogcmVzdWx0LmZ1bGxOYW1lLCBocmVmOiBzcGVjSHJlZihyZXN1bHQpfSwgcmVzdWx0LmZ1bGxOYW1lKVxcbiAgICAgICAgICAgICksXFxuICAgICAgICAgICAgY3JlYXRlRG9tKCdkaXYnLCB7Y2xhc3NOYW1lOiAnamFzbWluZS1tZXNzYWdlcyd9KVxcbiAgICAgICAgICApO1xcbiAgICAgICAgdmFyIG1lc3NhZ2VzID0gZmFpbHVyZS5jaGlsZE5vZGVzWzFdO1xcblxcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHQuZmFpbGVkRXhwZWN0YXRpb25zLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgIHZhciBleHBlY3RhdGlvbiA9IHJlc3VsdC5mYWlsZWRFeHBlY3RhdGlvbnNbaV07XFxuICAgICAgICAgIG1lc3NhZ2VzLmFwcGVuZENoaWxkKGNyZWF0ZURvbSgnZGl2Jywge2NsYXNzTmFtZTogJ2phc21pbmUtcmVzdWx0LW1lc3NhZ2UnfSwgZXhwZWN0YXRpb24ubWVzc2FnZSkpO1xcbiAgICAgICAgICBtZXNzYWdlcy5hcHBlbmRDaGlsZChjcmVhdGVEb20oJ2RpdicsIHtjbGFzc05hbWU6ICdqYXNtaW5lLXN0YWNrLXRyYWNlJ30sIGV4cGVjdGF0aW9uLnN0YWNrKSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBmYWlsdXJlcy5wdXNoKGZhaWx1cmUpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PSAncGVuZGluZycpIHtcXG4gICAgICAgIHBlbmRpbmdTcGVjQ291bnQrKztcXG4gICAgICB9XFxuICAgIH07XFxuXFxuICAgIHRoaXMuamFzbWluZURvbmUgPSBmdW5jdGlvbihkb25lUmVzdWx0KSB7XFxuICAgICAgdmFyIGJhbm5lciA9IGZpbmQoJy5qYXNtaW5lLWJhbm5lcicpO1xcbiAgICAgIHZhciBhbGVydCA9IGZpbmQoJy5qYXNtaW5lLWFsZXJ0Jyk7XFxuICAgICAgdmFyIG9yZGVyID0gZG9uZVJlc3VsdCAmJiBkb25lUmVzdWx0Lm9yZGVyO1xcbiAgICAgIGFsZXJ0LmFwcGVuZENoaWxkKGNyZWF0ZURvbSgnc3BhbicsIHtjbGFzc05hbWU6ICdqYXNtaW5lLWR1cmF0aW9uJ30sICdmaW5pc2hlZCBpbiAnICsgdGltZXIuZWxhcHNlZCgpIC8gMTAwMCArICdzJykpO1xcblxcbiAgICAgIGJhbm5lci5hcHBlbmRDaGlsZChcXG4gICAgICAgIGNyZWF0ZURvbSgnZGl2JywgeyBjbGFzc05hbWU6ICdqYXNtaW5lLXJ1bi1vcHRpb25zJyB9LFxcbiAgICAgICAgICBjcmVhdGVEb20oJ3NwYW4nLCB7IGNsYXNzTmFtZTogJ2phc21pbmUtdHJpZ2dlcicgfSwgJ09wdGlvbnMnKSxcXG4gICAgICAgICAgY3JlYXRlRG9tKCdkaXYnLCB7IGNsYXNzTmFtZTogJ2phc21pbmUtcGF5bG9hZCcgfSxcXG4gICAgICAgICAgICBjcmVhdGVEb20oJ2RpdicsIHsgY2xhc3NOYW1lOiAnamFzbWluZS1leGNlcHRpb25zJyB9LFxcbiAgICAgICAgICAgICAgY3JlYXRlRG9tKCdpbnB1dCcsIHtcXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnamFzbWluZS1yYWlzZScsXFxuICAgICAgICAgICAgICAgIGlkOiAnamFzbWluZS1yYWlzZS1leGNlcHRpb25zJyxcXG4gICAgICAgICAgICAgICAgdHlwZTogJ2NoZWNrYm94J1xcbiAgICAgICAgICAgICAgfSksXFxuICAgICAgICAgICAgICBjcmVhdGVEb20oJ2xhYmVsJywgeyBjbGFzc05hbWU6ICdqYXNtaW5lLWxhYmVsJywgJ2Zvcic6ICdqYXNtaW5lLXJhaXNlLWV4Y2VwdGlvbnMnIH0sICdyYWlzZSBleGNlcHRpb25zJykpLFxcbiAgICAgICAgICAgIGNyZWF0ZURvbSgnZGl2JywgeyBjbGFzc05hbWU6ICdqYXNtaW5lLXRocm93LWZhaWx1cmVzJyB9LFxcbiAgICAgICAgICAgICAgY3JlYXRlRG9tKCdpbnB1dCcsIHtcXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnamFzbWluZS10aHJvdycsXFxuICAgICAgICAgICAgICAgIGlkOiAnamFzbWluZS10aHJvdy1mYWlsdXJlcycsXFxuICAgICAgICAgICAgICAgIHR5cGU6ICdjaGVja2JveCdcXG4gICAgICAgICAgICAgIH0pLFxcbiAgICAgICAgICAgICAgY3JlYXRlRG9tKCdsYWJlbCcsIHsgY2xhc3NOYW1lOiAnamFzbWluZS1sYWJlbCcsICdmb3InOiAnamFzbWluZS10aHJvdy1mYWlsdXJlcycgfSwgJ3N0b3Agc3BlYyBvbiBleHBlY3RhdGlvbiBmYWlsdXJlJykpLFxcbiAgICAgICAgICAgIGNyZWF0ZURvbSgnZGl2JywgeyBjbGFzc05hbWU6ICdqYXNtaW5lLXJhbmRvbS1vcmRlcicgfSxcXG4gICAgICAgICAgICAgIGNyZWF0ZURvbSgnaW5wdXQnLCB7XFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ2phc21pbmUtcmFuZG9tJyxcXG4gICAgICAgICAgICAgICAgaWQ6ICdqYXNtaW5lLXJhbmRvbS1vcmRlcicsXFxuICAgICAgICAgICAgICAgIHR5cGU6ICdjaGVja2JveCdcXG4gICAgICAgICAgICAgIH0pLFxcbiAgICAgICAgICAgICAgY3JlYXRlRG9tKCdsYWJlbCcsIHsgY2xhc3NOYW1lOiAnamFzbWluZS1sYWJlbCcsICdmb3InOiAnamFzbWluZS1yYW5kb20tb3JkZXInIH0sICdydW4gdGVzdHMgaW4gcmFuZG9tIG9yZGVyJykpXFxuICAgICAgICAgIClcXG4gICAgICAgICkpO1xcblxcbiAgICAgIHZhciByYWlzZUNoZWNrYm94ID0gZmluZCgnI2phc21pbmUtcmFpc2UtZXhjZXB0aW9ucycpO1xcblxcbiAgICAgIHJhaXNlQ2hlY2tib3guY2hlY2tlZCA9ICFlbnYuY2F0Y2hpbmdFeGNlcHRpb25zKCk7XFxuICAgICAgcmFpc2VDaGVja2JveC5vbmNsaWNrID0gb25SYWlzZUV4Y2VwdGlvbnNDbGljaztcXG5cXG4gICAgICB2YXIgdGhyb3dDaGVja2JveCA9IGZpbmQoJyNqYXNtaW5lLXRocm93LWZhaWx1cmVzJyk7XFxuICAgICAgdGhyb3dDaGVja2JveC5jaGVja2VkID0gZW52LnRocm93aW5nRXhwZWN0YXRpb25GYWlsdXJlcygpO1xcbiAgICAgIHRocm93Q2hlY2tib3gub25jbGljayA9IG9uVGhyb3dFeHBlY3RhdGlvbnNDbGljaztcXG5cXG4gICAgICB2YXIgcmFuZG9tQ2hlY2tib3ggPSBmaW5kKCcjamFzbWluZS1yYW5kb20tb3JkZXInKTtcXG4gICAgICByYW5kb21DaGVja2JveC5jaGVja2VkID0gZW52LnJhbmRvbVRlc3RzKCk7XFxuICAgICAgcmFuZG9tQ2hlY2tib3gub25jbGljayA9IG9uUmFuZG9tQ2xpY2s7XFxuXFxuICAgICAgdmFyIG9wdGlvbnNNZW51ID0gZmluZCgnLmphc21pbmUtcnVuLW9wdGlvbnMnKSxcXG4gICAgICAgICAgb3B0aW9uc1RyaWdnZXIgPSBvcHRpb25zTWVudS5xdWVyeVNlbGVjdG9yKCcuamFzbWluZS10cmlnZ2VyJyksXFxuICAgICAgICAgIG9wdGlvbnNQYXlsb2FkID0gb3B0aW9uc01lbnUucXVlcnlTZWxlY3RvcignLmphc21pbmUtcGF5bG9hZCcpLFxcbiAgICAgICAgICBpc09wZW4gPSAvXFxcXGJqYXNtaW5lLW9wZW5cXFxcYi87XFxuXFxuICAgICAgb3B0aW9uc1RyaWdnZXIub25jbGljayA9IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgaWYgKGlzT3Blbi50ZXN0KG9wdGlvbnNQYXlsb2FkLmNsYXNzTmFtZSkpIHtcXG4gICAgICAgICAgb3B0aW9uc1BheWxvYWQuY2xhc3NOYW1lID0gb3B0aW9uc1BheWxvYWQuY2xhc3NOYW1lLnJlcGxhY2UoaXNPcGVuLCAnJyk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBvcHRpb25zUGF5bG9hZC5jbGFzc05hbWUgKz0gJyBqYXNtaW5lLW9wZW4nO1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuXFxuICAgICAgaWYgKHNwZWNzRXhlY3V0ZWQgPCB0b3RhbFNwZWNzRGVmaW5lZCkge1xcbiAgICAgICAgdmFyIHNraXBwZWRNZXNzYWdlID0gJ1JhbiAnICsgc3BlY3NFeGVjdXRlZCArICcgb2YgJyArIHRvdGFsU3BlY3NEZWZpbmVkICsgJyBzcGVjcyAtIHJ1biBhbGwnO1xcbiAgICAgICAgYWxlcnQuYXBwZW5kQ2hpbGQoXFxuICAgICAgICAgIGNyZWF0ZURvbSgnc3BhbicsIHtjbGFzc05hbWU6ICdqYXNtaW5lLWJhciBqYXNtaW5lLXNraXBwZWQnfSxcXG4gICAgICAgICAgICBjcmVhdGVEb20oJ2EnLCB7aHJlZjogJz8nLCB0aXRsZTogJ1J1biBhbGwgc3BlY3MnfSwgc2tpcHBlZE1lc3NhZ2UpXFxuICAgICAgICAgIClcXG4gICAgICAgICk7XFxuICAgICAgfVxcbiAgICAgIHZhciBzdGF0dXNCYXJNZXNzYWdlID0gJyc7XFxuICAgICAgdmFyIHN0YXR1c0JhckNsYXNzTmFtZSA9ICdqYXNtaW5lLWJhciAnO1xcblxcbiAgICAgIGlmICh0b3RhbFNwZWNzRGVmaW5lZCA+IDApIHtcXG4gICAgICAgIHN0YXR1c0Jhck1lc3NhZ2UgKz0gcGx1cmFsaXplKCdzcGVjJywgc3BlY3NFeGVjdXRlZCkgKyAnLCAnICsgcGx1cmFsaXplKCdmYWlsdXJlJywgZmFpbHVyZUNvdW50KTtcXG4gICAgICAgIGlmIChwZW5kaW5nU3BlY0NvdW50KSB7IHN0YXR1c0Jhck1lc3NhZ2UgKz0gJywgJyArIHBsdXJhbGl6ZSgncGVuZGluZyBzcGVjJywgcGVuZGluZ1NwZWNDb3VudCk7IH1cXG4gICAgICAgIHN0YXR1c0JhckNsYXNzTmFtZSArPSAoZmFpbHVyZUNvdW50ID4gMCkgPyAnamFzbWluZS1mYWlsZWQnIDogJ2phc21pbmUtcGFzc2VkJztcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgc3RhdHVzQmFyQ2xhc3NOYW1lICs9ICdqYXNtaW5lLXNraXBwZWQnO1xcbiAgICAgICAgc3RhdHVzQmFyTWVzc2FnZSArPSAnTm8gc3BlY3MgZm91bmQnO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgc2VlZEJhcjtcXG4gICAgICBpZiAob3JkZXIgJiYgb3JkZXIucmFuZG9tKSB7XFxuICAgICAgICBzZWVkQmFyID0gY3JlYXRlRG9tKCdzcGFuJywge2NsYXNzTmFtZTogJ2phc21pbmUtc2VlZC1iYXInfSxcXG4gICAgICAgICAgJywgcmFuZG9taXplZCB3aXRoIHNlZWQgJyxcXG4gICAgICAgICAgY3JlYXRlRG9tKCdhJywge3RpdGxlOiAncmFuZG9taXplZCB3aXRoIHNlZWQgJyArIG9yZGVyLnNlZWQsIGhyZWY6IHNlZWRIcmVmKG9yZGVyLnNlZWQpfSwgb3JkZXIuc2VlZClcXG4gICAgICAgICk7XFxuICAgICAgfVxcblxcbiAgICAgIGFsZXJ0LmFwcGVuZENoaWxkKGNyZWF0ZURvbSgnc3BhbicsIHtjbGFzc05hbWU6IHN0YXR1c0JhckNsYXNzTmFtZX0sIHN0YXR1c0Jhck1lc3NhZ2UsIHNlZWRCYXIpKTtcXG5cXG4gICAgICBmb3IoaSA9IDA7IGkgPCBmYWlsZWRTdWl0ZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgIHZhciBmYWlsZWRTdWl0ZSA9IGZhaWxlZFN1aXRlc1tpXTtcXG4gICAgICAgIGZvcih2YXIgaiA9IDA7IGogPCBmYWlsZWRTdWl0ZS5mYWlsZWRFeHBlY3RhdGlvbnMubGVuZ3RoOyBqKyspIHtcXG4gICAgICAgICAgdmFyIGVycm9yQmFyTWVzc2FnZSA9ICdBZnRlckFsbCAnICsgZmFpbGVkU3VpdGUuZmFpbGVkRXhwZWN0YXRpb25zW2pdLm1lc3NhZ2U7XFxuICAgICAgICAgIHZhciBlcnJvckJhckNsYXNzTmFtZSA9ICdqYXNtaW5lLWJhciBqYXNtaW5lLWVycm9yZWQnO1xcbiAgICAgICAgICBhbGVydC5hcHBlbmRDaGlsZChjcmVhdGVEb20oJ3NwYW4nLCB7Y2xhc3NOYW1lOiBlcnJvckJhckNsYXNzTmFtZX0sIGVycm9yQmFyTWVzc2FnZSkpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgcmVzdWx0cyA9IGZpbmQoJy5qYXNtaW5lLXJlc3VsdHMnKTtcXG4gICAgICByZXN1bHRzLmFwcGVuZENoaWxkKHN1bW1hcnkpO1xcblxcbiAgICAgIHN1bW1hcnlMaXN0KHRvcFJlc3VsdHMsIHN1bW1hcnkpO1xcblxcbiAgICAgIGZ1bmN0aW9uIHN1bW1hcnlMaXN0KHJlc3VsdHNUcmVlLCBkb21QYXJlbnQpIHtcXG4gICAgICAgIHZhciBzcGVjTGlzdE5vZGU7XFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdHNUcmVlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgIHZhciByZXN1bHROb2RlID0gcmVzdWx0c1RyZWUuY2hpbGRyZW5baV07XFxuICAgICAgICAgIGlmIChyZXN1bHROb2RlLnR5cGUgPT0gJ3N1aXRlJykge1xcbiAgICAgICAgICAgIHZhciBzdWl0ZUxpc3ROb2RlID0gY3JlYXRlRG9tKCd1bCcsIHtjbGFzc05hbWU6ICdqYXNtaW5lLXN1aXRlJywgaWQ6ICdzdWl0ZS0nICsgcmVzdWx0Tm9kZS5yZXN1bHQuaWR9LFxcbiAgICAgICAgICAgICAgY3JlYXRlRG9tKCdsaScsIHtjbGFzc05hbWU6ICdqYXNtaW5lLXN1aXRlLWRldGFpbCd9LFxcbiAgICAgICAgICAgICAgICBjcmVhdGVEb20oJ2EnLCB7aHJlZjogc3BlY0hyZWYocmVzdWx0Tm9kZS5yZXN1bHQpfSwgcmVzdWx0Tm9kZS5yZXN1bHQuZGVzY3JpcHRpb24pXFxuICAgICAgICAgICAgICApXFxuICAgICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgICBzdW1tYXJ5TGlzdChyZXN1bHROb2RlLCBzdWl0ZUxpc3ROb2RlKTtcXG4gICAgICAgICAgICBkb21QYXJlbnQuYXBwZW5kQ2hpbGQoc3VpdGVMaXN0Tm9kZSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaWYgKHJlc3VsdE5vZGUudHlwZSA9PSAnc3BlYycpIHtcXG4gICAgICAgICAgICBpZiAoZG9tUGFyZW50LmdldEF0dHJpYnV0ZSgnY2xhc3MnKSAhPSAnamFzbWluZS1zcGVjcycpIHtcXG4gICAgICAgICAgICAgIHNwZWNMaXN0Tm9kZSA9IGNyZWF0ZURvbSgndWwnLCB7Y2xhc3NOYW1lOiAnamFzbWluZS1zcGVjcyd9KTtcXG4gICAgICAgICAgICAgIGRvbVBhcmVudC5hcHBlbmRDaGlsZChzcGVjTGlzdE5vZGUpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB2YXIgc3BlY0Rlc2NyaXB0aW9uID0gcmVzdWx0Tm9kZS5yZXN1bHQuZGVzY3JpcHRpb247XFxuICAgICAgICAgICAgaWYobm9FeHBlY3RhdGlvbnMocmVzdWx0Tm9kZS5yZXN1bHQpKSB7XFxuICAgICAgICAgICAgICBzcGVjRGVzY3JpcHRpb24gPSAnU1BFQyBIQVMgTk8gRVhQRUNUQVRJT05TICcgKyBzcGVjRGVzY3JpcHRpb247XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmKHJlc3VsdE5vZGUucmVzdWx0LnN0YXR1cyA9PT0gJ3BlbmRpbmcnICYmIHJlc3VsdE5vZGUucmVzdWx0LnBlbmRpbmdSZWFzb24gIT09ICcnKSB7XFxuICAgICAgICAgICAgICBzcGVjRGVzY3JpcHRpb24gPSBzcGVjRGVzY3JpcHRpb24gKyAnIFBFTkRJTkcgV0lUSCBNRVNTQUdFOiAnICsgcmVzdWx0Tm9kZS5yZXN1bHQucGVuZGluZ1JlYXNvbjtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgc3BlY0xpc3ROb2RlLmFwcGVuZENoaWxkKFxcbiAgICAgICAgICAgICAgY3JlYXRlRG9tKCdsaScsIHtcXG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdqYXNtaW5lLScgKyByZXN1bHROb2RlLnJlc3VsdC5zdGF0dXMsXFxuICAgICAgICAgICAgICAgICAgaWQ6ICdzcGVjLScgKyByZXN1bHROb2RlLnJlc3VsdC5pZFxcbiAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICBjcmVhdGVEb20oJ2EnLCB7aHJlZjogc3BlY0hyZWYocmVzdWx0Tm9kZS5yZXN1bHQpfSwgc3BlY0Rlc2NyaXB0aW9uKVxcbiAgICAgICAgICAgICAgKVxcbiAgICAgICAgICAgICk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGZhaWx1cmVzLmxlbmd0aCkge1xcbiAgICAgICAgYWxlcnQuYXBwZW5kQ2hpbGQoXFxuICAgICAgICAgIGNyZWF0ZURvbSgnc3BhbicsIHtjbGFzc05hbWU6ICdqYXNtaW5lLW1lbnUgamFzbWluZS1iYXIgamFzbWluZS1zcGVjLWxpc3QnfSxcXG4gICAgICAgICAgICBjcmVhdGVEb20oJ3NwYW4nLCB7fSwgJ1NwZWMgTGlzdCB8ICcpLFxcbiAgICAgICAgICAgIGNyZWF0ZURvbSgnYScsIHtjbGFzc05hbWU6ICdqYXNtaW5lLWZhaWx1cmVzLW1lbnUnLCBocmVmOiAnIyd9LCAnRmFpbHVyZXMnKSkpO1xcbiAgICAgICAgYWxlcnQuYXBwZW5kQ2hpbGQoXFxuICAgICAgICAgIGNyZWF0ZURvbSgnc3BhbicsIHtjbGFzc05hbWU6ICdqYXNtaW5lLW1lbnUgamFzbWluZS1iYXIgamFzbWluZS1mYWlsdXJlLWxpc3QnfSxcXG4gICAgICAgICAgICBjcmVhdGVEb20oJ2EnLCB7Y2xhc3NOYW1lOiAnamFzbWluZS1zcGVjLWxpc3QtbWVudScsIGhyZWY6ICcjJ30sICdTcGVjIExpc3QnKSxcXG4gICAgICAgICAgICBjcmVhdGVEb20oJ3NwYW4nLCB7fSwgJyB8IEZhaWx1cmVzICcpKSk7XFxuXFxuICAgICAgICBmaW5kKCcuamFzbWluZS1mYWlsdXJlcy1tZW51Jykub25jbGljayA9IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgICBzZXRNZW51TW9kZVRvKCdqYXNtaW5lLWZhaWx1cmUtbGlzdCcpO1xcbiAgICAgICAgfTtcXG4gICAgICAgIGZpbmQoJy5qYXNtaW5lLXNwZWMtbGlzdC1tZW51Jykub25jbGljayA9IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgICBzZXRNZW51TW9kZVRvKCdqYXNtaW5lLXNwZWMtbGlzdCcpO1xcbiAgICAgICAgfTtcXG5cXG4gICAgICAgIHNldE1lbnVNb2RlVG8oJ2phc21pbmUtZmFpbHVyZS1saXN0Jyk7XFxuXFxuICAgICAgICB2YXIgZmFpbHVyZU5vZGUgPSBmaW5kKCcuamFzbWluZS1mYWlsdXJlcycpO1xcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmYWlsdXJlcy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgICBmYWlsdXJlTm9kZS5hcHBlbmRDaGlsZChmYWlsdXJlc1tpXSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9O1xcblxcbiAgICByZXR1cm4gdGhpcztcXG5cXG4gICAgZnVuY3Rpb24gZmluZChzZWxlY3Rvcikge1xcbiAgICAgIHJldHVybiBnZXRDb250YWluZXIoKS5xdWVyeVNlbGVjdG9yKCcuamFzbWluZV9odG1sLXJlcG9ydGVyICcgKyBzZWxlY3Rvcik7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gY2xlYXJQcmlvcigpIHtcXG4gICAgICAvLyByZXR1cm4gdGhlIHJlcG9ydGVyXFxuICAgICAgdmFyIG9sZFJlcG9ydGVyID0gZmluZCgnJyk7XFxuXFxuICAgICAgaWYob2xkUmVwb3J0ZXIpIHtcXG4gICAgICAgIGdldENvbnRhaW5lcigpLnJlbW92ZUNoaWxkKG9sZFJlcG9ydGVyKTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gY3JlYXRlRG9tKHR5cGUsIGF0dHJzLCBjaGlsZHJlblZhckFyZ3MpIHtcXG4gICAgICB2YXIgZWwgPSBjcmVhdGVFbGVtZW50KHR5cGUpO1xcblxcbiAgICAgIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICB2YXIgY2hpbGQgPSBhcmd1bWVudHNbaV07XFxuXFxuICAgICAgICBpZiAodHlwZW9mIGNoaWxkID09PSAnc3RyaW5nJykge1xcbiAgICAgICAgICBlbC5hcHBlbmRDaGlsZChjcmVhdGVUZXh0Tm9kZShjaGlsZCkpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgaWYgKGNoaWxkKSB7XFxuICAgICAgICAgICAgZWwuYXBwZW5kQ2hpbGQoY2hpbGQpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGZvciAodmFyIGF0dHIgaW4gYXR0cnMpIHtcXG4gICAgICAgIGlmIChhdHRyID09ICdjbGFzc05hbWUnKSB7XFxuICAgICAgICAgIGVsW2F0dHJdID0gYXR0cnNbYXR0cl07XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoYXR0ciwgYXR0cnNbYXR0cl0pO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gZWw7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gcGx1cmFsaXplKHNpbmd1bGFyLCBjb3VudCkge1xcbiAgICAgIHZhciB3b3JkID0gKGNvdW50ID09IDEgPyBzaW5ndWxhciA6IHNpbmd1bGFyICsgJ3MnKTtcXG5cXG4gICAgICByZXR1cm4gJycgKyBjb3VudCArICcgJyArIHdvcmQ7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gc3BlY0hyZWYocmVzdWx0KSB7XFxuICAgICAgcmV0dXJuIGFkZFRvRXhpc3RpbmdRdWVyeVN0cmluZygnc3BlYycsIHJlc3VsdC5mdWxsTmFtZSk7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gc2VlZEhyZWYoc2VlZCkge1xcbiAgICAgIHJldHVybiBhZGRUb0V4aXN0aW5nUXVlcnlTdHJpbmcoJ3NlZWQnLCBzZWVkKTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBkZWZhdWx0UXVlcnlTdHJpbmcoa2V5LCB2YWx1ZSkge1xcbiAgICAgIHJldHVybiAnPycgKyBrZXkgKyAnPScgKyB2YWx1ZTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBzZXRNZW51TW9kZVRvKG1vZGUpIHtcXG4gICAgICBodG1sUmVwb3J0ZXJNYWluLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnamFzbWluZV9odG1sLXJlcG9ydGVyICcgKyBtb2RlKTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBub0V4cGVjdGF0aW9ucyhyZXN1bHQpIHtcXG4gICAgICByZXR1cm4gKHJlc3VsdC5mYWlsZWRFeHBlY3RhdGlvbnMubGVuZ3RoICsgcmVzdWx0LnBhc3NlZEV4cGVjdGF0aW9ucy5sZW5ndGgpID09PSAwICYmXFxuICAgICAgICByZXN1bHQuc3RhdHVzID09PSAncGFzc2VkJztcXG4gICAgfVxcbiAgfVxcblxcbiAgcmV0dXJuIEh0bWxSZXBvcnRlcjtcXG59O1xcblxcbmphc21pbmVSZXF1aXJlLkh0bWxTcGVjRmlsdGVyID0gZnVuY3Rpb24oKSB7XFxuICBmdW5jdGlvbiBIdG1sU3BlY0ZpbHRlcihvcHRpb25zKSB7XFxuICAgIHZhciBmaWx0ZXJTdHJpbmcgPSBvcHRpb25zICYmIG9wdGlvbnMuZmlsdGVyU3RyaW5nKCkgJiYgb3B0aW9ucy5maWx0ZXJTdHJpbmcoKS5yZXBsYWNlKC9bLVtcXFxcXXt9KCkqKz8uLFxcXFxcXFxcXiR8I1xcXFxzXS9nLCAnXFxcXFxcXFwkJicpO1xcbiAgICB2YXIgZmlsdGVyUGF0dGVybiA9IG5ldyBSZWdFeHAoZmlsdGVyU3RyaW5nKTtcXG5cXG4gICAgdGhpcy5tYXRjaGVzID0gZnVuY3Rpb24oc3BlY05hbWUpIHtcXG4gICAgICByZXR1cm4gZmlsdGVyUGF0dGVybi50ZXN0KHNwZWNOYW1lKTtcXG4gICAgfTtcXG4gIH1cXG5cXG4gIHJldHVybiBIdG1sU3BlY0ZpbHRlcjtcXG59O1xcblxcbmphc21pbmVSZXF1aXJlLlJlc3VsdHNOb2RlID0gZnVuY3Rpb24oKSB7XFxuICBmdW5jdGlvbiBSZXN1bHRzTm9kZShyZXN1bHQsIHR5cGUsIHBhcmVudCkge1xcbiAgICB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcXG4gICAgdGhpcy50eXBlID0gdHlwZTtcXG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XFxuXFxuICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcXG5cXG4gICAgdGhpcy5hZGRDaGlsZCA9IGZ1bmN0aW9uKHJlc3VsdCwgdHlwZSkge1xcbiAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChuZXcgUmVzdWx0c05vZGUocmVzdWx0LCB0eXBlLCB0aGlzKSk7XFxuICAgIH07XFxuXFxuICAgIHRoaXMubGFzdCA9IGZ1bmN0aW9uKCkge1xcbiAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuW3RoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMV07XFxuICAgIH07XFxuICB9XFxuXFxuICByZXR1cm4gUmVzdWx0c05vZGU7XFxufTtcXG5cXG5qYXNtaW5lUmVxdWlyZS5RdWVyeVN0cmluZyA9IGZ1bmN0aW9uKCkge1xcbiAgZnVuY3Rpb24gUXVlcnlTdHJpbmcob3B0aW9ucykge1xcblxcbiAgICB0aGlzLm5hdmlnYXRlV2l0aE5ld1BhcmFtID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xcbiAgICAgIG9wdGlvbnMuZ2V0V2luZG93TG9jYXRpb24oKS5zZWFyY2ggPSB0aGlzLmZ1bGxTdHJpbmdXaXRoTmV3UGFyYW0oa2V5LCB2YWx1ZSk7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuZnVsbFN0cmluZ1dpdGhOZXdQYXJhbSA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcXG4gICAgICB2YXIgcGFyYW1NYXAgPSBxdWVyeVN0cmluZ1RvUGFyYW1NYXAoKTtcXG4gICAgICBwYXJhbU1hcFtrZXldID0gdmFsdWU7XFxuICAgICAgcmV0dXJuIHRvUXVlcnlTdHJpbmcocGFyYW1NYXApO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLmdldFBhcmFtID0gZnVuY3Rpb24oa2V5KSB7XFxuICAgICAgcmV0dXJuIHF1ZXJ5U3RyaW5nVG9QYXJhbU1hcCgpW2tleV07XFxuICAgIH07XFxuXFxuICAgIHJldHVybiB0aGlzO1xcblxcbiAgICBmdW5jdGlvbiB0b1F1ZXJ5U3RyaW5nKHBhcmFtTWFwKSB7XFxuICAgICAgdmFyIHFTdHJQYWlycyA9IFtdO1xcbiAgICAgIGZvciAodmFyIHByb3AgaW4gcGFyYW1NYXApIHtcXG4gICAgICAgIHFTdHJQYWlycy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChwcm9wKSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChwYXJhbU1hcFtwcm9wXSkpO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gJz8nICsgcVN0clBhaXJzLmpvaW4oJyYnKTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBxdWVyeVN0cmluZ1RvUGFyYW1NYXAoKSB7XFxuICAgICAgdmFyIHBhcmFtU3RyID0gb3B0aW9ucy5nZXRXaW5kb3dMb2NhdGlvbigpLnNlYXJjaC5zdWJzdHJpbmcoMSksXFxuICAgICAgICBwYXJhbXMgPSBbXSxcXG4gICAgICAgIHBhcmFtTWFwID0ge307XFxuXFxuICAgICAgaWYgKHBhcmFtU3RyLmxlbmd0aCA+IDApIHtcXG4gICAgICAgIHBhcmFtcyA9IHBhcmFtU3RyLnNwbGl0KCcmJyk7XFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgICB2YXIgcCA9IHBhcmFtc1tpXS5zcGxpdCgnPScpO1xcbiAgICAgICAgICB2YXIgdmFsdWUgPSBkZWNvZGVVUklDb21wb25lbnQocFsxXSk7XFxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJ3RydWUnIHx8IHZhbHVlID09PSAnZmFsc2UnKSB7XFxuICAgICAgICAgICAgdmFsdWUgPSBKU09OLnBhcnNlKHZhbHVlKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBwYXJhbU1hcFtkZWNvZGVVUklDb21wb25lbnQocFswXSldID0gdmFsdWU7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBwYXJhbU1hcDtcXG4gICAgfVxcblxcbiAgfVxcblxcbiAgcmV0dXJuIFF1ZXJ5U3RyaW5nO1xcbn07XFxuXCJcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9saWIvamFzbWluZS0yLjQuMS9qYXNtaW5lLWh0bWwuanNcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiLyoqXFxuIFN0YXJ0aW5nIHdpdGggdmVyc2lvbiAyLjAsIHRoaXMgZmlsZSBcXFwiYm9vdHNcXFwiIEphc21pbmUsIHBlcmZvcm1pbmcgYWxsIG9mIHRoZSBuZWNlc3NhcnkgaW5pdGlhbGl6YXRpb24gYmVmb3JlIGV4ZWN1dGluZyB0aGUgbG9hZGVkIGVudmlyb25tZW50IGFuZCBhbGwgb2YgYSBwcm9qZWN0J3Mgc3BlY3MuIFRoaXMgZmlsZSBzaG91bGQgYmUgbG9hZGVkIGFmdGVyIGBqYXNtaW5lLmpzYCBhbmQgYGphc21pbmVfaHRtbC5qc2AsIGJ1dCBiZWZvcmUgYW55IHByb2plY3Qgc291cmNlIGZpbGVzIG9yIHNwZWMgZmlsZXMgYXJlIGxvYWRlZC4gVGh1cyB0aGlzIGZpbGUgY2FuIGFsc28gYmUgdXNlZCB0byBjdXN0b21pemUgSmFzbWluZSBmb3IgYSBwcm9qZWN0LlxcblxcbiBJZiBhIHByb2plY3QgaXMgdXNpbmcgSmFzbWluZSB2aWEgdGhlIHN0YW5kYWxvbmUgZGlzdHJpYnV0aW9uLCB0aGlzIGZpbGUgY2FuIGJlIGN1c3RvbWl6ZWQgZGlyZWN0bHkuIElmIGEgcHJvamVjdCBpcyB1c2luZyBKYXNtaW5lIHZpYSB0aGUgW1J1YnkgZ2VtXVtqYXNtaW5lLWdlbV0sIHRoaXMgZmlsZSBjYW4gYmUgY29waWVkIGludG8gdGhlIHN1cHBvcnQgZGlyZWN0b3J5IHZpYSBgamFzbWluZSBjb3B5X2Jvb3RfanNgLiBPdGhlciBlbnZpcm9ubWVudHMgKGUuZy4sIFB5dGhvbikgd2lsbCBoYXZlIGRpZmZlcmVudCBtZWNoYW5pc21zLlxcblxcbiBUaGUgbG9jYXRpb24gb2YgYGJvb3QuanNgIGNhbiBiZSBzcGVjaWZpZWQgYW5kL29yIG92ZXJyaWRkZW4gaW4gYGphc21pbmUueW1sYC5cXG5cXG4gW2phc21pbmUtZ2VtXTogaHR0cDovL2dpdGh1Yi5jb20vcGl2b3RhbC9qYXNtaW5lLWdlbVxcbiAqL1xcblxcbihmdW5jdGlvbigpIHtcXG5cXG4gIC8qKlxcbiAgICogIyMgUmVxdWlyZSAmYW1wOyBJbnN0YW50aWF0ZVxcbiAgICpcXG4gICAqIFJlcXVpcmUgSmFzbWluZSdzIGNvcmUgZmlsZXMuIFNwZWNpZmljYWxseSwgdGhpcyByZXF1aXJlcyBhbmQgYXR0YWNoZXMgYWxsIG9mIEphc21pbmUncyBjb2RlIHRvIHRoZSBgamFzbWluZWAgcmVmZXJlbmNlLlxcbiAgICovXFxuICB3aW5kb3cuamFzbWluZSA9IGphc21pbmVSZXF1aXJlLmNvcmUoamFzbWluZVJlcXVpcmUpO1xcblxcbiAgLyoqXFxuICAgKiBTaW5jZSB0aGlzIGlzIGJlaW5nIHJ1biBpbiBhIGJyb3dzZXIgYW5kIHRoZSByZXN1bHRzIHNob3VsZCBwb3B1bGF0ZSB0byBhbiBIVE1MIHBhZ2UsIHJlcXVpcmUgdGhlIEhUTUwtc3BlY2lmaWMgSmFzbWluZSBjb2RlLCBpbmplY3RpbmcgdGhlIHNhbWUgcmVmZXJlbmNlLlxcbiAgICovXFxuICBqYXNtaW5lUmVxdWlyZS5odG1sKGphc21pbmUpO1xcblxcbiAgLyoqXFxuICAgKiBDcmVhdGUgdGhlIEphc21pbmUgZW52aXJvbm1lbnQuIFRoaXMgaXMgdXNlZCB0byBydW4gYWxsIHNwZWNzIGluIGEgcHJvamVjdC5cXG4gICAqL1xcbiAgdmFyIGVudiA9IGphc21pbmUuZ2V0RW52KCk7XFxuXFxuICAvKipcXG4gICAqICMjIFRoZSBHbG9iYWwgSW50ZXJmYWNlXFxuICAgKlxcbiAgICogQnVpbGQgdXAgdGhlIGZ1bmN0aW9ucyB0aGF0IHdpbGwgYmUgZXhwb3NlZCBhcyB0aGUgSmFzbWluZSBwdWJsaWMgaW50ZXJmYWNlLiBBIHByb2plY3QgY2FuIGN1c3RvbWl6ZSwgcmVuYW1lIG9yIGFsaWFzIGFueSBvZiB0aGVzZSBmdW5jdGlvbnMgYXMgZGVzaXJlZCwgcHJvdmlkZWQgdGhlIGltcGxlbWVudGF0aW9uIHJlbWFpbnMgdW5jaGFuZ2VkLlxcbiAgICovXFxuICB2YXIgamFzbWluZUludGVyZmFjZSA9IGphc21pbmVSZXF1aXJlLmludGVyZmFjZShqYXNtaW5lLCBlbnYpO1xcblxcbiAgLyoqXFxuICAgKiBBZGQgYWxsIG9mIHRoZSBKYXNtaW5lIGdsb2JhbC9wdWJsaWMgaW50ZXJmYWNlIHRvIHRoZSBnbG9iYWwgc2NvcGUsIHNvIGEgcHJvamVjdCBjYW4gdXNlIHRoZSBwdWJsaWMgaW50ZXJmYWNlIGRpcmVjdGx5LiBGb3IgZXhhbXBsZSwgY2FsbGluZyBgZGVzY3JpYmVgIGluIHNwZWNzIGluc3RlYWQgb2YgYGphc21pbmUuZ2V0RW52KCkuZGVzY3JpYmVgLlxcbiAgICovXFxuICBleHRlbmQod2luZG93LCBqYXNtaW5lSW50ZXJmYWNlKTtcXG5cXG4gIC8qKlxcbiAgICogIyMgUnVubmVyIFBhcmFtZXRlcnNcXG4gICAqXFxuICAgKiBNb3JlIGJyb3dzZXIgc3BlY2lmaWMgY29kZSAtIHdyYXAgdGhlIHF1ZXJ5IHN0cmluZyBpbiBhbiBvYmplY3QgYW5kIHRvIGFsbG93IGZvciBnZXR0aW5nL3NldHRpbmcgcGFyYW1ldGVycyBmcm9tIHRoZSBydW5uZXIgdXNlciBpbnRlcmZhY2UuXFxuICAgKi9cXG5cXG4gIHZhciBxdWVyeVN0cmluZyA9IG5ldyBqYXNtaW5lLlF1ZXJ5U3RyaW5nKHtcXG4gICAgZ2V0V2luZG93TG9jYXRpb246IGZ1bmN0aW9uKCkgeyByZXR1cm4gd2luZG93LmxvY2F0aW9uOyB9XFxuICB9KTtcXG5cXG4gIHZhciBjYXRjaGluZ0V4Y2VwdGlvbnMgPSBxdWVyeVN0cmluZy5nZXRQYXJhbShcXFwiY2F0Y2hcXFwiKTtcXG4gIGVudi5jYXRjaEV4Y2VwdGlvbnModHlwZW9mIGNhdGNoaW5nRXhjZXB0aW9ucyA9PT0gXFxcInVuZGVmaW5lZFxcXCIgPyB0cnVlIDogY2F0Y2hpbmdFeGNlcHRpb25zKTtcXG5cXG4gIHZhciB0aHJvd2luZ0V4cGVjdGF0aW9uRmFpbHVyZXMgPSBxdWVyeVN0cmluZy5nZXRQYXJhbShcXFwidGhyb3dGYWlsdXJlc1xcXCIpO1xcbiAgZW52LnRocm93T25FeHBlY3RhdGlvbkZhaWx1cmUodGhyb3dpbmdFeHBlY3RhdGlvbkZhaWx1cmVzKTtcXG5cXG4gIHZhciByYW5kb20gPSBxdWVyeVN0cmluZy5nZXRQYXJhbShcXFwicmFuZG9tXFxcIik7XFxuICBlbnYucmFuZG9taXplVGVzdHMocmFuZG9tKTtcXG5cXG4gIHZhciBzZWVkID0gcXVlcnlTdHJpbmcuZ2V0UGFyYW0oXFxcInNlZWRcXFwiKTtcXG4gIGlmIChzZWVkKSB7XFxuICAgIGVudi5zZWVkKHNlZWQpO1xcbiAgfVxcblxcbiAgLyoqXFxuICAgKiAjIyBSZXBvcnRlcnNcXG4gICAqIFRoZSBgSHRtbFJlcG9ydGVyYCBidWlsZHMgYWxsIG9mIHRoZSBIVE1MIFVJIGZvciB0aGUgcnVubmVyIHBhZ2UuIFRoaXMgcmVwb3J0ZXIgcGFpbnRzIHRoZSBkb3RzLCBzdGFycywgYW5kIHgncyBmb3Igc3BlY3MsIGFzIHdlbGwgYXMgYWxsIHNwZWMgbmFtZXMgYW5kIGFsbCBmYWlsdXJlcyAoaWYgYW55KS5cXG4gICAqL1xcbiAgdmFyIGh0bWxSZXBvcnRlciA9IG5ldyBqYXNtaW5lLkh0bWxSZXBvcnRlcih7XFxuICAgIGVudjogZW52LFxcbiAgICBvblJhaXNlRXhjZXB0aW9uc0NsaWNrOiBmdW5jdGlvbigpIHsgcXVlcnlTdHJpbmcubmF2aWdhdGVXaXRoTmV3UGFyYW0oXFxcImNhdGNoXFxcIiwgIWVudi5jYXRjaGluZ0V4Y2VwdGlvbnMoKSk7IH0sXFxuICAgIG9uVGhyb3dFeHBlY3RhdGlvbnNDbGljazogZnVuY3Rpb24oKSB7IHF1ZXJ5U3RyaW5nLm5hdmlnYXRlV2l0aE5ld1BhcmFtKFxcXCJ0aHJvd0ZhaWx1cmVzXFxcIiwgIWVudi50aHJvd2luZ0V4cGVjdGF0aW9uRmFpbHVyZXMoKSk7IH0sXFxuICAgIG9uUmFuZG9tQ2xpY2s6IGZ1bmN0aW9uKCkgeyBxdWVyeVN0cmluZy5uYXZpZ2F0ZVdpdGhOZXdQYXJhbShcXFwicmFuZG9tXFxcIiwgIWVudi5yYW5kb21UZXN0cygpKTsgfSxcXG4gICAgYWRkVG9FeGlzdGluZ1F1ZXJ5U3RyaW5nOiBmdW5jdGlvbihrZXksIHZhbHVlKSB7IHJldHVybiBxdWVyeVN0cmluZy5mdWxsU3RyaW5nV2l0aE5ld1BhcmFtKGtleSwgdmFsdWUpOyB9LFxcbiAgICBnZXRDb250YWluZXI6IGZ1bmN0aW9uKCkgeyByZXR1cm4gZG9jdW1lbnQuYm9keTsgfSxcXG4gICAgY3JlYXRlRWxlbWVudDogZnVuY3Rpb24oKSB7IHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50LmFwcGx5KGRvY3VtZW50LCBhcmd1bWVudHMpOyB9LFxcbiAgICBjcmVhdGVUZXh0Tm9kZTogZnVuY3Rpb24oKSB7IHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZS5hcHBseShkb2N1bWVudCwgYXJndW1lbnRzKTsgfSxcXG4gICAgdGltZXI6IG5ldyBqYXNtaW5lLlRpbWVyKClcXG4gIH0pO1xcblxcbiAgLyoqXFxuICAgKiBUaGUgYGpzQXBpUmVwb3J0ZXJgIGFsc28gcmVjZWl2ZXMgc3BlYyByZXN1bHRzLCBhbmQgaXMgdXNlZCBieSBhbnkgZW52aXJvbm1lbnQgdGhhdCBuZWVkcyB0byBleHRyYWN0IHRoZSByZXN1bHRzICBmcm9tIEphdmFTY3JpcHQuXFxuICAgKi9cXG4gIGVudi5hZGRSZXBvcnRlcihqYXNtaW5lSW50ZXJmYWNlLmpzQXBpUmVwb3J0ZXIpO1xcbiAgZW52LmFkZFJlcG9ydGVyKGh0bWxSZXBvcnRlcik7XFxuXFxuICAvKipcXG4gICAqIEZpbHRlciB3aGljaCBzcGVjcyB3aWxsIGJlIHJ1biBieSBtYXRjaGluZyB0aGUgc3RhcnQgb2YgdGhlIGZ1bGwgbmFtZSBhZ2FpbnN0IHRoZSBgc3BlY2AgcXVlcnkgcGFyYW0uXFxuICAgKi9cXG4gIHZhciBzcGVjRmlsdGVyID0gbmV3IGphc21pbmUuSHRtbFNwZWNGaWx0ZXIoe1xcbiAgICBmaWx0ZXJTdHJpbmc6IGZ1bmN0aW9uKCkgeyByZXR1cm4gcXVlcnlTdHJpbmcuZ2V0UGFyYW0oXFxcInNwZWNcXFwiKTsgfVxcbiAgfSk7XFxuXFxuICBlbnYuc3BlY0ZpbHRlciA9IGZ1bmN0aW9uKHNwZWMpIHtcXG4gICAgcmV0dXJuIHNwZWNGaWx0ZXIubWF0Y2hlcyhzcGVjLmdldEZ1bGxOYW1lKCkpO1xcbiAgfTtcXG5cXG4gIC8qKlxcbiAgICogU2V0dGluZyB1cCB0aW1pbmcgZnVuY3Rpb25zIHRvIGJlIGFibGUgdG8gYmUgb3ZlcnJpZGRlbi4gQ2VydGFpbiBicm93c2VycyAoU2FmYXJpLCBJRSA4LCBwaGFudG9tanMpIHJlcXVpcmUgdGhpcyBoYWNrLlxcbiAgICovXFxuICB3aW5kb3cuc2V0VGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0O1xcbiAgd2luZG93LnNldEludGVydmFsID0gd2luZG93LnNldEludGVydmFsO1xcbiAgd2luZG93LmNsZWFyVGltZW91dCA9IHdpbmRvdy5jbGVhclRpbWVvdXQ7XFxuICB3aW5kb3cuY2xlYXJJbnRlcnZhbCA9IHdpbmRvdy5jbGVhckludGVydmFsO1xcblxcbiAgLyoqXFxuICAgKiAjIyBFeGVjdXRpb25cXG4gICAqXFxuICAgKiBSZXBsYWNlIHRoZSBicm93c2VyIHdpbmRvdydzIGBvbmxvYWRgLCBlbnN1cmUgaXQncyBjYWxsZWQsIGFuZCB0aGVuIHJ1biBhbGwgb2YgdGhlIGxvYWRlZCBzcGVjcy4gVGhpcyBpbmNsdWRlcyBpbml0aWFsaXppbmcgdGhlIGBIdG1sUmVwb3J0ZXJgIGluc3RhbmNlIGFuZCB0aGVuIGV4ZWN1dGluZyB0aGUgbG9hZGVkIEphc21pbmUgZW52aXJvbm1lbnQuIEFsbCBvZiB0aGlzIHdpbGwgaGFwcGVuIGFmdGVyIGFsbCBvZiB0aGUgc3BlY3MgYXJlIGxvYWRlZC5cXG4gICAqL1xcbiAgdmFyIGN1cnJlbnRXaW5kb3dPbmxvYWQgPSB3aW5kb3cub25sb2FkO1xcblxcbiAgd2luZG93Lm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xcbiAgICBpZiAoY3VycmVudFdpbmRvd09ubG9hZCkge1xcbiAgICAgIGN1cnJlbnRXaW5kb3dPbmxvYWQoKTtcXG4gICAgfVxcbiAgICBodG1sUmVwb3J0ZXIuaW5pdGlhbGl6ZSgpO1xcbiAgICBlbnYuZXhlY3V0ZSgpO1xcbiAgfTtcXG5cXG4gIC8qKlxcbiAgICogSGVscGVyIGZ1bmN0aW9uIGZvciByZWFkYWJpbGl0eSBhYm92ZS5cXG4gICAqL1xcbiAgZnVuY3Rpb24gZXh0ZW5kKGRlc3RpbmF0aW9uLCBzb3VyY2UpIHtcXG4gICAgZm9yICh2YXIgcHJvcGVydHkgaW4gc291cmNlKSBkZXN0aW5hdGlvbltwcm9wZXJ0eV0gPSBzb3VyY2VbcHJvcGVydHldO1xcbiAgICByZXR1cm4gZGVzdGluYXRpb247XFxuICB9XFxuXFxufSgpKTtcXG5cIlxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2xpYi9qYXNtaW5lLTIuNC4xL2Jvb3QuanNcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9